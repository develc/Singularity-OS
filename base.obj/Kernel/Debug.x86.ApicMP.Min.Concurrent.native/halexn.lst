; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	C:\Users\cc\source\repos\Singularity-OS\base\Kernel\Native\ix64\halexn.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

EXTRN	?c_codeBaseStartTable@Class_System_GCs_CallStack@@2PAIA:DWORD ; Class_System_GCs_CallStack::c_codeBaseStartTable
EXTRN	?TableBase@@3PAUTableEntry@@A:QWORD		; TableBase
EXTRN	?TableBound@@3PAUTableEntry@@A:QWORD		; TableBound
; Function compile flags: /Ogtp
; File c:\users\cc\source\repos\singularity-os\base\kernel\native\ix64\halexn.cpp
;	COMDAT ?LookupTable@@YIIIPAPAUExceptionTableEntry@@0@Z
_TEXT	SEGMENT
_throwAddr$ = 8						; size = 4
_tableBaseEntry$ = 12					; size = 4
_tableEndEntry$ = 16					; size = 4
?LookupTable@@YIIIPAPAUExceptionTableEntry@@0@Z PROC	; LookupTable, COMDAT

; 74   :                            ExceptionTableEntry **tableEndEntry) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 08	 mov	 ecx, DWORD PTR _throwAddr$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 75   : #if 0
; 76   :     printf("LookupTable(throwAddr=%p, tableBase=%p, tableEnd=%p)\n",
; 77   :            throwAddr, tableBaseEntry, tableEndEntry);
; 78   :     printf("  TableBase=%p, TableBound=%p, maxIndex = %d\n",
; 79   :            TableBase, TableBound, TableBound - TableBase);
; 80   :     printf("  callSiteTableCount=%d\n",
; 81   :            Class_System_GCs_CallStack::c_callSiteTableCount);
; 82   :     printf("  codeBaseStartTable=%p\n",
; 83   :            Class_System_GCs_CallStack::c_codeBaseStartTable);
; 84   :     printf("  returnAddressToCallSiteSetNumbers=%p\n",
; 85   :            Class_System_GCs_CallStack::c_returnAddressToCallSiteSetNumbers);
; 86   :     printf("  callSiteSetCount=%p\n",
; 87   :            Class_System_GCs_CallStack::c_callSiteSetCount);
; 88   : #endif
; 89   : 
; 90   :     //  search to find which table to use
; 91   :     int maxIndex = (int) (TableBound - TableBase);

  00009	bf 00 00 00 00	 mov	 edi, OFFSET ?TableBound@@3PAUTableEntry@@A ; TableBound
  0000e	81 ef 00 00 00
	00		 sub	 edi, OFFSET ?TableBase@@3PAUTableEntry@@A ; TableBase
  00014	c1 ff 03	 sar	 edi, 3

; 92   :     uintptr codeBase = (uintptr) -1;
; 93   :     uintptr relCodeAddr = 0;
; 94   :     for (int i = 0; i < maxIndex; i++) {

  00017	33 d2		 xor	 edx, edx
  00019	85 ff		 test	 edi, edi
  0001b	7e 40		 jle	 SHORT $LN3@LookupTabl
  0001d	8d 49 00	 npad	 3
$LL5@LookupTabl:

; 95   :         TableEntry *entry = &TableBase[i];
; 96   : #if 0
; 97   :         printf("   TableBase[%d]  base=%p end=%p  codeBaseStartTable[]=%p\n",
; 98   :                i, entry->tableBaseAddr, entry->tableEndAddr,
; 99   :                Class_System_GCs_CallStack::c_codeBaseStartTable[i]);
; 100  : #endif
; 101  :         codeBase =
; 102  :             ((uintptr*)Class_System_GCs_CallStack::c_codeBaseStartTable)[i];

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ?c_codeBaseStartTable@Class_System_GCs_CallStack@@2PAIA ; Class_System_GCs_CallStack::c_codeBaseStartTable
  00025	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]

; 103  : 
; 104  :         if (throwAddr < codeBase) {

  00028	3b c8		 cmp	 ecx, eax
  0002a	72 2a		 jb	 SHORT $LN4@LookupTabl

; 105  :             continue;
; 106  :         }
; 107  :         relCodeAddr = throwAddr - codeBase;
; 108  :         *tableBaseEntry = entry->tableBaseAddr;

  0002c	8b 34 d5 00 00
	00 00		 mov	 esi, DWORD PTR ?TableBase@@3PAUTableEntry@@A[edx*8]
  00033	8b 5d 0c	 mov	 ebx, DWORD PTR _tableBaseEntry$[ebp]
  00036	89 33		 mov	 DWORD PTR [ebx], esi

; 109  :         *tableEndEntry = entry->tableEndAddr;

  00038	8b 5d 10	 mov	 ebx, DWORD PTR _tableEndEntry$[ebp]
  0003b	8b 34 d5 04 00
	00 00		 mov	 esi, DWORD PTR ?TableBase@@3PAUTableEntry@@A[edx*8+4]
  00042	89 33		 mov	 DWORD PTR [ebx], esi

; 110  : 
; 111  : #if 0
; 112  :         printf("   relCodeAddr = %p\n", relCodeAddr);
; 113  :         printf("    tableBase scopeBaseAddr=%p class=%p handler=%p\n",
; 114  :                (*tableBaseEntry)->scopeBaseAddr,
; 115  :                (*tableBaseEntry)->exceptionClass,
; 116  :                (*tableBaseEntry)->handlerAddr);
; 117  :         printf("    tableEnd  scopeBaseAddr=%p class=%p handler=%p\n",
; 118  :                (*tableEndEntry)->scopeBaseAddr,
; 119  :                (*tableEndEntry)->exceptionClass,
; 120  :                (*tableEndEntry)->handlerAddr);
; 121  : #endif
; 122  : 
; 123  :         if ((relCodeAddr >= (*tableBaseEntry)->scopeBaseAddr)
; 124  :             && (relCodeAddr <= (*tableEndEntry)->scopeBaseAddr)) {

  00044	8b 5d 0c	 mov	 ebx, DWORD PTR _tableBaseEntry$[ebp]
  00047	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  00049	2b c8		 sub	 ecx, eax
  0004b	3b 0b		 cmp	 ecx, DWORD PTR [ebx]
  0004d	72 04		 jb	 SHORT $LN11@LookupTabl
  0004f	3b 0e		 cmp	 ecx, DWORD PTR [esi]
  00051	76 0d		 jbe	 SHORT $LN6@LookupTabl
$LN11@LookupTabl:
  00053	8b 4d 08	 mov	 ecx, DWORD PTR _throwAddr$[ebp]
$LN4@LookupTabl:

; 92   :     uintptr codeBase = (uintptr) -1;
; 93   :     uintptr relCodeAddr = 0;
; 94   :     for (int i = 0; i < maxIndex; i++) {

  00056	83 c2 01	 add	 edx, 1
  00059	3b d7		 cmp	 edx, edi
  0005b	7c c3		 jl	 SHORT $LL5@LookupTabl
$LN3@LookupTabl:

; 125  :             return codeBase;
; 126  :         }
; 127  :     }
; 128  : 
; 129  :     return (uintptr) -1;

  0005d	83 c8 ff	 or	 eax, -1
$LN6@LookupTabl:
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx

; 130  :     //exit(-2);
; 131  :     //__asm int 3;
; 132  : }

  00063	5d		 pop	 ebp
  00064	c2 0c 00	 ret	 12			; 0000000cH
?LookupTable@@YIIIPAPAUExceptionTableEntry@@0@Z ENDP	; LookupTable
_TEXT	ENDS
PUBLIC	?getRealVTable@@YIPAUClass_System_VTable@@PAU1@@Z ; getRealVTable
; Function compile flags: /Ogtp
;	COMDAT ?getRealVTable@@YIPAUClass_System_VTable@@PAU1@@Z
_TEXT	SEGMENT
?getRealVTable@@YIPAUClass_System_VTable@@PAU1@@Z PROC	; getRealVTable, COMDAT
; _vt$ = ecx

; 135  : {

  00000	8b c1		 mov	 eax, ecx

; 136  :     return (Class_System_VTable *)((uintptr)vt & (~((uintptr)3)));

  00002	83 e0 fc	 and	 eax, -4			; fffffffcH

; 137  : }

  00005	c3		 ret	 0
?getRealVTable@@YIPAUClass_System_VTable@@PAU1@@Z ENDP	; getRealVTable
_TEXT	ENDS
PUBLIC	?ExceptionAssert@@YIXXZ				; ExceptionAssert
; Function compile flags: /Ogtp
;	COMDAT ?ExceptionAssert@@YIXXZ
_TEXT	SEGMENT
?ExceptionAssert@@YIXXZ PROC				; ExceptionAssert, COMDAT

; 146  : #if SPIN
; 147  :     // Useful for native cases when no debugger is avaiable
; 148  :     while (1)
; 149  :         ;
; 150  : #endif
; 151  : 
; 152  :     __debugbreak();

  00000	cc		 int	 3

; 153  : }

  00001	c3		 ret	 0
?ExceptionAssert@@YIXXZ ENDP				; ExceptionAssert
_TEXT	ENDS
PUBLIC	??_C@_0FD@PDKNOKII@assert?$CIentry?9?$DOscopeBaseAddr?5?$DN?$DN?5b@ ; `string'
PUBLIC	??_C@_0HE@HFLLIPKH@assert?$CI?$CI?$CIentry?9?$DOframeSetupInfo?5?$CG@ ; `string'
PUBLIC	?ExceptionTableLookup@@YI_KPAUClass_System_Exception@@I@Z ; ExceptionTableLookup
EXTRN	?g_RestoreInterrupts@Class_Microsoft_Singularity_Processor@@SIX_N@Z:PROC ; Class_Microsoft_Singularity_Processor::g_RestoreInterrupts
EXTRN	?KdNotifyException@@YIXPAUClass_System_Exception@@I@Z:PROC ; KdNotifyException
EXTRN	?g_DisableInterrupts@Class_Microsoft_Singularity_Processor@@SI_NXZ:PROC ; Class_Microsoft_Singularity_Processor::g_DisableInterrupts
EXTRN	?LogExceptionInfo@@YIXPAUuintPtr@@0PAUClass_System_String@@@Z:PROC ; LogExceptionInfo
EXTRN	?g_IsExceptionHandler@Class_System_VTable@@SI_NPAUClass_System_Type@@PAUClass_System_Exception@@@Z:PROC ; Class_System_VTable::g_IsExceptionHandler
EXTRN	?fail_assert@@YIXPBD@Z:PROC			; fail_assert
EXTRN	?g_TerminateByException@Class_System_VTable@@SIXPAUClass_System_Exception@@@Z:PROC ; Class_System_VTable::g_TerminateByException
EXTRN	?KdDebuggerNotPresent@@3HA:DWORD		; KdDebuggerNotPresent
;	COMDAT ??_C@_0FD@PDKNOKII@assert?$CIentry?9?$DOscopeBaseAddr?5?$DN?$DN?5b@
CONST	SEGMENT
??_C@_0FD@PDKNOKII@assert?$CIentry?9?$DOscopeBaseAddr?5?$DN?$DN?5b@ DB 'a'
	DB	'ssert(entry->scopeBaseAddr == baseAddr) failed at Native\ix64'
	DB	'\halexn.cpp:__LINE__', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HE@HFLLIPKH@assert?$CI?$CI?$CIentry?9?$DOframeSetupInfo?5?$CG@
CONST	SEGMENT
??_C@_0HE@HFLLIPKH@assert?$CI?$CI?$CIentry?9?$DOframeSetupInfo?5?$CG@ DB 'a'
	DB	'ssert(((entry->frameSetupInfo & 0x1) != 0) || (entry->handler'
	DB	'Addr != 0)) failed at Native\ix64\halexn.cpp:__LINE__', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?ExceptionTableLookup@@YI_KPAUClass_System_Exception@@I@Z
_TEXT	SEGMENT
_retval$ = -24						; size = 8
_baseAddr$ = -20					; size = 4
_endEntry$ = -20					; size = 4
_codeBase$ = -16					; size = 4
_baseEntry$ = -12					; size = 4
_exception$ = -8					; size = 4
_iflag$11575 = -1					; size = 1
?ExceptionTableLookup@@YI_KPAUClass_System_Exception@@I@Z PROC ; ExceptionTableLookup, COMDAT
; _exception$ = ecx
; _throwAddr$ = edx

; 167  :                                                  uintptr throwAddr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 168  : 
; 169  : #if 0
; 170  :     printf("\n");
; 171  :     printf("ExceptionTableLookup(exception=%p, vtable=%p, throwAddr=%p)\n",
; 172  :            exception, ((uintptr *)exception)[0], throwAddr);
; 173  : #endif
; 174  : 
; 175  :     if (exception->_throwAddress == NULL) {

  0000a	33 db		 xor	 ebx, ebx
  0000c	39 5e 10	 cmp	 DWORD PTR [esi+16], ebx
  0000f	57		 push	 edi
  00010	8b fa		 mov	 edi, edx
  00012	89 75 f8	 mov	 DWORD PTR _exception$[ebp], esi
  00015	75 03		 jne	 SHORT $LN23@ExceptionT

; 176  :         exception->_throwAddress = throwAddr;

  00017	89 7e 10	 mov	 DWORD PTR [esi+16], edi
$LN23@ExceptionT:

; 177  :     }
; 178  : 
; 179  :     //  search for table using throwAddr
; 180  :     ExceptionTableEntry *baseEntry = NULL;
; 181  :     ExceptionTableEntry *endEntry = NULL;
; 182  :     uintptr codeBase = LookupTable(throwAddr, &baseEntry, &endEntry);

  0001a	8d 45 ec	 lea	 eax, DWORD PTR _endEntry$[ebp]
  0001d	50		 push	 eax
  0001e	8d 4d f4	 lea	 ecx, DWORD PTR _baseEntry$[ebp]
  00021	51		 push	 ecx
  00022	57		 push	 edi
  00023	89 5d f4	 mov	 DWORD PTR _baseEntry$[ebp], ebx
  00026	89 5d ec	 mov	 DWORD PTR _endEntry$[ebp], ebx
  00029	e8 00 00 00 00	 call	 ?LookupTable@@YIIIPAPAUExceptionTableEntry@@0@Z ; LookupTable

; 183  : 
; 184  : #if SINGULARITY_KERNEL
; 185  : #if 0
; 186  :     printf("  codeBase=%p baseEntry=%p endEntry=%p\n",
; 187  :            codeBase, baseEntry, endEntry);
; 188  : #endif
; 189  : #endif
; 190  : 
; 191  :     if (codeBase == (uintptr) -1) {

  0002e	83 f8 ff	 cmp	 eax, -1
  00031	89 45 f0	 mov	 DWORD PTR _codeBase$[ebp], eax
  00034	75 11		 jne	 SHORT $LN28@ExceptionT

; 192  : #if SINGULARITY_KERNEL
; 193  : #if 0
; 194  :         printf("Exception outside of any known code regions!\n");
; 195  : #endif
; 196  :         if (!KdDebuggerNotPresent) {

  00036	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?KdDebuggerNotPresent@@3HA, ebx ; KdDebuggerNotPresent
  0003c	75 01		 jne	 SHORT $LN26@ExceptionT

; 197  :             ExceptionAssert();

  0003e	cc		 int	 3
$LN26@ExceptionT:

; 198  :         }
; 199  : #if 0
; 200  :         printf("Terminating by exception!\n");
; 201  : #endif
; 202  :         Class_System_VTable::g_TerminateByException(exception);

  0003f	8b ce		 mov	 ecx, esi
  00041	e8 00 00 00 00	 call	 ?g_TerminateByException@Class_System_VTable@@SIXPAUClass_System_Exception@@@Z ; Class_System_VTable::g_TerminateByException

; 203  :         ExceptionAssert();

  00046	cc		 int	 3
$LN28@ExceptionT:

; 204  : #elif SINGULARITY_PROCESS
; 205  :         Assert("Exception outside of any known code regions!\n");
; 206  :         Class_System_VTable::g_TerminateByException(exception);
; 207  : #endif
; 208  :     }
; 209  : 
; 210  :     // bsearch for throwAddr
; 211  :     int minIndex = 0;
; 212  :     int maxIndex = (int) (endEntry-baseEntry);

  00047	8b 4d ec	 mov	 ecx, DWORD PTR _endEntry$[ebp]
  0004a	2b 4d f4	 sub	 ecx, DWORD PTR _baseEntry$[ebp]

; 213  :     throwAddr -= codeBase;

  0004d	2b 7d f0	 sub	 edi, DWORD PTR _codeBase$[ebp]
  00050	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00055	f7 e9		 imul	 ecx

; 214  : 
; 215  :     if (throwAddr < baseEntry[minIndex].scopeBaseAddr ||
; 216  :         throwAddr > baseEntry[maxIndex].scopeBaseAddr) {

  00057	8b 4d f4	 mov	 ecx, DWORD PTR _baseEntry$[ebp]
  0005a	d1 fa		 sar	 edx, 1
  0005c	8b f2		 mov	 esi, edx
  0005e	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00061	03 f2		 add	 esi, edx
  00063	3b 39		 cmp	 edi, DWORD PTR [ecx]
  00065	72 08		 jb	 SHORT $LN19@ExceptionT
  00067	8d 14 76	 lea	 edx, DWORD PTR [esi+esi*2]
  0006a	3b 3c 91	 cmp	 edi, DWORD PTR [ecx+edx*4]
  0006d	76 15		 jbe	 SHORT $LN36@ExceptionT
$LN19@ExceptionT:

; 217  :         // BUGBUG: callback to C# code that may trigger GC
; 218  : #if SINGULARITY_KERNEL
; 219  : #if 0
; 220  :         printf("Exception outside of known code region for %p\n", codeBase);
; 221  : #endif
; 222  :         if (!KdDebuggerNotPresent) {

  0006f	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?KdDebuggerNotPresent@@3HA, ebx ; KdDebuggerNotPresent
  00075	75 01		 jne	 SHORT $LN18@ExceptionT

; 223  :             __debugbreak();

  00077	cc		 int	 3
$LN18@ExceptionT:

; 224  :         }
; 225  :         Class_System_VTable::g_TerminateByException(exception);

  00078	8b 4d f8	 mov	 ecx, DWORD PTR _exception$[ebp]
  0007b	e8 00 00 00 00	 call	 ?g_TerminateByException@Class_System_VTable@@SIXPAUClass_System_Exception@@@Z ; Class_System_VTable::g_TerminateByException

; 226  : #if 0
; 227  :         printf("top-level exception handling code failed\n");
; 228  : #endif
; 229  :         __debugbreak();

  00080	cc		 int	 3
  00081	8b 4d f4	 mov	 ecx, DWORD PTR _baseEntry$[ebp]
$LN36@ExceptionT:

; 230  : #elif SINGULARITY_PROCESS
; 231  :         Assert("Exception outside of known code region for.\n");
; 232  :         Class_System_VTable::g_TerminateByException(exception);
; 233  :         Assert("top-level exception handling code failed\n");
; 234  : #endif
; 235  :     }
; 236  :     while (minIndex+1 < maxIndex) {

  00084	83 fe 01	 cmp	 esi, 1
  00087	7e 24		 jle	 SHORT $LN16@ExceptionT
  00089	8d a4 24 00 00
	00 00		 npad	 7
$LL17@ExceptionT:

; 237  :         int midIndex = (minIndex+maxIndex)/2;

  00090	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]
  00093	99		 cdq
  00094	2b c2		 sub	 eax, edx
  00096	d1 f8		 sar	 eax, 1

; 238  :         uintptr midAddr = baseEntry[midIndex].scopeBaseAddr;

  00098	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]

; 239  :         if (throwAddr < midAddr) {

  0009b	3b 3c 91	 cmp	 edi, DWORD PTR [ecx+edx*4]
  0009e	73 04		 jae	 SHORT $LN15@ExceptionT

; 240  :             maxIndex = midIndex;

  000a0	8b f0		 mov	 esi, eax

; 241  :         } else {

  000a2	eb 02		 jmp	 SHORT $LN14@ExceptionT
$LN15@ExceptionT:

; 242  :             minIndex = midIndex;

  000a4	8b d8		 mov	 ebx, eax
$LN14@ExceptionT:

; 230  : #elif SINGULARITY_PROCESS
; 231  :         Assert("Exception outside of known code region for.\n");
; 232  :         Class_System_VTable::g_TerminateByException(exception);
; 233  :         Assert("top-level exception handling code failed\n");
; 234  : #endif
; 235  :     }
; 236  :     while (minIndex+1 < maxIndex) {

  000a6	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  000a9	3b c6		 cmp	 eax, esi
  000ab	7c e3		 jl	 SHORT $LL17@ExceptionT
$LN16@ExceptionT:

; 243  :         }
; 244  :     }
; 245  :     ExceptionTableEntry *entry = &baseEntry[minIndex];

  000ad	8d 14 5b	 lea	 edx, DWORD PTR [ebx+ebx*2]

; 246  : 
; 247  :     //  back up to first entry containing throwAddr (there may be several)
; 248  : 
; 249  :     uintptr baseAddr;
; 250  :     for (baseAddr = entry->scopeBaseAddr;

  000b0	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  000b3	8d 34 91	 lea	 esi, DWORD PTR [ecx+edx*4]
  000b6	89 45 ec	 mov	 DWORD PTR _baseAddr$[ebp], eax
  000b9	8d a4 24 00 00
	00 00		 npad	 7
$LL13@ExceptionT:

; 251  :          entry->scopeBaseAddr == baseAddr && entry >= baseEntry;
; 252  :          entry--) {

  000c0	3b f1		 cmp	 esi, ecx
  000c2	72 07		 jb	 SHORT $LN11@ExceptionT
  000c4	83 ee 0c	 sub	 esi, 12			; 0000000cH
  000c7	39 06		 cmp	 DWORD PTR [esi], eax
  000c9	74 f5		 je	 SHORT $LL13@ExceptionT
$LN11@ExceptionT:

; 253  :         continue;
; 254  :     }
; 255  : 
; 256  :     //  check each of the handlers in turn
; 257  : 
; 258  :     for (entry++; entry->scopeBaseAddr <= throwAddr; entry++) {

  000cb	83 c6 0c	 add	 esi, 12			; 0000000cH
  000ce	39 3e		 cmp	 DWORD PTR [esi], edi
  000d0	77 35		 ja	 SHORT $LN48@ExceptionT
$LL44@ExceptionT:

; 259  : #if 0
; 260  :         printf("    entry=%p[%d]  "
; 261  :                "scopeBaseAddr=%p exceptionClass=%p handler=%p\n",
; 262  :                entry, entry - baseEntry,
; 263  :                entry->scopeBaseAddr, entry->exceptionClass, entry->handlerAddr);
; 264  : #endif
; 265  : 
; 266  :         // 0 now means "no frame pointer omission and no callee save registers
; 267  :         // have been saved to the stack":
; 268  :         // Assert(entry->exceptionClass);
; 269  : 
; 270  :         Assert(((entry->frameSetupInfo & 0x1) != 0)
; 271  :                || (entry->handlerAddr != NULL));

  000d2	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  000d6	75 10		 jne	 SHORT $LN45@ExceptionT
  000d8	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  000dc	75 0a		 jne	 SHORT $LN45@ExceptionT
  000de	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0HE@HFLLIPKH@assert?$CI?$CI?$CIentry?9?$DOframeSetupInfo?5?$CG@
  000e3	e8 00 00 00 00	 call	 ?fail_assert@@YIXPBD@Z	; fail_assert
$LN45@ExceptionT:

; 272  :         if (((entry->frameSetupInfo & 0x1) != 0)
; 273  :             || Class_System_VTable::g_IsExceptionHandler(entry->exceptionClass,
; 274  :                                                          exception)) {

  000e8	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000eb	f6 c1 01	 test	 cl, 1
  000ee	8b 5d f8	 mov	 ebx, DWORD PTR _exception$[ebp]
  000f1	75 17		 jne	 SHORT $LN39@ExceptionT
  000f3	8b d3		 mov	 edx, ebx
  000f5	e8 00 00 00 00	 call	 ?g_IsExceptionHandler@Class_System_VTable@@SI_NPAUClass_System_Type@@PAUClass_System_Exception@@@Z ; Class_System_VTable::g_IsExceptionHandler
  000fa	84 c0		 test	 al, al
  000fc	75 0c		 jne	 SHORT $LN39@ExceptionT
  000fe	83 c6 0c	 add	 esi, 12			; 0000000cH
  00101	39 3e		 cmp	 DWORD PTR [esi], edi
  00103	76 cd		 jbe	 SHORT $LL44@ExceptionT

; 253  :         continue;
; 254  :     }
; 255  : 
; 256  :     //  check each of the handlers in turn
; 257  : 
; 258  :     for (entry++; entry->scopeBaseAddr <= throwAddr; entry++) {

  00105	eb 03		 jmp	 SHORT $LN39@ExceptionT
$LN48@ExceptionT:
  00107	8b 5d f8	 mov	 ebx, DWORD PTR _exception$[ebp]
$LN39@ExceptionT:

; 275  : #if 0
; 276  :             printf("Found matching exception entry: %p\n", entry);
; 277  : #endif
; 278  :             break;
; 279  :         }
; 280  :     }
; 281  :     Assert(entry->scopeBaseAddr == baseAddr);

  0010a	8b 45 ec	 mov	 eax, DWORD PTR _baseAddr$[ebp]
  0010d	39 06		 cmp	 DWORD PTR [esi], eax
  0010f	74 0a		 je	 SHORT $LN4@ExceptionT
  00111	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0FD@PDKNOKII@assert?$CIentry?9?$DOscopeBaseAddr?5?$DN?$DN?5b@
  00116	e8 00 00 00 00	 call	 ?fail_assert@@YIXPBD@Z	; fail_assert
$LN4@ExceptionT:

; 282  : 
; 283  :     ExceptionTableLookupReturn retval;
; 284  : 
; 285  :     if((entry->frameSetupInfo & 0x1) != 0) {

  0011b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0011e	a8 01		 test	 al, 1

; 286  :         retval.frameSetupInfo = entry->frameSetupInfo;
; 287  :         retval.spillSize = entry->spillSize;

  00120	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  00123	89 45 e8	 mov	 DWORD PTR _retval$[ebp], eax
  00126	74 15		 je	 SHORT $LN3@ExceptionT

; 288  : #ifndef NOEVENTING
; 289  :         LogExceptionInfo((UIntPtr)(codeBase + throwAddr),
; 290  :                          0,
; 291  :                          getRealVTable(exception->postHeader.vtableObject)->vtableType->name);

  00128	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0012a	83 e1 fc	 and	 ecx, -4			; fffffffcH
  0012d	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00130	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00133	8b 4d f0	 mov	 ecx, DWORD PTR _codeBase$[ebp]
  00136	03 cf		 add	 ecx, edi
  00138	50		 push	 eax
  00139	33 d2		 xor	 edx, edx

; 292  : #endif
; 293  :     } else {

  0013b	eb 16		 jmp	 SHORT $LN50@ExceptionT
$LN3@ExceptionT:

; 294  :         retval.exceptionClass = entry->exceptionClass;
; 295  :         retval.handlerAddr = entry->handlerAddr + codeBase;

  0013d	8b 45 f0	 mov	 eax, DWORD PTR _codeBase$[ebp]

; 296  : #ifndef NOEVENTING
; 297  :         LogExceptionInfo((UIntPtr)(codeBase + throwAddr),
; 298  :                          (UIntPtr)(retval.handlerAddr),
; 299  :                          getRealVTable(exception->postHeader.vtableObject)->vtableType->name);

  00140	8b 13		 mov	 edx, DWORD PTR [ebx]
  00142	03 f0		 add	 esi, eax
  00144	83 e2 fc	 and	 edx, -4			; fffffffcH
  00147	8b 4a 44	 mov	 ecx, DWORD PTR [edx+68]
  0014a	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0014d	52		 push	 edx
  0014e	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  00151	8b d6		 mov	 edx, esi
$LN50@ExceptionT:
  00153	e8 00 00 00 00	 call	 ?LogExceptionInfo@@YIXPAUuintPtr@@0PAUClass_System_String@@@Z ; LogExceptionInfo

; 300  : #endif
; 301  :     }
; 302  : 
; 303  : #if SINGULARITY_KERNEL
; 304  :     if (!exception->_notifiedDebugger && !KdDebuggerNotPresent) {

  00158	80 7b 0c 00	 cmp	 BYTE PTR [ebx+12], 0
  0015c	75 26		 jne	 SHORT $LN43@ExceptionT
  0015e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?KdDebuggerNotPresent@@3HA, 0 ; KdDebuggerNotPresent
  00165	75 1d		 jne	 SHORT $LN43@ExceptionT

; 305  :         exception->_notifiedDebugger = true;

  00167	c6 43 0c 01	 mov	 BYTE PTR [ebx+12], 1

; 306  : 
; 307  :         bool iflag =
; 308  :             Class_Microsoft_Singularity_Processor::g_DisableInterrupts();

  0016b	e8 00 00 00 00	 call	 ?g_DisableInterrupts@Class_Microsoft_Singularity_Processor@@SI_NXZ ; Class_Microsoft_Singularity_Processor::g_DisableInterrupts

; 309  :         Class_System_VTable * vtable = getRealVTable(exception->postHeader.vtableObject);
; 310  : #if 0
; 311  :         if ((entry->frameSetupInfo & 0x1) != 0) {
; 312  :             printf("\n---- First chance %ls at %p.  Handler is shared ----\n",
; 313  :                    &(vtable->vtableType->name->m_firstChar),
; 314  :                    codeBase + throwAddr);
; 315  :         }
; 316  :         else {
; 317  :             printf("\n---- First chance %ls at %p.  Handler is %p ----\n",
; 318  :                    &(vtable->vtableType->name->m_firstChar),
; 319  :                    codeBase + throwAddr,
; 320  :                    retval.handlerAddr);
; 321  :         }
; 322  :         if (exception->_message != NULL) {
; 323  :             printf("------ Message: %ls\n",
; 324  :                    &(exception->_message->m_firstChar));
; 325  :         }
; 326  : #endif
; 327  :         KdNotifyException(exception, (uint32) throwAddr);

  00170	8b d7		 mov	 edx, edi
  00172	8b cb		 mov	 ecx, ebx
  00174	88 45 ff	 mov	 BYTE PTR _iflag$11575[ebp], al
  00177	e8 00 00 00 00	 call	 ?KdNotifyException@@YIXPAUClass_System_Exception@@I@Z ; KdNotifyException

; 328  :         Class_Microsoft_Singularity_Processor::g_RestoreInterrupts(iflag);

  0017c	8a 4d ff	 mov	 cl, BYTE PTR _iflag$11575[ebp]
  0017f	e8 00 00 00 00	 call	 ?g_RestoreInterrupts@Class_Microsoft_Singularity_Processor@@SIX_N@Z ; Class_Microsoft_Singularity_Processor::g_RestoreInterrupts
$LN43@ExceptionT:

; 329  :     }
; 330  : #endif
; 331  : 
; 332  :     return(retval.etlReturn);

  00184	8b 45 e8	 mov	 eax, DWORD PTR _retval$[ebp]
  00187	5f		 pop	 edi
  00188	8b d6		 mov	 edx, esi
  0018a	5e		 pop	 esi
  0018b	5b		 pop	 ebx

; 333  : }

  0018c	8b e5		 mov	 esp, ebp
  0018e	5d		 pop	 ebp
  0018f	c3		 ret	 0
?ExceptionTableLookup@@YI_KPAUClass_System_Exception@@I@Z ENDP ; ExceptionTableLookup
_TEXT	ENDS
END
