; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	C:\Users\cc\source\repos\Singularity-OS\base\Kernel\Native\ZoneAllocation.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?SetEndOfBuffer@@YIXPAU_MEMORY_ZONE@@@Z		; SetEndOfBuffer
; Function compile flags: /Ogtp
; File c:\users\cc\source\repos\singularity-os\base\kernel\native\zoneallocation.cpp
;	COMDAT ?SetEndOfBuffer@@YIXPAU_MEMORY_ZONE@@@Z
_TEXT	SEGMENT
?SetEndOfBuffer@@YIXPAU_MEMORY_ZONE@@@Z PROC		; SetEndOfBuffer, COMDAT
; _Zone$ = ecx

; 27   :     uint32 * ptr = (uint32 *)((ULONG_PTR)Zone + Zone->ZoneSize);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	03 c1		 add	 eax, ecx

; 28   :     *ptr = EOB_SIGNATURE;

  00005	c7 00 cd cd cd
	cd		 mov	 DWORD PTR [eax], -842150451 ; cdcdcdcdH

; 29   : 
; 30   :     ptr = (uint32 *)((ULONG_PTR)Zone) - 1;
; 31   :     *ptr = BOB_SIGNATURE;

  0000b	c7 41 fc ab ab
	ab ab		 mov	 DWORD PTR [ecx-4], -1414812757 ; ababababH

; 32   : }

  00012	c3		 ret	 0
?SetEndOfBuffer@@YIXPAU_MEMORY_ZONE@@@Z ENDP		; SetEndOfBuffer
_TEXT	ENDS
PUBLIC	?CheckEndOfBuffer@@YIXPAU_MEMORY_ZONE@@@Z	; CheckEndOfBuffer
; Function compile flags: /Ogtp
;	COMDAT ?CheckEndOfBuffer@@YIXPAU_MEMORY_ZONE@@@Z
_TEXT	SEGMENT
?CheckEndOfBuffer@@YIXPAU_MEMORY_ZONE@@@Z PROC		; CheckEndOfBuffer, COMDAT
; _Zone$ = ecx

; 36   :     uint32 * ptr = (uint32 *)((ULONG_PTR)Zone + Zone->ZoneSize);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	03 c1		 add	 eax, ecx

; 37   :     EV_ASSERT(*ptr == EOB_SIGNATURE);

  00005	81 38 cd cd cd
	cd		 cmp	 DWORD PTR [eax], -842150451 ; cdcdcdcdH
  0000b	74 01		 je	 SHORT $LN2@CheckEndOf
  0000d	cc		 int	 3
$LN2@CheckEndOf:

; 38   : 
; 39   :     ptr = (uint32 *)((ULONG_PTR)Zone) - 1;
; 40   :     EV_ASSERT(*ptr == BOB_SIGNATURE);

  0000e	81 79 fc ab ab
	ab ab		 cmp	 DWORD PTR [ecx-4], -1414812757 ; ababababH
  00015	74 01		 je	 SHORT $LN1@CheckEndOf
  00017	cc		 int	 3
$LN1@CheckEndOf:

; 41   : }

  00018	c3		 ret	 0
?CheckEndOfBuffer@@YIXPAU_MEMORY_ZONE@@@Z ENDP		; CheckEndOfBuffer
_TEXT	ENDS
PUBLIC	?InitializeMemoryZone@@YIPAU_MEMORY_ZONE@@PAXGPAUuintPtr@@@Z ; InitializeMemoryZone
; Function compile flags: /Ogtp
;	COMDAT ?InitializeMemoryZone@@YIPAU_MEMORY_ZONE@@PAXGPAUuintPtr@@@Z
_TEXT	SEGMENT
_storageHandle$ = 8					; size = 4
?InitializeMemoryZone@@YIPAU_MEMORY_ZONE@@PAXGPAUuintPtr@@@Z PROC ; InitializeMemoryZone, COMDAT
; _Buffer$ = ecx
; _Size$ = edx

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 54   :     PMEMORY_ZONE Zone;
; 55   : 
; 56   : #ifdef BUFFER_VALIDATION
; 57   : 
; 58   :     //  In buffer validation mode, add extra space for the end signature
; 59   :     //  to detect potential buffer overruns
; 60   : 
; 61   :     Size = Size - 2 * sizeof(uint32);

  00003	81 c2 f8 ff 00
	00		 add	 edx, 65528		; 0000fff8H

; 63   : 
; 64   : #endif // BUFFER_VALIDATION
; 65   : 
; 66   :     if (Size <= sizeof(MEMORY_ZONE)) {

  00009	66 83 fa 20	 cmp	 dx, 32			; 00000020H
  0000d	77 06		 ja	 SHORT $LN3@Initialize

; 67   :         return NULL;

  0000f	33 c0		 xor	 eax, eax

; 90   :     return Zone;
; 91   : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Initialize:

; 62   :     Buffer = (void *)((ULONG_PTR)Buffer + sizeof(uint32));

  00015	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 68   :     }
; 69   : 
; 70   :     Zone = (PMEMORY_ZONE)Buffer;
; 71   : 
; 72   :     Zone->ZoneSize = Size;

  00018	0f b7 ca	 movzx	 ecx, dx
  0001b	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 73   :     Zone->Link = NULL;
; 74   :     Zone->StorageHandle = storageHandle;

  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _storageHandle$[ebp]
  00021	33 d2		 xor	 edx, edx
  00023	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00026	89 10		 mov	 DWORD PTR [eax], edx

; 75   :     Zone->LastSyncPoint = 0;

  00028	66 89 50 1c	 mov	 WORD PTR [eax+28], dx

; 76   : 
; 77   :     Zone->Allocation.AtomicValue32 = 0;

  0002c	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 78   :     Zone->ReadyList.AtomicValue32 = 0;
; 79   : 
; 80   :     Zone->Allocation.FreeOffset = sizeof(MEMORY_ZONE);
; 81   : 
; 82   :     //  Assert the assumptions regarding the bit values that have been initialized
; 83   :     //  with the dword write above
; 84   : 
; 85   :     EV_ASSERT(Zone->Allocation.Filled == 0);

  0002f	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  00033	f7 c1 00 40 00
	00		 test	 ecx, 16384		; 00004000H
  00039	89 50 10	 mov	 DWORD PTR [eax+16], edx
  0003c	66 c7 40 0c 20
	00		 mov	 WORD PTR [eax+12], 32	; 00000020H
  00042	74 01		 je	 SHORT $LN2@Initialize
  00044	cc		 int	 3
$LN2@Initialize:

; 86   :     EV_ASSERT(Zone->Allocation.Committed  == 0);

  00045	f7 c1 00 80 00
	00		 test	 ecx, 32768		; 00008000H
  0004b	74 01		 je	 SHORT $LN1@Initialize
  0004d	cc		 int	 3
$LN1@Initialize:

; 87   :     Zone->Generation = 0;
; 88   : 
; 89   :     SetEndOfBuffer(Zone);

  0004e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00051	89 50 18	 mov	 DWORD PTR [eax+24], edx
  00054	03 c8		 add	 ecx, eax
  00056	c7 01 cd cd cd
	cd		 mov	 DWORD PTR [ecx], -842150451 ; cdcdcdcdH
  0005c	c7 40 fc ab ab
	ab ab		 mov	 DWORD PTR [eax-4], -1414812757 ; ababababH

; 90   :     return Zone;
; 91   : }

  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?InitializeMemoryZone@@YIPAU_MEMORY_ZONE@@PAXGPAUuintPtr@@@Z ENDP ; InitializeMemoryZone
_TEXT	ENDS
PUBLIC	?MarkZoneFull@@YIXPAU_MEMORY_ZONE@@@Z		; MarkZoneFull
; Function compile flags: /Ogtp
;	COMDAT ?MarkZoneFull@@YIXPAU_MEMORY_ZONE@@@Z
_TEXT	SEGMENT
_CapturedOffset$ = -8					; size = 4
_NextValueOffset$ = -4					; size = 4
?MarkZoneFull@@YIXPAU_MEMORY_ZONE@@@Z PROC		; MarkZoneFull, COMDAT
; _Zone$ = ecx

; 151  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 152  :     ZONE_ALLOCATION_POINTER CapturedOffset;
; 153  :     ZONE_ALLOCATION_POINTER NextValueOffset;
; 154  : 
; 155  :     CheckEndOfBuffer(Zone);

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	03 c1		 add	 eax, ecx
  00008	83 ec 08	 sub	 esp, 8
  0000b	81 38 cd cd cd
	cd		 cmp	 DWORD PTR [eax], -842150451 ; cdcdcdcdH
  00011	74 01		 je	 SHORT $LN9@MarkZoneFu
  00013	cc		 int	 3
$LN9@MarkZoneFu:
  00014	81 79 fc ab ab
	ab ab		 cmp	 DWORD PTR [ecx-4], -1414812757 ; ababababH
  0001b	74 01		 je	 SHORT $LN12@MarkZoneFu
  0001d	cc		 int	 3
$LN12@MarkZoneFu:
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	8d 71 0c	 lea	 esi, DWORD PTR [ecx+12]
$LL5@MarkZoneFu:

; 156  : 
; 157  :     do {
; 158  : 
; 159  :         CapturedOffset.AtomicValue32 = Zone->Allocation.AtomicValue32;

  00023	8b 06		 mov	 eax, DWORD PTR [esi]
  00025	89 45 f8	 mov	 DWORD PTR _CapturedOffset$[ebp], eax

; 160  : 
; 161  :         if (CapturedOffset.Filled) {

  00028	8b 45 f8	 mov	 eax, DWORD PTR _CapturedOffset$[ebp]
  0002b	c1 e8 10	 shr	 eax, 16			; 00000010H
  0002e	a9 00 40 00 00	 test	 eax, 16384		; 00004000H
  00033	75 3d		 jne	 SHORT $LN3@MarkZoneFu

; 162  : 
; 163  :             //  Someone already did it. We are done here.
; 164  : 
; 165  :             return;
; 166  :         }
; 167  : 
; 168  :         NextValueOffset.AtomicValue32 = CapturedOffset.AtomicValue32;

  00035	8b 55 f8	 mov	 edx, DWORD PTR _CapturedOffset$[ebp]
  00038	89 55 fc	 mov	 DWORD PTR _NextValueOffset$[ebp], edx

; 169  :         NextValueOffset.Filled = 1;

  0003b	8b 55 fc	 mov	 edx, DWORD PTR _NextValueOffset$[ebp]
  0003e	c1 ea 10	 shr	 edx, 16			; 00000010H
  00041	81 ca 00 40 00
	00		 or	 edx, 16384		; 00004000H

; 170  : 
; 171  :         //
; 172  :         //  Atomically also set the committed flag if all entries have been commited
; 173  :         //
; 174  : 
; 175  :         if (Zone->ReadyList.Count == CapturedOffset.Count) {

  00047	25 ff 1f 00 00	 and	 eax, 8191		; 00001fffH
  0004c	66 39 41 12	 cmp	 WORD PTR [ecx+18], ax
  00050	66 89 55 fe	 mov	 WORD PTR _NextValueOffset$[ebp+2], dx
  00054	75 09		 jne	 SHORT $LN4@MarkZoneFu

; 176  : 
; 177  :             NextValueOffset.Committed = 1;

  00056	66 81 ca 00 80	 or	 dx, 32768		; 00008000H
  0005b	66 89 55 fe	 mov	 WORD PTR _NextValueOffset$[ebp+2], dx
$LN4@MarkZoneFu:

; 178  :         }
; 179  : 
; 180  :     } while (InterlockedCompareExchange(&Zone->Allocation.AtomicValue32,
; 181  :                 NextValueOffset.AtomicValue32,
; 182  :                 CapturedOffset.AtomicValue32) != CapturedOffset.AtomicValue32);

  0005f	8b 45 f8	 mov	 eax, DWORD PTR _CapturedOffset$[ebp]
  00062	8b 55 fc	 mov	 edx, DWORD PTR _NextValueOffset$[ebp]
  00065	8b fe		 mov	 edi, esi
  00067	f0 0f b1 17	 lock	  cmpxchg DWORD PTR [edi], edx
  0006b	8b 55 f8	 mov	 edx, DWORD PTR _CapturedOffset$[ebp]
  0006e	3b c2		 cmp	 eax, edx
  00070	75 b1		 jne	 SHORT $LL5@MarkZoneFu
$LN3@MarkZoneFu:
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi

; 183  : 
; 184  : }

  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
?MarkZoneFull@@YIXPAU_MEMORY_ZONE@@@Z ENDP		; MarkZoneFull
_TEXT	ENDS
PUBLIC	?MarkZoneCommited@@YIXPAU_MEMORY_ZONE@@@Z	; MarkZoneCommited
; Function compile flags: /Ogtp
;	COMDAT ?MarkZoneCommited@@YIXPAU_MEMORY_ZONE@@@Z
_TEXT	SEGMENT
_NextValue$ = -8					; size = 4
_CapturedValue$ = -4					; size = 4
?MarkZoneCommited@@YIXPAU_MEMORY_ZONE@@@Z PROC		; MarkZoneCommited, COMDAT
; _Zone$ = ecx

; 188  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 189  :     ZONE_ALLOCATION_POINTER CapturedValue;
; 190  :     ZONE_ALLOCATION_POINTER NextValue;
; 191  : 
; 192  :     CheckEndOfBuffer(Zone);

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	03 c1		 add	 eax, ecx
  00008	83 ec 08	 sub	 esp, 8
  0000b	81 38 cd cd cd
	cd		 cmp	 DWORD PTR [eax], -842150451 ; cdcdcdcdH
  00011	74 01		 je	 SHORT $LN9@MarkZoneCo
  00013	cc		 int	 3
$LN9@MarkZoneCo:
  00014	81 79 fc ab ab
	ab ab		 cmp	 DWORD PTR [ecx-4], -1414812757 ; ababababH
  0001b	74 01		 je	 SHORT $LN12@MarkZoneCo
  0001d	cc		 int	 3
$LN12@MarkZoneCo:
  0001e	56		 push	 esi
  0001f	8d 51 0c	 lea	 edx, DWORD PTR [ecx+12]
  00022	57		 push	 edi
$LL5@MarkZoneCo:

; 193  : 
; 194  :     do {
; 195  : 
; 196  :         CapturedValue.AtomicValue32 = Zone->Allocation.AtomicValue32;

  00023	8b 02		 mov	 eax, DWORD PTR [edx]
  00025	89 45 fc	 mov	 DWORD PTR _CapturedValue$[ebp], eax

; 197  : 
; 198  :         if ((CapturedValue.Committed == 1)
; 199  :                 ||
; 200  :             (CapturedValue.Recycling == 1)
; 201  :                 ||
; 202  :             (CapturedValue.Filled == 0)
; 203  :                 ||
; 204  :             (Zone->ReadyList.Count != CapturedValue.Count)) {

  00028	8b 45 fc	 mov	 eax, DWORD PTR _CapturedValue$[ebp]
  0002b	c1 e8 10	 shr	 eax, 16			; 00000010H
  0002e	a9 00 a0 00 00	 test	 eax, 40960		; 0000a000H
  00033	75 3a		 jne	 SHORT $LN3@MarkZoneCo
  00035	a9 00 40 00 00	 test	 eax, 16384		; 00004000H
  0003a	74 33		 je	 SHORT $LN3@MarkZoneCo
  0003c	25 ff 1f 00 00	 and	 eax, 8191		; 00001fffH
  00041	66 39 41 12	 cmp	 WORD PTR [ecx+18], ax
  00045	75 28		 jne	 SHORT $LN3@MarkZoneCo

; 205  : 
; 206  :             return;
; 207  :         }
; 208  : 
; 209  :         NextValue.AtomicValue32 = CapturedValue.AtomicValue32;

  00047	8b 45 fc	 mov	 eax, DWORD PTR _CapturedValue$[ebp]
  0004a	89 45 f8	 mov	 DWORD PTR _NextValue$[ebp], eax

; 210  :         NextValue.Committed = 1;

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _NextValue$[ebp]
  00050	c1 e8 10	 shr	 eax, 16			; 00000010H
  00053	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  00058	66 89 45 fa	 mov	 WORD PTR _NextValue$[ebp+2], ax

; 211  : 
; 212  :     } while (InterlockedCompareExchange(&Zone->Allocation.AtomicValue32,
; 213  :                 NextValue.AtomicValue32,
; 214  :                 CapturedValue.AtomicValue32) != CapturedValue.AtomicValue32);

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _CapturedValue$[ebp]
  0005f	8b 75 f8	 mov	 esi, DWORD PTR _NextValue$[ebp]
  00062	8b fa		 mov	 edi, edx
  00064	f0 0f b1 37	 lock	  cmpxchg DWORD PTR [edi], esi
  00068	8b 75 fc	 mov	 esi, DWORD PTR _CapturedValue$[ebp]
  0006b	3b c6		 cmp	 eax, esi
  0006d	75 b4		 jne	 SHORT $LL5@MarkZoneCo
$LN3@MarkZoneCo:
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi

; 215  : 
; 216  : }

  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?MarkZoneCommited@@YIXPAU_MEMORY_ZONE@@@Z ENDP		; MarkZoneCommited
_TEXT	ENDS
PUBLIC	?AllocateEventEntry@@YIPAU_MEMORY_HEADER@@PAU_MEMORY_ZONE@@G@Z ; AllocateEventEntry
EXTRN	?g_GetCurrentProcessorContext@Class_Microsoft_Singularity_Processor@@SIPAUStruct_Microsoft_Singularity_ProcessorContext@@XZ:PROC ; Class_Microsoft_Singularity_Processor::g_GetCurrentProcessorContext
EXTRN	?g_GetCurrentThreadContext@Class_Microsoft_Singularity_Processor@@SIPAUStruct_Microsoft_Singularity_ThreadContext@@XZ:PROC ; Class_Microsoft_Singularity_Processor::g_GetCurrentThreadContext
;	COMDAT ?s_timestamp@?O@??AllocateEventEntry@@YIPAU_MEMORY_HEADER@@PAU_MEMORY_ZONE@@G@Z@4JA
_BSS	SEGMENT
?s_timestamp@?O@??AllocateEventEntry@@YIPAU_MEMORY_HEADER@@PAU_MEMORY_ZONE@@G@Z@4JA DD 01H DUP (?) ; `AllocateEventEntry'::`14'::s_timestamp
; Function compile flags: /Ogtp
_BSS	ENDS
;	COMDAT ?AllocateEventEntry@@YIPAU_MEMORY_HEADER@@PAU_MEMORY_ZONE@@G@Z
_TEXT	SEGMENT
_NextValueOffset$ = -12					; size = 4
_CapturedOffset$ = -4					; size = 4
?AllocateEventEntry@@YIPAU_MEMORY_HEADER@@PAU_MEMORY_ZONE@@G@Z PROC ; AllocateEventEntry, COMDAT
; _Zone$ = ecx
; _size$ = edx

; 221  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx

; 222  :     PMEMORY_HEADER ReturnBuffer;
; 223  :     ZONE_ALLOCATION_POINTER CapturedOffset;
; 224  :     ZONE_ALLOCATION_POINTER NextValueOffset;
; 225  :     uint16 Reqsize = size;
; 226  : 
; 227  :     CheckEndOfBuffer(Zone);

  0000b	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0000e	03 c7		 add	 eax, edi
  00010	81 38 cd cd cd
	cd		 cmp	 DWORD PTR [eax], -842150451 ; cdcdcdcdH
  00016	74 01		 je	 SHORT $LN12@AllocateEv
  00018	cc		 int	 3
$LN12@AllocateEv:
  00019	81 7f fc ab ab
	ab ab		 cmp	 DWORD PTR [edi-4], -1414812757 ; ababababH
  00020	74 01		 je	 SHORT $LN11@AllocateEv
  00022	cc		 int	 3
$LN11@AllocateEv:

; 228  : 
; 229  :     size += sizeof(MEMORY_HEADER);
; 230  :     size = (uint16)ROUND_UP_TO_POWER2(size, sizeof(uint64));

  00023	8d 4a 1f	 lea	 ecx, DWORD PTR [edx+31]
  00026	81 e1 f8 ff 00
	00		 and	 ecx, 65528		; 0000fff8H
  0002c	8d 64 24 00	 npad	 4
$LL8@AllocateEv:

; 231  : 
; 232  :     do {
; 233  : 
; 234  :         CapturedOffset.AtomicValue32 = Zone->Allocation.AtomicValue32;

  00030	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00033	89 45 fc	 mov	 DWORD PTR _CapturedOffset$[ebp], eax

; 235  :         ReturnBuffer = GetMemoryHeader(Zone, CapturedOffset.FreeOffset);

  00036	8b 45 fc	 mov	 eax, DWORD PTR _CapturedOffset$[ebp]
  00039	0f b7 f0	 movzx	 esi, ax

; 236  : 
; 237  :         if (CapturedOffset.Filled) {

  0003c	c1 e8 10	 shr	 eax, 16			; 00000010H
  0003f	03 f7		 add	 esi, edi
  00041	a9 00 40 00 00	 test	 eax, 16384		; 00004000H
  00046	0f 85 df 00 00
	00		 jne	 $LN20@AllocateEv

; 238  : 
; 239  :             return NULL;
; 240  :         }
; 241  : 
; 242  :         NextValueOffset.AtomicValue32 = CapturedOffset.AtomicValue32;

  0004c	8b 55 fc	 mov	 edx, DWORD PTR _CapturedOffset$[ebp]
  0004f	89 55 f4	 mov	 DWORD PTR _NextValueOffset$[ebp], edx

; 243  :         NextValueOffset.FreeOffset += size;
; 244  :         NextValueOffset.Count += 1;

  00052	8b 55 f6	 mov	 edx, DWORD PTR _NextValueOffset$[ebp+2]
  00055	66 8b 45 f4	 mov	 ax, WORD PTR _NextValueOffset$[ebp]
  00059	8d 5a 01	 lea	 ebx, DWORD PTR [edx+1]
  0005c	33 da		 xor	 ebx, edx
  0005e	66 03 c1	 add	 ax, cx
  00061	81 e3 ff 1f 00
	00		 and	 ebx, 8191		; 00001fffH
  00067	66 31 5d f6	 xor	 WORD PTR _NextValueOffset$[ebp+2], bx

; 245  : 
; 246  :         if ((NextValueOffset.FreeOffset >= Zone->ZoneSize)
; 247  :                 ||
; 248  :             (NextValueOffset.FreeOffset < CapturedOffset.FreeOffset )) {

  0006b	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  0006e	0f b7 d0	 movzx	 edx, ax
  00071	3b d3		 cmp	 edx, ebx
  00073	66 89 45 f4	 mov	 WORD PTR _NextValueOffset$[ebp], ax
  00077	0f 83 a7 00 00
	00		 jae	 $LN3@AllocateEv
  0007d	66 3b 45 fc	 cmp	 ax, WORD PTR _CapturedOffset$[ebp]
  00081	0f 82 9d 00 00
	00		 jb	 $LN3@AllocateEv

; 255  :         }
; 256  :     } while (InterlockedCompareExchange(&Zone->Allocation.AtomicValue32,
; 257  :                 NextValueOffset.AtomicValue32,
; 258  :                 CapturedOffset.AtomicValue32) != CapturedOffset.AtomicValue32);

  00087	8b 45 fc	 mov	 eax, DWORD PTR _CapturedOffset$[ebp]
  0008a	8b 55 f4	 mov	 edx, DWORD PTR _NextValueOffset$[ebp]
  0008d	8b da		 mov	 ebx, edx
  0008f	8d 57 0c	 lea	 edx, DWORD PTR [edi+12]
  00092	f0 0f b1 1a	 lock	  cmpxchg DWORD PTR [edx], ebx
  00096	8b 55 fc	 mov	 edx, DWORD PTR _CapturedOffset$[ebp]
  00099	3b c2		 cmp	 eax, edx
  0009b	75 93		 jne	 SHORT $LL8@AllocateEv

; 259  : 
; 260  :     EV_ASSERT(((ULONG_PTR)ReturnBuffer + size) <= ((ULONG_PTR)Zone + Zone->ZoneSize));

  0009d	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  000a0	0f b7 c1	 movzx	 eax, cx
  000a3	03 c6		 add	 eax, esi
  000a5	03 d7		 add	 edx, edi
  000a7	3b c2		 cmp	 eax, edx
  000a9	76 01		 jbe	 SHORT $LN2@AllocateEv
  000ab	cc		 int	 3
$LN2@AllocateEv:

; 261  :     EV_ASSERT((ULONG_PTR)ReturnBuffer >= ((ULONG_PTR)(Zone + 1)));

  000ac	8d 47 20	 lea	 eax, DWORD PTR [edi+32]
  000af	3b f0		 cmp	 esi, eax
  000b1	73 01		 jae	 SHORT $LN1@AllocateEv
  000b3	cc		 int	 3
$LN1@AllocateEv:

; 262  : #ifdef BUFFER_VALIDATION
; 263  :     ReturnBuffer->Link = 0xffff;
; 264  : #endif
; 265  : 
; 266  :     ReturnBuffer->Size = (uint16)size;

  000b4	66 89 0e	 mov	 WORD PTR [esi], cx

; 267  :     ReturnBuffer->Offset = CapturedOffset.FreeOffset;

  000b7	66 8b 4d fc	 mov	 cx, WORD PTR _CapturedOffset$[ebp]
  000bb	66 c7 46 02 ff
	ff		 mov	 WORD PTR [esi+2], 65535	; 0000ffffH
  000c1	66 89 4e 04	 mov	 WORD PTR [esi+4], cx

; 268  :     ReturnBuffer->Flags = 0;

  000c5	66 c7 46 06 00
	00		 mov	 WORD PTR [esi+6], 0

; 269  : 
; 270  : 
; 271  :     Struct_Microsoft_Singularity_ThreadContext *threadContext =
; 272  :         Class_Microsoft_Singularity_Processor::g_GetCurrentThreadContext();

  000cb	e8 00 00 00 00	 call	 ?g_GetCurrentThreadContext@Class_Microsoft_Singularity_Processor@@SIPAUStruct_Microsoft_Singularity_ThreadContext@@XZ ; Class_Microsoft_Singularity_Processor::g_GetCurrentThreadContext
  000d0	8b d8		 mov	 ebx, eax

; 273  :     Struct_Microsoft_Singularity_ProcessorContext *processorContext =
; 274  :         Class_Microsoft_Singularity_Processor::g_GetCurrentProcessorContext();

  000d2	e8 00 00 00 00	 call	 ?g_GetCurrentProcessorContext@Class_Microsoft_Singularity_Processor@@SIPAUStruct_Microsoft_Singularity_ProcessorContext@@XZ ; Class_Microsoft_Singularity_Processor::g_GetCurrentProcessorContext

; 275  : 
; 276  : #if SINGULARITY_KERNEL
; 277  :     ReturnBuffer->TID = threadContext->threadIndex;

  000d7	66 8b 93 88 02
	00 00		 mov	 dx, WORD PTR [ebx+648]
  000de	66 89 56 14	 mov	 WORD PTR [esi+20], dx

; 278  : #else
; 279  :     ReturnBuffer->TID = threadContext->kernelThreadIndex;
; 280  : #endif
; 281  :     ReturnBuffer->Cpu = processorContext->cpuRecord.id;

  000e2	66 8b 80 40 02
	00 00		 mov	 ax, WORD PTR [eax+576]
  000e9	66 89 46 16	 mov	 WORD PTR [esi+22], ax

; 282  : 
; 283  : #if ISA_XSCALE
; 284  :     ReturnBuffer->Timestamp = Class_Microsoft_Singularity_Isal_Isa::g_GetCycleCount();
; 285  : #else // ISA_XSCALE
; 286  :     // Guarantee strict ordering across all CPUs (which RDTSC does not provide)
; 287  :     static long s_timestamp;
; 288  :     ReturnBuffer->Timestamp = ::InterlockedIncrement(&s_timestamp);

  000ed	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_timestamp@?O@??AllocateEventEntry@@YIPAU_MEMORY_HEADER@@PAU_MEMORY_ZONE@@G@Z@4JA
  000f2	b8 01 00 00 00	 mov	 eax, 1
  000f7	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  000fb	40		 inc	 eax
  000fc	99		 cdq
  000fd	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00100	89 56 0c	 mov	 DWORD PTR [esi+12], edx

; 289  : #endif // ISA_XSCALE
; 290  : 
; 291  :     CheckEndOfBuffer(Zone);

  00103	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00106	03 c7		 add	 eax, edi
  00108	81 38 cd cd cd
	cd		 cmp	 DWORD PTR [eax], -842150451 ; cdcdcdcdH
  0010e	74 01		 je	 SHORT $LN16@AllocateEv
  00110	cc		 int	 3
$LN16@AllocateEv:
  00111	81 7f fc ab ab
	ab ab		 cmp	 DWORD PTR [edi-4], -1414812757 ; ababababH
  00118	74 01		 je	 SHORT $LN15@AllocateEv
  0011a	cc		 int	 3
$LN15@AllocateEv:
  0011b	5f		 pop	 edi

; 292  : 
; 293  :     return ReturnBuffer;

  0011c	8b c6		 mov	 eax, esi
  0011e	5e		 pop	 esi
  0011f	5b		 pop	 ebx

; 294  : }

  00120	8b e5		 mov	 esp, ebp
  00122	5d		 pop	 ebp
  00123	c3		 ret	 0
$LN3@AllocateEv:

; 249  : 
; 250  :             MarkZoneFull(Zone);

  00124	8b cf		 mov	 ecx, edi
  00126	e8 00 00 00 00	 call	 ?MarkZoneFull@@YIXPAU_MEMORY_ZONE@@@Z ; MarkZoneFull
$LN20@AllocateEv:
  0012b	5f		 pop	 edi
  0012c	5e		 pop	 esi

; 251  : 
; 252  :             // After that call this zone might have been recycled, no operations
; 253  : 
; 254  :             return NULL;

  0012d	33 c0		 xor	 eax, eax
  0012f	5b		 pop	 ebx

; 294  : }

  00130	8b e5		 mov	 esp, ebp
  00132	5d		 pop	 ebp
  00133	c3		 ret	 0
?AllocateEventEntry@@YIPAU_MEMORY_HEADER@@PAU_MEMORY_ZONE@@G@Z ENDP ; AllocateEventEntry
_TEXT	ENDS
PUBLIC	?CommitEventEntry@@YIXPAU_MEMORY_HEADER@@@Z	; CommitEventEntry
; Function compile flags: /Ogtp
;	COMDAT ?CommitEventEntry@@YIXPAU_MEMORY_HEADER@@@Z
_TEXT	SEGMENT
_CapturedAllocationInfo$ = -12				; size = 4
_NextReadyList$ = -8					; size = 4
_CapturedReadyList$ = -4				; size = 4
?CommitEventEntry@@YIXPAU_MEMORY_HEADER@@@Z PROC	; CommitEventEntry, COMDAT
; _Entry$ = ecx

; 298  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx

; 299  :     PMEMORY_ZONE Zone = (PMEMORY_ZONE)((ULONG_PTR)Entry - Entry->Offset);

  0000b	0f b7 47 04	 movzx	 eax, WORD PTR [edi+4]
  0000f	2b c8		 sub	 ecx, eax

; 300  :     ZONE_ALLOCATION_POINTER CapturedAllocationInfo;
; 301  :     ZONE_READY_LIST CapturedReadyList;
; 302  :     ZONE_READY_LIST NextReadyList;
; 303  : 
; 304  :     EV_ASSERT(Entry->Link == 0xffff);

  00011	66 81 7f 02 ff
	ff		 cmp	 WORD PTR [edi+2], 65535	; 0000ffffH
  00017	74 01		 je	 SHORT $LN8@CommitEven
  00019	cc		 int	 3
$LN8@CommitEven:

; 305  :     CheckEndOfBuffer(Zone);

  0001a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0001d	03 c1		 add	 eax, ecx
  0001f	81 38 cd cd cd
	cd		 cmp	 DWORD PTR [eax], -842150451 ; cdcdcdcdH
  00025	74 01		 je	 SHORT $LN12@CommitEven
  00027	cc		 int	 3
$LN12@CommitEven:
  00028	81 79 fc ab ab
	ab ab		 cmp	 DWORD PTR [ecx-4], -1414812757 ; ababababH
  0002f	74 01		 je	 SHORT $LL7@CommitEven
  00031	cc		 int	 3
$LL7@CommitEven:

; 306  : 
; 307  :     do {
; 308  : 
; 309  :         CapturedReadyList.AtomicValue32 = Zone->ReadyList.AtomicValue32;

  00032	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00035	89 55 fc	 mov	 DWORD PTR _CapturedReadyList$[ebp], edx

; 310  :         CapturedAllocationInfo.AtomicValue32 = Zone->Allocation.AtomicValue32;

  00038	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0003b	89 45 f4	 mov	 DWORD PTR _CapturedAllocationInfo$[ebp], eax

; 311  : 
; 312  :         EV_ASSERT(CapturedAllocationInfo.Committed == 0);

  0003e	8b 5d f4	 mov	 ebx, DWORD PTR _CapturedAllocationInfo$[ebp]
  00041	8b c3		 mov	 eax, ebx
  00043	c1 e8 10	 shr	 eax, 16			; 00000010H
  00046	a9 00 80 00 00	 test	 eax, 32768		; 00008000H
  0004b	74 01		 je	 SHORT $LN4@CommitEven
  0004d	cc		 int	 3
$LN4@CommitEven:

; 313  :         EV_ASSERT(CapturedAllocationInfo.Count > CapturedReadyList.Count);

  0004e	8b 75 fc	 mov	 esi, DWORD PTR _CapturedReadyList$[ebp]
  00051	8b d6		 mov	 edx, esi
  00053	25 ff 1f 00 00	 and	 eax, 8191		; 00001fffH
  00058	c1 ea 10	 shr	 edx, 16			; 00000010H
  0005b	66 3b c2	 cmp	 ax, dx
  0005e	77 01		 ja	 SHORT $LN3@CommitEven
  00060	cc		 int	 3
$LN3@CommitEven:

; 314  : 
; 315  :         Entry->Link = CapturedReadyList.ReadyList;
; 316  : 
; 317  :         NextReadyList.Count = CapturedReadyList.Count + 1;

  00061	83 c2 01	 add	 edx, 1

; 318  :         NextReadyList.ReadyList = Entry->Offset;
; 319  : 
; 320  :         if (NextReadyList.Count == CapturedAllocationInfo.Count) {

  00064	66 3b d0	 cmp	 dx, ax
  00067	66 89 77 02	 mov	 WORD PTR [edi+2], si
  0006b	66 8b 77 04	 mov	 si, WORD PTR [edi+4]
  0006f	66 89 55 fa	 mov	 WORD PTR _NextReadyList$[ebp+2], dx
  00073	66 89 75 f8	 mov	 WORD PTR _NextReadyList$[ebp], si
  00077	75 04		 jne	 SHORT $LN6@CommitEven

; 321  : 
; 322  :             //  Remember the new high watermark for forward zone walking
; 323  : 
; 324  :             Zone->LastSyncPoint = CapturedAllocationInfo.FreeOffset;

  00079	66 89 59 1c	 mov	 WORD PTR [ecx+28], bx
$LN6@CommitEven:

; 325  :         }
; 326  : 
; 327  :     } while (InterlockedCompareExchange(&Zone->ReadyList.AtomicValue32,
; 328  :              NextReadyList.AtomicValue32,
; 329  :              CapturedReadyList.AtomicValue32) != CapturedReadyList.AtomicValue32);

  0007d	8b 45 fc	 mov	 eax, DWORD PTR _CapturedReadyList$[ebp]
  00080	8b 55 f8	 mov	 edx, DWORD PTR _NextReadyList$[ebp]
  00083	8b f2		 mov	 esi, edx
  00085	8d 51 10	 lea	 edx, DWORD PTR [ecx+16]
  00088	f0 0f b1 32	 lock	  cmpxchg DWORD PTR [edx], esi
  0008c	8b 55 fc	 mov	 edx, DWORD PTR _CapturedReadyList$[ebp]
  0008f	3b c2		 cmp	 eax, edx
  00091	75 9f		 jne	 SHORT $LL7@CommitEven

; 330  : 
; 331  :     if (Zone->Allocation.Filled) {

  00093	66 f7 41 0e 00
	40		 test	 WORD PTR [ecx+14], 16384 ; 00004000H
  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx
  0009c	74 05		 je	 SHORT $LN1@CommitEven

; 332  : 
; 333  :         //  The thread that took the last entry from the zone, did not had
; 334  :         //  a chance to see this last commit. We need to update also the
; 335  :         //  commit flag
; 336  : 
; 337  :         MarkZoneCommited(Zone);

  0009e	e8 00 00 00 00	 call	 ?MarkZoneCommited@@YIXPAU_MEMORY_ZONE@@@Z ; MarkZoneCommited
$LN1@CommitEven:

; 338  :     }
; 339  : 
; 340  : 
; 341  : }

  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
?CommitEventEntry@@YIXPAU_MEMORY_HEADER@@@Z ENDP	; CommitEventEntry
_TEXT	ENDS
PUBLIC	?IsZoneCompleted@@YI_NPAU_MEMORY_ZONE@@@Z	; IsZoneCompleted
; Function compile flags: /Ogtp
;	COMDAT ?IsZoneCompleted@@YI_NPAU_MEMORY_ZONE@@@Z
_TEXT	SEGMENT
_CapturedValue$ = -4					; size = 4
?IsZoneCompleted@@YI_NPAU_MEMORY_ZONE@@@Z PROC		; IsZoneCompleted, COMDAT
; _Zone$ = ecx

; 346  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 347  :     ZONE_ALLOCATION_POINTER CapturedValue;
; 348  : 
; 349  :     CapturedValue.AtomicValue32 = Zone->Allocation.AtomicValue32;

  00004	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00007	89 45 fc	 mov	 DWORD PTR _CapturedValue$[ebp], eax

; 350  :     return ((CapturedValue.Filled != 0) && (CapturedValue.Committed != 0));

  0000a	8b 45 fc	 mov	 eax, DWORD PTR _CapturedValue$[ebp]
  0000d	c1 e8 10	 shr	 eax, 16			; 00000010H
  00010	a9 00 40 00 00	 test	 eax, 16384		; 00004000H
  00015	74 10		 je	 SHORT $LN3@IsZoneComp
  00017	a9 00 80 00 00	 test	 eax, 32768		; 00008000H
  0001c	74 09		 je	 SHORT $LN3@IsZoneComp
  0001e	b8 01 00 00 00	 mov	 eax, 1

; 351  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN3@IsZoneComp:

; 350  :     return ((CapturedValue.Filled != 0) && (CapturedValue.Committed != 0));

  00027	33 c0		 xor	 eax, eax

; 351  : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?IsZoneCompleted@@YI_NPAU_MEMORY_ZONE@@@Z ENDP		; IsZoneCompleted
_TEXT	ENDS
PUBLIC	?IsEntryCommited@@YI_NPAU_MEMORY_ZONE@@PAU_MEMORY_HEADER@@@Z ; IsEntryCommited
; Function compile flags: /Ogtp
;	COMDAT ?IsEntryCommited@@YI_NPAU_MEMORY_ZONE@@PAU_MEMORY_HEADER@@@Z
_TEXT	SEGMENT
?IsEntryCommited@@YI_NPAU_MEMORY_ZONE@@PAU_MEMORY_HEADER@@@Z PROC ; IsEntryCommited, COMDAT
; _Zone$ = ecx
; _Entry$ = edx

; 356  :     // This function assumes the zone is locked for read so it does not get
; 357  :     // recycled during this test
; 358  : 
; 359  :     uint16 offsetKey = Entry->Offset;

  00000	0f b7 52 04	 movzx	 edx, WORD PTR [edx+4]

; 360  : 
; 361  :     if (offsetKey < Zone->LastSyncPoint) {

  00004	66 3b 51 1c	 cmp	 dx, WORD PTR [ecx+28]
  00008	73 03		 jae	 SHORT $LN4@IsEntryCom
$LN8@IsEntryCom:

; 362  : 
; 363  :         return true;

  0000a	b0 01		 mov	 al, 1

; 380  : }

  0000c	c3		 ret	 0
$LN4@IsEntryCom:

; 364  :     }
; 365  : 
; 366  :     uint16 crtOffset = Zone->ReadyList.ReadyList;

  0000d	0f b7 41 10	 movzx	 eax, WORD PTR [ecx+16]

; 367  : 
; 368  :     while (crtOffset) {

  00011	66 85 c0	 test	 ax, ax
  00014	74 12		 je	 SHORT $LN2@IsEntryCom
$LL3@IsEntryCom:

; 369  : 
; 370  :         if (crtOffset == offsetKey) {

  00016	66 3b c2	 cmp	 ax, dx
  00019	74 ef		 je	 SHORT $LN8@IsEntryCom

; 371  : 
; 372  :             return true;
; 373  :         }
; 374  : 
; 375  :         Entry = (PMEMORY_HEADER)((ULONG_PTR)Zone + crtOffset);
; 376  :         crtOffset = Entry->Link;

  0001b	0f b7 c0	 movzx	 eax, ax
  0001e	0f b7 44 08 02	 movzx	 eax, WORD PTR [eax+ecx+2]
  00023	66 85 c0	 test	 ax, ax
  00026	75 ee		 jne	 SHORT $LL3@IsEntryCom
$LN2@IsEntryCom:

; 377  :     }
; 378  : 
; 379  :     return false;

  00028	32 c0		 xor	 al, al

; 380  : }

  0002a	c3		 ret	 0
?IsEntryCommited@@YI_NPAU_MEMORY_ZONE@@PAU_MEMORY_HEADER@@@Z ENDP ; IsEntryCommited
_TEXT	ENDS
PUBLIC	?GetFirstReadyEntry@@YIPAU_MEMORY_HEADER@@PAU_MEMORY_ZONE@@G@Z ; GetFirstReadyEntry
; Function compile flags: /Ogtp
;	COMDAT ?GetFirstReadyEntry@@YIPAU_MEMORY_HEADER@@PAU_MEMORY_ZONE@@G@Z
_TEXT	SEGMENT
?GetFirstReadyEntry@@YIPAU_MEMORY_HEADER@@PAU_MEMORY_ZONE@@G@Z PROC ; GetFirstReadyEntry, COMDAT
; _Zone$ = ecx
; _offset$ = dx

; 385  :     PMEMORY_HEADER Entry;
; 386  : 
; 387  :     // This function assumes the zone is locked for read so it does not get
; 388  :     // recycled during this test
; 389  : 
; 390  :     uint16 offsetFound = Zone->ZoneSize;

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	56		 push	 esi
  00004	0f b7 f0	 movzx	 esi, ax

; 391  :     uint16 crtOffset = Zone->ReadyList.ReadyList;

  00007	0f b7 41 10	 movzx	 eax, WORD PTR [ecx+16]

; 392  : 
; 393  :     while (crtOffset) {

  0000b	66 85 c0	 test	 ax, ax
  0000e	74 1a		 je	 SHORT $LN3@GetFirstRe
$LL4@GetFirstRe:

; 394  : 
; 395  :         if ((crtOffset > offset) && (crtOffset < offsetFound)) {

  00010	66 3b c2	 cmp	 ax, dx
  00013	76 08		 jbe	 SHORT $LN2@GetFirstRe
  00015	66 3b c6	 cmp	 ax, si
  00018	73 03		 jae	 SHORT $LN2@GetFirstRe

; 396  : 
; 397  :             offsetFound = crtOffset;

  0001a	0f b7 f0	 movzx	 esi, ax
$LN2@GetFirstRe:

; 398  :         }
; 399  : 
; 400  :         Entry = (PMEMORY_HEADER)((ULONG_PTR)Zone + crtOffset);
; 401  :         crtOffset = Entry->Link;

  0001d	0f b7 c0	 movzx	 eax, ax
  00020	0f b7 44 08 02	 movzx	 eax, WORD PTR [eax+ecx+2]
  00025	66 85 c0	 test	 ax, ax
  00028	75 e6		 jne	 SHORT $LL4@GetFirstRe
$LN3@GetFirstRe:

; 402  :     }
; 403  : 
; 404  :     if (offsetFound != Zone->ZoneSize) {

  0002a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002d	0f b7 c6	 movzx	 eax, si
  00030	3b c2		 cmp	 eax, edx
  00032	5e		 pop	 esi
  00033	74 03		 je	 SHORT $LN1@GetFirstRe

; 405  : 
; 406  :         return (PMEMORY_HEADER)((ULONG_PTR)Zone + offsetFound);

  00035	03 c1		 add	 eax, ecx

; 410  : }

  00037	c3		 ret	 0
$LN1@GetFirstRe:

; 407  : 
; 408  :     }
; 409  :     return NULL;

  00038	33 c0		 xor	 eax, eax

; 410  : }

  0003a	c3		 ret	 0
?GetFirstReadyEntry@@YIPAU_MEMORY_HEADER@@PAU_MEMORY_ZONE@@G@Z ENDP ; GetFirstReadyEntry
_TEXT	ENDS
PUBLIC	?GetFirstEntry@@YIPAU_MEMORY_HEADER@@PAU_MEMORY_ZONE@@_N@Z ; GetFirstEntry
; Function compile flags: /Ogtp
;	COMDAT ?GetFirstEntry@@YIPAU_MEMORY_HEADER@@PAU_MEMORY_ZONE@@_N@Z
_TEXT	SEGMENT
?GetFirstEntry@@YIPAU_MEMORY_HEADER@@PAU_MEMORY_ZONE@@_N@Z PROC ; GetFirstEntry, COMDAT
; _Zone$ = ecx
; _forward$ = dl

; 416  :     if (forward) {

  00000	84 d2		 test	 dl, dl
  00002	74 07		 je	 SHORT $LN2@GetFirstEn

; 417  : 
; 418  :         return GetFirstReadyEntry(Zone, 0);

  00004	33 d2		 xor	 edx, edx
  00006	e9 00 00 00 00	 jmp	 ?GetFirstReadyEntry@@YIPAU_MEMORY_HEADER@@PAU_MEMORY_ZONE@@G@Z ; GetFirstReadyEntry
$LN2@GetFirstEn:

; 419  :     }
; 420  : 
; 421  :     uint16 crtOffset = Zone->ReadyList.ReadyList;

  0000b	0f b7 41 10	 movzx	 eax, WORD PTR [ecx+16]

; 422  : 
; 423  :     if (crtOffset == 0) {

  0000f	66 85 c0	 test	 ax, ax
  00012	75 03		 jne	 SHORT $LN1@GetFirstEn

; 424  : 
; 425  :         return NULL;

  00014	33 c0		 xor	 eax, eax

; 429  : }

  00016	c3		 ret	 0
$LN1@GetFirstEn:

; 426  :     }
; 427  : 
; 428  :     return (PMEMORY_HEADER)((ULONG_PTR)Zone + crtOffset);

  00017	0f b7 c0	 movzx	 eax, ax
  0001a	03 c1		 add	 eax, ecx

; 429  : }

  0001c	c3		 ret	 0
?GetFirstEntry@@YIPAU_MEMORY_HEADER@@PAU_MEMORY_ZONE@@_N@Z ENDP ; GetFirstEntry
_TEXT	ENDS
PUBLIC	?GetNextEntry@@YIPAU_MEMORY_HEADER@@PAU_QUERY_VIEW@@@Z ; GetNextEntry
; Function compile flags: /Ogtp
;	COMDAT ?GetNextEntry@@YIPAU_MEMORY_HEADER@@PAU_QUERY_VIEW@@@Z
_TEXT	SEGMENT
?GetNextEntry@@YIPAU_MEMORY_HEADER@@PAU_QUERY_VIEW@@@Z PROC ; GetNextEntry, COMDAT
; _view$ = ecx

; 435  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 436  :     PMEMORY_ZONE Zone = view->CurrentZone;

  00003	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]

; 437  :     PMEMORY_HEADER Entry = view->CurrentEntry;
; 438  : 
; 439  :     if (!Zone->Allocation.Filled) {

  00006	ba 00 40 00 00	 mov	 edx, 16384		; 00004000H
  0000b	66 85 51 0e	 test	 WORD PTR [ecx+14], dx
  0000f	57		 push	 edi
  00010	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  00013	75 0d		 jne	 SHORT $LN8@GetNextEnt

; 440  : 
; 441  :         // The Zone is during allocations
; 442  : 
; 443  :         if (view->ZoneGeneration != Zone->Generation) {

  00015	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00018	3b 41 18	 cmp	 eax, DWORD PTR [ecx+24]
  0001b	74 05		 je	 SHORT $LN8@GetNextEnt
  0001d	5f		 pop	 edi

; 444  : 
; 445  :             //  We lost the context as the zone has been recycled
; 446  : 
; 447  :             return NULL;

  0001e	33 c0		 xor	 eax, eax
  00020	5e		 pop	 esi

; 484  :         Entry = view->CurrentEntry;
; 485  :     }
; 486  : 
; 487  :     return Entry;
; 488  : }

  00021	c3		 ret	 0
$LN8@GetNextEnt:

; 448  :         }
; 449  :     }
; 450  : 
; 451  :     if (view->Forward) {

  00022	80 7e 20 00	 cmp	 BYTE PTR [esi+32], 0
  00026	53		 push	 ebx
  00027	74 45		 je	 SHORT $LN7@GetNextEnt

; 452  : 
; 453  :         view->CurrentEntryIndex += 1;

  00029	83 46 1c 01	 add	 DWORD PTR [esi+28], 1

; 454  : 
; 455  :         if (view->CurrentEntryIndex >= Zone->Allocation.Count) {

  0002d	0f b7 59 0e	 movzx	 ebx, WORD PTR [ecx+14]
  00031	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00034	81 e3 ff 1f 00
	00		 and	 ebx, 8191		; 00001fffH
  0003a	3b c3		 cmp	 eax, ebx

; 456  : 
; 457  :             return NULL;

  0003c	73 39		 jae	 SHORT $LN14@GetNextEnt

; 458  :         }
; 459  : 
; 460  :         view->CurrentEntry = (PMEMORY_HEADER)((ULONG_PTR)Entry + Entry->Size);

  0003e	0f b7 07	 movzx	 eax, WORD PTR [edi]
  00041	8d 1c 38	 lea	 ebx, DWORD PTR [eax+edi]
  00044	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 461  : 
; 462  :         if ((Zone->Allocation.Filled != 0) || IsEntryCommited(Zone, Entry)) {

  00047	66 85 51 0e	 test	 WORD PTR [ecx+14], dx
  0004b	75 1b		 jne	 SHORT $LN4@GetNextEnt
  0004d	8b d7		 mov	 edx, edi
  0004f	e8 00 00 00 00	 call	 ?IsEntryCommited@@YI_NPAU_MEMORY_ZONE@@PAU_MEMORY_HEADER@@@Z ; IsEntryCommited
  00054	84 c0		 test	 al, al
  00056	75 10		 jne	 SHORT $LN4@GetNextEnt

; 467  : 
; 468  :         } else {
; 469  : 
; 470  :             view->CurrentEntry = GetFirstReadyEntry(Zone, Entry->Offset);

  00058	66 8b 57 04	 mov	 dx, WORD PTR [edi+4]
  0005c	e8 00 00 00 00	 call	 ?GetFirstReadyEntry@@YIPAU_MEMORY_HEADER@@PAU_MEMORY_ZONE@@G@Z ; GetFirstReadyEntry
  00061	5b		 pop	 ebx
  00062	5f		 pop	 edi

; 481  :         }
; 482  : 
; 483  :         view->CurrentEntry = (PMEMORY_HEADER)((ULONG_PTR)Zone + Entry->Link);

  00063	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00066	5e		 pop	 esi

; 484  :         Entry = view->CurrentEntry;
; 485  :     }
; 486  : 
; 487  :     return Entry;
; 488  : }

  00067	c3		 ret	 0
$LN4@GetNextEnt:

; 463  : 
; 464  :             // Valid entry
; 465  : 
; 466  :             Entry = view->CurrentEntry;

  00068	8b c3		 mov	 eax, ebx
  0006a	5b		 pop	 ebx
  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi

; 484  :         Entry = view->CurrentEntry;
; 485  :     }
; 486  : 
; 487  :     return Entry;
; 488  : }

  0006d	c3		 ret	 0
$LN7@GetNextEnt:

; 471  :             Entry = view->CurrentEntry;
; 472  :         }
; 473  : 
; 474  :     } else {
; 475  : 
; 476  :         if (Entry->Link == 0) {

  0006e	0f b7 47 02	 movzx	 eax, WORD PTR [edi+2]
  00072	66 85 c0	 test	 ax, ax
  00075	75 06		 jne	 SHORT $LN1@GetNextEnt
$LN14@GetNextEnt:
  00077	5b		 pop	 ebx
  00078	5f		 pop	 edi

; 477  : 
; 478  :             //  We finished to walk the chain backwards
; 479  : 
; 480  :             return NULL;

  00079	33 c0		 xor	 eax, eax
  0007b	5e		 pop	 esi

; 484  :         Entry = view->CurrentEntry;
; 485  :     }
; 486  : 
; 487  :     return Entry;
; 488  : }

  0007c	c3		 ret	 0
$LN1@GetNextEnt:

; 481  :         }
; 482  : 
; 483  :         view->CurrentEntry = (PMEMORY_HEADER)((ULONG_PTR)Zone + Entry->Link);

  0007d	0f b7 d0	 movzx	 edx, ax
  00080	5b		 pop	 ebx
  00081	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  00084	5f		 pop	 edi
  00085	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00088	5e		 pop	 esi

; 484  :         Entry = view->CurrentEntry;
; 485  :     }
; 486  : 
; 487  :     return Entry;
; 488  : }

  00089	c3		 ret	 0
?GetNextEntry@@YIPAU_MEMORY_HEADER@@PAU_QUERY_VIEW@@@Z ENDP ; GetNextEntry
_TEXT	ENDS
PUBLIC	?RecycleZone@@YI_NPAU_MEMORY_ZONE@@@Z		; RecycleZone
EXTRN	?MemoryStorageGetNextGeneration@@YIIPAU_MEMORY_STORAGE@@@Z:PROC ; MemoryStorageGetNextGeneration
; Function compile flags: /Ogtp
;	COMDAT ?RecycleZone@@YI_NPAU_MEMORY_ZONE@@@Z
_TEXT	SEGMENT
_CapturedValue$11733 = -8				; size = 4
_Allocation$ = -8					; size = 4
_NextValue$ = -8					; size = 4
_CapturedValue$ = -4					; size = 4
?RecycleZone@@YI_NPAU_MEMORY_ZONE@@@Z PROC		; RecycleZone, COMDAT
; _Zone$ = ecx

; 95   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx

; 96   :     CheckEndOfBuffer(Zone);

  0000a	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0000d	03 c7		 add	 eax, edi
  0000f	81 38 cd cd cd
	cd		 cmp	 DWORD PTR [eax], -842150451 ; cdcdcdcdH
  00015	74 01		 je	 SHORT $LN12@RecycleZon
  00017	cc		 int	 3
$LN12@RecycleZon:
  00018	81 7f fc ab ab
	ab ab		 cmp	 DWORD PTR [edi-4], -1414812757 ; ababababH
  0001f	74 01		 je	 SHORT $LN24@RecycleZon
  00021	cc		 int	 3
$LN24@RecycleZon:
  00022	8d 77 0c	 lea	 esi, DWORD PTR [edi+12]
$LL8@RecycleZon:

; 97   : 
; 98   :     ZONE_ALLOCATION_POINTER CapturedValue;
; 99   :     ZONE_ALLOCATION_POINTER NextValue;
; 100  : 
; 101  :     do {
; 102  : 
; 103  :         CapturedValue.AtomicValue32 = Zone->Allocation.AtomicValue32;

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	89 45 fc	 mov	 DWORD PTR _CapturedValue$[ebp], eax

; 104  : 
; 105  :         if (CapturedValue.Recycling) {

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _CapturedValue$[ebp]
  0002d	c1 e8 10	 shr	 eax, 16			; 00000010H
  00030	a9 00 20 00 00	 test	 eax, 8192		; 00002000H
  00035	0f 85 9b 00 00
	00		 jne	 $LN3@RecycleZon

; 106  : 
; 107  :             //  Someone is already recycling this zone. Nothing left to do, just return
; 108  : 
; 109  :             return false;
; 110  :         }
; 111  : 
; 112  :         //  Also test whether the zone has been already recycled and in is in use
; 113  : 
; 114  :         if ((CapturedValue.Filled == 0) || (CapturedValue.Committed == 0)) {

  0003b	a9 00 40 00 00	 test	 eax, 16384		; 00004000H
  00040	0f 84 90 00 00
	00		 je	 $LN3@RecycleZon
  00046	a9 00 80 00 00	 test	 eax, 32768		; 00008000H
  0004b	0f 84 85 00 00
	00		 je	 $LN3@RecycleZon

; 117  :         }
; 118  : 
; 119  :         NextValue.AtomicValue32 = CapturedValue.AtomicValue32;

  00051	8b 4d fc	 mov	 ecx, DWORD PTR _CapturedValue$[ebp]
  00054	89 4d f8	 mov	 DWORD PTR _NextValue$[ebp], ecx

; 120  :         NextValue.Recycling = 1;

  00057	8b 55 f8	 mov	 edx, DWORD PTR _NextValue$[ebp]

; 121  : 
; 122  :         //  Atomically also set the recycling flag to prevent other concurrent recycling
; 123  : 
; 124  :     } while (InterlockedCompareExchange(&Zone->Allocation.AtomicValue32,
; 125  :                 NextValue.AtomicValue32,
; 126  :                 CapturedValue.AtomicValue32) != CapturedValue.AtomicValue32);

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _CapturedValue$[ebp]
  0005d	c1 ea 10	 shr	 edx, 16			; 00000010H
  00060	81 ca 00 20 00
	00		 or	 edx, 8192		; 00002000H
  00066	66 89 55 fa	 mov	 WORD PTR _NextValue$[ebp+2], dx
  0006a	8b 4d f8	 mov	 ecx, DWORD PTR _NextValue$[ebp]
  0006d	8b d6		 mov	 edx, esi
  0006f	f0 0f b1 0a	 lock	  cmpxchg DWORD PTR [edx], ecx
  00073	8b 4d fc	 mov	 ecx, DWORD PTR _CapturedValue$[ebp]
  00076	3b c1		 cmp	 eax, ecx
  00078	75 ab		 jne	 SHORT $LL8@RecycleZon

; 127  : 
; 128  :     //  We sucessfully too ownership on recycling phase. We can now reinitialize the fields
; 129  :     //  The last operation should be atomically updating the flags and offset in
; 130  :     //  the allocation field
; 131  : 
; 132  :     EV_ASSERT(IsZoneCompleted(Zone));

  0007a	8b 16		 mov	 edx, DWORD PTR [esi]
  0007c	89 55 f8	 mov	 DWORD PTR _CapturedValue$11733[ebp], edx
  0007f	8b 45 f8	 mov	 eax, DWORD PTR _CapturedValue$11733[ebp]
  00082	c1 e8 10	 shr	 eax, 16			; 00000010H
  00085	a9 00 40 00 00	 test	 eax, 16384		; 00004000H
  0008a	74 07		 je	 SHORT $LN17@RecycleZon
  0008c	a9 00 80 00 00	 test	 eax, 32768		; 00008000H
  00091	75 01		 jne	 SHORT $LN2@RecycleZon
$LN17@RecycleZon:
  00093	cc		 int	 3
$LN2@RecycleZon:

; 133  :     EV_ASSERT(Zone->Allocation.Count == Zone->ReadyList.Count);

  00094	66 8b 47 0e	 mov	 ax, WORD PTR [edi+14]
  00098	66 25 ff 1f	 and	 ax, 8191		; 00001fffH
  0009c	66 3b 47 12	 cmp	 ax, WORD PTR [edi+18]
  000a0	74 01		 je	 SHORT $LN1@RecycleZon
  000a2	cc		 int	 3
$LN1@RecycleZon:

; 134  : 
; 135  :     ZONE_ALLOCATION_POINTER Allocation;
; 136  :     Allocation.AtomicValue32 = 0;
; 137  :     Allocation.FreeOffset = sizeof(MEMORY_ZONE);
; 138  :     Zone->LastSyncPoint = Allocation.FreeOffset;
; 139  : 
; 140  :     Zone->Generation = MemoryStorageGetNextGeneration(HANDLE_TO_STORAGE(Zone->StorageHandle));

  000a3	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  000a6	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  000ab	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _Allocation$[ebp], 0
  000b2	66 89 45 f8	 mov	 WORD PTR _Allocation$[ebp], ax
  000b6	66 89 47 1c	 mov	 WORD PTR [edi+28], ax
  000ba	e8 00 00 00 00	 call	 ?MemoryStorageGetNextGeneration@@YIIPAU_MEMORY_STORAGE@@@Z ; MemoryStorageGetNextGeneration
  000bf	89 47 18	 mov	 DWORD PTR [edi+24], eax

; 141  : 
; 142  :     InterlockedExchange(&Zone->ReadyList.AtomicValue32, 0);

  000c2	33 c9		 xor	 ecx, ecx
  000c4	83 c7 10	 add	 edi, 16			; 00000010H
  000c7	87 0f		 xchg	 DWORD PTR [edi], ecx

; 143  :     InterlockedExchange(&Zone->Allocation.AtomicValue32, Allocation.AtomicValue32);

  000c9	8b 55 f8	 mov	 edx, DWORD PTR _Allocation$[ebp]
  000cc	87 16		 xchg	 DWORD PTR [esi], edx
  000ce	5f		 pop	 edi

; 144  : 
; 145  :     return true;

  000cf	b0 01		 mov	 al, 1
  000d1	5e		 pop	 esi

; 146  : }

  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
$LN3@RecycleZon:
  000d6	5f		 pop	 edi

; 115  : 
; 116  :             return false;

  000d7	32 c0		 xor	 al, al
  000d9	5e		 pop	 esi

; 146  : }

  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
?RecycleZone@@YI_NPAU_MEMORY_ZONE@@@Z ENDP		; RecycleZone
_TEXT	ENDS
END
