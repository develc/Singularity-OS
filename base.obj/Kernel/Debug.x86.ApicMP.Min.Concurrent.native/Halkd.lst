; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	C:\Users\cc\source\repos\Singularity-OS\base\Kernel\Native\Halkd.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?KernelEntry@@3UKLDR_DATA_TABLE_ENTRY_WITH_NAME@@A ; KernelEntry
PUBLIC	?HalEntry@@3UKLDR_DATA_TABLE_ENTRY_WITH_NAME@@A	; HalEntry
PUBLIC	?KdDebuggerNotPresent@@3HA			; KdDebuggerNotPresent
PUBLIC	?KdAlwaysPrintOutput@@3HA			; KdAlwaysPrintOutput
PUBLIC	?KdpBreakpointInstruction@@3EA			; KdpBreakpointInstruction
PUBLIC	?KdpBreakpointTable@@3PAU_BREAKPOINT_ENTRY@@A	; KdpBreakpointTable
PUBLIC	?KdCompNumberRetries@@3KA			; KdCompNumberRetries
PUBLIC	?KdCompRetryCount@@3KA				; KdCompRetryCount
PUBLIC	?KdPacketId@@3KA				; KdPacketId
PUBLIC	?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket
PUBLIC	?KdReceivePacket@@3P6I?AW4KDP_STATUS@@KPAU_STRING@@0PAKPAU_KD_CONTEXT@@@ZA ; KdReceivePacket
PUBLIC	?KdPollBreakIn@@3P6I_NXZA			; KdPollBreakIn
PUBLIC	?KdpLock@@3P6IXXZA				; KdpLock
PUBLIC	?KdpUnlock@@3P6IXXZA				; KdpUnlock
PUBLIC	?KdpEnter@@3P6IXXZA				; KdpEnter
PUBLIC	?KdpLeave@@3P6IXXZA				; KdpLeave
_BSS	SEGMENT
?KernelEntry@@3UKLDR_DATA_TABLE_ENTRY_WITH_NAME@@A DB 08cH DUP (?) ; KernelEntry
?HalEntry@@3UKLDR_DATA_TABLE_ENTRY_WITH_NAME@@A DB 08cH DUP (?) ; HalEntry
?KdDebuggerNotPresent@@3HA DD 01H DUP (?)		; KdDebuggerNotPresent
?KdAlwaysPrintOutput@@3HA DD 01H DUP (?)		; KdAlwaysPrintOutput
?KdpBreakpointTable@@3PAU_BREAKPOINT_ENTRY@@A DB 0200H DUP (?) ; KdpBreakpointTable
?KdPacketId@@3KA DD 01H DUP (?)				; KdPacketId
_KdModuleKernelUsed DD 01H DUP (?)
_KdpInDebugger DD 01H DUP (?)
_KdpInDebuggerIntEnabled DB 01H DUP (?)
	ALIGN	4

_KdpMpEnterCount DD 01H DUP (?)
_KdpLockEnterCount DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_KeNumberProcessors DD 01H
?KdpBreakpointInstruction@@3EA DB 0ccH			; KdpBreakpointInstruction
	ORG $+3
?KdCompNumberRetries@@3KA DD 05H			; KdCompNumberRetries
?KdCompRetryCount@@3KA DD 05H				; KdCompRetryCount
?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA DD FLAT:?KdpNulSendPacket@@YIXKPAU_STRING@@0PAU_KD_CONTEXT@@@Z ; KdSendPacket
?KdReceivePacket@@3P6I?AW4KDP_STATUS@@KPAU_STRING@@0PAKPAU_KD_CONTEXT@@@ZA DD FLAT:?KdpNulReceivePacket@@YI?AW4KDP_STATUS@@KPAU_STRING@@0PAKPAU_KD_CONTEXT@@@Z ; KdReceivePacket
?KdPollBreakIn@@3P6I_NXZA DD FLAT:?KdpNulPollBreakIn@@YI_NXZ ; KdPollBreakIn
?KdpLock@@3P6IXXZA DD FLAT:?KdpMpLock@@YIXXZ		; KdpLock
_KdVersionBlock DW 0700H
	DW	00H
	DW	06H
	DW	08H
	DW	014cH
	DB	0cH
	DB	03H
	DB	03H
	DB	00H
	DW	00H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
?KdpUnlock@@3P6IXXZA DD FLAT:?KdpMpUnlock@@YIXXZ	; KdpUnlock
?KdpEnter@@3P6IXXZA DD FLAT:?KdpMpEnter@@YIXXZ		; KdpEnter
?KdpLeave@@3P6IXXZA DD FLAT:?KdpMpLeave@@YIXXZ		; KdpLeave
_KdpCpuInDebugger DD 0ffffffffH
_DATA	ENDS
PUBLIC	?InitializeListHead@@YIXPAU_LIST_ENTRY@@@Z	; InitializeListHead
; Function compile flags: /Ogtp
; File c:\users\cc\source\repos\singularity-os\base\kernel\native\halkd.cpp
;	COMDAT ?InitializeListHead@@YIXPAU_LIST_ENTRY@@@Z
_TEXT	SEGMENT
?InitializeListHead@@YIXPAU_LIST_ENTRY@@@Z PROC		; InitializeListHead, COMDAT
; _ListHead$ = ecx

; 82   :     ListHead->Flink = ListHead->Blink = ListHead;

  00000	89 49 04	 mov	 DWORD PTR [ecx+4], ecx
  00003	89 09		 mov	 DWORD PTR [ecx], ecx

; 83   : }

  00005	c3		 ret	 0
?InitializeListHead@@YIXPAU_LIST_ENTRY@@@Z ENDP		; InitializeListHead
_TEXT	ENDS
PUBLIC	?RemoveEntryList@@YIHPAU_LIST_ENTRY@@@Z		; RemoveEntryList
; Function compile flags: /Ogtp
;	COMDAT ?RemoveEntryList@@YIHPAU_LIST_ENTRY@@@Z
_TEXT	SEGMENT
?RemoveEntryList@@YIHPAU_LIST_ENTRY@@@Z PROC		; RemoveEntryList, COMDAT
; _Entry$ = ecx

; 91   :     PLIST_ENTRY Blink;
; 92   :     PLIST_ENTRY Flink;
; 93   : 
; 94   :     Flink = Entry->Flink;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 95   :     Blink = Entry->Blink;

  00002	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]

; 96   :     Blink->Flink = Flink;
; 97   :     Flink->Blink = Blink;
; 98   :     return (BOOLEAN)(Flink == Blink);

  00005	33 d2		 xor	 edx, edx
  00007	3b c1		 cmp	 eax, ecx
  00009	0f 94 c2	 sete	 dl
  0000c	89 01		 mov	 DWORD PTR [ecx], eax
  0000e	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00011	8b c2		 mov	 eax, edx

; 99   : }

  00013	c3		 ret	 0
?RemoveEntryList@@YIHPAU_LIST_ENTRY@@@Z ENDP		; RemoveEntryList
_TEXT	ENDS
PUBLIC	?InsertTailList@@YIXPAU_LIST_ENTRY@@0@Z		; InsertTailList
; Function compile flags: /Ogtp
;	COMDAT ?InsertTailList@@YIXPAU_LIST_ENTRY@@0@Z
_TEXT	SEGMENT
?InsertTailList@@YIXPAU_LIST_ENTRY@@0@Z PROC		; InsertTailList, COMDAT
; _ListHead$ = ecx
; _Entry$ = edx

; 108  :     PLIST_ENTRY Blink;
; 109  : 
; 110  :     Blink = ListHead->Blink;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 111  :     Entry->Flink = ListHead;

  00003	89 0a		 mov	 DWORD PTR [edx], ecx

; 112  :     Entry->Blink = Blink;

  00005	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 113  :     Blink->Flink = Entry;

  00008	89 10		 mov	 DWORD PTR [eax], edx

; 114  :     ListHead->Blink = Entry;

  0000a	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 115  : }

  0000d	c3		 ret	 0
?InsertTailList@@YIXPAU_LIST_ENTRY@@0@Z ENDP		; InsertTailList
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?KdpNulSendPacket@@YIXKPAU_STRING@@0PAU_KD_CONTEXT@@@Z
_TEXT	SEGMENT
_MessageData$ = 8					; size = 4
_KdContext$ = 12					; size = 4
?KdpNulSendPacket@@YIXKPAU_STRING@@0PAU_KD_CONTEXT@@@Z PROC ; KdpNulSendPacket, COMDAT
; _PacketType$ = ecx
; _MessageHeader$ = edx

; 136  : }

  00000	c2 08 00	 ret	 8
?KdpNulSendPacket@@YIXKPAU_STRING@@0PAU_KD_CONTEXT@@@Z ENDP ; KdpNulSendPacket
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?KdpNulReceivePacket@@YI?AW4KDP_STATUS@@KPAU_STRING@@0PAKPAU_KD_CONTEXT@@@Z
_TEXT	SEGMENT
_MessageData$ = 8					; size = 4
_DataLength$ = 12					; size = 4
_KdContext$ = 16					; size = 4
?KdpNulReceivePacket@@YI?AW4KDP_STATUS@@KPAU_STRING@@0PAKPAU_KD_CONTEXT@@@Z PROC ; KdpNulReceivePacket, COMDAT
; _PacketType$ = ecx
; _MessageHeader$ = edx

; 144  :     return KDP_PACKET_TIMEOUT;

  00000	b8 01 00 00 00	 mov	 eax, 1

; 145  : }

  00005	c2 0c 00	 ret	 12			; 0000000cH
?KdpNulReceivePacket@@YI?AW4KDP_STATUS@@KPAU_STRING@@0PAKPAU_KD_CONTEXT@@@Z ENDP ; KdpNulReceivePacket
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?KdpNulPollBreakIn@@YI_NXZ
_TEXT	SEGMENT
?KdpNulPollBreakIn@@YI_NXZ PROC				; KdpNulPollBreakIn, COMDAT

; 149  :     return false;

  00000	32 c0		 xor	 al, al

; 150  : }

  00002	c3		 ret	 0
?KdpNulPollBreakIn@@YI_NXZ ENDP				; KdpNulPollBreakIn
_TEXT	ENDS
EXTRN	?KdpDisableInterruptsInline@@YI_NXZ:PROC	; KdpDisableInterruptsInline
; Function compile flags: /Ogtp
;	COMDAT ?KdpDisableInterrupts@@YI_NXZ
_TEXT	SEGMENT
?KdpDisableInterrupts@@YI_NXZ PROC			; KdpDisableInterrupts, COMDAT

; 251  :     return KdpDisableInterruptsInline();

  00000	e9 00 00 00 00	 jmp	 ?KdpDisableInterruptsInline@@YI_NXZ ; KdpDisableInterruptsInline
?KdpDisableInterrupts@@YI_NXZ ENDP			; KdpDisableInterrupts
_TEXT	ENDS
EXTRN	?KdpRestoreInterruptsInline@@YIX_N@Z:PROC	; KdpRestoreInterruptsInline
; Function compile flags: /Ogtp
;	COMDAT ?KdpRestoreInterrupts@@YIX_N@Z
_TEXT	SEGMENT
?KdpRestoreInterrupts@@YIX_N@Z PROC			; KdpRestoreInterrupts, COMDAT
; _enabled$ = ecx

; 256  :     return KdpRestoreInterruptsInline(enabled);

  00000	e9 00 00 00 00	 jmp	 ?KdpRestoreInterruptsInline@@YIX_N@Z ; KdpRestoreInterruptsInline
?KdpRestoreInterrupts@@YIX_N@Z ENDP			; KdpRestoreInterrupts
_TEXT	ENDS
PUBLIC	?KdCurrentCpuId@@YIHXZ				; KdCurrentCpuId
EXTRN	?g_GetCurrentCpu@Class_Microsoft_Singularity_Isal_Isa@@SIPAUStruct_Microsoft_Singularity_Isal_CpuRecord@@XZ:PROC ; Class_Microsoft_Singularity_Isal_Isa::g_GetCurrentCpu
; Function compile flags: /Ogtp
;	COMDAT ?KdCurrentCpuId@@YIHXZ
_TEXT	SEGMENT
?KdCurrentCpuId@@YIHXZ PROC				; KdCurrentCpuId, COMDAT

; 350  :     return Class_Microsoft_Singularity_Isal_Isa::g_GetCurrentCpu()->id;

  00000	e8 00 00 00 00	 call	 ?g_GetCurrentCpu@Class_Microsoft_Singularity_Isal_Isa@@SIPAUStruct_Microsoft_Singularity_Isal_CpuRecord@@XZ ; Class_Microsoft_Singularity_Isal_Isa::g_GetCurrentCpu
  00005	8b 80 40 02 00
	00		 mov	 eax, DWORD PTR [eax+576]

; 351  : }

  0000b	c3		 ret	 0
?KdCurrentCpuId@@YIHXZ ENDP				; KdCurrentCpuId
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?KdpMpUnlock@@YIXXZ
_TEXT	SEGMENT
?KdpMpUnlock@@YIXXZ PROC				; KdpMpUnlock, COMDAT

; 383  :     KdpLockEnterCount--;

  00000	83 c8 ff	 or	 eax, -1
  00003	01 05 00 00 00
	00		 add	 DWORD PTR _KdpLockEnterCount, eax

; 384  : 
; 385  :     // Recursive lock leave
; 386  :     if (KdpLockEnterCount != 0) {

  00009	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _KdpLockEnterCount
  0000f	75 1a		 jne	 SHORT $LN4@KdpMpUnloc

; 387  :         return;
; 388  :     }
; 389  : 
; 390  :     // Must grab the state of interrupts before we release our lock.  Fortunately,
; 391  :     // KdpInDebuggerIntEnabled is volatile, so the compiler will not reorder our
; 392  :     // read:
; 393  :     bool intEnabled = KdpInDebuggerIntEnabled;

  00011	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _KdpInDebuggerIntEnabled

; 394  : 
; 395  :     KdpCpuInDebugger = -1;

  00017	a3 00 00 00 00	 mov	 DWORD PTR _KdpCpuInDebugger, eax

; 396  : 
; 397  :     KdpInDebugger = 0;

  0001c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _KdpInDebugger, 0

; 398  :     KdpRestoreInterrupts(intEnabled);

  00026	e9 00 00 00 00	 jmp	 ?KdpRestoreInterruptsInline@@YIX_N@Z ; KdpRestoreInterruptsInline
$LN4@KdpMpUnloc:

; 399  : }

  0002b	c3		 ret	 0
?KdpMpUnlock@@YIXXZ ENDP				; KdpMpUnlock
_TEXT	ENDS
EXTRN	?g_ThawAllProcessors@Class_Microsoft_Singularity_MpExecution@@SIXXZ:PROC ; Class_Microsoft_Singularity_MpExecution::g_ThawAllProcessors
; Function compile flags: /Ogtp
;	COMDAT ?KdpMpLeave@@YIXXZ
_TEXT	SEGMENT
?KdpMpLeave@@YIXXZ PROC					; KdpMpLeave, COMDAT

; 417  :     KdpMpEnterCount--;

  00000	83 05 00 00 00
	00 ff		 add	 DWORD PTR _KdpMpEnterCount, -1

; 418  :     Class_Microsoft_Singularity_MpExecution::g_ThawAllProcessors();

  00007	e9 00 00 00 00	 jmp	 ?g_ThawAllProcessors@Class_Microsoft_Singularity_MpExecution@@SIXXZ ; Class_Microsoft_Singularity_MpExecution::g_ThawAllProcessors
?KdpMpLeave@@YIXXZ ENDP					; KdpMpLeave
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?KdpUpLock@@YIXXZ
_TEXT	SEGMENT
?KdpUpLock@@YIXXZ PROC					; KdpUpLock, COMDAT

; 427  :     bool enabled = KdpDisableInterrupts();

  00000	e8 00 00 00 00	 call	 ?KdpDisableInterruptsInline@@YI_NXZ ; KdpDisableInterruptsInline

; 428  :     KdpInDebugger++;

  00005	83 05 00 00 00
	00 01		 add	 DWORD PTR _KdpInDebugger, 1

; 429  : 
; 430  :     if (KdpInDebugger == 1) {

  0000c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _KdpInDebugger
  00012	83 f9 01	 cmp	 ecx, 1
  00015	75 05		 jne	 SHORT $LN1@KdpUpLock

; 431  :         KdpInDebuggerIntEnabled = enabled;

  00017	a2 00 00 00 00	 mov	 BYTE PTR _KdpInDebuggerIntEnabled, al
$LN1@KdpUpLock:

; 432  :     }
; 433  : }

  0001c	c3		 ret	 0
?KdpUpLock@@YIXXZ ENDP					; KdpUpLock
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?KdpUpUnlock@@YIXXZ
_TEXT	SEGMENT
?KdpUpUnlock@@YIXXZ PROC				; KdpUpUnlock, COMDAT

; 437  :     KdpInDebugger--;

  00000	83 05 00 00 00
	00 ff		 add	 DWORD PTR _KdpInDebugger, -1

; 438  :     if (KdpInDebugger == 0) {

  00007	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdpInDebugger
  0000c	75 0b		 jne	 SHORT $LN4@KdpUpUnloc

; 439  :         KdpRestoreInterrupts(KdpInDebuggerIntEnabled);

  0000e	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _KdpInDebuggerIntEnabled
  00014	e9 00 00 00 00	 jmp	 ?KdpRestoreInterruptsInline@@YIX_N@Z ; KdpRestoreInterruptsInline
$LN4@KdpUpUnloc:

; 440  :     }
; 441  : }

  00019	c3		 ret	 0
?KdpUpUnlock@@YIXXZ ENDP				; KdpUpUnlock
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?KdpUpEnter@@YIXXZ
_TEXT	SEGMENT
?KdpUpEnter@@YIXXZ PROC					; KdpUpEnter, COMDAT

; 445  : }

  00000	c3		 ret	 0
?KdpUpEnter@@YIXXZ ENDP					; KdpUpEnter
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?KdpUpLeave@@YIXXZ
_TEXT	SEGMENT
?KdpUpLeave@@YIXXZ PROC					; KdpUpLeave, COMDAT

; 449  : }

  00000	c3		 ret	 0
?KdpUpLeave@@YIXXZ ENDP					; KdpUpLeave
_TEXT	ENDS
;	COMDAT ?kdcurs@?1??koutput@@YIXPAXD@Z@4GA
_BSS	SEGMENT
?kdcurs@?1??koutput@@YIXPAXD@Z@4GA DW 01H DUP (?)	; `koutput'::`2'::kdcurs
_BSS	ENDS
;	COMDAT ?kdattr@?1??koutput@@YIXPAXD@Z@4GA
_DATA	SEGMENT
?kdattr@?1??koutput@@YIXPAXD@Z@4GA DW 02f00H		; `koutput'::`2'::kdattr
; Function compile flags: /Ogtp
_DATA	ENDS
;	COMDAT ?koutput@@YIXPAXD@Z
_TEXT	SEGMENT
_c$ = -4						; size = 1
?koutput@@YIXPAXD@Z PROC				; koutput, COMDAT
; _pContext$ = ecx
; _c$ = dl

; 458  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 459  : #if ISA_IX86 || ISA_IX64
; 460  : #define KD_LEFT     0
; 461  : #define KD_HEIGHT   46
; 462  : 
; 463  :     static UINT16 kdcurs = KD_LEFT;
; 464  :     static UINT16 kdattr = 0x2f00;
; 465  : 
; 466  :     //
; 467  :     // Update cursor position
; 468  :     //
; 469  :     if ((kdcurs % 80) < KD_LEFT) {

  00005	66 8b 1d 00 00
	00 00		 mov	 bx, WORD PTR ?kdcurs@?1??koutput@@YIXPAXD@Z@4GA
  0000c	0f b7 c3	 movzx	 eax, bx
  0000f	8a ca		 mov	 cl, dl
  00011	56		 push	 esi
  00012	99		 cdq
  00013	be 50 00 00 00	 mov	 esi, 80			; 00000050H
  00018	f7 fe		 idiv	 esi
  0001a	57		 push	 edi
  0001b	88 4d fc	 mov	 BYTE PTR _c$[ebp], cl
  0001e	85 d2		 test	 edx, edx
  00020	7d 0a		 jge	 SHORT $LN22@koutput

; 470  :         kdcurs += KD_LEFT - (kdcurs % 80);

  00022	66 2b da	 sub	 bx, dx
  00025	66 89 1d 00 00
	00 00		 mov	 WORD PTR ?kdcurs@?1??koutput@@YIXPAXD@Z@4GA, bx
$LN22@koutput:

; 471  :     }
; 472  : 
; 473  :     if (kdcurs >= KD_HEIGHT * 80) {

  0002c	66 81 fb 60 0e	 cmp	 bx, 3680		; 00000e60H
  00031	72 58		 jb	 SHORT $LN34@koutput

; 474  :         for (UINT16 i = 0; i < KD_HEIGHT - 1; i++) {

  00033	b8 a0 80 0b 00	 mov	 eax, 753824		; 000b80a0H
  00038	ba 2d 00 00 00	 mov	 edx, 45			; 0000002dH
  0003d	8d 49 00	 npad	 3
$LL33@koutput:

; 475  :             for (UINT16 j = KD_LEFT; j < 80; j++) {
; 476  :                 ((UINT16 *)0xb8000)[i*80+j] = ((UINT16 *)0xb8000)[i*80+80+j];

  00040	8b f0		 mov	 esi, eax
  00042	8d b8 60 ff ff
	ff		 lea	 edi, DWORD PTR [eax-160]
  00048	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  0004d	05 a0 00 00 00	 add	 eax, 160		; 000000a0H
  00052	83 ea 01	 sub	 edx, 1
  00055	66 f3 a5	 rep movsw
  00058	75 e6		 jne	 SHORT $LL33@koutput

; 477  :             }
; 478  :         }
; 479  :         for (UINT16 j = KD_LEFT; j < 80; j++) {
; 480  :             ((UINT16 *)0xb8000)[(KD_HEIGHT-1)*80+j] = kdattr | ' ';

  0005a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?kdattr@?1??koutput@@YIXPAXD@Z@4GA
  00060	8d 4a 28	 lea	 ecx, DWORD PTR [edx+40]
  00063	8b c6		 mov	 eax, esi
  00065	83 c8 20	 or	 eax, 32			; 00000020H
  00068	66 8b d0	 mov	 dx, ax
  0006b	bf 20 9c 0b 00	 mov	 edi, 760864		; 000b9c20H
  00070	c1 e2 10	 shl	 edx, 16			; 00000010H
  00073	66 8b d0	 mov	 dx, ax

; 481  :         }
; 482  :         kdcurs = kdcurs - 80;

  00076	66 81 c3 b0 ff	 add	 bx, 65456		; 0000ffb0H
  0007b	66 89 1d 00 00
	00 00		 mov	 WORD PTR ?kdcurs@?1??koutput@@YIXPAXD@Z@4GA, bx
  00082	8b c2		 mov	 eax, edx
  00084	f3 ab		 rep stosd
  00086	8a 4d fc	 mov	 cl, BYTE PTR _c$[ebp]
  00089	eb 06		 jmp	 SHORT $LN21@koutput
$LN34@koutput:
  0008b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?kdattr@?1??koutput@@YIXPAXD@Z@4GA
$LN21@koutput:

; 483  :     }
; 484  : 
; 485  :     //
; 486  :     // Output character
; 487  :     //
; 488  :     if (c >= ' ' && c <= '~') {

  00091	8a c1		 mov	 al, cl
  00093	2c 20		 sub	 al, 32			; 00000020H
  00095	3c 5e		 cmp	 al, 94			; 0000005eH
  00097	77 24		 ja	 SHORT $LN11@koutput

; 489  :         ((UINT16 *)0xb8000)[kdcurs++] = kdattr | c;

  00099	66 0f be c9	 movsx	 cx, cl
  0009d	66 0b ce	 or	 cx, si
  000a0	0f b7 d3	 movzx	 edx, bx
  000a3	5f		 pop	 edi
  000a4	66 83 c3 01	 add	 bx, 1
  000a8	5e		 pop	 esi
  000a9	66 89 1d 00 00
	00 00		 mov	 WORD PTR ?kdcurs@?1??koutput@@YIXPAXD@Z@4GA, bx
  000b0	66 89 0c 55 00
	80 0b 00	 mov	 WORD PTR [edx*2+753664], cx
  000b8	5b		 pop	 ebx

; 504  :     }
; 505  : #elif ISA_ARM
; 506  :     // Do nothing.
; 507  : #endif
; 508  : }

  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
$LN11@koutput:

; 490  :     }
; 491  :     else if (c == '\t') {

  000bd	80 f9 09	 cmp	 cl, 9
  000c0	75 27		 jne	 SHORT $LN9@koutput

; 492  :         kdcurs += 8 - (kdcurs % 8);

  000c2	0f b7 c3	 movzx	 eax, bx
  000c5	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  000ca	79 05		 jns	 SHORT $LN35@koutput
  000cc	48		 dec	 eax
  000cd	83 c8 f8	 or	 eax, -8			; fffffff8H
  000d0	40		 inc	 eax
$LN35@koutput:
  000d1	b9 08 00 00 00	 mov	 ecx, 8
  000d6	2b c8		 sub	 ecx, eax
  000d8	5f		 pop	 edi
  000d9	66 03 d9	 add	 bx, cx
  000dc	5e		 pop	 esi
  000dd	66 89 1d 00 00
	00 00		 mov	 WORD PTR ?kdcurs@?1??koutput@@YIXPAXD@Z@4GA, bx
  000e4	5b		 pop	 ebx

; 504  :     }
; 505  : #elif ISA_ARM
; 506  :     // Do nothing.
; 507  : #endif
; 508  : }

  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
$LN9@koutput:

; 493  :     }
; 494  :     else if (c == '\n') {

  000e9	80 f9 0a	 cmp	 cl, 10			; 0000000aH
  000ec	75 4d		 jne	 SHORT $LN7@koutput

; 495  :         while ((kdcurs % 80) != 0) {

  000ee	0f b7 cb	 movzx	 ecx, bx
  000f1	8b c1		 mov	 eax, ecx
  000f3	99		 cdq
  000f4	bf 50 00 00 00	 mov	 edi, 80			; 00000050H
  000f9	f7 ff		 idiv	 edi
  000fb	85 d2		 test	 edx, edx
  000fd	74 6b		 je	 SHORT $LN1@koutput
  000ff	83 ce 20	 or	 esi, 32			; 00000020H
  00102	eb 0c 8d a4 24
	00 00 00 00 eb
	03 8d 49 00	 npad	 14
$LL6@koutput:

; 496  :             ((UINT16 *)0xb8000)[kdcurs++] = kdattr | ' ';

  00110	66 83 c3 01	 add	 bx, 1
  00114	66 89 34 4d 00
	80 0b 00	 mov	 WORD PTR [ecx*2+753664], si
  0011c	0f b7 cb	 movzx	 ecx, bx
  0011f	8b c1		 mov	 eax, ecx
  00121	99		 cdq
  00122	bf 50 00 00 00	 mov	 edi, 80			; 00000050H
  00127	f7 ff		 idiv	 edi
  00129	85 d2		 test	 edx, edx
  0012b	75 e3		 jne	 SHORT $LL6@koutput
  0012d	5f		 pop	 edi
  0012e	5e		 pop	 esi
  0012f	66 89 1d 00 00
	00 00		 mov	 WORD PTR ?kdcurs@?1??koutput@@YIXPAXD@Z@4GA, bx
  00136	5b		 pop	 ebx

; 504  :     }
; 505  : #elif ISA_ARM
; 506  :     // Do nothing.
; 507  : #endif
; 508  : }

  00137	8b e5		 mov	 esp, ebp
  00139	5d		 pop	 ebp
  0013a	c3		 ret	 0
$LN7@koutput:

; 497  :         }
; 498  :     }
; 499  :     else if (c == '\r') {

  0013b	80 f9 0d	 cmp	 cl, 13			; 0000000dH
  0013e	75 1c		 jne	 SHORT $LN3@koutput

; 500  :         kdcurs -= (kdcurs % 80);

  00140	0f b7 c3	 movzx	 eax, bx
  00143	99		 cdq
  00144	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00149	f7 f9		 idiv	 ecx
  0014b	5f		 pop	 edi
  0014c	5e		 pop	 esi
  0014d	66 2b da	 sub	 bx, dx
  00150	66 89 1d 00 00
	00 00		 mov	 WORD PTR ?kdcurs@?1??koutput@@YIXPAXD@Z@4GA, bx
  00157	5b		 pop	 ebx

; 504  :     }
; 505  : #elif ISA_ARM
; 506  :     // Do nothing.
; 507  : #endif
; 508  : }

  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c3		 ret	 0
$LN3@koutput:

; 501  :     }
; 502  :     else if (c == '\f') {

  0015c	80 f9 0c	 cmp	 cl, 12			; 0000000cH
  0015f	75 09		 jne	 SHORT $LN1@koutput

; 503  :         kdcurs = 0;

  00161	66 c7 05 00 00
	00 00 00 00	 mov	 WORD PTR ?kdcurs@?1??koutput@@YIXPAXD@Z@4GA, 0
$LN1@koutput:
  0016a	5f		 pop	 edi
  0016b	5e		 pop	 esi
  0016c	5b		 pop	 ebx

; 504  :     }
; 505  : #elif ISA_ARM
; 506  :     // Do nothing.
; 507  : #endif
; 508  : }

  0016d	8b e5		 mov	 esp, ebp
  0016f	5d		 pop	 ebp
  00170	c3		 ret	 0
?koutput@@YIXPAXD@Z ENDP				; koutput
_TEXT	ENDS
PUBLIC	?kdprints@@YIXPBD@Z				; kdprints
; Function compile flags: /Ogtp
;	COMDAT ?kdprints@@YIXPBD@Z
_TEXT	SEGMENT
?kdprints@@YIXPBD@Z PROC				; kdprints, COMDAT
; _pszFmt$ = ecx

; 511  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 512  :     while (*pszFmt) {

  00003	8a 16		 mov	 dl, BYTE PTR [esi]
  00005	84 d2		 test	 dl, dl
  00007	74 18		 je	 SHORT $LN1@kdprints
  00009	8d a4 24 00 00
	00 00		 npad	 7
$LL2@kdprints:

; 513  :         koutput(NULL, *pszFmt++);

  00010	33 c9		 xor	 ecx, ecx
  00012	e8 00 00 00 00	 call	 ?koutput@@YIXPAXD@Z	; koutput
  00017	8a 56 01	 mov	 dl, BYTE PTR [esi+1]
  0001a	83 c6 01	 add	 esi, 1
  0001d	84 d2		 test	 dl, dl
  0001f	75 ef		 jne	 SHORT $LL2@kdprints
$LN1@kdprints:
  00021	5e		 pop	 esi

; 514  :     }
; 515  : }

  00022	c3		 ret	 0
?kdprints@@YIXPBD@Z ENDP				; kdprints
_TEXT	ENDS
PUBLIC	?kdprintf@@YAXPBDZZ				; kdprintf
EXTRN	?strformat@@YIHP6IXPAXD@Z0PBDPAD@Z:PROC		; strformat
; Function compile flags: /Ogtp
;	COMDAT ?kdprintf@@YAXPBDZZ
_TEXT	SEGMENT
_pszFmt$ = 8						; size = 4
?kdprintf@@YAXPBDZZ PROC				; kdprintf, COMDAT

; 518  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 519  :     va_list args;
; 520  : 
; 521  :     va_start(args, pszFmt);
; 522  :     strformat(koutput, NULL, pszFmt, args);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pszFmt$[ebp]
  00006	8d 45 0c	 lea	 eax, DWORD PTR _pszFmt$[ebp+4]
  00009	50		 push	 eax
  0000a	51		 push	 ecx
  0000b	33 d2		 xor	 edx, edx
  0000d	b9 00 00 00 00	 mov	 ecx, OFFSET ?koutput@@YIXPAXD@Z ; koutput
  00012	e8 00 00 00 00	 call	 ?strformat@@YIHP6IXPAXD@Z0PBDPAD@Z ; strformat

; 523  :     va_end(args);
; 524  : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?kdprintf@@YAXPBDZZ ENDP				; kdprintf
_TEXT	ENDS
PUBLIC	?ProbeMemoryRange@@YIH_KK@Z			; ProbeMemoryRange
EXTRN	?c_thePlatform@Class_Microsoft_Singularity_Hal_Platform@@2PAU1@A:DWORD ; Class_Microsoft_Singularity_Hal_Platform::c_thePlatform
; Function compile flags: /Ogtp
;	COMDAT ?ProbeMemoryRange@@YIH_KK@Z
_TEXT	SEGMENT
tv328 = -24						; size = 8
tv304 = -24						; size = 8
tv280 = -24						; size = 8
tv247 = -24						; size = 8
tv225 = -24						; size = 8
tv163 = -24						; size = 8
tv325 = -16						; size = 8
tv252 = -16						; size = 8
tv228 = -16						; size = 8
tv166 = -16						; size = 8
_smapCount$ = -8					; size = 4
_i$11750 = -4						; size = 4
tv301 = 8						; size = 8
tv277 = 8						; size = 8
tv192 = 8						; size = 8
_address$ = 8						; size = 8
tv267 = 12						; size = 4
?ProbeMemoryRange@@YIH_KK@Z PROC			; ProbeMemoryRange, COMDAT
; _length$ = ecx

; 528  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 529  :     Struct_Microsoft_Singularity_SMAPINFO *sm =
; 530  :         (Struct_Microsoft_Singularity_SMAPINFO *)Class_Microsoft_Singularity_Hal_Platform::c_thePlatform->Smap32;
; 531  :     int smapCount = Class_Microsoft_Singularity_Hal_Platform::c_thePlatform->SmapCount;
; 532  : 
; 533  :     for (int32 i = 0; i < smapCount; i++) {

  00006	8b 45 0c	 mov	 eax, DWORD PTR _address$[ebp+4]
  00009	8b 55 08	 mov	 edx, DWORD PTR _address$[ebp]
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?c_thePlatform@Class_Microsoft_Singularity_Hal_Platform@@2PAU1@A ; Class_Microsoft_Singularity_Hal_Platform::c_thePlatform
  00015	8b 5f 30	 mov	 ebx, DWORD PTR [edi+48]
  00018	85 db		 test	 ebx, ebx
  0001a	8b 77 2c	 mov	 esi, DWORD PTR [edi+44]
  0001d	89 5d f8	 mov	 DWORD PTR _smapCount$[ebp], ebx
  00020	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$11750[ebp], 0
  00027	7e 69		 jle	 SHORT $LN11@ProbeMemor
  00029	8d a4 24 00 00
	00 00		 npad	 7
$LL36@ProbeMemor:

; 534  :         if (// (sm[i].type == Struct_Microsoft_Singularity_SMAPINFO_AddressTypeFree) &&
; 535  :             (sm[i].addr <= address) &&
; 536  :             (sm[i].addr + sm[i].size) >= (address + length)) {

  00030	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00033	3b f8		 cmp	 edi, eax
  00035	77 45		 ja	 SHORT $LN12@ProbeMemor
  00037	72 06		 jb	 SHORT $LN19@ProbeMemor
  00039	8b 3e		 mov	 edi, DWORD PTR [esi]
  0003b	3b fa		 cmp	 edi, edx
  0003d	77 3d		 ja	 SHORT $LN12@ProbeMemor
$LN19@ProbeMemor:
  0003f	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00042	03 3e		 add	 edi, DWORD PTR [esi]
  00044	8b d9		 mov	 ebx, ecx
  00046	89 7d e8	 mov	 DWORD PTR tv328[ebp], edi
  00049	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
  0004c	13 7e 04	 adc	 edi, DWORD PTR [esi+4]
  0004f	03 da		 add	 ebx, edx
  00051	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR tv192[ebp+4], 0
  00058	89 5d f0	 mov	 DWORD PTR tv325[ebp], ebx
  0005b	8b 5d 0c	 mov	 ebx, DWORD PTR tv192[ebp+4]
  0005e	13 d8		 adc	 ebx, eax
  00060	3b fb		 cmp	 edi, ebx
  00062	89 4d 08	 mov	 DWORD PTR tv192[ebp], ecx
  00065	0f 87 ea 01 00
	00		 ja	 $LN17@ProbeMemor
  0006b	72 0c		 jb	 SHORT $LN37@ProbeMemor
  0006d	8b 7d f0	 mov	 edi, DWORD PTR tv325[ebp]
  00070	39 7d e8	 cmp	 DWORD PTR tv328[ebp], edi
  00073	0f 83 dc 01 00
	00		 jae	 $LN17@ProbeMemor
$LN37@ProbeMemor:
  00079	8b 5d f8	 mov	 ebx, DWORD PTR _smapCount$[ebp]
$LN12@ProbeMemor:

; 529  :     Struct_Microsoft_Singularity_SMAPINFO *sm =
; 530  :         (Struct_Microsoft_Singularity_SMAPINFO *)Class_Microsoft_Singularity_Hal_Platform::c_thePlatform->Smap32;
; 531  :     int smapCount = Class_Microsoft_Singularity_Hal_Platform::c_thePlatform->SmapCount;
; 532  : 
; 533  :     for (int32 i = 0; i < smapCount; i++) {

  0007c	8b 7d fc	 mov	 edi, DWORD PTR _i$11750[ebp]
  0007f	83 c7 01	 add	 edi, 1
  00082	83 c6 18	 add	 esi, 24			; 00000018H
  00085	3b fb		 cmp	 edi, ebx
  00087	89 7d fc	 mov	 DWORD PTR _i$11750[ebp], edi
  0008a	7c a4		 jl	 SHORT $LL36@ProbeMemor

; 534  :         if (// (sm[i].type == Struct_Microsoft_Singularity_SMAPINFO_AddressTypeFree) &&
; 535  :             (sm[i].addr <= address) &&
; 536  :             (sm[i].addr + sm[i].size) >= (address + length)) {

  0008c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?c_thePlatform@Class_Microsoft_Singularity_Hal_Platform@@2PAU1@A ; Class_Microsoft_Singularity_Hal_Platform::c_thePlatform
$LN11@ProbeMemor:

; 539  :         }
; 540  :     }
; 541  : 
; 542  :     if ((address >= Class_Microsoft_Singularity_Hal_Platform::c_thePlatform->Smap32) &&
; 543  :         ((address + length) <= (Class_Microsoft_Singularity_Hal_Platform::c_thePlatform->Smap32 + 4096))) {

  00092	8b 5f 2c	 mov	 ebx, DWORD PTR [edi+44]
  00095	33 f6		 xor	 esi, esi
  00097	3b c6		 cmp	 eax, esi
  00099	72 35		 jb	 SHORT $LN38@ProbeMemor
  0009b	77 04		 ja	 SHORT $LN21@ProbeMemor
  0009d	3b d3		 cmp	 edx, ebx
  0009f	72 2f		 jb	 SHORT $LN38@ProbeMemor
$LN21@ProbeMemor:
  000a1	33 f6		 xor	 esi, esi
  000a3	8b d9		 mov	 ebx, ecx
  000a5	03 da		 add	 ebx, edx
  000a7	89 5d e8	 mov	 DWORD PTR tv304[ebp], ebx
  000aa	8b 5f 2c	 mov	 ebx, DWORD PTR [edi+44]
  000ad	13 f0		 adc	 esi, eax
  000af	81 c3 00 10 00
	00		 add	 ebx, 4096		; 00001000H
  000b5	89 5d 08	 mov	 DWORD PTR tv301[ebp], ebx
  000b8	33 db		 xor	 ebx, ebx
  000ba	3b f3		 cmp	 esi, ebx
  000bc	77 12		 ja	 SHORT $LN38@ProbeMemor
  000be	0f 82 91 01 00
	00		 jb	 $LN17@ProbeMemor
  000c4	8b 75 08	 mov	 esi, DWORD PTR tv301[ebp]
  000c7	39 75 e8	 cmp	 DWORD PTR tv304[ebp], esi

; 544  : 
; 545  :         return true;

  000ca	0f 86 85 01 00
	00		 jbe	 $LN17@ProbeMemor
$LN38@ProbeMemor:

; 546  :     }
; 547  : 
; 548  :     if ((address >= Class_Microsoft_Singularity_Hal_Platform::c_thePlatform->LogRecordBuffer) &&
; 549  :         ((address + length) <= (Class_Microsoft_Singularity_Hal_Platform::c_thePlatform->LogRecordBuffer + Class_Microsoft_Singularity_Hal_Platform::c_thePlatform->LogRecordSize))) {

  000d0	8b 5f 7c	 mov	 ebx, DWORD PTR [edi+124]
  000d3	33 f6		 xor	 esi, esi
  000d5	3b c6		 cmp	 eax, esi
  000d7	72 34		 jb	 SHORT $LN39@ProbeMemor
  000d9	77 04		 ja	 SHORT $LN23@ProbeMemor
  000db	3b d3		 cmp	 edx, ebx
  000dd	72 2e		 jb	 SHORT $LN39@ProbeMemor
$LN23@ProbeMemor:
  000df	8b b7 80 00 00
	00		 mov	 esi, DWORD PTR [edi+128]
  000e5	03 f3		 add	 esi, ebx
  000e7	89 75 08	 mov	 DWORD PTR tv277[ebp], esi
  000ea	33 f6		 xor	 esi, esi
  000ec	8b d9		 mov	 ebx, ecx
  000ee	03 da		 add	 ebx, edx
  000f0	13 f0		 adc	 esi, eax
  000f2	89 5d e8	 mov	 DWORD PTR tv280[ebp], ebx
  000f5	33 db		 xor	 ebx, ebx
  000f7	3b f3		 cmp	 esi, ebx
  000f9	77 12		 ja	 SHORT $LN39@ProbeMemor
  000fb	0f 82 54 01 00
	00		 jb	 $LN17@ProbeMemor
  00101	8b 75 08	 mov	 esi, DWORD PTR tv277[ebp]
  00104	39 75 e8	 cmp	 DWORD PTR tv280[ebp], esi

; 550  : 
; 551  :         return true;

  00107	0f 86 48 01 00
	00		 jbe	 $LN17@ProbeMemor
$LN39@ProbeMemor:

; 552  :     }
; 553  : 
; 554  :     if ((address >= Class_Microsoft_Singularity_Hal_Platform::c_thePlatform->LogTextBuffer) &&
; 555  :         ((address + length) <= (Class_Microsoft_Singularity_Hal_Platform::c_thePlatform->LogTextBuffer + Class_Microsoft_Singularity_Hal_Platform::c_thePlatform->LogTextSize))) {

  0010d	8b 9f 84 00 00
	00		 mov	 ebx, DWORD PTR [edi+132]
  00113	33 f6		 xor	 esi, esi
  00115	3b c6		 cmp	 eax, esi
  00117	72 3a		 jb	 SHORT $LN7@ProbeMemor
  00119	77 04		 ja	 SHORT $LN25@ProbeMemor
  0011b	3b d3		 cmp	 edx, ebx
  0011d	72 34		 jb	 SHORT $LN7@ProbeMemor
$LN25@ProbeMemor:
  0011f	8b b7 88 00 00
	00		 mov	 esi, DWORD PTR [edi+136]
  00125	03 f3		 add	 esi, ebx
  00127	89 75 e8	 mov	 DWORD PTR tv247[ebp], esi
  0012a	33 f6		 xor	 esi, esi
  0012c	8b d9		 mov	 ebx, ecx
  0012e	03 da		 add	 ebx, edx
  00130	13 f0		 adc	 esi, eax
  00132	89 5d f0	 mov	 DWORD PTR tv252[ebp], ebx
  00135	33 db		 xor	 ebx, ebx
  00137	3b f3		 cmp	 esi, ebx
  00139	77 12		 ja	 SHORT $LN40@ProbeMemor
  0013b	0f 82 14 01 00
	00		 jb	 $LN17@ProbeMemor
  00141	8b 75 e8	 mov	 esi, DWORD PTR tv247[ebp]
  00144	39 75 f0	 cmp	 DWORD PTR tv252[ebp], esi

; 556  : 
; 557  :         return true;

  00147	0f 86 08 01 00
	00		 jbe	 $LN17@ProbeMemor
$LN40@ProbeMemor:
  0014d	8b 9f 84 00 00
	00		 mov	 ebx, DWORD PTR [edi+132]
$LN7@ProbeMemor:

; 558  :     }
; 559  : 
; 560  :     if ((address >= Class_Microsoft_Singularity_Hal_Platform::c_thePlatform->Smap32) &&
; 561  :         ((address + length) <= (Class_Microsoft_Singularity_Hal_Platform::c_thePlatform->Smap32 + 4096))) {

  00153	33 f6		 xor	 esi, esi
  00155	3b c6		 cmp	 eax, esi
  00157	72 3c		 jb	 SHORT $LN6@ProbeMemor
  00159	77 05		 ja	 SHORT $LN27@ProbeMemor
  0015b	3b 57 2c	 cmp	 edx, DWORD PTR [edi+44]
  0015e	72 35		 jb	 SHORT $LN6@ProbeMemor
$LN27@ProbeMemor:
  00160	33 f6		 xor	 esi, esi
  00162	8b d9		 mov	 ebx, ecx
  00164	03 da		 add	 ebx, edx
  00166	89 5d f0	 mov	 DWORD PTR tv228[ebp], ebx
  00169	8b 5f 2c	 mov	 ebx, DWORD PTR [edi+44]
  0016c	13 f0		 adc	 esi, eax
  0016e	81 c3 00 10 00
	00		 add	 ebx, 4096		; 00001000H
  00174	89 5d e8	 mov	 DWORD PTR tv225[ebp], ebx
  00177	33 db		 xor	 ebx, ebx
  00179	3b f3		 cmp	 esi, ebx
  0017b	77 12		 ja	 SHORT $LN41@ProbeMemor
  0017d	0f 82 d2 00 00
	00		 jb	 $LN17@ProbeMemor
  00183	8b 75 e8	 mov	 esi, DWORD PTR tv225[ebp]
  00186	39 75 f0	 cmp	 DWORD PTR tv228[ebp], esi

; 562  : 
; 563  :         return true;

  00189	0f 86 c6 00 00
	00		 jbe	 $LN17@ProbeMemor
$LN41@ProbeMemor:
  0018f	8b 9f 84 00 00
	00		 mov	 ebx, DWORD PTR [edi+132]
$LN6@ProbeMemor:

; 564  :     }
; 565  : 
; 566  :     if ((address >= Class_Microsoft_Singularity_Hal_Platform::c_thePlatform->LogRecordBuffer) &&
; 567  :         ((address + length) <= (Class_Microsoft_Singularity_Hal_Platform::c_thePlatform->LogRecordBuffer + Class_Microsoft_Singularity_Hal_Platform::c_thePlatform->LogRecordSize))) {

  00195	33 f6		 xor	 esi, esi
  00197	3b c6		 cmp	 eax, esi
  00199	72 3c		 jb	 SHORT $LN5@ProbeMemor
  0019b	77 05		 ja	 SHORT $LN29@ProbeMemor
  0019d	3b 57 7c	 cmp	 edx, DWORD PTR [edi+124]
  001a0	72 35		 jb	 SHORT $LN5@ProbeMemor
$LN29@ProbeMemor:
  001a2	8b b7 80 00 00
	00		 mov	 esi, DWORD PTR [edi+128]
  001a8	03 77 7c	 add	 esi, DWORD PTR [edi+124]
  001ab	8b d9		 mov	 ebx, ecx
  001ad	89 75 e8	 mov	 DWORD PTR tv163[ebp], esi
  001b0	33 f6		 xor	 esi, esi
  001b2	03 da		 add	 ebx, edx
  001b4	13 f0		 adc	 esi, eax
  001b6	89 5d f0	 mov	 DWORD PTR tv166[ebp], ebx
  001b9	33 db		 xor	 ebx, ebx
  001bb	3b f3		 cmp	 esi, ebx
  001bd	77 12		 ja	 SHORT $LN42@ProbeMemor
  001bf	0f 82 90 00 00
	00		 jb	 $LN17@ProbeMemor
  001c5	8b 75 e8	 mov	 esi, DWORD PTR tv163[ebp]
  001c8	39 75 f0	 cmp	 DWORD PTR tv166[ebp], esi

; 568  : 
; 569  :         return true;

  001cb	0f 86 84 00 00
	00		 jbe	 $LN17@ProbeMemor
$LN42@ProbeMemor:
  001d1	8b 9f 84 00 00
	00		 mov	 ebx, DWORD PTR [edi+132]
$LN5@ProbeMemor:

; 570  :     }
; 571  : 
; 572  :     if ((address >= Class_Microsoft_Singularity_Hal_Platform::c_thePlatform->LogTextBuffer) &&
; 573  :         ((address + length) <= (Class_Microsoft_Singularity_Hal_Platform::c_thePlatform->LogTextBuffer + Class_Microsoft_Singularity_Hal_Platform::c_thePlatform->LogTextSize))) {

  001d7	33 f6		 xor	 esi, esi
  001d9	3b c6		 cmp	 eax, esi
  001db	72 20		 jb	 SHORT $LN43@ProbeMemor
  001dd	77 04		 ja	 SHORT $LN31@ProbeMemor
  001df	3b d3		 cmp	 edx, ebx
  001e1	72 1a		 jb	 SHORT $LN43@ProbeMemor
$LN31@ProbeMemor:
  001e3	8b bf 88 00 00
	00		 mov	 edi, DWORD PTR [edi+136]
  001e9	03 fb		 add	 edi, ebx
  001eb	33 f6		 xor	 esi, esi
  001ed	03 ca		 add	 ecx, edx
  001ef	13 f0		 adc	 esi, eax
  001f1	33 db		 xor	 ebx, ebx
  001f3	3b f3		 cmp	 esi, ebx
  001f5	77 06		 ja	 SHORT $LN43@ProbeMemor
  001f7	72 5c		 jb	 SHORT $LN17@ProbeMemor
  001f9	3b cf		 cmp	 ecx, edi

; 574  : 
; 575  :         return true;

  001fb	76 58		 jbe	 SHORT $LN17@ProbeMemor
$LN43@ProbeMemor:

; 576  :     }
; 577  : 
; 578  : #if ISA_IX
; 579  :     // TODO: HACK!HACK!HACK! These I/O ranges
; 580  :     // should not be hardcoded, but probed and put into the SMAP
; 581  :     // as reserved, .
; 582  :     const UINT64 ApicBase     = 0xfee00000;
; 583  :     const UINT32 ApicLength   = 0x1000;
; 584  :     const UINT64 IoApic0Base  = 0xfec00000;
; 585  :     const UINT32 IoApicLength = 0x100;
; 586  :     const UINT64 IoApic1Base  = 0xfec80000;
; 587  : 
; 588  :     if (address >= ApicBase &&
; 589  :         address <= ApicBase + ApicLength) {

  001fd	8b f2		 mov	 esi, edx
  001ff	81 c6 00 00 20
	01		 add	 esi, 18874368		; 01200000H
  00205	8b c8		 mov	 ecx, eax
  00207	83 d1 ff	 adc	 ecx, -1
  0020a	85 c9		 test	 ecx, ecx
  0020c	77 0a		 ja	 SHORT $LN3@ProbeMemor
  0020e	72 45		 jb	 SHORT $LN17@ProbeMemor
  00210	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H

; 590  :         return true;

  00216	76 3d		 jbe	 SHORT $LN17@ProbeMemor
$LN3@ProbeMemor:

; 591  :     }
; 592  :     if (address >= IoApic0Base &&
; 593  :         address <= IoApic0Base + IoApicLength) {

  00218	8b f2		 mov	 esi, edx
  0021a	81 c6 00 00 40
	01		 add	 esi, 20971520		; 01400000H
  00220	8b c8		 mov	 ecx, eax
  00222	83 d1 ff	 adc	 ecx, -1
  00225	85 c9		 test	 ecx, ecx
  00227	77 0a		 ja	 SHORT $LN2@ProbeMemor
  00229	72 2a		 jb	 SHORT $LN17@ProbeMemor
  0022b	81 fe 00 01 00
	00		 cmp	 esi, 256		; 00000100H

; 594  :         return true;

  00231	76 22		 jbe	 SHORT $LN17@ProbeMemor
$LN2@ProbeMemor:

; 595  :     }
; 596  :     if (address >= IoApic1Base &&
; 597  :         address <= IoApic1Base + IoApicLength) {

  00233	81 c2 00 00 38
	01		 add	 edx, 20447232		; 01380000H
  00239	83 d0 ff	 adc	 eax, -1
  0023c	85 c0		 test	 eax, eax
  0023e	77 0a		 ja	 SHORT $LN1@ProbeMemor
  00240	72 13		 jb	 SHORT $LN17@ProbeMemor
  00242	81 fa 00 01 00
	00		 cmp	 edx, 256		; 00000100H

; 598  :         return true;

  00248	76 0b		 jbe	 SHORT $LN17@ProbeMemor
$LN1@ProbeMemor:
  0024a	5f		 pop	 edi
  0024b	5e		 pop	 esi

; 599  :     }
; 600  : #endif
; 601  : 
; 602  :     //
; 603  :     // TODO: revisit this with paging and new MM design
; 604  :     //
; 605  : #if ISA_ARM
; 606  :     KDDBG("ProbeFailed %p..%p\n", (UIntPtr)address, (UIntPtr)(address + length));
; 607  : #endif
; 608  : 
; 609  :     return false;

  0024c	33 c0		 xor	 eax, eax
  0024e	5b		 pop	 ebx

; 610  : }

  0024f	8b e5		 mov	 esp, ebp
  00251	5d		 pop	 ebp
  00252	c2 08 00	 ret	 8
$LN17@ProbeMemor:
  00255	5f		 pop	 edi
  00256	5e		 pop	 esi

; 537  : 
; 538  :             return true;

  00257	b8 01 00 00 00	 mov	 eax, 1
  0025c	5b		 pop	 ebx

; 610  : }

  0025d	8b e5		 mov	 esp, ebp
  0025f	5d		 pop	 ebp
  00260	c2 08 00	 ret	 8
?ProbeMemoryRange@@YIH_KK@Z ENDP			; ProbeMemoryRange
_TEXT	ENDS
PUBLIC	?KdpComputeChecksum@@YIKPADK@Z			; KdpComputeChecksum
; Function compile flags: /Ogtp
;	COMDAT ?KdpComputeChecksum@@YIKPADK@Z
_TEXT	SEGMENT
?KdpComputeChecksum@@YIKPADK@Z PROC			; KdpComputeChecksum, COMDAT
; _Buffer$ = ecx
; _Length$ = edx

; 616  :     // Compute the checksum for the string passed in.
; 617  :     UINT32 Checksum = 0;

  00000	33 c0		 xor	 eax, eax

; 618  : 
; 619  :     while (Length > 0) {

  00002	85 d2		 test	 edx, edx
  00004	76 0f		 jbe	 SHORT $LN1@KdpCompute
  00006	56		 push	 esi
$LL2@KdpCompute:

; 620  :         Checksum = Checksum + (UINT32)*(PUCHAR)Buffer++;

  00007	0f b6 31	 movzx	 esi, BYTE PTR [ecx]
  0000a	03 c6		 add	 eax, esi
  0000c	83 c1 01	 add	 ecx, 1

; 621  :         Length--;

  0000f	83 ea 01	 sub	 edx, 1
  00012	75 f3		 jne	 SHORT $LL2@KdpCompute
  00014	5e		 pop	 esi
$LN1@KdpCompute:

; 622  :     }
; 623  : 
; 624  :     return(Checksum);
; 625  : } // KdpComputeChecksum

  00015	c3		 ret	 0
?KdpComputeChecksum@@YIKPADK@Z ENDP			; KdpComputeChecksum
_TEXT	ENDS
PUBLIC	?KdpGetCurrentProcessorNumber@@YIGXZ		; KdpGetCurrentProcessorNumber
; Function compile flags: /Ogtp
;	COMDAT ?KdpGetCurrentProcessorNumber@@YIGXZ
_TEXT	SEGMENT
?KdpGetCurrentProcessorNumber@@YIGXZ PROC		; KdpGetCurrentProcessorNumber, COMDAT

; 631  :     return (UINT16) Class_Microsoft_Singularity_Isal_Isa::g_GetCurrentCpu()->id;

  00000	e8 00 00 00 00	 call	 ?g_GetCurrentCpu@Class_Microsoft_Singularity_Isal_Isa@@SIPAUStruct_Microsoft_Singularity_Isal_CpuRecord@@XZ ; Class_Microsoft_Singularity_Isal_Isa::g_GetCurrentCpu
  00005	66 8b 80 40 02
	00 00		 mov	 ax, WORD PTR [eax+576]

; 632  : } // KdpGetCurrentProcessorNumber

  0000c	c3		 ret	 0
?KdpGetCurrentProcessorNumber@@YIGXZ ENDP		; KdpGetCurrentProcessorNumber
_TEXT	ENDS
PUBLIC	?KdpCopyMemoryChunks@@YIK_KPAXKKKPAK@Z		; KdpCopyMemoryChunks
EXTRN	?KdpFlushInstCache@@YIXXZ:PROC			; KdpFlushInstCache
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
;	COMDAT ?KdpCopyMemoryChunks@@YIK_KPAXKKKPAK@Z
_TEXT	SEGMENT
_TotalSize$ = -8					; size = 4
_Buffer$ = -4						; size = 4
_Address$ = 8						; size = 8
_ChunkSize$ = 16					; size = 4
_Flags$ = 20						; size = 4
_ActualSize$ = 24					; size = 4
?KdpCopyMemoryChunks@@YIK_KPAXKKKPAK@Z PROC		; KdpCopyMemoryChunks, COMDAT
; _Buffer$ = ecx
; _TotalSize$ = edx

; 663  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 664  :     UINT32 Length;
; 665  :     UINT32 CopyChunk;
; 666  : 
; 667  :     if (ChunkSize > MMDBG_COPY_MAX_SIZE) {

  00006	8b 45 10	 mov	 eax, DWORD PTR _ChunkSize$[ebp]
  00009	83 f8 08	 cmp	 eax, 8
  0000c	89 55 f8	 mov	 DWORD PTR _TotalSize$[ebp], edx
  0000f	89 4d fc	 mov	 DWORD PTR _Buffer$[ebp], ecx
  00012	76 09		 jbe	 SHORT $LN16@KdpCopyMem

; 668  :         ChunkSize = MMDBG_COPY_MAX_SIZE;

  00014	c7 45 10 08 00
	00 00		 mov	 DWORD PTR _ChunkSize$[ebp], 8
  0001b	eb 0b		 jmp	 SHORT $LN14@KdpCopyMem
$LN16@KdpCopyMem:

; 669  :     }
; 670  :     else if (ChunkSize == 0) {

  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN14@KdpCopyMem

; 671  :         // Default to 4 byte chunks as that's
; 672  :         // what the previous code did.
; 673  :         ChunkSize = 4;

  00021	c7 45 10 04 00
	00 00		 mov	 DWORD PTR _ChunkSize$[ebp], 4
$LN14@KdpCopyMem:

; 674  :     }
; 675  : 
; 676  :     //
; 677  :     // MmDbgCopyMemory only copies a single aligned chunk at a
; 678  :     // time.  It is Kd's responsibility to chunk up a larger
; 679  :     // request for individual copy requests.  This gives Kd
; 680  :     // the flexibility to pick a chunk size and also frees
; 681  :     // Mm from having to worry about more than a page at a time.
; 682  :     // Additionally, it is important that we access memory with the
; 683  :     // largest size possible because we could be accessing
; 684  :     // memory-mapped I/O space.
; 685  :     //
; 686  : 
; 687  :     Length = TotalSize;
; 688  :     CopyChunk = 1;
; 689  : 
; 690  :     while (Length > 0) {

  00028	85 d2		 test	 edx, edx
  0002a	53		 push	 ebx
  0002b	56		 push	 esi
  0002c	8b da		 mov	 ebx, edx
  0002e	be 01 00 00 00	 mov	 esi, 1
  00033	0f 86 8a 00 00
	00		 jbe	 $LN22@KdpCopyMem
  00039	57		 push	 edi
  0003a	8b 7d 08	 mov	 edi, DWORD PTR _Address$[ebp]
  0003d	8d 49 00	 npad	 3
$LL13@KdpCopyMem:

; 691  : 
; 692  :         // Expand the chunk size as long as:
; 693  :         //   We haven't hit the chunk limit.
; 694  :         //   We have enough data left.
; 695  :         //   The address is properly aligned.
; 696  :         while (CopyChunk < ChunkSize &&
; 697  :                (CopyChunk << 1) <= Length &&
; 698  :                (Address & ((CopyChunk << 1) - 1)) == 0) {

  00040	3b 75 10	 cmp	 esi, DWORD PTR _ChunkSize$[ebp]
  00043	73 1d		 jae	 SHORT $LN30@KdpCopyMem
$LL11@KdpCopyMem:
  00045	8d 14 36	 lea	 edx, DWORD PTR [esi+esi]
  00048	3b d3		 cmp	 edx, ebx
  0004a	77 16		 ja	 SHORT $LN30@KdpCopyMem
  0004c	33 c9		 xor	 ecx, ecx
  0004e	23 4d 0c	 and	 ecx, DWORD PTR _Address$[ebp+4]
  00051	8d 44 36 ff	 lea	 eax, DWORD PTR [esi+esi-1]
  00055	23 c7		 and	 eax, edi
  00057	0b c1		 or	 eax, ecx
  00059	75 07		 jne	 SHORT $LN30@KdpCopyMem

; 699  :             CopyChunk <<= 1;

  0005b	8b f2		 mov	 esi, edx
  0005d	3b 75 10	 cmp	 esi, DWORD PTR _ChunkSize$[ebp]
  00060	72 e3		 jb	 SHORT $LL11@KdpCopyMem
$LN30@KdpCopyMem:

; 700  :         }
; 701  : 
; 702  :         // Shrink the chunk size to fit the available data.
; 703  :         while (CopyChunk > Length) {

  00062	3b f3		 cmp	 esi, ebx
  00064	76 06		 jbe	 SHORT $LN8@KdpCopyMem
$LL9@KdpCopyMem:

; 704  :             CopyChunk >>= 1;

  00066	d1 ee		 shr	 esi, 1
  00068	3b f3		 cmp	 esi, ebx
  0006a	77 fa		 ja	 SHORT $LL9@KdpCopyMem
$LN8@KdpCopyMem:

; 705  :         }
; 706  : 
; 707  :         if (Address < Class_Microsoft_Singularity_Hal_Platform::c_thePlatform->PhysicalBase) {

  0006c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?c_thePlatform@Class_Microsoft_Singularity_Hal_Platform@@2PAU1@A ; Class_Microsoft_Singularity_Hal_Platform::c_thePlatform
  00071	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00074	33 c0		 xor	 eax, eax
  00076	39 45 0c	 cmp	 DWORD PTR _Address$[ebp+4], eax
  00079	72 44		 jb	 SHORT $LN32@KdpCopyMem
  0007b	77 04		 ja	 SHORT $LN28@KdpCopyMem
  0007d	3b f9		 cmp	 edi, ecx
  0007f	72 3e		 jb	 SHORT $LN32@KdpCopyMem
$LN28@KdpCopyMem:

; 708  :             break;
; 709  :         }
; 710  :         if (Address == 0) {

  00081	8b 45 0c	 mov	 eax, DWORD PTR _Address$[ebp+4]
  00084	8b cf		 mov	 ecx, edi
  00086	0b c8		 or	 ecx, eax
  00088	74 35		 je	 SHORT $LN32@KdpCopyMem

; 711  :             break;
; 712  :         }
; 713  : #if PAGING
; 714  :         UINT64 RawAddress = Address;
; 715  :         if (Flags & MMDBG_COPY_PHYSICAL) {
; 716  :             // Temporarily map the physical memory range.
; 717  :             // TODO: KernelMapPhysicalMemory tries to acquire a lock -- if
; 718  :             // this lock is not free, we may deadlock here.
; 719  :             // Also, remapping for every chunk is inefficient.
; 720  :             KDDBG("Physical address = 0x%x size = 0x%x\n", int(Address), int(CopyChunk));
; 721  :             Struct_Microsoft_Singularity_Memory_PhysicalAddress physical;
; 722  :             Struct_Microsoft_Singularity_Memory_PhysicalAddress::m__ctor(
; 723  :                 &physical,
; 724  :                 UIntPtr(Address));
; 725  :             Address = UINT64(Class_Microsoft_Singularity_Memory_MemoryManager
; 726  :                 ::g_KernelMapPhysicalMemory(
; 727  :                     physical,
; 728  :                     UIntPtr(CopyChunk)));
; 729  :             KDDBG("Physical address 0x%x mapped to virtual address 0x%x\n", int(RawAddress), int(Address));
; 730  :         }
; 731  :         else {
; 732  :             if (Class_Microsoft_Singularity_Memory_MemoryManager::c_isInitialized
; 733  :                 && !Class_Microsoft_Singularity_Memory_VMManager::g_IsPageMapped(
; 734  :                         Class_Microsoft_Singularity_Memory_MemoryManager::g_PageAlign(
; 735  :                             UIntPtr(Address)))) {
; 736  :                 break;
; 737  :             }
; 738  :         }
; 739  : 
; 740  : #endif
; 741  :         //
; 742  :         //  It is illegal to just touch the memory that the debugger just asked for
; 743  :         //  w/o making sure it is valid. Otherwise this will trap inside the debugger
; 744  :         //  code, hanging both the system and debugger. We need to ansure the memory
; 745  :         //  is valid. For now just check against the smap.
; 746  :         //
; 747  : 
; 748  :         if (!ProbeMemoryRange(Address, CopyChunk)) {

  0008a	50		 push	 eax
  0008b	57		 push	 edi
  0008c	8b ce		 mov	 ecx, esi
  0008e	e8 00 00 00 00	 call	 ?ProbeMemoryRange@@YIH_KK@Z ; ProbeMemoryRange
  00093	85 c0		 test	 eax, eax
  00095	74 28		 je	 SHORT $LN32@KdpCopyMem

; 749  :             break;
; 750  :         }
; 751  : 
; 752  :         if (Flags & MMDBG_COPY_WRITE) {

  00097	f6 45 14 01	 test	 BYTE PTR _Flags$[ebp], 1

; 753  :             memcpy((void*)Address, Buffer, CopyChunk);

  0009b	56		 push	 esi
  0009c	74 07		 je	 SHORT $LN4@KdpCopyMem
  0009e	8b 55 fc	 mov	 edx, DWORD PTR _Buffer$[ebp]
  000a1	52		 push	 edx
  000a2	57		 push	 edi

; 754  :         }
; 755  :         else {

  000a3	eb 05		 jmp	 SHORT $LN33@KdpCopyMem
$LN4@KdpCopyMem:

; 756  :             memcpy(Buffer, (void*)Address, CopyChunk);

  000a5	8b 45 fc	 mov	 eax, DWORD PTR _Buffer$[ebp]
  000a8	57		 push	 edi
  000a9	50		 push	 eax
$LN33@KdpCopyMem:
  000aa	e8 00 00 00 00	 call	 _memcpy
  000af	83 c4 0c	 add	 esp, 12			; 0000000cH

; 757  :         }
; 758  : 
; 759  : #if PAGING
; 760  :         if (Flags & MMDBG_COPY_PHYSICAL) {
; 761  :             KDDBG("Unmapping physical address 0x%x (virtual address 0x%x)\n", int(RawAddress), int(Address));
; 762  :             Class_Microsoft_Singularity_Memory_MemoryManager
; 763  :                 ::g_KernelUnmapPhysicalMemory(
; 764  :                     UIntPtr(Address), UIntPtr(Address + CopyChunk));
; 765  :             KDDBG("Unmapped physical address 0x%x (virtual address 0x%x)\n", int(RawAddress), int(Address));
; 766  :             Address = RawAddress;
; 767  :         }
; 768  : #endif
; 769  : 
; 770  :         Address += CopyChunk;

  000b2	03 fe		 add	 edi, esi
  000b4	83 55 0c 00	 adc	 DWORD PTR _Address$[ebp+4], 0

; 771  :         Buffer = (PVOID)((PUCHAR)Buffer + CopyChunk);

  000b8	01 75 fc	 add	 DWORD PTR _Buffer$[ebp], esi

; 772  :         Length -= CopyChunk;

  000bb	2b de		 sub	 ebx, esi
  000bd	75 81		 jne	 SHORT $LL13@KdpCopyMem
$LN32@KdpCopyMem:

; 674  :     }
; 675  : 
; 676  :     //
; 677  :     // MmDbgCopyMemory only copies a single aligned chunk at a
; 678  :     // time.  It is Kd's responsibility to chunk up a larger
; 679  :     // request for individual copy requests.  This gives Kd
; 680  :     // the flexibility to pick a chunk size and also frees
; 681  :     // Mm from having to worry about more than a page at a time.
; 682  :     // Additionally, it is important that we access memory with the
; 683  :     // largest size possible because we could be accessing
; 684  :     // memory-mapped I/O space.
; 685  :     //
; 686  : 
; 687  :     Length = TotalSize;
; 688  :     CopyChunk = 1;
; 689  : 
; 690  :     while (Length > 0) {

  000bf	8b 55 f8	 mov	 edx, DWORD PTR _TotalSize$[ebp]
  000c2	5f		 pop	 edi
$LN22@KdpCopyMem:

; 773  :     }
; 774  : 
; 775  :     if (ActualSize) {

  000c3	8b 45 18	 mov	 eax, DWORD PTR _ActualSize$[ebp]
  000c6	85 c0		 test	 eax, eax
  000c8	74 06		 je	 SHORT $LN2@KdpCopyMem

; 776  :         *ActualSize = TotalSize - Length;

  000ca	8b ca		 mov	 ecx, edx
  000cc	2b cb		 sub	 ecx, ebx
  000ce	89 08		 mov	 DWORD PTR [eax], ecx
$LN2@KdpCopyMem:

; 777  :     }
; 778  : 
; 779  :     //
; 780  :     // Flush the instruction cache in case the write was into the instruction
; 781  :     // stream.  Only do this when writing into the kernel address space,
; 782  :     // and if any bytes were actually written
; 783  :     //
; 784  : 
; 785  :     if ((Flags & MMDBG_COPY_WRITE) && Length < TotalSize) {

  000d0	f6 45 14 01	 test	 BYTE PTR _Flags$[ebp], 1
  000d4	74 09		 je	 SHORT $LN1@KdpCopyMem
  000d6	3b da		 cmp	 ebx, edx
  000d8	73 05		 jae	 SHORT $LN1@KdpCopyMem

; 786  :         KdpFlushInstCache();

  000da	e8 00 00 00 00	 call	 ?KdpFlushInstCache@@YIXXZ ; KdpFlushInstCache
$LN1@KdpCopyMem:

; 787  :     }
; 788  : 
; 789  :     return Length != 0 ? STATUS_UNSUCCESSFUL : STATUS_SUCCESS;

  000df	8b c3		 mov	 eax, ebx
  000e1	f7 d8		 neg	 eax
  000e3	1b c0		 sbb	 eax, eax
  000e5	5e		 pop	 esi
  000e6	25 01 00 00 c0	 and	 eax, -1073741823	; c0000001H
  000eb	5b		 pop	 ebx

; 790  : }

  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c2 14 00	 ret	 20			; 00000014H
?KdpCopyMemoryChunks@@YIK_KPAXKKKPAK@Z ENDP		; KdpCopyMemoryChunks
_TEXT	ENDS
EXTRN	?g_GetCurrentThreadContext@Class_Microsoft_Singularity_Processor@@SIPAUStruct_Microsoft_Singularity_ThreadContext@@XZ:PROC ; Class_Microsoft_Singularity_Processor::g_GetCurrentThreadContext
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
;	COMDAT ?KdpSetCommonState@@YIXKPAUStruct_Microsoft_Singularity_Isal_SpillContext@@PAU_DBGKD_ANY_WAIT_STATE_CHANGE@@@Z
_TEXT	SEGMENT
_InstrCount$ = 8					; size = 4
_Context$ = 8						; size = 4
?KdpSetCommonState@@YIXKPAUStruct_Microsoft_Singularity_Isal_SpillContext@@PAU_DBGKD_ANY_WAIT_STATE_CHANGE@@@Z PROC ; KdpSetCommonState, COMDAT
; _NewState$ = eax
; _WaitStateChange$ = esi

; 799  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 800  :     UINT32 InstrCount;
; 801  :     PUCHAR InstrStream;
; 802  : 
; 803  :     WaitStateChange->NewState = NewState;

  00003	89 06		 mov	 DWORD PTR [esi], eax

; 804  :     WaitStateChange->ProcessorLevel = KeProcessorLevel;

  00005	66 c7 46 04 0f
	00		 mov	 WORD PTR [esi+4], 15	; 0000000fH

; 805  :     WaitStateChange->Processor = KdpGetCurrentProcessorNumber();

  0000b	e8 00 00 00 00	 call	 ?g_GetCurrentCpu@Class_Microsoft_Singularity_Isal_Isa@@SIPAUStruct_Microsoft_Singularity_Isal_CpuRecord@@XZ ; Class_Microsoft_Singularity_Isal_Isa::g_GetCurrentCpu
  00010	0f b7 88 40 02
	00 00		 movzx	 ecx, WORD PTR [eax+576]

; 806  :     WaitStateChange->NumberProcessors = KeNumberProcessors;

  00017	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _KeNumberProcessors
  0001d	66 89 4e 06	 mov	 WORD PTR [esi+6], cx
  00021	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 807  :     WaitStateChange->Thread
; 808  :         = SIGN_EXTEND(Class_Microsoft_Singularity_Processor::g_GetCurrentThreadContext()->_thread);

  00024	e8 00 00 00 00	 call	 ?g_GetCurrentThreadContext@Class_Microsoft_Singularity_Processor@@SIPAUStruct_Microsoft_Singularity_ThreadContext@@XZ ; Class_Microsoft_Singularity_Processor::g_GetCurrentThreadContext
  00029	8b 80 78 02 00
	00		 mov	 eax, DWORD PTR [eax+632]
  0002f	99		 cdq
  00030	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 809  : 
; 810  : #if ISA_IX86
; 811  :     WaitStateChange->ProgramCounter = SIGN_EXTEND(Context->ip);

  00033	8b 45 08	 mov	 eax, DWORD PTR _Context$[ebp]
  00036	89 56 14	 mov	 DWORD PTR [esi+20], edx
  00039	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]

; 812  : #elif ISA_IX64
; 813  :     WaitStateChange->ProgramCounter = Context->ip;
; 814  : #elif ISA_ARM
; 815  :     WaitStateChange->ProgramCounter = SIGN_EXTEND(Context->pc);
; 816  : #endif
; 817  :     RtlZeroMemory(&WaitStateChange->AnyControlReport,
; 818  :                   sizeof(WaitStateChange->AnyControlReport));

  0003c	6a 30		 push	 48			; 00000030H
  0003e	99		 cdq
  0003f	8d 8e c0 00 00
	00		 lea	 ecx, DWORD PTR [esi+192]
  00045	6a 00		 push	 0
  00047	51		 push	 ecx
  00048	89 46 18	 mov	 DWORD PTR [esi+24], eax
  0004b	89 56 1c	 mov	 DWORD PTR [esi+28], edx
  0004e	e8 00 00 00 00	 call	 _memset

; 819  : 
; 820  :     //
; 821  :     // Copy instruction stream immediately following location of event.
; 822  :     //
; 823  :     PCHAR PcMemory = (PCHAR)WaitStateChange->ProgramCounter;
; 824  : 
; 825  :     InstrStream = (PUCHAR)&WaitStateChange->ControlReport.InstructionStream;
; 826  :     KdpCopyFromPtr(InstrStream, PcMemory,
; 827  :                    sizeof(WaitStateChange->ControlReport.InstructionStream), &InstrCount);

  00053	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	8d 55 08	 lea	 edx, DWORD PTR _InstrCount$[ebp]
  0005c	52		 push	 edx
  0005d	6a 04		 push	 4
  0005f	6a 00		 push	 0
  00061	6a 00		 push	 0
  00063	8d 8e cc 00 00
	00		 lea	 ecx, DWORD PTR [esi+204]
  00069	50		 push	 eax
  0006a	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  0006f	e8 00 00 00 00	 call	 ?KdpCopyMemoryChunks@@YIK_KPAXKKKPAK@Z ; KdpCopyMemoryChunks

; 828  :     WaitStateChange->ControlReport.InstructionCount = (UINT16)InstrCount;

  00074	0f b7 4d 08	 movzx	 ecx, WORD PTR _InstrCount$[ebp]
  00078	66 89 8e c8 00
	00 00		 mov	 WORD PTR [esi+200], cx

; 829  : 
; 830  :     //
; 831  :     // Clear breakpoints in copied area.
; 832  :     // If there were any breakpoints cleared, recopy the instruction area
; 833  :     // without them.
; 834  :     //
; 835  : 
; 836  :     // if (KdpDeleteBreakpointRange(PcMemory, PcMemory + InstrCount - 1)) {
; 837  :     //    KdpCopyFromPtr(InstrStream, PcMemory, InstrCount, &InstrCount);
; 838  :     // }
; 839  : }

  0007f	5d		 pop	 ebp
  00080	c2 04 00	 ret	 4
?KdpSetCommonState@@YIXKPAUStruct_Microsoft_Singularity_Isal_SpillContext@@PAU_DBGKD_ANY_WAIT_STATE_CHANGE@@@Z ENDP ; KdpSetCommonState
_TEXT	ENDS
PUBLIC	?WcsToStr@@YIKPA_WKPAD@Z			; WcsToStr
; Function compile flags: /Ogtp
;	COMDAT ?WcsToStr@@YIKPA_WKPAD@Z
_TEXT	SEGMENT
_pszDst$ = 8						; size = 4
?WcsToStr@@YIKPA_WKPAD@Z PROC				; WcsToStr, COMDAT
; _pwcsSrc$ = ecx
; _Length$ = edx

; 842  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 843  :     for (UINT32 n = 0; n < Length; n++) {

  00003	8b 45 08	 mov	 eax, DWORD PTR _pszDst$[ebp]
  00006	57		 push	 edi
  00007	8b fa		 mov	 edi, edx
  00009	85 ff		 test	 edi, edi
  0000b	76 13		 jbe	 SHORT $LN1@WcsToStr
  0000d	56		 push	 esi
  0000e	8b f7		 mov	 esi, edi
$LL3@WcsToStr:

; 844  :         *pszDst++ = (char)*pwcsSrc++;

  00010	8a 11		 mov	 dl, BYTE PTR [ecx]
  00012	88 10		 mov	 BYTE PTR [eax], dl
  00014	83 c0 01	 add	 eax, 1
  00017	83 c1 02	 add	 ecx, 2
  0001a	83 ee 01	 sub	 esi, 1
  0001d	75 f1		 jne	 SHORT $LL3@WcsToStr
  0001f	5e		 pop	 esi
$LN1@WcsToStr:

; 845  :     }
; 846  :     *pszDst++ = '\0';

  00020	c6 00 00	 mov	 BYTE PTR [eax], 0

; 847  : 
; 848  :     return Length + 1;

  00023	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00026	5f		 pop	 edi

; 849  : }

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?WcsToStr@@YIKPA_WKPAD@Z ENDP				; WcsToStr
_TEXT	ENDS
_BSS	SEGMENT
_KdpContext DQ	01H DUP (?)
; Function compile flags: /Ogtp
_BSS	ENDS
;	COMDAT ?KdpReadVirtualMemory@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@@Z
_TEXT	SEGMENT
_MessageHeader$ = -12					; size = 8
_Length$ = -4						; size = 4
?KdpReadVirtualMemory@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@@Z PROC ; KdpReadVirtualMemory, COMDAT
; _m$ = esi
; _AdditionalData$ = edi

; 1003 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1004 :     UINT32 Length;
; 1005 :     STRING MessageHeader;
; 1006 : 
; 1007 :     //
; 1008 :     // Trim the transfer count to fit in a single message.
; 1009 :     //
; 1010 : 
; 1011 :     Length = m->ReadMemory.TransferCount;

  00006	8b 56 18	 mov	 edx, DWORD PTR [esi+24]

; 1012 :     if (Length > (PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64))) {

  00009	81 fa 68 0f 00
	00		 cmp	 edx, 3944		; 00000f68H
  0000f	89 55 fc	 mov	 DWORD PTR _Length$[ebp], edx
  00012	76 08		 jbe	 SHORT $LN1@KdpReadVir

; 1013 :         Length = PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64);

  00014	ba 68 0f 00 00	 mov	 edx, 3944		; 00000f68H
  00019	89 55 fc	 mov	 DWORD PTR _Length$[ebp], edx
$LN1@KdpReadVir:

; 1014 :     }
; 1015 : 
; 1016 :     //
; 1017 :     // Move the data to the destination buffer.
; 1018 :     //
; 1019 : 
; 1020 :     m->ReturnStatus =
; 1021 :         KdpCopyMemoryChunks((UINT64)(ULONG_PTR)m->ReadMemory.TargetBaseAddress,
; 1022 :                             AdditionalData->Buffer,
; 1023 :                             Length,
; 1024 :                             0,
; 1025 :                             MMDBG_COPY_UNSAFE,
; 1026 :                             &Length);

  0001c	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0001f	8d 45 fc	 lea	 eax, DWORD PTR _Length$[ebp]
  00022	50		 push	 eax
  00023	6a 04		 push	 4
  00025	6a 00		 push	 0
  00027	6a 00		 push	 0
  00029	51		 push	 ecx
  0002a	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0002d	e8 00 00 00 00	 call	 ?KdpCopyMemoryChunks@@YIK_KPAXKKKPAK@Z ; KdpCopyMemoryChunks
  00032	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1027 : 
; 1028 :     //
; 1029 :     // Set the actual number of bytes read, initialize the message header,
; 1030 :     // and send the reply packet to the host debugger.
; 1031 :     //
; 1032 : 
; 1033 :     AdditionalData->Length = (UINT16)Length;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _Length$[ebp]

; 1034 :     m->ReadMemory.ActualBytesRead = Length;
; 1035 : 
; 1036 :     MessageHeader.Length = sizeof(DBGKD_MANIPULATE_STATE64);
; 1037 :     MessageHeader.Buffer = (PCHAR)m;
; 1038 :     KdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
; 1039 :                  &MessageHeader,
; 1040 :                  AdditionalData,
; 1041 :                  &KdpContext);

  00038	68 00 00 00 00	 push	 OFFSET _KdpContext
  0003d	66 89 07	 mov	 WORD PTR [edi], ax
  00040	57		 push	 edi
  00041	8d 55 f4	 lea	 edx, DWORD PTR _MessageHeader$[ebp]
  00044	b9 02 00 00 00	 mov	 ecx, 2
  00049	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  0004c	66 c7 45 f4 38
	00		 mov	 WORD PTR _MessageHeader$[ebp], 56 ; 00000038H
  00052	89 75 f8	 mov	 DWORD PTR _MessageHeader$[ebp+4], esi
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket

; 1042 : 
; 1043 :     return;
; 1044 : }

  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
?KdpReadVirtualMemory@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@@Z ENDP ; KdpReadVirtualMemory
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?KdpWriteVirtualMemory@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@@Z
_TEXT	SEGMENT
_MessageHeader$ = -8					; size = 8
?KdpWriteVirtualMemory@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@@Z PROC ; KdpWriteVirtualMemory, COMDAT
; _m$ = esi
; _AdditionalData$ = eax

; 1061 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1062 : 
; 1063 :     STRING MessageHeader;
; 1064 : 
; 1065 :     //
; 1066 :     // Move the data to the destination buffer.
; 1067 :     //
; 1068 : 
; 1069 :     m->ReturnStatus =
; 1070 :         KdpCopyMemoryChunks((UINT64)(ULONG_PTR)m->WriteMemory.TargetBaseAddress,
; 1071 :                             AdditionalData->Buffer,
; 1072 :                             AdditionalData->Length,
; 1073 :                             0,
; 1074 :                             MMDBG_COPY_WRITE | MMDBG_COPY_UNSAFE,
; 1075 :                             &m->WriteMemory.ActualBytesWritten);

  00006	0f b7 10	 movzx	 edx, WORD PTR [eax]
  00009	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
  0000c	51		 push	 ecx
  0000d	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00010	6a 05		 push	 5
  00012	6a 00		 push	 0
  00014	6a 00		 push	 0
  00016	51		 push	 ecx
  00017	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001a	e8 00 00 00 00	 call	 ?KdpCopyMemoryChunks@@YIK_KPAXKKKPAK@Z ; KdpCopyMemoryChunks

; 1076 : 
; 1077 :     //
; 1078 :     // Set the actual number of bytes written, initialize the message header,
; 1079 :     // and send the reply packet to the host debugger.
; 1080 :     //
; 1081 : 
; 1082 :     MessageHeader.Length = sizeof(DBGKD_MANIPULATE_STATE64);
; 1083 :     MessageHeader.Buffer = (PCHAR)m;
; 1084 :     KdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
; 1085 :                  &MessageHeader,
; 1086 :                  NULL,
; 1087 :                  &KdpContext);

  0001f	68 00 00 00 00	 push	 OFFSET _KdpContext
  00024	6a 00		 push	 0
  00026	8d 55 f8	 lea	 edx, DWORD PTR _MessageHeader$[ebp]
  00029	b9 02 00 00 00	 mov	 ecx, 2
  0002e	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00031	66 c7 45 f8 38
	00		 mov	 WORD PTR _MessageHeader$[ebp], 56 ; 00000038H
  00037	89 75 fc	 mov	 DWORD PTR _MessageHeader$[ebp+4], esi
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket

; 1088 : 
; 1089 :     return;
; 1090 : }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?KdpWriteVirtualMemory@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@@Z ENDP ; KdpWriteVirtualMemory
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?KdpReadPhysicalMemory@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@@Z
_TEXT	SEGMENT
_MessageHeader$ = -12					; size = 8
_Length$ = -4						; size = 4
?KdpReadPhysicalMemory@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@@Z PROC ; KdpReadPhysicalMemory, COMDAT
; _m$ = esi
; _AdditionalData$ = edi

; 1107 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1108 :     UINT32 Length;
; 1109 :     STRING MessageHeader;
; 1110 : 
; 1111 :     //
; 1112 :     // Trim the transfer count to fit in a single message.
; 1113 :     //
; 1114 : 
; 1115 :     Length = m->ReadMemory.TransferCount;

  00006	8b 56 18	 mov	 edx, DWORD PTR [esi+24]

; 1116 :     if (Length > (PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64))) {

  00009	81 fa 68 0f 00
	00		 cmp	 edx, 3944		; 00000f68H
  0000f	89 55 fc	 mov	 DWORD PTR _Length$[ebp], edx
  00012	76 08		 jbe	 SHORT $LN1@KdpReadPhy

; 1117 :         Length = PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64);

  00014	ba 68 0f 00 00	 mov	 edx, 3944		; 00000f68H
  00019	89 55 fc	 mov	 DWORD PTR _Length$[ebp], edx
$LN1@KdpReadPhy:

; 1118 :     }
; 1119 : 
; 1120 :     m->ReturnStatus =
; 1121 :         KdpCopyMemoryChunks((UINT64)(ULONG_PTR)m->ReadMemory.TargetBaseAddress,
; 1122 :                             AdditionalData->Buffer,
; 1123 :                             Length,
; 1124 :                             0,
; 1125 :                             MMDBG_COPY_UNSAFE | MMDBG_COPY_PHYSICAL,
; 1126 :                             &Length);

  0001c	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0001f	8d 45 fc	 lea	 eax, DWORD PTR _Length$[ebp]
  00022	50		 push	 eax
  00023	6a 06		 push	 6
  00025	6a 00		 push	 0
  00027	6a 00		 push	 0
  00029	51		 push	 ecx
  0002a	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0002d	e8 00 00 00 00	 call	 ?KdpCopyMemoryChunks@@YIK_KPAXKKKPAK@Z ; KdpCopyMemoryChunks
  00032	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1127 : 
; 1128 :     //
; 1129 :     // Set the actual number of bytes read, initialize the message header,
; 1130 :     // and send the reply packet to the host debugger.
; 1131 :     //
; 1132 : 
; 1133 :     AdditionalData->Length = (UINT16)Length;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _Length$[ebp]

; 1134 :     m->ReadMemory.ActualBytesRead = Length;
; 1135 : 
; 1136 :     MessageHeader.Length = sizeof(DBGKD_MANIPULATE_STATE64);
; 1137 :     MessageHeader.Buffer = (PCHAR)m;
; 1138 :     KdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
; 1139 :                  &MessageHeader,
; 1140 :                  AdditionalData,
; 1141 :                  &KdpContext);

  00038	68 00 00 00 00	 push	 OFFSET _KdpContext
  0003d	66 89 07	 mov	 WORD PTR [edi], ax
  00040	57		 push	 edi
  00041	8d 55 f4	 lea	 edx, DWORD PTR _MessageHeader$[ebp]
  00044	b9 02 00 00 00	 mov	 ecx, 2
  00049	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  0004c	66 c7 45 f4 38
	00		 mov	 WORD PTR _MessageHeader$[ebp], 56 ; 00000038H
  00052	89 75 f8	 mov	 DWORD PTR _MessageHeader$[ebp+4], esi
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket

; 1142 : 
; 1143 :     return;
; 1144 : }

  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
?KdpReadPhysicalMemory@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@@Z ENDP ; KdpReadPhysicalMemory
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?KdpWritePhysicalMemory@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@@Z
_TEXT	SEGMENT
_MessageHeader$ = -8					; size = 8
?KdpWritePhysicalMemory@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@@Z PROC ; KdpWritePhysicalMemory, COMDAT
; _m$ = esi
; _AdditionalData$ = eax

; 1161 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1162 :     STRING MessageHeader;
; 1163 : 
; 1164 :     //
; 1165 :     // Move the data to the destination buffer.
; 1166 :     //
; 1167 : 
; 1168 :     m->ReturnStatus =
; 1169 :         KdpCopyMemoryChunks((UINT64)(ULONG_PTR)m->WriteMemory.TargetBaseAddress,
; 1170 :                             AdditionalData->Buffer,
; 1171 :                             AdditionalData->Length,
; 1172 :                             0,
; 1173 :                             MMDBG_COPY_WRITE | MMDBG_COPY_UNSAFE | MMDBG_COPY_PHYSICAL,
; 1174 :                             &m->WriteMemory.ActualBytesWritten);

  00006	0f b7 10	 movzx	 edx, WORD PTR [eax]
  00009	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
  0000c	51		 push	 ecx
  0000d	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00010	6a 07		 push	 7
  00012	6a 00		 push	 0
  00014	6a 00		 push	 0
  00016	51		 push	 ecx
  00017	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001a	e8 00 00 00 00	 call	 ?KdpCopyMemoryChunks@@YIK_KPAXKKKPAK@Z ; KdpCopyMemoryChunks

; 1175 : 
; 1176 :     //
; 1177 :     // Set the actual number of bytes written, initialize the message header,
; 1178 :     // and send the reply packet to the host debugger.
; 1179 :     //
; 1180 : 
; 1181 :     MessageHeader.Length = sizeof(DBGKD_MANIPULATE_STATE64);
; 1182 :     MessageHeader.Buffer = (PCHAR)m;
; 1183 :     KdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
; 1184 :                  &MessageHeader,
; 1185 :                  NULL,
; 1186 :                  &KdpContext);

  0001f	68 00 00 00 00	 push	 OFFSET _KdpContext
  00024	6a 00		 push	 0
  00026	8d 55 f8	 lea	 edx, DWORD PTR _MessageHeader$[ebp]
  00029	b9 02 00 00 00	 mov	 ecx, 2
  0002e	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00031	66 c7 45 f8 38
	00		 mov	 WORD PTR _MessageHeader$[ebp], 56 ; 00000038H
  00037	89 75 fc	 mov	 DWORD PTR _MessageHeader$[ebp+4], esi
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket

; 1187 : 
; 1188 :     return;
; 1189 : }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?KdpWritePhysicalMemory@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@@Z ENDP ; KdpWritePhysicalMemory
_TEXT	ENDS
EXTRN	?KdpReadMsr@@YI_NKPAK0@Z:PROC			; KdpReadMsr
; Function compile flags: /Ogtp
;	COMDAT ?KdpReadMachineSpecificRegister@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z
_TEXT	SEGMENT
_MessageHeader$ = -8					; size = 8
?KdpReadMachineSpecificRegister@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z PROC ; KdpReadMachineSpecificRegister, COMDAT
; _m$ = esi

; 1207 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1208 :     STRING MessageHeader;
; 1209 : 
; 1210 :     //
; 1211 :     // Read the MSR
; 1212 :     //
; 1213 :     m->ReturnStatus = KdpReadMsr(m->ReadWriteMsr.Msr,
; 1214 :                                  &m->ReadWriteMsr.DataValueLow,
; 1215 :                                  &m->ReadWriteMsr.DataValueHigh)
; 1216 :         ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;

  00006	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00009	8d 46 18	 lea	 eax, DWORD PTR [esi+24]
  0000c	50		 push	 eax
  0000d	8d 56 14	 lea	 edx, DWORD PTR [esi+20]
  00010	e8 00 00 00 00	 call	 ?KdpReadMsr@@YI_NKPAK0@Z ; KdpReadMsr
  00015	f6 d8		 neg	 al

; 1217 : 
; 1218 :     //
; 1219 :     // Set the actual number of bytes written, initialize the message header,
; 1220 :     // and send the reply packet to the host debugger.
; 1221 :     //
; 1222 : 
; 1223 :     MessageHeader.Length = sizeof(DBGKD_MANIPULATE_STATE64);
; 1224 :     MessageHeader.Buffer = (PCHAR)m;
; 1225 :     KdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
; 1226 :                  &MessageHeader,
; 1227 :                  NULL,
; 1228 :                  &KdpContext);

  00017	68 00 00 00 00	 push	 OFFSET _KdpContext
  0001c	6a 00		 push	 0
  0001e	8d 55 f8	 lea	 edx, DWORD PTR _MessageHeader$[ebp]
  00021	b9 02 00 00 00	 mov	 ecx, 2
  00026	66 c7 45 f8 38
	00		 mov	 WORD PTR _MessageHeader$[ebp], 56 ; 00000038H
  0002c	89 75 fc	 mov	 DWORD PTR _MessageHeader$[ebp+4], esi
  0002f	1b c0		 sbb	 eax, eax
  00031	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  00036	05 01 00 00 c0	 add	 eax, -1073741823	; c0000001H
  0003b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket

; 1229 : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?KdpReadMachineSpecificRegister@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ENDP ; KdpReadMachineSpecificRegister
_TEXT	ENDS
EXTRN	?KdpWriteMsr@@YI_NKKK@Z:PROC			; KdpWriteMsr
; Function compile flags: /Ogtp
;	COMDAT ?KdpWriteMachineSpecificRegister@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z
_TEXT	SEGMENT
_MessageHeader$ = -8					; size = 8
?KdpWriteMachineSpecificRegister@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z PROC ; KdpWriteMachineSpecificRegister, COMDAT
; _m$ = esi

; 1247 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1248 :     STRING MessageHeader;
; 1249 : 
; 1250 :     //
; 1251 :     // Write the MSR
; 1252 :     //
; 1253 :     m->ReturnStatus = KdpWriteMsr(m->ReadWriteMsr.Msr,
; 1254 :                                   m->ReadWriteMsr.DataValueLow,
; 1255 :                                   m->ReadWriteMsr.DataValueHigh)
; 1256 :         ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;

  00006	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00009	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0000c	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?KdpWriteMsr@@YI_NKKK@Z	; KdpWriteMsr
  00015	f6 d8		 neg	 al

; 1257 : 
; 1258 :     //
; 1259 :     // Set the actual number of bytes written, initialize the message header,
; 1260 :     // and send the reply packet to the host debugger.
; 1261 :     //
; 1262 : 
; 1263 :     MessageHeader.Length = sizeof(DBGKD_MANIPULATE_STATE64);
; 1264 :     MessageHeader.Buffer = (PCHAR)m;
; 1265 :     KdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
; 1266 :                  &MessageHeader,
; 1267 :                  NULL,
; 1268 :                  &KdpContext);

  00017	68 00 00 00 00	 push	 OFFSET _KdpContext
  0001c	6a 00		 push	 0
  0001e	8d 55 f8	 lea	 edx, DWORD PTR _MessageHeader$[ebp]
  00021	b9 02 00 00 00	 mov	 ecx, 2
  00026	66 c7 45 f8 38
	00		 mov	 WORD PTR _MessageHeader$[ebp], 56 ; 00000038H
  0002c	89 75 fc	 mov	 DWORD PTR _MessageHeader$[ebp+4], esi
  0002f	1b c0		 sbb	 eax, eax
  00031	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  00036	05 01 00 00 c0	 add	 eax, -1073741823	; c0000001H
  0003b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket

; 1269 : 
; 1270 :     return;
; 1271 : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?KdpWriteMachineSpecificRegister@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ENDP ; KdpWriteMachineSpecificRegister
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?wcslen@@YIHPA_W@Z
_TEXT	SEGMENT
?wcslen@@YIHPA_W@Z PROC					; wcslen, COMDAT
; _pwz$ = ecx

; 1275 :     int len = 0;

  00000	33 c0		 xor	 eax, eax

; 1276 : 
; 1277 :     while (*pwz++) {

  00002	66 39 01	 cmp	 WORD PTR [ecx], ax
  00005	74 15		 je	 SHORT $LN6@wcslen
  00007	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL2@wcslen:
  00010	83 c1 02	 add	 ecx, 2

; 1278 :         len++;

  00013	83 c0 01	 add	 eax, 1
  00016	66 83 39 00	 cmp	 WORD PTR [ecx], 0
  0001a	75 f4		 jne	 SHORT $LL2@wcslen
$LN6@wcslen:

; 1279 :     }
; 1280 :     return len;
; 1281 : }

  0001c	c3		 ret	 0
?wcslen@@YIHPA_W@Z ENDP					; wcslen
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?trim@@YIPA_WPA_W@Z
_TEXT	SEGMENT
?trim@@YIPA_WPA_W@Z PROC				; trim, COMDAT
; _pwz$ = edx

; 1285 :     WCHAR *pwzBeg = pwz;
; 1286 :     for (; *pwz; pwz++) {

  00000	0f b7 0a	 movzx	 ecx, WORD PTR [edx]
  00003	66 85 c9	 test	 cx, cx
  00006	8b c2		 mov	 eax, edx
  00008	74 1b		 je	 SHORT $LN2@trim
  0000a	8d 9b 00 00 00
	00		 npad	 6
$LL4@trim:

; 1287 :         if (*pwz == '\\') {

  00010	66 83 f9 5c	 cmp	 cx, 92			; 0000005cH
  00014	75 03		 jne	 SHORT $LN3@trim

; 1285 :     WCHAR *pwzBeg = pwz;
; 1286 :     for (; *pwz; pwz++) {

  00016	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
$LN3@trim:
  00019	0f b7 4a 02	 movzx	 ecx, WORD PTR [edx+2]
  0001d	83 c2 02	 add	 edx, 2
  00020	66 85 c9	 test	 cx, cx
  00023	75 eb		 jne	 SHORT $LL4@trim
$LN2@trim:

; 1288 :             pwzBeg = pwz + 1;
; 1289 :         }
; 1290 :     }
; 1291 :     return pwzBeg;
; 1292 : }

  00025	c3		 ret	 0
?trim@@YIPA_WPA_W@Z ENDP				; trim
_TEXT	ENDS
PUBLIC	??_C@_1BG@HCKDILII@?$AAk?$AAe?$AAr?$AAn?$AAe?$AAl?$AA?4?$AAx?$AA8?$AA6?$AA?$AA@ ; `string'
_BSS	SEGMENT
_PsLoadedModuleList DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_1BG@HCKDILII@?$AAk?$AAe?$AAr?$AAn?$AAe?$AAl?$AA?4?$AAx?$AA8?$AA6?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@HCKDILII@?$AAk?$AAe?$AAr?$AAn?$AAe?$AAl?$AA?4?$AAx?$AA8?$AA6?$AA?$AA@ DB 'k'
	DB	00H, 'e', 00H, 'r', 00H, 'n', 00H, 'e', 00H, 'l', 00H, '.', 00H
	DB	'x', 00H, '8', 00H, '6', 00H, 00H, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?KdpFakeOutPsLoadedModuleList@@YIXPAUClass_Microsoft_Singularity_Hal_Platform@@@Z
_TEXT	SEGMENT
?KdpFakeOutPsLoadedModuleList@@YIXPAUClass_Microsoft_Singularity_Hal_Platform@@@Z PROC ; KdpFakeOutPsLoadedModuleList, COMDAT
; _platform$ = eax

; 1298 : {

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax

; 1299 :     //
; 1300 :     //  If the debug information has not been filled in by the loader
; 1301 :     //  we need to reconstruct the loader list from the bootinfo data,
; 1302 :     //  including the hal and the kernel modules
; 1303 :     //
; 1304 :     KdVersionBlock.PsLoadedModuleList = SIGN_EXTEND(&PsLoadedModuleList);
; 1305 :     KdVersionBlock.KernBase = SIGN_EXTEND(platform->KernelDllBase);

  00003	8b 8e 8c 00 00
	00		 mov	 ecx, DWORD PTR [esi+140]
  00009	b8 00 00 00 00	 mov	 eax, OFFSET _PsLoadedModuleList
  0000e	99		 cdq
  0000f	a3 18 00 00 00	 mov	 DWORD PTR _KdVersionBlock+24, eax
  00014	8b c1		 mov	 eax, ecx
  00016	89 15 1c 00 00
	00		 mov	 DWORD PTR _KdVersionBlock+28, edx
  0001c	99		 cdq
  0001d	a3 10 00 00 00	 mov	 DWORD PTR _KdVersionBlock+16, eax

; 1306 : 
; 1307 :     KernelEntry.DllBase = (void *) platform->KernelDllBase;
; 1308 :     KernelEntry.CheckSum = 0;

  00022	33 c0		 xor	 eax, eax
  00024	a3 40 00 00 00	 mov	 DWORD PTR ?KernelEntry@@3UKLDR_DATA_TABLE_ENTRY_WITH_NAME@@A+64, eax

; 1309 :     KernelEntry.TimeDateStamp = 0;

  00029	a3 44 00 00 00	 mov	 DWORD PTR ?KernelEntry@@3UKLDR_DATA_TABLE_ENTRY_WITH_NAME@@A+68, eax
  0002e	89 0d 18 00 00
	00		 mov	 DWORD PTR ?KernelEntry@@3UKLDR_DATA_TABLE_ENTRY_WITH_NAME@@A+24, ecx
  00034	57		 push	 edi

; 1310 :     KernelEntry.LoadCount = 1;

  00035	66 c7 05 38 00
	00 00 01 00	 mov	 WORD PTR ?KernelEntry@@3UKLDR_DATA_TABLE_ENTRY_WITH_NAME@@A+56, 1

; 1311 :     KernelEntry.SizeOfImage = (uint32)platform->KernelDllSize;

  0003e	8b 86 90 00 00
	00		 mov	 eax, DWORD PTR [esi+144]
  00044	89 15 14 00 00
	00		 mov	 DWORD PTR _KdVersionBlock+20, edx

; 1312 : 
; 1313 : #if ISA_IX86
; 1314 :     memcpy(KernelEntry.wzName, L"kernel.x86", sizeof(KernelEntry.wzName));

  0004a	ba 4c 00 00 00	 mov	 edx, OFFSET ?KernelEntry@@3UKLDR_DATA_TABLE_ENTRY_WITH_NAME@@A+76
  0004f	a3 20 00 00 00	 mov	 DWORD PTR ?KernelEntry@@3UKLDR_DATA_TABLE_ENTRY_WITH_NAME@@A+32, eax

; 1315 : #elif ISA_IX64
; 1316 :     memcpy(KernelEntry.wzName, L"kernel.x64", sizeof(KernelEntry.wzName));
; 1317 : #elif ISA_ARM
; 1318 :     memcpy(KernelEntry.wzName, L"kernel.arm", sizeof(KernelEntry.wzName));
; 1319 : #endif
; 1320 : 
; 1321 :     RtlInitUnicodeString(&KernelEntry.BaseDllName, KernelEntry.wzName, 20);

  00054	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00059	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0005e	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_1BG@HCKDILII@?$AAk?$AAe?$AAr?$AAn?$AAe?$AAl?$AA?4?$AAx?$AA8?$AA6?$AA?$AA@
  00063	8b fa		 mov	 edi, edx
  00065	f3 a5		 rep movsd
  00067	66 a3 2e 00 00
	00		 mov	 WORD PTR ?KernelEntry@@3UKLDR_DATA_TABLE_ENTRY_WITH_NAME@@A+46, ax
  0006d	66 a3 2c 00 00
	00		 mov	 WORD PTR ?KernelEntry@@3UKLDR_DATA_TABLE_ENTRY_WITH_NAME@@A+44, ax

; 1322 :     RtlInitUnicodeString(&KernelEntry.FullDllName, KernelEntry.wzName, 20);

  00073	66 a3 26 00 00
	00		 mov	 WORD PTR ?KernelEntry@@3UKLDR_DATA_TABLE_ENTRY_WITH_NAME@@A+38, ax
  00079	66 a3 24 00 00
	00		 mov	 WORD PTR ?KernelEntry@@3UKLDR_DATA_TABLE_ENTRY_WITH_NAME@@A+36, ax

; 1323 : 
; 1324 :     InitializeListHead(&PsLoadedModuleList);
; 1325 :     InsertTailList(&PsLoadedModuleList, &KernelEntry.InLoadOrderLinks);

  0007f	b8 00 00 00 00	 mov	 eax, OFFSET ?KernelEntry@@3UKLDR_DATA_TABLE_ENTRY_WITH_NAME@@A ; KernelEntry
  00084	5f		 pop	 edi
  00085	89 15 30 00 00
	00		 mov	 DWORD PTR ?KernelEntry@@3UKLDR_DATA_TABLE_ENTRY_WITH_NAME@@A+48, edx
  0008b	89 15 28 00 00
	00		 mov	 DWORD PTR ?KernelEntry@@3UKLDR_DATA_TABLE_ENTRY_WITH_NAME@@A+40, edx
  00091	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?KernelEntry@@3UKLDR_DATA_TABLE_ENTRY_WITH_NAME@@A, OFFSET _PsLoadedModuleList
  0009b	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?KernelEntry@@3UKLDR_DATA_TABLE_ENTRY_WITH_NAME@@A+4, OFFSET _PsLoadedModuleList
  000a5	a3 00 00 00 00	 mov	 DWORD PTR _PsLoadedModuleList, eax
  000aa	a3 04 00 00 00	 mov	 DWORD PTR _PsLoadedModuleList+4, eax
  000af	5e		 pop	 esi

; 1326 : }

  000b0	c3		 ret	 0
?KdpFakeOutPsLoadedModuleList@@YIXPAUClass_Microsoft_Singularity_Hal_Platform@@@Z ENDP ; KdpFakeOutPsLoadedModuleList
_TEXT	ENDS
PUBLIC	?KdpSysGetVersion@@YIXPAU_DBGKD_GET_VERSION64@@@Z ; KdpSysGetVersion
; Function compile flags: /Ogtp
;	COMDAT ?KdpSysGetVersion@@YIXPAU_DBGKD_GET_VERSION64@@@Z
_TEXT	SEGMENT
?KdpSysGetVersion@@YIXPAU_DBGKD_GET_VERSION64@@@Z PROC	; KdpSysGetVersion, COMDAT
; _Version$ = ecx

; 1340 : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 1341 :     *Version = KdVersionBlock;

  00004	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00009	be 00 00 00 00	 mov	 esi, OFFSET _KdVersionBlock
  0000e	f3 a5		 rep movsd
  00010	5f		 pop	 edi
  00011	5e		 pop	 esi

; 1342 : }

  00012	c3		 ret	 0
?KdpSysGetVersion@@YIXPAU_DBGKD_GET_VERSION64@@@Z ENDP	; KdpSysGetVersion
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?KdpGetVersion@@YIXPAU_DBGKD_MANIPULATE_STATE64@@@Z
_TEXT	SEGMENT
_messageHeader$ = -8					; size = 8
?KdpGetVersion@@YIXPAU_DBGKD_MANIPULATE_STATE64@@@Z PROC ; KdpGetVersion, COMDAT
; _m$ = eax

; 1358 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi

; 1359 :     STRING messageHeader;
; 1360 : 
; 1361 :     messageHeader.Length = sizeof(*m);
; 1362 :     messageHeader.Buffer = (PCHAR)m;
; 1363 : 
; 1364 :     KdpSysGetVersion(&m->GetVersion64);

  00008	8d 78 10	 lea	 edi, DWORD PTR [eax+16]
  0000b	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00010	be 00 00 00 00	 mov	 esi, OFFSET _KdVersionBlock

; 1365 : 
; 1366 :     //
; 1367 :     // the usual stuff
; 1368 :     //
; 1369 :     m->ReturnStatus = STATUS_SUCCESS;
; 1370 :     m->ApiNumber = DbgKdGetVersionApi;
; 1371 : 
; 1372 :     KdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
; 1373 :                  &messageHeader,
; 1374 :                  NULL,
; 1375 :                  &KdpContext
; 1376 :                  );

  00015	68 00 00 00 00	 push	 OFFSET _KdpContext
  0001a	f3 a5		 rep movsd
  0001c	6a 00		 push	 0
  0001e	8d 55 f8	 lea	 edx, DWORD PTR _messageHeader$[ebp]
  00021	b9 02 00 00 00	 mov	 ecx, 2
  00026	66 c7 45 f8 38
	00		 mov	 WORD PTR _messageHeader$[ebp], 56 ; 00000038H
  0002c	89 45 fc	 mov	 DWORD PTR _messageHeader$[ebp+4], eax
  0002f	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00036	c7 00 46 31 00
	00		 mov	 DWORD PTR [eax], 12614	; 00003146H
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi

; 1377 : 
; 1378 :     return;
; 1379 : } // KdGetVersion

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?KdpGetVersion@@YIXPAU_DBGKD_MANIPULATE_STATE64@@@Z ENDP ; KdpGetVersion
_TEXT	ENDS
EXTRN	?KdpReadSpecialRegisters@@YIXPAUStruct_Microsoft_Singularity_Kd_X86KSpecialRegisters@@PBUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z:PROC ; KdpReadSpecialRegisters
_BSS	SEGMENT
_KdpProcessorState DB 0320H DUP (?)
; Function compile flags: /Ogtp
_BSS	ENDS
;	COMDAT ?KdpReadControlSpace@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z
_TEXT	SEGMENT
_MessageHeader$ = -12					; size = 8
_Actual$ = -4						; size = 4
_AdditionalData$ = 8					; size = 4
?KdpReadControlSpace@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z PROC ; KdpReadControlSpace, COMDAT
; _m$ = esi
; _Context$ = edx

; 1402 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1403 :     PDBGKD_READ_MEMORY64 a = &m->ReadMemory;
; 1404 :     STRING MessageHeader;
; 1405 :     PVOID Source = NULL;
; 1406 :     UINT32 Length = 0;
; 1407 :     UINT32 Actual = 0;
; 1408 :     UINT32 Isa = (UINT32)a->TargetBaseAddress;
; 1409 : 
; 1410 :     MessageHeader.Length = sizeof(*m);
; 1411 :     MessageHeader.Buffer = (PCHAR)m;
; 1412 : 
; 1413 :     ASSERT(AdditionalData->Length == 0);
; 1414 : 
; 1415 :     KDDBG2(" rctl base=%x, len=%x\n", Isa, a->TransferCount);
; 1416 : 
; 1417 :     if (m->Processor < (UINT32)KeNumberProcessors) {

  00006	0f b7 46 06	 movzx	 eax, WORD PTR [esi+6]
  0000a	53		 push	 ebx
  0000b	33 db		 xor	 ebx, ebx
  0000d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _KeNumberProcessors
  00013	57		 push	 edi
  00014	89 5d fc	 mov	 DWORD PTR _Actual$[ebp], ebx
  00017	66 c7 45 f4 38
	00		 mov	 WORD PTR _MessageHeader$[ebp], 56 ; 00000038H
  0001d	89 75 f8	 mov	 DWORD PTR _MessageHeader$[ebp+4], esi
  00020	73 5a		 jae	 SHORT $LN9@KdpReadCon

; 1418 :         PKPROCESSOR_STATE ProcessorState = &KdpProcessorState[m->Processor];
; 1419 : 
; 1420 :         switch (Isa) {

  00022	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00025	69 c0 20 03 00
	00		 imul	 eax, 800		; 00000320H
  0002b	05 00 00 00 00	 add	 eax, OFFSET _KdpProcessorState
  00030	83 e9 02	 sub	 ecx, 2
  00033	74 08		 je	 SHORT $LN6@KdpReadCon
  00035	81 e9 ca 02 00
	00		 sub	 ecx, 714		; 000002caH
  0003b	75 46		 jne	 SHORT $LN13@KdpReadCon
$LN6@KdpReadCon:

; 1421 :             case X86_DEBUG_CONTROL_SPACE_KSPECIAL:
; 1422 :             case DEBUG_CONTROL_SPACE_KSPECIAL:
; 1423 :                 KdpReadSpecialRegisters(&ProcessorState->SpecialRegisters, Context);

  0003d	8d b8 cc 02 00
	00		 lea	 edi, DWORD PTR [eax+716]
  00043	8b cf		 mov	 ecx, edi
  00045	e8 00 00 00 00	 call	 ?KdpReadSpecialRegisters@@YIXPAUStruct_Microsoft_Singularity_Kd_X86KSpecialRegisters@@PBUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ; KdpReadSpecialRegisters

; 1424 :                 Source = &ProcessorState->SpecialRegisters;
; 1425 :                 Length = sizeof(ProcessorState->SpecialRegisters);
; 1426 :                 break;
; 1427 :         }
; 1428 : 
; 1429 :         if (Source != NULL) {

  0004a	85 ff		 test	 edi, edi
  0004c	ba 54 00 00 00	 mov	 edx, 84			; 00000054H
  00051	74 30		 je	 SHORT $LN13@KdpReadCon

; 1430 :             if (Length > a->TransferCount) {

  00053	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00056	3b c2		 cmp	 eax, edx
  00058	73 02		 jae	 SHORT $LN4@KdpReadCon

; 1431 :                 Length = a->TransferCount;

  0005a	8b d0		 mov	 edx, eax
$LN4@KdpReadCon:

; 1432 :             }
; 1433 :             m->ReturnStatus = KdpCopyToPtr(AdditionalData->Buffer, Source, Length, &Actual);

  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _AdditionalData$[ebp]
  0005f	8d 45 fc	 lea	 eax, DWORD PTR _Actual$[ebp]
  00062	50		 push	 eax
  00063	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00066	6a 05		 push	 5
  00068	6a 00		 push	 0
  0006a	6a 00		 push	 0
  0006c	50		 push	 eax
  0006d	8b cf		 mov	 ecx, edi
  0006f	e8 00 00 00 00	 call	 ?KdpCopyMemoryChunks@@YIK_KPAXKKKPAK@Z ; KdpCopyMemoryChunks

; 1434 : 
; 1435 :             KDDBG2(" rctl: copy src=%p, len=%x, Actual=%x, return status=%x\n",
; 1436 :                   Source, Length, Actual, m->ReturnStatus);
; 1437 :         }
; 1438 :     }
; 1439 :     else {

  00074	8b 5d fc	 mov	 ebx, DWORD PTR _Actual$[ebp]
  00077	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0007a	eb 07		 jmp	 SHORT $LN13@KdpReadCon
$LN9@KdpReadCon:

; 1440 :         KDDBG("ReadControl: proc %d unknown control type (%d)\n", m->Processor, Isa);
; 1441 :         m->ReturnStatus = STATUS_UNSUCCESSFUL;

  0007c	c7 46 08 01 00
	00 c0		 mov	 DWORD PTR [esi+8], -1073741823 ; c0000001H
$LN13@KdpReadCon:

; 1442 :     }
; 1443 : 
; 1444 :     AdditionalData->Length = (UINT16)Actual;

  00083	8b 45 08	 mov	 eax, DWORD PTR _AdditionalData$[ebp]

; 1445 :     a->ActualBytesRead = Actual;
; 1446 :     KdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &MessageHeader, AdditionalData, &KdpContext);

  00086	68 00 00 00 00	 push	 OFFSET _KdpContext
  0008b	66 89 18	 mov	 WORD PTR [eax], bx
  0008e	50		 push	 eax
  0008f	8d 55 f4	 lea	 edx, DWORD PTR _MessageHeader$[ebp]
  00092	b9 02 00 00 00	 mov	 ecx, 2
  00097	89 5e 1c	 mov	 DWORD PTR [esi+28], ebx
  0009a	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket
  000a0	5f		 pop	 edi
  000a1	5b		 pop	 ebx

; 1447 : }

  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c2 04 00	 ret	 4
?KdpReadControlSpace@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ENDP ; KdpReadControlSpace
_TEXT	ENDS
EXTRN	?KdpWriteSpecialRegisters@@YIXPBUStruct_Microsoft_Singularity_Kd_X86KSpecialRegisters@@@Z:PROC ; KdpWriteSpecialRegisters
; Function compile flags: /Ogtp
;	COMDAT ?KdpWriteControlSpace@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z
_TEXT	SEGMENT
_MessageHeader$ = -12					; size = 8
_Actual$ = -4						; size = 4
_AdditionalData$ = 8					; size = 4
?KdpWriteControlSpace@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z PROC ; KdpWriteControlSpace, COMDAT
; _m$ = esi

; 1465 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1466 :     PDBGKD_WRITE_MEMORY64 a = &m->WriteMemory;
; 1467 :     STRING MessageHeader;
; 1468 :     PVOID Dest = NULL;      // Pointer to bytes available to target.
; 1469 :     UINT32 Length = 0;      // # of bytes available to target.
; 1470 :     UINT32 Isa = (UINT32)a->TargetBaseAddress;
; 1471 :     PKPROCESSOR_STATE ProcessorState = NULL;
; 1472 : 
; 1473 :     MessageHeader.Length = sizeof(*m);
; 1474 :     MessageHeader.Buffer = (PCHAR)m;
; 1475 : 
; 1476 :     KDDBG2(" wctl base=%x, len=%x\n", Isa, a->TransferCount);
; 1477 : 
; 1478 :     if (m->Processor < (UINT32)KeNumberProcessors) {

  00006	0f b7 46 06	 movzx	 eax, WORD PTR [esi+6]
  0000a	53		 push	 ebx
  0000b	33 c9		 xor	 ecx, ecx
  0000d	33 d2		 xor	 edx, edx
  0000f	33 db		 xor	 ebx, ebx
  00011	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _KeNumberProcessors
  00017	57		 push	 edi
  00018	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0001b	66 c7 45 f4 38
	00		 mov	 WORD PTR _MessageHeader$[ebp], 56 ; 00000038H
  00021	89 75 f8	 mov	 DWORD PTR _MessageHeader$[ebp+4], esi
  00024	73 26		 jae	 SHORT $LN10@KdpWriteCo

; 1479 :         ProcessorState = &KdpProcessorState[m->Processor];

  00026	69 c0 20 03 00
	00		 imul	 eax, 800		; 00000320H
  0002c	05 00 00 00 00	 add	 eax, OFFSET _KdpProcessorState
  00031	8b d8		 mov	 ebx, eax

; 1480 : 
; 1481 :         switch (Isa) {

  00033	8b c7		 mov	 eax, edi
  00035	83 e8 02	 sub	 eax, 2
  00038	74 07		 je	 SHORT $LN9@KdpWriteCo
  0003a	2d ca 02 00 00	 sub	 eax, 714		; 000002caH
  0003f	75 0b		 jne	 SHORT $LN10@KdpWriteCo
$LN9@KdpWriteCo:

; 1482 :             case X86_DEBUG_CONTROL_SPACE_KSPECIAL:
; 1483 :             case DEBUG_CONTROL_SPACE_KSPECIAL:
; 1484 :                 Dest = &ProcessorState->SpecialRegisters;

  00041	8d 8b cc 02 00
	00		 lea	 ecx, DWORD PTR [ebx+716]

; 1485 :                 Length = sizeof(ProcessorState->SpecialRegisters);

  00047	ba 54 00 00 00	 mov	 edx, 84			; 00000054H
$LN10@KdpWriteCo:

; 1486 :                 break;
; 1487 :         }
; 1488 :     }
; 1489 : 
; 1490 :     UINT32 Actual = 0;
; 1491 :     if (Dest != NULL) {

  0004c	85 c9		 test	 ecx, ecx
  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Actual$[ebp], 0
  00055	74 3d		 je	 SHORT $LN8@KdpWriteCo

; 1492 :         if (Length > a->TransferCount) {

  00057	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0005a	3b d0		 cmp	 edx, eax
  0005c	76 02		 jbe	 SHORT $LN7@KdpWriteCo

; 1493 :             Length = a->TransferCount;

  0005e	8b d0		 mov	 edx, eax
$LN7@KdpWriteCo:

; 1494 :         }
; 1495 : 
; 1496 :         m->ReturnStatus = KdpCopyToPtr(Dest, AdditionalData->Buffer, Length, &Actual);

  00060	8d 45 fc	 lea	 eax, DWORD PTR _Actual$[ebp]
  00063	50		 push	 eax
  00064	6a 05		 push	 5
  00066	6a 00		 push	 0
  00068	6a 00		 push	 0
  0006a	51		 push	 ecx
  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _AdditionalData$[ebp]
  0006e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00071	e8 00 00 00 00	 call	 ?KdpCopyMemoryChunks@@YIK_KPAXKKKPAK@Z ; KdpCopyMemoryChunks
  00076	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1497 : 
; 1498 :         switch (Isa) {

  00079	8b c7		 mov	 eax, edi
  0007b	83 e8 02	 sub	 eax, 2
  0007e	74 07		 je	 SHORT $LN4@KdpWriteCo
  00080	2d ca 02 00 00	 sub	 eax, 714		; 000002caH
  00085	75 14		 jne	 SHORT $LN16@KdpWriteCo
$LN4@KdpWriteCo:

; 1499 :             case X86_DEBUG_CONTROL_SPACE_KSPECIAL:
; 1500 :             case DEBUG_CONTROL_SPACE_KSPECIAL:
; 1501 :                 KdpWriteSpecialRegisters(&ProcessorState->SpecialRegisters);

  00087	8d 8b cc 02 00
	00		 lea	 ecx, DWORD PTR [ebx+716]
  0008d	e8 00 00 00 00	 call	 ?KdpWriteSpecialRegisters@@YIXPBUStruct_Microsoft_Singularity_Kd_X86KSpecialRegisters@@@Z ; KdpWriteSpecialRegisters

; 1502 :                 break;
; 1503 :         }
; 1504 : 
; 1505 :         KDDBG2(" wctl: copy dst=%p, len=%x, Actual=%x, return status=%x\n",
; 1506 :               Dest, Length, Actual, m->ReturnStatus);
; 1507 :     }
; 1508 :     else {

  00092	eb 07		 jmp	 SHORT $LN16@KdpWriteCo
$LN8@KdpWriteCo:

; 1509 :         KDDBG("WriteControl: proc %d unknown control type (%d)\n",
; 1510 :               m->Processor, Isa);
; 1511 :         m->ReturnStatus = STATUS_UNSUCCESSFUL;

  00094	c7 46 08 01 00
	00 c0		 mov	 DWORD PTR [esi+8], -1073741823 ; c0000001H
$LN16@KdpWriteCo:

; 1512 :     }
; 1513 : 
; 1514 :     a->ActualBytesWritten = Actual;

  0009b	8b 55 fc	 mov	 edx, DWORD PTR _Actual$[ebp]

; 1515 :     KdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &MessageHeader, AdditionalData, &KdpContext);

  0009e	8b 45 08	 mov	 eax, DWORD PTR _AdditionalData$[ebp]
  000a1	68 00 00 00 00	 push	 OFFSET _KdpContext
  000a6	89 56 1c	 mov	 DWORD PTR [esi+28], edx
  000a9	50		 push	 eax
  000aa	8d 55 f4	 lea	 edx, DWORD PTR _MessageHeader$[ebp]
  000ad	b9 02 00 00 00	 mov	 ecx, 2
  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket
  000b8	5f		 pop	 edi
  000b9	5b		 pop	 ebx

; 1516 : }

  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c2 04 00	 ret	 4
?KdpWriteControlSpace@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ENDP ; KdpWriteControlSpace
_TEXT	ENDS
EXTRN	?KdpReadWriteIoSpace@@YIHHHGI@Z:PROC		; KdpReadWriteIoSpace
; Function compile flags: /Ogtp
;	COMDAT ?KdpReadIoSpace@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z
_TEXT	SEGMENT
_MessageHeader$ = -8					; size = 8
?KdpReadIoSpace@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z PROC ; KdpReadIoSpace, COMDAT
; _m$ = esi

; 1534 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1535 :     PDBGKD_READ_WRITE_IO64 a = &m->ReadWriteIo;
; 1536 :     STRING MessageHeader;
; 1537 :     UINT16 Target = (UINT16)a->IoAddress;

  00003	0f b7 4e 10	 movzx	 ecx, WORD PTR [esi+16]

; 1538 : 
; 1539 :     ASSERT(AdditionalData->Length == 0);
; 1540 : 
; 1541 :     KDDBG(" read io base=%x, len=%x\n", Target, a->DataSize, AdditionalData->Buffer);
; 1542 : 
; 1543 :     //
; 1544 :     // Zero-fill the entire value so that shorter reads
; 1545 :     // do not leave unset bytes.
; 1546 :     //
; 1547 :     a->DataValue = 0;

  00007	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 1548 : 
; 1549 :     m->ReturnStatus = STATUS_SUCCESS;

  0000e	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1550 : 
; 1551 :     switch (a->DataSize) {

  00015	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00018	83 ec 08	 sub	 esp, 8
  0001b	83 e8 01	 sub	 eax, 1
  0001e	74 27		 je	 SHORT $LN5@KdpReadIoS
  00020	83 e8 01	 sub	 eax, 1
  00023	74 18		 je	 SHORT $LN4@KdpReadIoS
  00025	83 e8 02	 sub	 eax, 2
  00028	74 09		 je	 SHORT $LN3@KdpReadIoS

; 1563 : 
; 1564 :     default:
; 1565 :         KDDBG("ReadIoSpace: Unrecognized size (%d)\n", a->DataSize);
; 1566 :         m->ReturnStatus = STATUS_UNSUCCESSFUL;

  0002a	c7 46 08 01 00
	00 c0		 mov	 DWORD PTR [esi+8], -1073741823 ; c0000001H

; 1567 :         break;

  00031	eb 26		 jmp	 SHORT $LN6@KdpReadIoS
$LN3@KdpReadIoS:

; 1559 : 
; 1560 :     case 4:
; 1561 :         a->DataValue = KdpReadWriteIoSpace(a->DataSize, 0, Target, 0);

  00033	6a 00		 push	 0
  00035	51		 push	 ecx
  00036	b9 04 00 00 00	 mov	 ecx, 4

; 1562 :         break;

  0003b	eb 12		 jmp	 SHORT $LN11@KdpReadIoS
$LN4@KdpReadIoS:

; 1554 :         break;
; 1555 : 
; 1556 :     case 2:
; 1557 :         a->DataValue = KdpReadWriteIoSpace(a->DataSize, 0, Target, 0);

  0003d	6a 00		 push	 0
  0003f	51		 push	 ecx
  00040	b9 02 00 00 00	 mov	 ecx, 2

; 1558 :         break;

  00045	eb 08		 jmp	 SHORT $LN11@KdpReadIoS
$LN5@KdpReadIoS:

; 1552 :     case 1:
; 1553 :         a->DataValue = KdpReadWriteIoSpace(a->DataSize, 0, Target, 0);

  00047	6a 00		 push	 0
  00049	51		 push	 ecx
  0004a	b9 01 00 00 00	 mov	 ecx, 1
$LN11@KdpReadIoS:
  0004f	33 d2		 xor	 edx, edx
  00051	e8 00 00 00 00	 call	 ?KdpReadWriteIoSpace@@YIHHHGI@Z ; KdpReadWriteIoSpace
  00056	89 46 1c	 mov	 DWORD PTR [esi+28], eax
$LN6@KdpReadIoS:

; 1568 :     }
; 1569 : 
; 1570 :     //
; 1571 :     // Send the response
; 1572 :     //
; 1573 :     MessageHeader.Length = sizeof(DBGKD_MANIPULATE_STATE64);
; 1574 :     MessageHeader.Buffer = (PCHAR)m;
; 1575 : 
; 1576 :     KdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &MessageHeader, NULL, &KdpContext);

  00059	68 00 00 00 00	 push	 OFFSET _KdpContext
  0005e	6a 00		 push	 0
  00060	8d 55 f8	 lea	 edx, DWORD PTR _MessageHeader$[ebp]
  00063	b9 02 00 00 00	 mov	 ecx, 2
  00068	66 c7 45 f8 38
	00		 mov	 WORD PTR _MessageHeader$[ebp], 56 ; 00000038H
  0006e	89 75 fc	 mov	 DWORD PTR _MessageHeader$[ebp+4], esi
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket

; 1577 : }

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
?KdpReadIoSpace@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ENDP ; KdpReadIoSpace
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?KdpWriteIoSpace@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z
_TEXT	SEGMENT
_MessageHeader$ = -8					; size = 8
?KdpWriteIoSpace@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z PROC ; KdpWriteIoSpace, COMDAT
; _m$ = esi

; 1595 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1596 :     PDBGKD_READ_WRITE_IO64 a = &m->ReadWriteIo;
; 1597 :     STRING MessageHeader;
; 1598 :     UINT16 Target = (UINT16)a->IoAddress;

  00003	0f b7 4e 10	 movzx	 ecx, WORD PTR [esi+16]

; 1599 : 
; 1600 :     ASSERT(AdditionalData->Length == 0);
; 1601 : 
; 1602 :     KDDBG(" write io base=%x, len=%x, value=%x\n", Target, a->DataSize, a->DataValue);
; 1603 : 
; 1604 :     m->ReturnStatus = STATUS_SUCCESS;

  00007	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1605 : 
; 1606 :     switch (a->DataSize) {

  0000e	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00011	83 ec 08	 sub	 esp, 8
  00014	83 e8 01	 sub	 eax, 1
  00017	74 32		 je	 SHORT $LN5@KdpWriteIo
  00019	83 e8 01	 sub	 eax, 1
  0001c	74 1d		 je	 SHORT $LN4@KdpWriteIo
  0001e	83 e8 02	 sub	 eax, 2
  00021	74 09		 je	 SHORT $LN3@KdpWriteIo

; 1618 : 
; 1619 :     default:
; 1620 :         KDDBG("WriteIoSpace: Unrecognized size (%d)\n", a->DataSize);
; 1621 :         m->ReturnStatus = STATUS_UNSUCCESSFUL;

  00023	c7 46 08 01 00
	00 c0		 mov	 DWORD PTR [esi+8], -1073741823 ; c0000001H

; 1622 :         break;

  0002a	eb 31		 jmp	 SHORT $LN6@KdpWriteIo
$LN3@KdpWriteIo:

; 1614 : 
; 1615 :     case 4:
; 1616 :         KdpReadWriteIoSpace(a->DataSize, 1, Target, a->DataValue);

  0002c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0002f	50		 push	 eax
  00030	ba 01 00 00 00	 mov	 edx, 1
  00035	51		 push	 ecx
  00036	8d 4a 03	 lea	 ecx, DWORD PTR [edx+3]

; 1617 :         break;

  00039	eb 1d		 jmp	 SHORT $LN11@KdpWriteIo
$LN4@KdpWriteIo:

; 1609 :         break;
; 1610 : 
; 1611 :     case 2:
; 1612 :         KdpReadWriteIoSpace(a->DataSize, 1, Target, a->DataValue & 0x0000FFFF);

  0003b	0f b7 56 1c	 movzx	 edx, WORD PTR [esi+28]
  0003f	52		 push	 edx
  00040	ba 01 00 00 00	 mov	 edx, 1
  00045	51		 push	 ecx
  00046	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]

; 1613 :         break;

  00049	eb 0d		 jmp	 SHORT $LN11@KdpWriteIo
$LN5@KdpWriteIo:

; 1607 :     case 1:
; 1608 :         KdpReadWriteIoSpace(a->DataSize, 1, Target, a->DataValue & 0x000000FF);

  0004b	0f b6 46 1c	 movzx	 eax, BYTE PTR [esi+28]
  0004f	50		 push	 eax
  00050	ba 01 00 00 00	 mov	 edx, 1
  00055	51		 push	 ecx
  00056	8b ca		 mov	 ecx, edx
$LN11@KdpWriteIo:
  00058	e8 00 00 00 00	 call	 ?KdpReadWriteIoSpace@@YIHHHGI@Z ; KdpReadWriteIoSpace
$LN6@KdpWriteIo:

; 1623 :     }
; 1624 : 
; 1625 :     // Send the reply
; 1626 :     MessageHeader.Length = sizeof(DBGKD_MANIPULATE_STATE64);
; 1627 :     MessageHeader.Buffer = (PCHAR)m;
; 1628 : 
; 1629 :     KdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &MessageHeader, NULL, &KdpContext);

  0005d	68 00 00 00 00	 push	 OFFSET _KdpContext
  00062	6a 00		 push	 0
  00064	8d 55 f8	 lea	 edx, DWORD PTR _MessageHeader$[ebp]
  00067	b9 02 00 00 00	 mov	 ecx, 2
  0006c	66 c7 45 f8 38
	00		 mov	 WORD PTR _MessageHeader$[ebp], 56 ; 00000038H
  00072	89 75 fc	 mov	 DWORD PTR _MessageHeader$[ebp+4], esi
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket

; 1630 : }

  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
?KdpWriteIoSpace@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ENDP ; KdpWriteIoSpace
_TEXT	ENDS
EXTRN	?KdpFromKdContext@@YIXPBUStruct_Microsoft_Singularity_Kd_X86Context@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z:PROC ; KdpFromKdContext
_BSS	SEGMENT
_KdpContextSent DD 01H DUP (?)
; Function compile flags: /Ogtp
_BSS	ENDS
;	COMDAT ?KdpSetContext@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z
_TEXT	SEGMENT
_MessageHeader$ = -8					; size = 8
_AdditionalData$ = 8					; size = 4
?KdpSetContext@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z PROC ; KdpSetContext, COMDAT
; _m$ = eax
; _Context$ = edx

; 1648 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1649 :     STRING MessageHeader;
; 1650 : 
; 1651 :     MessageHeader.Length = sizeof(*m);
; 1652 :     MessageHeader.Buffer = (PCHAR)m;
; 1653 : 
; 1654 :     ASSERT(AdditionalData->Length == sizeof(CONTEXT));
; 1655 : 
; 1656 :     if ((m->Processor >= (UINT16)KeNumberProcessors) || (KdpContextSent == FALSE)) {

  00006	66 8b 48 06	 mov	 cx, WORD PTR [eax+6]
  0000a	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR _KeNumberProcessors
  00011	66 c7 45 f8 38
	00		 mov	 WORD PTR _MessageHeader$[ebp], 56 ; 00000038H
  00017	89 45 fc	 mov	 DWORD PTR _MessageHeader$[ebp+4], eax
  0001a	73 1d		 jae	 SHORT $LN2@KdpSetCont
  0001c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _KdpContextSent, 0
  00023	74 14		 je	 SHORT $LN2@KdpSetCont

; 1658 :     }
; 1659 :     else {
; 1660 :         m->ReturnStatus = STATUS_SUCCESS;

  00025	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1661 :         KdpFromKdContext((CONTEXT*)AdditionalData->Buffer, Context);

  0002c	8b 45 08	 mov	 eax, DWORD PTR _AdditionalData$[ebp]
  0002f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00032	e8 00 00 00 00	 call	 ?KdpFromKdContext@@YIXPBUStruct_Microsoft_Singularity_Kd_X86Context@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ; KdpFromKdContext
  00037	eb 07		 jmp	 SHORT $LN1@KdpSetCont
$LN2@KdpSetCont:

; 1657 :         m->ReturnStatus = STATUS_UNSUCCESSFUL;

  00039	c7 40 08 01 00
	00 c0		 mov	 DWORD PTR [eax+8], -1073741823 ; c0000001H
$LN1@KdpSetCont:

; 1662 :     }
; 1663 : 
; 1664 :     KdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
; 1665 :                  &MessageHeader,
; 1666 :                  NULL,
; 1667 :                  &KdpContext);

  00040	68 00 00 00 00	 push	 OFFSET _KdpContext
  00045	6a 00		 push	 0
  00047	8d 55 f8	 lea	 edx, DWORD PTR _MessageHeader$[ebp]
  0004a	b9 02 00 00 00	 mov	 ecx, 2
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket

; 1668 : }

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
?KdpSetContext@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ENDP ; KdpSetContext
_TEXT	ENDS
EXTRN	?KdpToKdContext@@YIXPBUStruct_Microsoft_Singularity_Isal_SpillContext@@PAUStruct_Microsoft_Singularity_Kd_X86Context@@@Z:PROC ; KdpToKdContext
; Function compile flags: /Ogtp
;	COMDAT ?KdpGetContext@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z
_TEXT	SEGMENT
_MessageHeader$ = -8					; size = 8
_Context$ = 8						; size = 4
?KdpGetContext@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z PROC ; KdpGetContext, COMDAT
; _m$ = eax
; _AdditionalData$ = esi

; 1686 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1687 :     STRING MessageHeader;
; 1688 : 
; 1689 :     MessageHeader.Length = sizeof(*m);
; 1690 :     MessageHeader.Buffer = (PCHAR)m;
; 1691 : 
; 1692 :     ASSERT(AdditionalData->Length == 0);
; 1693 : 
; 1694 :     if (m->Processor >= (UINT16)KeNumberProcessors) {

  00006	66 8b 48 06	 mov	 cx, WORD PTR [eax+6]
  0000a	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR _KeNumberProcessors
  00011	66 c7 45 f8 38
	00		 mov	 WORD PTR _MessageHeader$[ebp], 56 ; 00000038H
  00017	89 45 fc	 mov	 DWORD PTR _MessageHeader$[ebp+4], eax
  0001a	72 09		 jb	 SHORT $LN2@KdpGetCont

; 1695 :         m->ReturnStatus = STATUS_UNSUCCESSFUL;

  0001c	c7 40 08 01 00
	00 c0		 mov	 DWORD PTR [eax+8], -1073741823 ; c0000001H

; 1696 :     }
; 1697 :     else {

  00023	eb 34		 jmp	 SHORT $LN1@KdpGetCont
$LN2@KdpGetCont:

; 1698 :         m->ReturnStatus = STATUS_SUCCESS;

  00025	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1699 :         AdditionalData->Length = sizeof(CONTEXT);
; 1700 : 
; 1701 :         RtlZeroMemory(AdditionalData->Buffer, AdditionalData->Length);

  0002c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0002f	68 cc 02 00 00	 push	 716			; 000002ccH
  00034	6a 00		 push	 0
  00036	52		 push	 edx
  00037	66 c7 06 cc 02	 mov	 WORD PTR [esi], 716	; 000002ccH
  0003c	e8 00 00 00 00	 call	 _memset

; 1702 :         KdpToKdContext(Context, (CONTEXT*)AdditionalData->Buffer);

  00041	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00044	8b 4d 08	 mov	 ecx, DWORD PTR _Context$[ebp]
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004a	e8 00 00 00 00	 call	 ?KdpToKdContext@@YIXPBUStruct_Microsoft_Singularity_Isal_SpillContext@@PAUStruct_Microsoft_Singularity_Kd_X86Context@@@Z ; KdpToKdContext

; 1703 :         KdpContextSent = TRUE;

  0004f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _KdpContextSent, 1
$LN1@KdpGetCont:

; 1704 :     }
; 1705 : 
; 1706 :     KdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
; 1707 :                  &MessageHeader,
; 1708 :                  AdditionalData,
; 1709 :                  &KdpContext);

  00059	68 00 00 00 00	 push	 OFFSET _KdpContext
  0005e	56		 push	 esi
  0005f	8d 55 f8	 lea	 edx, DWORD PTR _MessageHeader$[ebp]
  00062	b9 02 00 00 00	 mov	 ecx, 2
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket

; 1710 : }

  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
?KdpGetContext@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ENDP ; KdpGetContext
_TEXT	ENDS
PUBLIC	?KdpAddBreakpoint@@YIKPAX@Z			; KdpAddBreakpoint
; Function compile flags: /Ogtp
;	COMDAT ?KdpAddBreakpoint@@YIKPAX@Z
_TEXT	SEGMENT
_Address$ = -20						; size = 4
$T12957 = -16						; size = 4
$T12933 = -16						; size = 4
_Index$ = -12						; size = 4
_Length$12937 = -8					; size = 4
_Length$12913 = -8					; size = 4
_Content$ = -1						; size = 1
?KdpAddBreakpoint@@YIKPAX@Z PROC			; KdpAddBreakpoint, COMDAT
; _Address$ = ecx

; 1731 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _Address$[ebp], ecx

; 1732 :     UINT32 Index;
; 1733 :     KDP_BREAKPOINT_TYPE Content;
; 1734 :     BOOL Accessible;
; 1735 : 
; 1736 :     KDDBG2("KdpAddBreakpoint(%p)\n", Address);
; 1737 : 
; 1738 :     for (Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index++) {

  00009	33 d2		 xor	 edx, edx
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET ?KdpBreakpointTable@@3PAU_BREAKPOINT_ENTRY@@A ; KdpBreakpointTable
$LL11@KdpAddBrea:

; 1739 :         if (KdpBreakpointTable[Index].Flags == 0) {

  00010	83 38 00	 cmp	 DWORD PTR [eax], 0
  00013	74 0b		 je	 SHORT $LN87@KdpAddBrea
  00015	83 c2 01	 add	 edx, 1
  00018	83 c0 10	 add	 eax, 16			; 00000010H
  0001b	83 fa 20	 cmp	 edx, 32			; 00000020H
  0001e	72 f0		 jb	 SHORT $LL11@KdpAddBrea
$LN87@KdpAddBrea:

; 1740 :             break;
; 1741 :         }
; 1742 :     }
; 1743 :     if (Index == BREAKPOINT_TABLE_SIZE) {

  00020	83 fa 20	 cmp	 edx, 32			; 00000020H
  00023	89 55 f4	 mov	 DWORD PTR _Index$[ebp], edx
  00026	75 06		 jne	 SHORT $LN7@KdpAddBrea

; 1744 :         KDDBG("KD: ran out of breakpoints!\n");
; 1745 :         return 0;

  00028	33 c0		 xor	 eax, eax

; 1771 : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
$LN7@KdpAddBrea:
  0002e	53		 push	 ebx

; 1746 :     }
; 1747 : 
; 1748 :     Accessible = NT_SUCCESS(KdpCopyFromPtr(&Content,
; 1749 :                                            Address,
; 1750 :                                            sizeof(KDP_BREAKPOINT_TYPE),
; 1751 :                                            NULL));

  0002f	8d 45 ff	 lea	 eax, DWORD PTR _Content$[ebp]
  00032	56		 push	 esi
  00033	89 45 f0	 mov	 DWORD PTR $T12933[ebp], eax
  00036	b8 01 00 00 00	 mov	 eax, 1
  0003b	57		 push	 edi
  0003c	33 db		 xor	 ebx, ebx
  0003e	8b f9		 mov	 edi, ecx
  00040	89 45 f8	 mov	 DWORD PTR _Length$12913[ebp], eax
  00043	8b f0		 mov	 esi, eax
  00045	eb 03		 jmp	 SHORT $LN29@KdpAddBrea
$LL79@KdpAddBrea:
  00047	8b 45 f8	 mov	 eax, DWORD PTR _Length$12913[ebp]
$LN29@KdpAddBrea:
  0004a	83 fe 04	 cmp	 esi, 4
  0004d	73 24		 jae	 SHORT $LN56@KdpAddBrea
  0004f	eb 03		 jmp	 SHORT $LN27@KdpAddBrea
$LL85@KdpAddBrea:
  00051	8b 45 f8	 mov	 eax, DWORD PTR _Length$12913[ebp]
$LN27@KdpAddBrea:
  00054	8d 14 36	 lea	 edx, DWORD PTR [esi+esi]
  00057	3b d0		 cmp	 edx, eax
  00059	77 18		 ja	 SHORT $LN56@KdpAddBrea
  0005b	33 c9		 xor	 ecx, ecx
  0005d	8d 44 36 ff	 lea	 eax, DWORD PTR [esi+esi-1]
  00061	23 c7		 and	 eax, edi
  00063	23 cb		 and	 ecx, ebx
  00065	0b c1		 or	 eax, ecx
  00067	75 07		 jne	 SHORT $LN86@KdpAddBrea
  00069	8b f2		 mov	 esi, edx
  0006b	83 fe 04	 cmp	 esi, 4
  0006e	72 e1		 jb	 SHORT $LL85@KdpAddBrea
$LN86@KdpAddBrea:
  00070	8b 45 f8	 mov	 eax, DWORD PTR _Length$12913[ebp]
$LN56@KdpAddBrea:
  00073	3b f0		 cmp	 esi, eax
  00075	76 06		 jbe	 SHORT $LN24@KdpAddBrea
$LL25@KdpAddBrea:
  00077	d1 ee		 shr	 esi, 1
  00079	3b f0		 cmp	 esi, eax
  0007b	77 fa		 ja	 SHORT $LL25@KdpAddBrea
$LN24@KdpAddBrea:
  0007d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?c_thePlatform@Class_Microsoft_Singularity_Hal_Platform@@2PAU1@A ; Class_Microsoft_Singularity_Hal_Platform::c_thePlatform
  00083	8b 49 34	 mov	 ecx, DWORD PTR [ecx+52]
  00086	33 c0		 xor	 eax, eax
  00088	3b d8		 cmp	 ebx, eax
  0008a	72 34		 jb	 SHORT $LN80@KdpAddBrea
  0008c	77 04		 ja	 SHORT $LN76@KdpAddBrea
  0008e	3b f9		 cmp	 edi, ecx
  00090	72 2e		 jb	 SHORT $LN80@KdpAddBrea
$LN76@KdpAddBrea:
  00092	8b d7		 mov	 edx, edi
  00094	0b d3		 or	 edx, ebx
  00096	74 28		 je	 SHORT $LN80@KdpAddBrea
  00098	53		 push	 ebx
  00099	57		 push	 edi
  0009a	8b ce		 mov	 ecx, esi
  0009c	e8 00 00 00 00	 call	 ?ProbeMemoryRange@@YIH_KK@Z ; ProbeMemoryRange
  000a1	85 c0		 test	 eax, eax
  000a3	74 1b		 je	 SHORT $LN80@KdpAddBrea
  000a5	8b 45 f0	 mov	 eax, DWORD PTR $T12933[ebp]
  000a8	56		 push	 esi
  000a9	57		 push	 edi
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 _memcpy
  000b0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b3	03 fe		 add	 edi, esi
  000b5	83 d3 00	 adc	 ebx, 0
  000b8	01 75 f0	 add	 DWORD PTR $T12933[ebp], esi
  000bb	29 75 f8	 sub	 DWORD PTR _Length$12913[ebp], esi
  000be	75 87		 jne	 SHORT $LL79@KdpAddBrea
$LN80@KdpAddBrea:

; 1752 :     KDDBG("KD: memory %saccessible\n", Accessible ? "" : "in");
; 1753 : 
; 1754 :     if (Accessible) {
; 1755 :         KdpBreakpointTable[Index].Address = Address;

  000c0	8b 45 f4	 mov	 eax, DWORD PTR _Index$[ebp]
  000c3	8b 7d ec	 mov	 edi, DWORD PTR _Address$[ebp]

; 1756 :         KdpBreakpointTable[Index].Content = Content;

  000c6	8a 4d ff	 mov	 cl, BYTE PTR _Content$[ebp]
  000c9	c1 e0 04	 shl	 eax, 4

; 1757 :         KdpBreakpointTable[Index].Flags = KD_BREAKPOINT_IN_USE;

  000cc	be 01 00 00 00	 mov	 esi, 1
  000d1	89 b8 08 00 00
	00		 mov	 DWORD PTR ?KdpBreakpointTable@@3PAU_BREAKPOINT_ENTRY@@A[eax+8], edi
  000d7	88 88 0c 00 00
	00		 mov	 BYTE PTR ?KdpBreakpointTable@@3PAU_BREAKPOINT_ENTRY@@A[eax+12], cl
  000dd	89 b0 00 00 00
	00		 mov	 DWORD PTR ?KdpBreakpointTable@@3PAU_BREAKPOINT_ENTRY@@A[eax], esi

; 1758 : 
; 1759 :         if (!NT_SUCCESS(KdpCopyToPtr(Address,
; 1760 :                                      &KdpBreakpointInstruction,
; 1761 :                                      sizeof(KDP_BREAKPOINT_TYPE),
; 1762 :                                      NULL))) {

  000e3	8b c6		 mov	 eax, esi
  000e5	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T12957[ebp], OFFSET ?KdpBreakpointInstruction@@3EA ; KdpBreakpointInstruction
  000ec	33 db		 xor	 ebx, ebx
  000ee	89 45 f8	 mov	 DWORD PTR _Length$12937[ebp], eax
  000f1	eb 03		 jmp	 SHORT $LN47@KdpAddBrea
$LL78@KdpAddBrea:
  000f3	8b 45 f8	 mov	 eax, DWORD PTR _Length$12937[ebp]
$LN47@KdpAddBrea:
  000f6	83 fe 04	 cmp	 esi, 4
  000f9	73 27		 jae	 SHORT $LN59@KdpAddBrea
  000fb	eb 06		 jmp	 SHORT $LN45@KdpAddBrea
  000fd	8d 49 00	 npad	 3
$LL82@KdpAddBrea:
  00100	8b 45 f8	 mov	 eax, DWORD PTR _Length$12937[ebp]
$LN45@KdpAddBrea:
  00103	8d 14 36	 lea	 edx, DWORD PTR [esi+esi]
  00106	3b d0		 cmp	 edx, eax
  00108	77 18		 ja	 SHORT $LN59@KdpAddBrea
  0010a	33 c9		 xor	 ecx, ecx
  0010c	8d 44 36 ff	 lea	 eax, DWORD PTR [esi+esi-1]
  00110	23 c7		 and	 eax, edi
  00112	23 cb		 and	 ecx, ebx
  00114	0b c1		 or	 eax, ecx
  00116	75 07		 jne	 SHORT $LN84@KdpAddBrea
  00118	8b f2		 mov	 esi, edx
  0011a	83 fe 04	 cmp	 esi, 4
  0011d	72 e1		 jb	 SHORT $LL82@KdpAddBrea
$LN84@KdpAddBrea:
  0011f	8b 45 f8	 mov	 eax, DWORD PTR _Length$12937[ebp]
$LN59@KdpAddBrea:
  00122	3b f0		 cmp	 esi, eax
  00124	76 06		 jbe	 SHORT $LN42@KdpAddBrea
$LL43@KdpAddBrea:
  00126	d1 ee		 shr	 esi, 1
  00128	3b f0		 cmp	 esi, eax
  0012a	77 fa		 ja	 SHORT $LL43@KdpAddBrea
$LN42@KdpAddBrea:
  0012c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?c_thePlatform@Class_Microsoft_Singularity_Hal_Platform@@2PAU1@A ; Class_Microsoft_Singularity_Hal_Platform::c_thePlatform
  00132	8b 52 34	 mov	 edx, DWORD PTR [edx+52]
  00135	33 c9		 xor	 ecx, ecx
  00137	3b d9		 cmp	 ebx, ecx
  00139	72 37		 jb	 SHORT $LN64@KdpAddBrea
  0013b	77 04		 ja	 SHORT $LN77@KdpAddBrea
  0013d	3b fa		 cmp	 edi, edx
  0013f	72 31		 jb	 SHORT $LN64@KdpAddBrea
$LN77@KdpAddBrea:
  00141	8b cf		 mov	 ecx, edi
  00143	0b cb		 or	 ecx, ebx
  00145	74 2b		 je	 SHORT $LN64@KdpAddBrea
  00147	53		 push	 ebx
  00148	57		 push	 edi
  00149	8b ce		 mov	 ecx, esi
  0014b	e8 00 00 00 00	 call	 ?ProbeMemoryRange@@YIH_KK@Z ; ProbeMemoryRange
  00150	85 c0		 test	 eax, eax
  00152	74 1b		 je	 SHORT $LN81@KdpAddBrea
  00154	8b 55 f0	 mov	 edx, DWORD PTR $T12957[ebp]
  00157	56		 push	 esi
  00158	52		 push	 edx
  00159	57		 push	 edi
  0015a	e8 00 00 00 00	 call	 _memcpy
  0015f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00162	03 fe		 add	 edi, esi
  00164	83 d3 00	 adc	 ebx, 0
  00167	01 75 f0	 add	 DWORD PTR $T12957[ebp], esi
  0016a	29 75 f8	 sub	 DWORD PTR _Length$12937[ebp], esi
  0016d	75 84		 jne	 SHORT $LL78@KdpAddBrea
$LN81@KdpAddBrea:
  0016f	8b 45 f8	 mov	 eax, DWORD PTR _Length$12937[ebp]
$LN64@KdpAddBrea:
  00172	83 f8 01	 cmp	 eax, 1
  00175	5f		 pop	 edi
  00176	5e		 pop	 esi
  00177	5b		 pop	 ebx
  00178	73 05		 jae	 SHORT $LN35@KdpAddBrea
  0017a	e8 00 00 00 00	 call	 ?KdpFlushInstCache@@YIXXZ ; KdpFlushInstCache
$LN35@KdpAddBrea:

; 1763 :             KDDBG("KD: Unable to write BP!\n");
; 1764 :         }
; 1765 :     }
; 1766 :     else {
; 1767 :         return 0;
; 1768 :     }
; 1769 : 
; 1770 :     return Index+1;

  0017f	8b 45 f4	 mov	 eax, DWORD PTR _Index$[ebp]
  00182	83 c0 01	 add	 eax, 1

; 1771 : }

  00185	8b e5		 mov	 esp, ebp
  00187	5d		 pop	 ebp
  00188	c3		 ret	 0
?KdpAddBreakpoint@@YIKPAX@Z ENDP			; KdpAddBreakpoint
_TEXT	ENDS
PUBLIC	?KdpDeleteBreakpoint@@YIHK@Z			; KdpDeleteBreakpoint
; Function compile flags: /Ogtp
;	COMDAT ?KdpDeleteBreakpoint@@YIHK@Z
_TEXT	SEGMENT
tv195 = -12						; size = 4
$T13018 = -8						; size = 4
_Length$12998 = -4					; size = 4
?KdpDeleteBreakpoint@@YIHK@Z PROC			; KdpDeleteBreakpoint, COMDAT
; _Handle$ = ecx

; 1777 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1778 :     UINT32 Index = Handle - 1;
; 1779 :     KDDBG2("KD: Delete Breakpoint %d\n", Handle);
; 1780 : 
; 1781 :     if ((Handle == 0) || (Handle > BREAKPOINT_TABLE_SIZE)) {

  00006	85 c9		 test	 ecx, ecx
  00008	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  0000b	0f 84 d4 00 00
	00		 je	 $LN6@KdpDeleteB
  00011	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00014	0f 87 cb 00 00
	00		 ja	 $LN6@KdpDeleteB
  0001a	53		 push	 ebx

; 1784 :     }
; 1785 : 
; 1786 :     //
; 1787 :     // Replace the instruction contents.
; 1788 :     //
; 1789 :     if (!NT_SUCCESS(KdpCopyToPtr(KdpBreakpointTable[Index].Address,
; 1790 :                                  &KdpBreakpointTable[Index].Content,
; 1791 :                                  sizeof(KDP_BREAKPOINT_TYPE),
; 1792 :                                  NULL))) {

  0001b	c1 e0 04	 shl	 eax, 4
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	8b b8 08 00 00
	00		 mov	 edi, DWORD PTR ?KdpBreakpointTable@@3PAU_BREAKPOINT_ENTRY@@A[eax+8]
  00026	8d 88 0c 00 00
	00		 lea	 ecx, DWORD PTR ?KdpBreakpointTable@@3PAU_BREAKPOINT_ENTRY@@A[eax+12]
  0002c	89 45 f4	 mov	 DWORD PTR tv195[ebp], eax
  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	89 4d f8	 mov	 DWORD PTR $T13018[ebp], ecx
  00037	33 db		 xor	 ebx, ebx
  00039	89 45 fc	 mov	 DWORD PTR _Length$12998[ebp], eax
  0003c	8b f0		 mov	 esi, eax
  0003e	eb 03		 jmp	 SHORT $LN23@KdpDeleteB
$LL40@KdpDeleteB:
  00040	8b 45 fc	 mov	 eax, DWORD PTR _Length$12998[ebp]
$LN23@KdpDeleteB:
  00043	83 fe 04	 cmp	 esi, 4
  00046	73 2a		 jae	 SHORT $LN31@KdpDeleteB
  00048	eb 09		 jmp	 SHORT $LN21@KdpDeleteB
  0004a	8d 9b 00 00 00
	00		 npad	 6
$LL42@KdpDeleteB:
  00050	8b 45 fc	 mov	 eax, DWORD PTR _Length$12998[ebp]
$LN21@KdpDeleteB:
  00053	8d 14 36	 lea	 edx, DWORD PTR [esi+esi]
  00056	3b d0		 cmp	 edx, eax
  00058	77 18		 ja	 SHORT $LN31@KdpDeleteB
  0005a	33 c9		 xor	 ecx, ecx
  0005c	8d 44 36 ff	 lea	 eax, DWORD PTR [esi+esi-1]
  00060	23 c7		 and	 eax, edi
  00062	23 cb		 and	 ecx, ebx
  00064	0b c1		 or	 eax, ecx
  00066	75 07		 jne	 SHORT $LN43@KdpDeleteB
  00068	8b f2		 mov	 esi, edx
  0006a	83 fe 04	 cmp	 esi, 4
  0006d	72 e1		 jb	 SHORT $LL42@KdpDeleteB
$LN43@KdpDeleteB:
  0006f	8b 45 fc	 mov	 eax, DWORD PTR _Length$12998[ebp]
$LN31@KdpDeleteB:
  00072	3b f0		 cmp	 esi, eax
  00074	76 06		 jbe	 SHORT $LN18@KdpDeleteB
$LL19@KdpDeleteB:
  00076	d1 ee		 shr	 esi, 1
  00078	3b f0		 cmp	 esi, eax
  0007a	77 fa		 ja	 SHORT $LL19@KdpDeleteB
$LN18@KdpDeleteB:
  0007c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?c_thePlatform@Class_Microsoft_Singularity_Hal_Platform@@2PAU1@A ; Class_Microsoft_Singularity_Hal_Platform::c_thePlatform
  00082	8b 52 34	 mov	 edx, DWORD PTR [edx+52]
  00085	33 c9		 xor	 ecx, ecx
  00087	3b d9		 cmp	 ebx, ecx
  00089	72 37		 jb	 SHORT $LN44@KdpDeleteB
  0008b	77 04		 ja	 SHORT $LN39@KdpDeleteB
  0008d	3b fa		 cmp	 edi, edx
  0008f	72 31		 jb	 SHORT $LN44@KdpDeleteB
$LN39@KdpDeleteB:
  00091	8b cf		 mov	 ecx, edi
  00093	0b cb		 or	 ecx, ebx
  00095	74 2b		 je	 SHORT $LN44@KdpDeleteB
  00097	53		 push	 ebx
  00098	57		 push	 edi
  00099	8b ce		 mov	 ecx, esi
  0009b	e8 00 00 00 00	 call	 ?ProbeMemoryRange@@YIH_KK@Z ; ProbeMemoryRange
  000a0	85 c0		 test	 eax, eax
  000a2	74 1b		 je	 SHORT $LN41@KdpDeleteB
  000a4	8b 55 f8	 mov	 edx, DWORD PTR $T13018[ebp]
  000a7	56		 push	 esi
  000a8	52		 push	 edx
  000a9	57		 push	 edi
  000aa	e8 00 00 00 00	 call	 _memcpy
  000af	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b2	03 fe		 add	 edi, esi
  000b4	83 d3 00	 adc	 ebx, 0
  000b7	01 75 f8	 add	 DWORD PTR $T13018[ebp], esi
  000ba	29 75 fc	 sub	 DWORD PTR _Length$12998[ebp], esi
  000bd	75 81		 jne	 SHORT $LL40@KdpDeleteB
$LN41@KdpDeleteB:
  000bf	8b 45 fc	 mov	 eax, DWORD PTR _Length$12998[ebp]
$LN44@KdpDeleteB:
  000c2	83 f8 01	 cmp	 eax, 1
  000c5	5f		 pop	 edi
  000c6	5e		 pop	 esi
  000c7	5b		 pop	 ebx
  000c8	73 05		 jae	 SHORT $LN11@KdpDeleteB
  000ca	e8 00 00 00 00	 call	 ?KdpFlushInstCache@@YIXXZ ; KdpFlushInstCache
$LN11@KdpDeleteB:

; 1793 :         KDDBG("KD: Breakpoint at 0x%p; unable to clear, flag set.\n",
; 1794 :                   KdpBreakpointTable[Index].Address);
; 1795 :         return FALSE;
; 1796 :     }
; 1797 :     else {
; 1798 :         KDDBG2("KD: Breakpoint at 0x%p cleared.\n",
; 1799 :                KdpBreakpointTable[Index].Address);
; 1800 :         KdpBreakpointTable[Index].Flags = 0;

  000cf	8b 45 f4	 mov	 eax, DWORD PTR tv195[ebp]
  000d2	c7 80 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?KdpBreakpointTable@@3PAU_BREAKPOINT_ENTRY@@A[eax], 0

; 1801 :     }
; 1802 :     return TRUE;

  000dc	b8 01 00 00 00	 mov	 eax, 1

; 1803 : }

  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
$LN6@KdpDeleteB:

; 1782 :         KDDBG("KD: Breakpoint %d invalid.\n", Index);
; 1783 :         return FALSE;

  000e5	33 c0		 xor	 eax, eax

; 1803 : }

  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c3		 ret	 0
?KdpDeleteBreakpoint@@YIHK@Z ENDP			; KdpDeleteBreakpoint
_TEXT	ENDS
PUBLIC	?KdpWriteBreakpoint@@YIXPAU_DBGKD_MANIPULATE_STATE64@@@Z ; KdpWriteBreakpoint
; Function compile flags: /Ogtp
;	COMDAT ?KdpWriteBreakpoint@@YIXPAU_DBGKD_MANIPULATE_STATE64@@@Z
_TEXT	SEGMENT
_MessageHeader$ = -8					; size = 8
?KdpWriteBreakpoint@@YIXPAU_DBGKD_MANIPULATE_STATE64@@@Z PROC ; KdpWriteBreakpoint, COMDAT
; _m$ = ecx

; 1818 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 1819 :     PDBGKD_WRITE_BREAKPOINT64 a = &m->WriteBreakPoint;
; 1820 :     STRING MessageHeader;
; 1821 : 
; 1822 :     MessageHeader.Length = sizeof(*m);
; 1823 :     MessageHeader.Buffer = (PCHAR)m;
; 1824 : 
; 1825 :     ASSERT(AdditionalData->Length == 0);
; 1826 : 
; 1827 :     a->BreakPointHandle = KdpAddBreakpoint((PVOID)(ULONG_PTR)a->BreakPointAddress);

  00009	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0000c	66 c7 45 f8 38
	00		 mov	 WORD PTR _MessageHeader$[ebp], 56 ; 00000038H
  00012	89 75 fc	 mov	 DWORD PTR _MessageHeader$[ebp+4], esi
  00015	e8 00 00 00 00	 call	 ?KdpAddBreakpoint@@YIKPAX@Z ; KdpAddBreakpoint
  0001a	89 46 18	 mov	 DWORD PTR [esi+24], eax

; 1828 :     if (a->BreakPointHandle != 0) {

  0001d	f7 d8		 neg	 eax
  0001f	1b c0		 sbb	 eax, eax
  00021	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH

; 1829 :         m->ReturnStatus = STATUS_SUCCESS;
; 1830 :     }
; 1831 :     else {
; 1832 :         m->ReturnStatus = STATUS_UNSUCCESSFUL;
; 1833 :     }
; 1834 :     KdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
; 1835 :                  &MessageHeader,
; 1836 :                  NULL,
; 1837 :                  &KdpContext);

  00026	68 00 00 00 00	 push	 OFFSET _KdpContext
  0002b	05 01 00 00 c0	 add	 eax, -1073741823	; c0000001H
  00030	6a 00		 push	 0
  00032	8d 55 f8	 lea	 edx, DWORD PTR _MessageHeader$[ebp]
  00035	b9 02 00 00 00	 mov	 ecx, 2
  0003a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket
  00043	5e		 pop	 esi

; 1838 : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?KdpWriteBreakpoint@@YIXPAU_DBGKD_MANIPULATE_STATE64@@@Z ENDP ; KdpWriteBreakpoint
_TEXT	ENDS
PUBLIC	?KdpRestoreBreakpoint@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@@Z ; KdpRestoreBreakpoint
; Function compile flags: /Ogtp
;	COMDAT ?KdpRestoreBreakpoint@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@@Z
_TEXT	SEGMENT
_MessageHeader$ = -8					; size = 8
?KdpRestoreBreakpoint@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@@Z PROC ; KdpRestoreBreakpoint, COMDAT
; _m$ = ecx
; _AdditionalData$ = edx

; 1854 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 1855 :     PDBGKD_RESTORE_BREAKPOINT a = &m->RestoreBreakPoint;
; 1856 :     STRING MessageHeader;
; 1857 : 
; 1858 :     MessageHeader.Length = sizeof(*m);
; 1859 :     MessageHeader.Buffer = (PCHAR)m;
; 1860 : 
; 1861 :     ASSERT(AdditionalData->Length == 0);
; 1862 :     if (KdpDeleteBreakpoint(a->BreakPointHandle)) {

  00009	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0000c	66 c7 45 f8 38
	00		 mov	 WORD PTR _MessageHeader$[ebp], 56 ; 00000038H
  00012	89 75 fc	 mov	 DWORD PTR _MessageHeader$[ebp+4], esi
  00015	e8 00 00 00 00	 call	 ?KdpDeleteBreakpoint@@YIHK@Z ; KdpDeleteBreakpoint
  0001a	f7 d8		 neg	 eax
  0001c	1b c0		 sbb	 eax, eax
  0001e	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH

; 1863 :         m->ReturnStatus = STATUS_SUCCESS;
; 1864 :     }
; 1865 :     else {
; 1866 :         m->ReturnStatus = STATUS_UNSUCCESSFUL;
; 1867 :     }
; 1868 :     KdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
; 1869 :                  &MessageHeader,
; 1870 :                  NULL,
; 1871 :                  &KdpContext);

  00023	68 00 00 00 00	 push	 OFFSET _KdpContext
  00028	05 01 00 00 c0	 add	 eax, -1073741823	; c0000001H
  0002d	6a 00		 push	 0
  0002f	8d 55 f8	 lea	 edx, DWORD PTR _MessageHeader$[ebp]
  00032	b9 02 00 00 00	 mov	 ecx, 2
  00037	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket
  00040	5e		 pop	 esi

; 1872 : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?KdpRestoreBreakpoint@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@@Z ENDP ; KdpRestoreBreakpoint
_TEXT	ENDS
EXTRN	?KdpSetControlSet@@YIXPBUStruct_Microsoft_Singularity_Kd_X86KdControlSet@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z:PROC ; KdpSetControlSet
; Function compile flags: /Ogtp
;	COMDAT ?KdpGetStateChange@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z
_TEXT	SEGMENT
?KdpGetStateChange@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z PROC ; KdpGetStateChange, COMDAT
; _ManipulateState$ = ecx
; _Context$ = edx

; 1887 :     if (NT_SUCCESS(ManipulateState->Continue2.ContinueStatus)) {
; 1888 :         //
; 1889 :         // If NT_SUCCESS returns TRUE, then the debugger is doing a
; 1890 :         // continue, and it makes sense to apply control changes.
; 1891 :         // Otherwise the debugger is saying that it doesn't know what
; 1892 :         // to do with this exception, so control values are ignored.
; 1893 :         //
; 1894 : 
; 1895 :         KdpSetControlSet(&ManipulateState->Continue2.ControlSet, Context);

  00000	83 c1 10	 add	 ecx, 16			; 00000010H
  00003	e9 00 00 00 00	 jmp	 ?KdpSetControlSet@@YIXPBUStruct_Microsoft_Singularity_Kd_X86KdControlSet@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ; KdpSetControlSet
?KdpGetStateChange@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ENDP ; KdpGetStateChange
_TEXT	ENDS
EXTRN	?g_SwitchFrozenProcessor@Class_Microsoft_Singularity_MpExecution@@SI_NH@Z:PROC ; Class_Microsoft_Singularity_MpExecution::g_SwitchFrozenProcessor
_BSS	SEGMENT
_KdpMessageBuffer DB 01000H DUP (?)
; Function compile flags: /Ogtp
_BSS	ENDS
;	COMDAT ?KdpSendWaitContinue@@YI?AW4KCONTINUE_STATUS@@KPAU_STRING@@0PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z
_TEXT	SEGMENT
_Length$ = -160						; size = 4
_MessageHeader$13106 = -156				; size = 8
_MessageHeader$13049 = -148				; size = 8
_MessageHeader$13054 = -140				; size = 8
_MessageHeader$13102 = -132				; size = 8
_MessageHeader$13076 = -124				; size = 8
_MessageHeader$13098 = -116				; size = 8
_messageHeader$13061 = -108				; size = 8
_MessageHeader$13093 = -100				; size = 8
_MessageHeader$13083 = -92				; size = 8
_MessageHeader$13068 = -84				; size = 8
_MessageHeader$ = -76					; size = 8
_ManipulateState$ = -68					; size = 56
_Length$13092 = -12					; size = 4
_Length$13048 = -12					; size = 4
_MessageData$ = -8					; size = 8
_OutPacketType$ = 8					; size = 4
_OutMessageHeader$ = 12					; size = 4
_OutMessageData$ = 16					; size = 4
_Context$ = 20						; size = 4
?KdpSendWaitContinue@@YI?AW4KCONTINUE_STATUS@@KPAU_STRING@@0PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z PROC ; KdpSendWaitContinue, COMDAT

; 1940 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H

; 1941 : 
; 1942 :     UINT32 Length;
; 1943 :     STRING MessageData;
; 1944 :     STRING MessageHeader;
; 1945 :     DBGKD_MANIPULATE_STATE64 ManipulateState;
; 1946 :     UINT32 ReturnCode;
; 1947 :     //    NTSTATUS Status;
; 1948 :     //    KCONTINUE_STATUS ContinueStatus;
; 1949 : 
; 1950 :     //
; 1951 :     // Loop servicing state manipulation message until a continue message
; 1952 :     // is received.
; 1953 :     //
; 1954 : 
; 1955 :     MessageHeader.MaximumLength = sizeof(DBGKD_MANIPULATE_STATE64);
; 1956 :     MessageHeader.Buffer = (PCHAR)&ManipulateState;
; 1957 :     MessageData.MaximumLength = arrayof(KdpMessageBuffer);
; 1958 :     MessageData.Buffer = KdpMessageBuffer;
; 1959 :     KdpContextSent = FALSE;
; 1960 : 
; 1961 :   ResendPacket:
; 1962 : 
; 1963 :     //
; 1964 :     // Send event notification packet to debugger on host.  Come back
; 1965 :     // here any time we see a breakin sequence.
; 1966 :     //
; 1967 : 
; 1968 :     KdSendPacket(OutPacketType,
; 1969 :                  OutMessageHeader,
; 1970 :                  OutMessageData,
; 1971 :                  &KdpContext);

  00009	8b 4d 10	 mov	 ecx, DWORD PTR _OutMessageData$[ebp]
  0000c	8b 55 0c	 mov	 edx, DWORD PTR _OutMessageHeader$[ebp]
  0000f	53		 push	 ebx
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	68 00 00 00 00	 push	 OFFSET _KdpContext
  00017	8d 45 bc	 lea	 eax, DWORD PTR _ManipulateState$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _OutPacketType$[ebp]
  0001e	bb 38 00 00 00	 mov	 ebx, 56			; 00000038H
  00023	33 ff		 xor	 edi, edi
  00025	66 89 5d b6	 mov	 WORD PTR _MessageHeader$[ebp+2], bx
  00029	89 45 b8	 mov	 DWORD PTR _MessageHeader$[ebp+4], eax
  0002c	66 c7 45 fa 00
	10		 mov	 WORD PTR _MessageData$[ebp+2], 4096 ; 00001000H
  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _MessageData$[ebp+4], OFFSET _KdpMessageBuffer
  00039	89 3d 00 00 00
	00		 mov	 DWORD PTR _KdpContextSent, edi
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket

; 1972 : 
; 1973 :     //
; 1974 :     // After sending packet, if there is no response from debugger
; 1975 :     // AND the packet is for reporting symbol (un)load, the debugger
; 1976 :     // will be declared to be not present.  Note If the packet is for
; 1977 :     // reporting exception, the KdSendPacket will never stop.
; 1978 :     //
; 1979 : 
; 1980 :     if (KdDebuggerNotPresent) {

  00045	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?KdDebuggerNotPresent@@3HA, edi ; KdDebuggerNotPresent
  0004b	0f 85 d0 03 00
	00		 jne	 $LN98@KdpSendWai
$ResendPacket$12233:

; 1982 :     }
; 1983 : 
; 1984 :     for (;;) {
; 1985 :         //
; 1986 :         // Wait for State Manipulate Packet without timeout.
; 1987 :         //
; 1988 : 
; 1989 :         do {
; 1990 :             ReturnCode = KdReceivePacket(
; 1991 :                                          PACKET_TYPE_KD_STATE_MANIPULATE,
; 1992 :                                          &MessageHeader,
; 1993 :                                          &MessageData,
; 1994 :                                          &Length,
; 1995 :                                          &KdpContext
; 1996 :                                         );

  00051	68 00 00 00 00	 push	 OFFSET _KdpContext
  00056	8d 95 60 ff ff
	ff		 lea	 edx, DWORD PTR _Length$[ebp]
  0005c	52		 push	 edx
  0005d	8d 45 f8	 lea	 eax, DWORD PTR _MessageData$[ebp]
  00060	50		 push	 eax
  00061	8d 55 b4	 lea	 edx, DWORD PTR _MessageHeader$[ebp]
  00064	b9 02 00 00 00	 mov	 ecx, 2
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdReceivePacket@@3P6I?AW4KDP_STATUS@@KPAU_STRING@@0PAKPAU_KD_CONTEXT@@@ZA ; KdReceivePacket

; 1997 :             KDDBG3("KdReceivePacket returned %d\n", ReturnCode);
; 1998 :             if (ReturnCode == KDP_PACKET_RESEND) {

  0006f	83 f8 02	 cmp	 eax, 2
  00072	0f 84 88 03 00
	00		 je	 $LN96@KdpSendWai

; 1999 :                 goto ResendPacket;
; 2000 :             }
; 2001 :         } while (ReturnCode == KDP_PACKET_TIMEOUT);

  00078	83 f8 01	 cmp	 eax, 1
  0007b	74 d4		 je	 SHORT $ResendPacket$12233

; 2002 : 
; 2003 :         KDDBG2("KdpSendWaitContinue: ManipulateState.ApiNumber=0x%x\n", ManipulateState.ApiNumber);
; 2004 : 
; 2005 :         //
; 2006 :         // Switch on the return message API number.
; 2007 :         //
; 2008 : 
; 2009 :         switch (ManipulateState.ApiNumber) {

  0007d	8b 45 bc	 mov	 eax, DWORD PTR _ManipulateState$[ebp]
  00080	05 d0 ce ff ff	 add	 eax, -12592		; ffffced0H
  00085	83 f8 23	 cmp	 eax, 35			; 00000023H
  00088	0f 87 4b 03 00
	00		 ja	 $LN2@KdpSendWai
  0008e	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN99@KdpSendWai[eax]
  00095	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN100@KdpSendWai[ecx*4]
$LN43@KdpSendWai:

; 2010 : 
; 2011 :           case DbgKdReadVirtualMemoryApi:
; 2012 :             KDDBG("KdReadVirt(%p-%p)\n",
; 2013 :                   (ULONG_PTR)ManipulateState.ReadMemory.TargetBaseAddress,
; 2014 :                   (ULONG_PTR)ManipulateState.ReadMemory.TargetBaseAddress +
; 2015 :                   ManipulateState.ReadMemory.TransferCount);
; 2016 :             KdpReadVirtualMemory(&ManipulateState, &MessageData);

  0009c	8b 55 d4	 mov	 edx, DWORD PTR _ManipulateState$[ebp+24]
  0009f	81 fa 68 0f 00
	00		 cmp	 edx, 3944		; 00000f68H
  000a5	89 55 f4	 mov	 DWORD PTR _Length$13048[ebp], edx
  000a8	76 08		 jbe	 SHORT $LN57@KdpSendWai
  000aa	ba 68 0f 00 00	 mov	 edx, 3944		; 00000f68H
  000af	89 55 f4	 mov	 DWORD PTR _Length$13048[ebp], edx
$LN57@KdpSendWai:
  000b2	8b 4d cc	 mov	 ecx, DWORD PTR _ManipulateState$[ebp+16]
  000b5	8d 45 f4	 lea	 eax, DWORD PTR _Length$13048[ebp]
  000b8	50		 push	 eax
  000b9	6a 04		 push	 4
  000bb	57		 push	 edi
  000bc	57		 push	 edi
  000bd	51		 push	 ecx
  000be	8b 4d fc	 mov	 ecx, DWORD PTR _MessageData$[ebp+4]
  000c1	e8 00 00 00 00	 call	 ?KdpCopyMemoryChunks@@YIK_KPAXKKKPAK@Z ; KdpCopyMemoryChunks
  000c6	89 45 c4	 mov	 DWORD PTR _ManipulateState$[ebp+8], eax
  000c9	8b 45 f4	 mov	 eax, DWORD PTR _Length$13048[ebp]
  000cc	66 89 45 f8	 mov	 WORD PTR _MessageData$[ebp], ax
  000d0	89 45 d8	 mov	 DWORD PTR _ManipulateState$[ebp+28], eax
  000d3	8d 55 bc	 lea	 edx, DWORD PTR _ManipulateState$[ebp]
  000d6	68 00 00 00 00	 push	 OFFSET _KdpContext
  000db	8d 45 f8	 lea	 eax, DWORD PTR _MessageData$[ebp]
  000de	89 95 70 ff ff
	ff		 mov	 DWORD PTR _MessageHeader$13049[ebp+4], edx
  000e4	50		 push	 eax
  000e5	8d 95 6c ff ff
	ff		 lea	 edx, DWORD PTR _MessageHeader$13049[ebp]
  000eb	b9 02 00 00 00	 mov	 ecx, 2
  000f0	66 89 9d 6c ff
	ff ff		 mov	 WORD PTR _MessageHeader$13049[ebp], bx
  000f7	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket

; 2017 :             break;

  000fd	e9 4f ff ff ff	 jmp	 $ResendPacket$12233
$LN41@KdpSendWai:

; 2018 : 
; 2019 : #if 0
; 2020 :           case DbgKdReadVirtualMemory64Api:
; 2021 :             KdpReadVirtualMemory64(&ManipulateState, &MessageData);
; 2022 :             break;
; 2023 : #endif
; 2024 :           case DbgKdWriteVirtualMemoryApi:
; 2025 :             KDDBG("KdWritVirt(%p-%p)\n",
; 2026 :                   (ULONG_PTR)ManipulateState.WriteMemory.TargetBaseAddress,
; 2027 :                   (ULONG_PTR)ManipulateState.WriteMemory.TargetBaseAddress +
; 2028 :                   ManipulateState.WriteMemory.TransferCount);
; 2029 :             KdpWriteVirtualMemory(&ManipulateState, &MessageData);

  00102	8b 45 cc	 mov	 eax, DWORD PTR _ManipulateState$[ebp+16]
  00105	0f b7 55 f8	 movzx	 edx, WORD PTR _MessageData$[ebp]
  00109	8d 4d d8	 lea	 ecx, DWORD PTR _ManipulateState$[ebp+28]
  0010c	51		 push	 ecx
  0010d	8b 4d fc	 mov	 ecx, DWORD PTR _MessageData$[ebp+4]
  00110	6a 05		 push	 5
  00112	57		 push	 edi
  00113	57		 push	 edi
  00114	50		 push	 eax
  00115	e8 00 00 00 00	 call	 ?KdpCopyMemoryChunks@@YIK_KPAXKKKPAK@Z ; KdpCopyMemoryChunks
  0011a	8d 4d bc	 lea	 ecx, DWORD PTR _ManipulateState$[ebp]
  0011d	68 00 00 00 00	 push	 OFFSET _KdpContext
  00122	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _MessageHeader$13054[ebp+4], ecx
  00128	57		 push	 edi
  00129	8d 95 74 ff ff
	ff		 lea	 edx, DWORD PTR _MessageHeader$13054[ebp]
  0012f	b9 02 00 00 00	 mov	 ecx, 2
  00134	89 45 c4	 mov	 DWORD PTR _ManipulateState$[ebp+8], eax
  00137	66 89 9d 74 ff
	ff ff		 mov	 WORD PTR _MessageHeader$13054[ebp], bx
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket

; 2030 :             break;

  00144	e9 08 ff ff ff	 jmp	 $ResendPacket$12233
$LN39@KdpSendWai:

; 2031 : #if 0
; 2032 :           case DbgKdWriteVirtualMemory64Api:
; 2033 :             KdpWriteVirtualMemory64(&ManipulateState, &MessageData);
; 2034 :             break;
; 2035 : #endif
; 2036 :           case DbgKdGetVersionApi:
; 2037 :             KDDBG("KdGetVersion()\n");
; 2038 :             KdpGetVersion(&ManipulateState);

  00149	8d 55 bc	 lea	 edx, DWORD PTR _ManipulateState$[ebp]
  0014c	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00151	be 00 00 00 00	 mov	 esi, OFFSET _KdVersionBlock
  00156	8d 7d cc	 lea	 edi, DWORD PTR _ManipulateState$[ebp+16]
  00159	f3 a5		 rep movsd
  0015b	68 00 00 00 00	 push	 OFFSET _KdpContext
  00160	89 55 98	 mov	 DWORD PTR _messageHeader$13061[ebp+4], edx
  00163	6a 00		 push	 0
  00165	8d 55 94	 lea	 edx, DWORD PTR _messageHeader$13061[ebp]
  00168	b9 02 00 00 00	 mov	 ecx, 2
  0016d	66 89 5d 94	 mov	 WORD PTR _messageHeader$13061[ebp], bx
  00171	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _ManipulateState$[ebp+8], 0
  00178	c7 45 bc 46 31
	00 00		 mov	 DWORD PTR _ManipulateState$[ebp], 12614 ; 00003146H
  0017f	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket

; 2039 :             break;

  00185	33 ff		 xor	 edi, edi
  00187	e9 c5 fe ff ff	 jmp	 $ResendPacket$12233
$LN37@KdpSendWai:

; 2040 : 
; 2041 :           case DbgKdGetContextApi:
; 2042 :             KDDBG("KdGetContext(p=%x)\n", ManipulateState.Processor);
; 2043 :             KdpGetContext(&ManipulateState, &MessageData, Context);

  0018c	8b 45 14	 mov	 eax, DWORD PTR _Context$[ebp]
  0018f	50		 push	 eax
  00190	8d 75 f8	 lea	 esi, DWORD PTR _MessageData$[ebp]
  00193	8d 45 bc	 lea	 eax, DWORD PTR _ManipulateState$[ebp]
  00196	e8 00 00 00 00	 call	 ?KdpGetContext@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ; KdpGetContext

; 2044 :             break;

  0019b	e9 b1 fe ff ff	 jmp	 $ResendPacket$12233
$LN35@KdpSendWai:

; 2045 : 
; 2046 :           case DbgKdReadControlSpaceApi:
; 2047 :             KDDBG("KdReadCtrl(%p-%p p=%x)\n",
; 2048 :                   (ULONG_PTR)ManipulateState.ReadMemory.TargetBaseAddress,
; 2049 :                   (ULONG_PTR)ManipulateState.ReadMemory.TargetBaseAddress +
; 2050 :                   ManipulateState.ReadMemory.TransferCount,
; 2051 :                   (ULONG_PTR)ManipulateState.Processor);
; 2052 :             KdpReadControlSpace(&ManipulateState, &MessageData, Context);

  001a0	8b 55 14	 mov	 edx, DWORD PTR _Context$[ebp]
  001a3	8d 4d f8	 lea	 ecx, DWORD PTR _MessageData$[ebp]
  001a6	51		 push	 ecx
  001a7	8d 75 bc	 lea	 esi, DWORD PTR _ManipulateState$[ebp]
  001aa	e8 00 00 00 00	 call	 ?KdpReadControlSpace@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ; KdpReadControlSpace

; 2053 :             break;

  001af	e9 9d fe ff ff	 jmp	 $ResendPacket$12233
$LN33@KdpSendWai:

; 2054 : 
; 2055 :           case DbgKdWriteControlSpaceApi:
; 2056 :             KDDBG("KdWriteCtrl(%p-%p p=%x)\n",
; 2057 :                   (ULONG_PTR)ManipulateState.WriteMemory.TargetBaseAddress,
; 2058 :                   (ULONG_PTR)ManipulateState.WriteMemory.TargetBaseAddress +
; 2059 :                   ManipulateState.WriteMemory.TransferCount,
; 2060 :                   (ULONG_PTR)ManipulateState.Processor);
; 2061 :             KdpWriteControlSpace(&ManipulateState, &MessageData, Context);

  001b4	8d 55 f8	 lea	 edx, DWORD PTR _MessageData$[ebp]
  001b7	52		 push	 edx
  001b8	8d 75 bc	 lea	 esi, DWORD PTR _ManipulateState$[ebp]
  001bb	e8 00 00 00 00	 call	 ?KdpWriteControlSpace@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ; KdpWriteControlSpace

; 2062 :             break;

  001c0	e9 8c fe ff ff	 jmp	 $ResendPacket$12233
$LN31@KdpSendWai:

; 2063 : 
; 2064 :         case DbgKdReadIoSpaceApi:
; 2065 :             KDDBG("KdReadIoSpace(%p size=%x p=%x)\n",
; 2066 :                   (ULONG_PTR)ManipulateState.ReadWriteIo.IoAddress,
; 2067 :                   (ULONG_PTR)ManipulateState.ReadWriteIo.DataSize,
; 2068 :                   (ULONG_PTR)ManipulateState.Processor);
; 2069 :             KdpReadIoSpace(&ManipulateState, &MessageData, Context);

  001c5	8d 75 bc	 lea	 esi, DWORD PTR _ManipulateState$[ebp]
  001c8	e8 00 00 00 00	 call	 ?KdpReadIoSpace@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ; KdpReadIoSpace

; 2070 :             break;

  001cd	e9 7f fe ff ff	 jmp	 $ResendPacket$12233
$LN29@KdpSendWai:

; 2071 : 
; 2072 :         case DbgKdWriteIoSpaceApi:
; 2073 :             KDDBG("KdWriteIoSpace(%p size=%x value=%x, p=%x)\n",
; 2074 :                   (ULONG_PTR)ManipulateState.ReadWriteIo.IoAddress,
; 2075 :                   (ULONG_PTR)ManipulateState.ReadWriteIo.DataSize,
; 2076 :                   (ULONG_PTR)ManipulateState.ReadWriteIo.DataValue,
; 2077 :                   (ULONG_PTR)ManipulateState.Processor);
; 2078 :             KdpWriteIoSpace(&ManipulateState, &MessageData, Context);

  001d2	8d 75 bc	 lea	 esi, DWORD PTR _ManipulateState$[ebp]
  001d5	e8 00 00 00 00	 call	 ?KdpWriteIoSpace@@YIXPAU_DBGKD_MANIPULATE_STATE64@@PAU_STRING@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ; KdpWriteIoSpace

; 2079 :             break;

  001da	e9 72 fe ff ff	 jmp	 $ResendPacket$12233
$LN27@KdpSendWai:

; 2080 : 
; 2081 :           case DbgKdSetContextApi:
; 2082 :             KDDBG("KdSetContext(p=%x)\n", ManipulateState.Processor);
; 2083 :             KdpSetContext(&ManipulateState, &MessageData, Context);

  001df	66 8b 4d c2	 mov	 cx, WORD PTR _ManipulateState$[ebp+6]
  001e3	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR _KeNumberProcessors
  001ea	8d 45 bc	 lea	 eax, DWORD PTR _ManipulateState$[ebp]
  001ed	66 89 5d ac	 mov	 WORD PTR _MessageHeader$13068[ebp], bx
  001f1	89 45 b0	 mov	 DWORD PTR _MessageHeader$13068[ebp+4], eax
  001f4	73 18		 jae	 SHORT $LN67@KdpSendWai
  001f6	39 3d 00 00 00
	00		 cmp	 DWORD PTR _KdpContextSent, edi
  001fc	74 10		 je	 SHORT $LN67@KdpSendWai
  001fe	8b 55 14	 mov	 edx, DWORD PTR _Context$[ebp]
  00201	8b 4d fc	 mov	 ecx, DWORD PTR _MessageData$[ebp+4]
  00204	89 7d c4	 mov	 DWORD PTR _ManipulateState$[ebp+8], edi
  00207	e8 00 00 00 00	 call	 ?KdpFromKdContext@@YIXPBUStruct_Microsoft_Singularity_Kd_X86Context@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ; KdpFromKdContext
  0020c	eb 07		 jmp	 SHORT $LN66@KdpSendWai
$LN67@KdpSendWai:
  0020e	c7 45 c4 01 00
	00 c0		 mov	 DWORD PTR _ManipulateState$[ebp+8], -1073741823 ; c0000001H
$LN66@KdpSendWai:
  00215	68 00 00 00 00	 push	 OFFSET _KdpContext
  0021a	57		 push	 edi
  0021b	8d 55 ac	 lea	 edx, DWORD PTR _MessageHeader$13068[ebp]
  0021e	b9 02 00 00 00	 mov	 ecx, 2
  00223	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket

; 2084 :             break;

  00229	e9 23 fe ff ff	 jmp	 $ResendPacket$12233
$LN25@KdpSendWai:

; 2085 : 
; 2086 :           case DbgKdWriteBreakPointApi:
; 2087 :             KDDBG("KdWriteBreak(%p)\n",
; 2088 :                   ManipulateState.WriteBreakPoint.BreakPointAddress);
; 2089 :             KdpWriteBreakpoint(&ManipulateState);

  0022e	8b 4d cc	 mov	 ecx, DWORD PTR _ManipulateState$[ebp+16]
  00231	8d 55 bc	 lea	 edx, DWORD PTR _ManipulateState$[ebp]
  00234	66 89 5d 84	 mov	 WORD PTR _MessageHeader$13076[ebp], bx
  00238	89 55 88	 mov	 DWORD PTR _MessageHeader$13076[ebp+4], edx
  0023b	e8 00 00 00 00	 call	 ?KdpAddBreakpoint@@YIKPAX@Z ; KdpAddBreakpoint
  00240	89 45 d4	 mov	 DWORD PTR _ManipulateState$[ebp+24], eax
  00243	f7 d8		 neg	 eax
  00245	1b c0		 sbb	 eax, eax
  00247	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  0024c	68 00 00 00 00	 push	 OFFSET _KdpContext
  00251	05 01 00 00 c0	 add	 eax, -1073741823	; c0000001H
  00256	57		 push	 edi
  00257	8d 55 84	 lea	 edx, DWORD PTR _MessageHeader$13076[ebp]
  0025a	b9 02 00 00 00	 mov	 ecx, 2
  0025f	89 45 c4	 mov	 DWORD PTR _ManipulateState$[ebp+8], eax
  00262	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket

; 2090 :             break;

  00268	e9 e4 fd ff ff	 jmp	 $ResendPacket$12233
$LN23@KdpSendWai:

; 2091 : 
; 2092 :           case DbgKdRestoreBreakPointApi:
; 2093 :             if (ManipulateState.RestoreBreakPoint.BreakPointHandle < 0x8 ||
; 2094 :                 ManipulateState.RestoreBreakPoint.BreakPointHandle > 0x1e) {
; 2095 :                 KDDBG("KdRestoreBreak(%x)\n",
; 2096 :                       ManipulateState.RestoreBreakPoint.BreakPointHandle);
; 2097 :             }
; 2098 :             KdpRestoreBreakpoint(&ManipulateState, &MessageData);

  0026d	8b 4d cc	 mov	 ecx, DWORD PTR _ManipulateState$[ebp+16]
  00270	8d 45 bc	 lea	 eax, DWORD PTR _ManipulateState$[ebp]
  00273	66 89 5d a4	 mov	 WORD PTR _MessageHeader$13083[ebp], bx
  00277	89 45 a8	 mov	 DWORD PTR _MessageHeader$13083[ebp+4], eax
  0027a	e8 00 00 00 00	 call	 ?KdpDeleteBreakpoint@@YIHK@Z ; KdpDeleteBreakpoint
  0027f	f7 d8		 neg	 eax
  00281	1b c0		 sbb	 eax, eax
  00283	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  00288	68 00 00 00 00	 push	 OFFSET _KdpContext
  0028d	05 01 00 00 c0	 add	 eax, -1073741823	; c0000001H
  00292	57		 push	 edi
  00293	8d 55 a4	 lea	 edx, DWORD PTR _MessageHeader$13083[ebp]
  00296	b9 02 00 00 00	 mov	 ecx, 2
  0029b	89 45 c4	 mov	 DWORD PTR _ManipulateState$[ebp+8], eax
  0029e	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket

; 2099 :             break;

  002a4	e9 a8 fd ff ff	 jmp	 $ResendPacket$12233
$LN9@KdpSendWai:

; 2119 :             }
; 2120 :             else {
; 2121 :                 KDDBG("KdpContinue2 Error!\n");
; 2122 :                 return ContinueError;
; 2123 :             }
; 2124 :             break;
; 2125 : 
; 2126 :           case DbgKdReadPhysicalMemoryApi:
; 2127 :             KDDBG("KdReadPhys(%8p-%8p)\n",
; 2128 :                   (ULONG_PTR)ManipulateState.ReadMemory.TargetBaseAddress,
; 2129 :                   (ULONG_PTR)ManipulateState.ReadMemory.TargetBaseAddress +
; 2130 :                   ManipulateState.ReadMemory.TransferCount);
; 2131 :             // KdpReadPhysicalMemory(&ManipulateState, &MessageData, Context);
; 2132 :             KdpReadPhysicalMemory(&ManipulateState, &MessageData);

  002a9	8b 55 d4	 mov	 edx, DWORD PTR _ManipulateState$[ebp+24]
  002ac	81 fa 68 0f 00
	00		 cmp	 edx, 3944		; 00000f68H
  002b2	89 55 f4	 mov	 DWORD PTR _Length$13092[ebp], edx
  002b5	76 08		 jbe	 SHORT $LN82@KdpSendWai
  002b7	ba 68 0f 00 00	 mov	 edx, 3944		; 00000f68H
  002bc	89 55 f4	 mov	 DWORD PTR _Length$13092[ebp], edx
$LN82@KdpSendWai:
  002bf	8b 45 cc	 mov	 eax, DWORD PTR _ManipulateState$[ebp+16]
  002c2	8d 4d f4	 lea	 ecx, DWORD PTR _Length$13092[ebp]
  002c5	51		 push	 ecx
  002c6	8b 4d fc	 mov	 ecx, DWORD PTR _MessageData$[ebp+4]
  002c9	6a 06		 push	 6
  002cb	57		 push	 edi
  002cc	57		 push	 edi
  002cd	50		 push	 eax
  002ce	e8 00 00 00 00	 call	 ?KdpCopyMemoryChunks@@YIK_KPAXKKKPAK@Z ; KdpCopyMemoryChunks
  002d3	8d 4d bc	 lea	 ecx, DWORD PTR _ManipulateState$[ebp]
  002d6	68 00 00 00 00	 push	 OFFSET _KdpContext
  002db	8d 55 f8	 lea	 edx, DWORD PTR _MessageData$[ebp]
  002de	89 45 c4	 mov	 DWORD PTR _ManipulateState$[ebp+8], eax
  002e1	8b 45 f4	 mov	 eax, DWORD PTR _Length$13092[ebp]
  002e4	89 4d a0	 mov	 DWORD PTR _MessageHeader$13093[ebp+4], ecx
  002e7	52		 push	 edx
  002e8	8d 55 9c	 lea	 edx, DWORD PTR _MessageHeader$13093[ebp]
  002eb	b9 02 00 00 00	 mov	 ecx, 2
  002f0	66 89 45 f8	 mov	 WORD PTR _MessageData$[ebp], ax
  002f4	89 45 d8	 mov	 DWORD PTR _ManipulateState$[ebp+28], eax
  002f7	66 89 5d 9c	 mov	 WORD PTR _MessageHeader$13093[ebp], bx
  002fb	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket

; 2133 :             break;

  00301	e9 4b fd ff ff	 jmp	 $ResendPacket$12233
$LN7@KdpSendWai:

; 2134 : 
; 2135 :           case DbgKdWritePhysicalMemoryApi:
; 2136 :             KdpWritePhysicalMemory(&ManipulateState, &MessageData);

  00306	8b 4d cc	 mov	 ecx, DWORD PTR _ManipulateState$[ebp+16]
  00309	0f b7 55 f8	 movzx	 edx, WORD PTR _MessageData$[ebp]
  0030d	8d 45 d8	 lea	 eax, DWORD PTR _ManipulateState$[ebp+28]
  00310	50		 push	 eax
  00311	6a 07		 push	 7
  00313	57		 push	 edi
  00314	57		 push	 edi
  00315	51		 push	 ecx
  00316	8b 4d fc	 mov	 ecx, DWORD PTR _MessageData$[ebp+4]
  00319	e8 00 00 00 00	 call	 ?KdpCopyMemoryChunks@@YIK_KPAXKKKPAK@Z ; KdpCopyMemoryChunks
  0031e	8d 55 bc	 lea	 edx, DWORD PTR _ManipulateState$[ebp]
  00321	68 00 00 00 00	 push	 OFFSET _KdpContext
  00326	89 55 90	 mov	 DWORD PTR _MessageHeader$13098[ebp+4], edx
  00329	57		 push	 edi
  0032a	8d 55 8c	 lea	 edx, DWORD PTR _MessageHeader$13098[ebp]
  0032d	b9 02 00 00 00	 mov	 ecx, 2
  00332	89 45 c4	 mov	 DWORD PTR _ManipulateState$[ebp+8], eax
  00335	66 89 5d 8c	 mov	 WORD PTR _MessageHeader$13098[ebp], bx
  00339	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket

; 2137 :             KDDBG("KdWritePhys(%8p-%8p)\n",
; 2138 :                   (ULONG_PTR)ManipulateState.WriteMemory.TargetBaseAddress,
; 2139 :                   (ULONG_PTR)ManipulateState.WriteMemory.TargetBaseAddress +
; 2140 :                   ManipulateState.ReadMemory.TransferCount);
; 2141 :             break;

  0033f	e9 0d fd ff ff	 jmp	 $ResendPacket$12233
$LN4@KdpSendWai:

; 2148 :                   // KdSave(FALSE);
; 2149 :               }
; 2150 :             break;
; 2151 : 
; 2152 :           case DbgKdReadMachineSpecificRegister:
; 2153 :             KdpReadMachineSpecificRegister(&ManipulateState, &MessageData, Context);

  00344	8b 4d cc	 mov	 ecx, DWORD PTR _ManipulateState$[ebp+16]
  00347	8d 45 d4	 lea	 eax, DWORD PTR _ManipulateState$[ebp+24]
  0034a	50		 push	 eax
  0034b	8d 55 d0	 lea	 edx, DWORD PTR _ManipulateState$[ebp+20]
  0034e	e8 00 00 00 00	 call	 ?KdpReadMsr@@YI_NKPAK0@Z ; KdpReadMsr
  00353	f6 d8		 neg	 al
  00355	8d 4d bc	 lea	 ecx, DWORD PTR _ManipulateState$[ebp]
  00358	68 00 00 00 00	 push	 OFFSET _KdpContext
  0035d	89 4d 80	 mov	 DWORD PTR _MessageHeader$13102[ebp+4], ecx
  00360	57		 push	 edi
  00361	8d 95 7c ff ff
	ff		 lea	 edx, DWORD PTR _MessageHeader$13102[ebp]
  00367	b9 02 00 00 00	 mov	 ecx, 2
  0036c	1b c0		 sbb	 eax, eax
  0036e	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  00373	05 01 00 00 c0	 add	 eax, -1073741823	; c0000001H
  00378	89 45 c4	 mov	 DWORD PTR _ManipulateState$[ebp+8], eax
  0037b	66 89 9d 7c ff
	ff ff		 mov	 WORD PTR _MessageHeader$13102[ebp], bx
  00382	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket

; 2154 :             break;

  00388	e9 c4 fc ff ff	 jmp	 $ResendPacket$12233
$LN3@KdpSendWai:

; 2155 : 
; 2156 :           case DbgKdWriteMachineSpecificRegister:
; 2157 :             KdpWriteMachineSpecificRegister(&ManipulateState, &MessageData, Context);

  0038d	8b 55 d4	 mov	 edx, DWORD PTR _ManipulateState$[ebp+24]
  00390	8b 4d cc	 mov	 ecx, DWORD PTR _ManipulateState$[ebp+16]
  00393	52		 push	 edx
  00394	8b 55 d0	 mov	 edx, DWORD PTR _ManipulateState$[ebp+20]
  00397	e8 00 00 00 00	 call	 ?KdpWriteMsr@@YI_NKKK@Z	; KdpWriteMsr
  0039c	f6 d8		 neg	 al
  0039e	68 00 00 00 00	 push	 OFFSET _KdpContext
  003a3	57		 push	 edi
  003a4	8d 95 64 ff ff
	ff		 lea	 edx, DWORD PTR _MessageHeader$13106[ebp]
  003aa	b9 02 00 00 00	 mov	 ecx, 2
  003af	66 89 9d 64 ff
	ff ff		 mov	 WORD PTR _MessageHeader$13106[ebp], bx
  003b6	1b c0		 sbb	 eax, eax
  003b8	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  003bd	05 01 00 00 c0	 add	 eax, -1073741823	; c0000001H
  003c2	89 45 c4	 mov	 DWORD PTR _ManipulateState$[ebp+8], eax
  003c5	8d 45 bc	 lea	 eax, DWORD PTR _ManipulateState$[ebp]
  003c8	89 85 68 ff ff
	ff		 mov	 DWORD PTR _MessageHeader$13106[ebp+4], eax
  003ce	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket

; 2158 :             break;

  003d4	e9 78 fc ff ff	 jmp	 $ResendPacket$12233
$LN2@KdpSendWai:

; 2159 : 
; 2160 :           default:
; 2161 :             KDDBG2("Kd Bad API (0x%x)\n", ManipulateState.ApiNumber);
; 2162 :             MessageData.Length = 0;
; 2163 :             ManipulateState.ReturnStatus = STATUS_UNSUCCESSFUL;
; 2164 :             KdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &MessageHeader, &MessageData, &KdpContext);

  003d9	68 00 00 00 00	 push	 OFFSET _KdpContext
  003de	8d 4d f8	 lea	 ecx, DWORD PTR _MessageData$[ebp]
  003e1	51		 push	 ecx
  003e2	8d 55 b4	 lea	 edx, DWORD PTR _MessageHeader$[ebp]
  003e5	b9 02 00 00 00	 mov	 ecx, 2
  003ea	66 89 7d f8	 mov	 WORD PTR _MessageData$[ebp], di
  003ee	c7 45 c4 01 00
	00 c0		 mov	 DWORD PTR _ManipulateState$[ebp+8], -1073741823 ; c0000001H
  003f5	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket

; 2165 :             break;
; 2166 :         }
; 2167 :     }

  003fb	e9 51 fc ff ff	 jmp	 $ResendPacket$12233
$LN96@KdpSendWai:

; 1941 : 
; 1942 :     UINT32 Length;
; 1943 :     STRING MessageData;
; 1944 :     STRING MessageHeader;
; 1945 :     DBGKD_MANIPULATE_STATE64 ManipulateState;
; 1946 :     UINT32 ReturnCode;
; 1947 :     //    NTSTATUS Status;
; 1948 :     //    KCONTINUE_STATUS ContinueStatus;
; 1949 : 
; 1950 :     //
; 1951 :     // Loop servicing state manipulation message until a continue message
; 1952 :     // is received.
; 1953 :     //
; 1954 : 
; 1955 :     MessageHeader.MaximumLength = sizeof(DBGKD_MANIPULATE_STATE64);
; 1956 :     MessageHeader.Buffer = (PCHAR)&ManipulateState;
; 1957 :     MessageData.MaximumLength = arrayof(KdpMessageBuffer);
; 1958 :     MessageData.Buffer = KdpMessageBuffer;
; 1959 :     KdpContextSent = FALSE;
; 1960 : 
; 1961 :   ResendPacket:
; 1962 : 
; 1963 :     //
; 1964 :     // Send event notification packet to debugger on host.  Come back
; 1965 :     // here any time we see a breakin sequence.
; 1966 :     //
; 1967 : 
; 1968 :     KdSendPacket(OutPacketType,
; 1969 :                  OutMessageHeader,
; 1970 :                  OutMessageData,
; 1971 :                  &KdpContext);

  00400	8b 55 10	 mov	 edx, DWORD PTR _OutMessageData$[ebp]
  00403	8b 4d 08	 mov	 ecx, DWORD PTR _OutPacketType$[ebp]
  00406	68 00 00 00 00	 push	 OFFSET _KdpContext
  0040b	52		 push	 edx
  0040c	8b 55 0c	 mov	 edx, DWORD PTR _OutMessageHeader$[ebp]
  0040f	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket

; 1972 : 
; 1973 :     //
; 1974 :     // After sending packet, if there is no response from debugger
; 1975 :     // AND the packet is for reporting symbol (un)load, the debugger
; 1976 :     // will be declared to be not present.  Note If the packet is for
; 1977 :     // reporting exception, the KdSendPacket will never stop.
; 1978 :     //
; 1979 : 
; 1980 :     if (KdDebuggerNotPresent) {

  00415	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?KdDebuggerNotPresent@@3HA, edi ; KdDebuggerNotPresent
  0041b	0f 84 30 fc ff
	ff		 je	 $ResendPacket$12233
$LN98@KdpSendWai:
  00421	5f		 pop	 edi
  00422	5e		 pop	 esi

; 1981 :         return ContinueSuccess;

  00423	b8 01 00 00 00	 mov	 eax, 1
  00428	5b		 pop	 ebx

; 2168 : }

  00429	8b e5		 mov	 esp, ebp
  0042b	5d		 pop	 ebp
  0042c	c2 10 00	 ret	 16			; 00000010H
$LN15@KdpSendWai:

; 2100 : 
; 2101 :           case DbgKdContinueApi:
; 2102 :             KDDBG("KdContinue(%08x)\n",
; 2103 :                   ManipulateState.Continue.ContinueStatus);
; 2104 :             if (NT_SUCCESS(ManipulateState.Continue.ContinueStatus)) {
; 2105 :                 return ContinueSuccess;
; 2106 :             }
; 2107 :             else {
; 2108 :                 return ContinueError;
; 2109 :             }
; 2110 :             break;
; 2111 : 
; 2112 :           case DbgKdContinueApi2:
; 2113 :             KDDBG("KdContinue2(%08x)\n",
; 2114 :                   ManipulateState.Continue2.ContinueStatus);
; 2115 :             if (NT_SUCCESS(ManipulateState.Continue2.ContinueStatus)) {
; 2116 :                 KDDBG("KdpGetStateChange()\n");
; 2117 :                 KdpGetStateChange(&ManipulateState, Context);

  0042f	8b 55 14	 mov	 edx, DWORD PTR _Context$[ebp]
  00432	8d 4d cc	 lea	 ecx, DWORD PTR _ManipulateState$[ebp+16]
  00435	e8 00 00 00 00	 call	 ?KdpSetControlSet@@YIXPBUStruct_Microsoft_Singularity_Kd_X86KdControlSet@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ; KdpSetControlSet
  0043a	5f		 pop	 edi
  0043b	5e		 pop	 esi

; 2118 :                 return ContinueSuccess;

  0043c	b8 01 00 00 00	 mov	 eax, 1
  00441	5b		 pop	 ebx

; 2168 : }

  00442	8b e5		 mov	 esp, ebp
  00444	5d		 pop	 ebp
  00445	c2 10 00	 ret	 16			; 00000010H
$LN5@KdpSendWai:

; 2142 : 
; 2143 :           case DbgKdSwitchProcessor:
; 2144 :               {
; 2145 :                   // KdRestore(FALSE);
; 2146 :                   bool switched = Class_Microsoft_Singularity_MpExecution::g_SwitchFrozenProcessor((int32) ManipulateState.Processor);
; 2147 :                   return (switched == true) ? ContinueNextProcessor : ContinueSuccess;

  00448	0f b7 4d c2	 movzx	 ecx, WORD PTR _ManipulateState$[ebp+6]
  0044c	e8 00 00 00 00	 call	 ?g_SwitchFrozenProcessor@Class_Microsoft_Singularity_MpExecution@@SI_NH@Z ; Class_Microsoft_Singularity_MpExecution::g_SwitchFrozenProcessor
  00451	2c 01		 sub	 al, 1
  00453	f6 d8		 neg	 al
  00455	5f		 pop	 edi
  00456	5e		 pop	 esi
  00457	5b		 pop	 ebx
  00458	1b c0		 sbb	 eax, eax
  0045a	83 e0 fe	 and	 eax, -2			; fffffffeH
  0045d	83 c0 03	 add	 eax, 3

; 2168 : }

  00460	8b e5		 mov	 esp, ebp
  00462	5d		 pop	 ebp
  00463	c2 10 00	 ret	 16			; 00000010H
  00466	8b ff		 npad	 2
$LN100@KdpSendWai:
  00468	00 00 00 00	 DD	 $LN43@KdpSendWai
  0046c	00 00 00 00	 DD	 $LN41@KdpSendWai
  00470	00 00 00 00	 DD	 $LN37@KdpSendWai
  00474	00 00 00 00	 DD	 $LN27@KdpSendWai
  00478	00 00 00 00	 DD	 $LN25@KdpSendWai
  0047c	00 00 00 00	 DD	 $LN23@KdpSendWai
  00480	00 00 00 00	 DD	 $LN98@KdpSendWai
  00484	00 00 00 00	 DD	 $LN35@KdpSendWai
  00488	00 00 00 00	 DD	 $LN33@KdpSendWai
  0048c	00 00 00 00	 DD	 $LN31@KdpSendWai
  00490	00 00 00 00	 DD	 $LN29@KdpSendWai
  00494	00 00 00 00	 DD	 $LN15@KdpSendWai
  00498	00 00 00 00	 DD	 $LN9@KdpSendWai
  0049c	00 00 00 00	 DD	 $LN7@KdpSendWai
  004a0	00 00 00 00	 DD	 $LN39@KdpSendWai
  004a4	00 00 00 00	 DD	 $LN5@KdpSendWai
  004a8	00 00 00 00	 DD	 $LN4@KdpSendWai
  004ac	00 00 00 00	 DD	 $LN3@KdpSendWai
  004b0	00 00 00 00	 DD	 $LN2@KdpSendWai
$LN99@KdpSendWai:
  004b4	00		 DB	 0
  004b5	01		 DB	 1
  004b6	02		 DB	 2
  004b7	03		 DB	 3
  004b8	04		 DB	 4
  004b9	05		 DB	 5
  004ba	06		 DB	 6
  004bb	07		 DB	 7
  004bc	08		 DB	 8
  004bd	09		 DB	 9
  004be	0a		 DB	 10			; 0000000aH
  004bf	12		 DB	 18			; 00000012H
  004c0	0b		 DB	 11			; 0000000bH
  004c1	0c		 DB	 12			; 0000000cH
  004c2	0d		 DB	 13			; 0000000dH
  004c3	12		 DB	 18			; 00000012H
  004c4	12		 DB	 18			; 00000012H
  004c5	12		 DB	 18			; 00000012H
  004c6	12		 DB	 18			; 00000012H
  004c7	12		 DB	 18			; 00000012H
  004c8	12		 DB	 18			; 00000012H
  004c9	12		 DB	 18			; 00000012H
  004ca	0e		 DB	 14			; 0000000eH
  004cb	12		 DB	 18			; 00000012H
  004cc	12		 DB	 18			; 00000012H
  004cd	12		 DB	 18			; 00000012H
  004ce	12		 DB	 18			; 00000012H
  004cf	12		 DB	 18			; 00000012H
  004d0	12		 DB	 18			; 00000012H
  004d1	12		 DB	 18			; 00000012H
  004d2	12		 DB	 18			; 00000012H
  004d3	12		 DB	 18			; 00000012H
  004d4	0f		 DB	 15			; 0000000fH
  004d5	12		 DB	 18			; 00000012H
  004d6	10		 DB	 16			; 00000010H
  004d7	11		 DB	 17			; 00000011H
?KdpSendWaitContinue@@YI?AW4KCONTINUE_STATUS@@KPAU_STRING@@0PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ENDP ; KdpSendWaitContinue
_TEXT	ENDS
PUBLIC	?KdPrintString@@YIHPAU_STRING@@H@Z		; KdPrintString
; Function compile flags: /Ogtp
;	COMDAT ?KdPrintString@@YIHPAU_STRING@@H@Z
_TEXT	SEGMENT
_DebugIo$ = -36						; size = 16
_MessageHeader$ = -20					; size = 8
_MessageData$ = -12					; size = 8
_Length$ = -4						; size = 4
?KdPrintString@@YIHPAU_STRING@@H@Z PROC			; KdPrintString, COMDAT
; _Output$ = ecx
; _Unicode$ = edx

; 2186 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 2187 : 
; 2188 :     UINT32 Length;
; 2189 :     STRING MessageData;
; 2190 :     STRING MessageHeader;
; 2191 :     DBGKD_DEBUG_IO DebugIo;
; 2192 : 
; 2193 :     if (KdDebuggerNotPresent) {

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?KdDebuggerNotPresent@@3HA, 0 ; KdDebuggerNotPresent
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b fa		 mov	 edi, edx
  00011	8b f1		 mov	 esi, ecx

; 2194 :         return FALSE;

  00013	0f 85 ae 00 00
	00		 jne	 $LN14@KdPrintStr

; 2195 :     }
; 2196 :     KdpLock();

  00019	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdpLock@@3P6IXXZA ; KdpLock

; 2197 : 
; 2198 :     // Move the output string to the message buffer.
; 2199 :     //
; 2200 :     if (Unicode) {

  0001f	85 ff		 test	 edi, edi

; 2201 :         WCHAR *pBuffer = (WCHAR *)Output->Buffer;

  00021	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00024	74 22		 je	 SHORT $LN6@KdPrintStr

; 2202 :         for (int i = 0; i < Output->Length; i++) {

  00026	33 c0		 xor	 eax, eax
  00028	66 39 06	 cmp	 WORD PTR [esi], ax
  0002b	76 16		 jbe	 SHORT $LN3@KdPrintStr
  0002d	8d 49 00	 npad	 3
$LL5@KdPrintStr:

; 2203 :             KdpMessageBuffer[i] = (char)pBuffer[i];

  00030	8a 14 41	 mov	 dl, BYTE PTR [ecx+eax*2]
  00033	88 90 00 00 00
	00		 mov	 BYTE PTR _KdpMessageBuffer[eax], dl
  00039	0f b7 16	 movzx	 edx, WORD PTR [esi]
  0003c	83 c0 01	 add	 eax, 1
  0003f	3b c2		 cmp	 eax, edx
  00041	7c ed		 jl	 SHORT $LL5@KdPrintStr
$LN3@KdPrintStr:

; 2204 :         }
; 2205 :         Length = Output->Length;

  00043	0f b7 36	 movzx	 esi, WORD PTR [esi]

; 2206 :     }
; 2207 :     else {

  00046	eb 1b		 jmp	 SHORT $LN2@KdPrintStr
$LN6@KdPrintStr:

; 2208 :         KdpCopyFromPtr(KdpMessageBuffer,
; 2209 :                        Output->Buffer,
; 2210 :                        Output->Length,
; 2211 :                        &Length);

  00048	0f b7 16	 movzx	 edx, WORD PTR [esi]
  0004b	8d 45 fc	 lea	 eax, DWORD PTR _Length$[ebp]
  0004e	50		 push	 eax
  0004f	6a 04		 push	 4
  00051	6a 00		 push	 0
  00053	6a 00		 push	 0
  00055	51		 push	 ecx
  00056	b9 00 00 00 00	 mov	 ecx, OFFSET _KdpMessageBuffer
  0005b	e8 00 00 00 00	 call	 ?KdpCopyMemoryChunks@@YIK_KPAXKKKPAK@Z ; KdpCopyMemoryChunks
  00060	8b 75 fc	 mov	 esi, DWORD PTR _Length$[ebp]
$LN2@KdPrintStr:

; 2212 :     }
; 2213 : 
; 2214 :     // If the total message length is greater than the maximum packet size,
; 2215 :     // then truncate the output string.
; 2216 :     //
; 2217 :     if ((sizeof(DBGKD_DEBUG_IO) + Length) > PACKET_MAX_SIZE) {

  00063	8d 56 10	 lea	 edx, DWORD PTR [esi+16]
  00066	81 fa a0 0f 00
	00		 cmp	 edx, 4000		; 00000fa0H
  0006c	76 05		 jbe	 SHORT $LN1@KdPrintStr

; 2218 :         Length = PACKET_MAX_SIZE - sizeof(DBGKD_DEBUG_IO);

  0006e	be 90 0f 00 00	 mov	 esi, 3984		; 00000f90H
$LN1@KdPrintStr:

; 2219 :     }
; 2220 : 
; 2221 :     // Construct the print string message and message descriptor.
; 2222 :     //
; 2223 :     DebugIo.ApiNumber = DbgKdPrintStringApi;

  00073	c7 45 dc 30 32
	00 00		 mov	 DWORD PTR _DebugIo$[ebp], 12848 ; 00003230H

; 2224 :     DebugIo.ProcessorLevel = KeProcessorLevel;

  0007a	66 c7 45 e0 0f
	00		 mov	 WORD PTR _DebugIo$[ebp+4], 15 ; 0000000fH

; 2225 :     DebugIo.Processor = (UINT16)KdpGetCurrentProcessorNumber();

  00080	e8 00 00 00 00	 call	 ?g_GetCurrentCpu@Class_Microsoft_Singularity_Isal_Isa@@SIPAUStruct_Microsoft_Singularity_Isal_CpuRecord@@XZ ; Class_Microsoft_Singularity_Isal_Isa::g_GetCurrentCpu
  00085	66 8b 80 40 02
	00 00		 mov	 ax, WORD PTR [eax+576]

; 2226 :     DebugIo.PrintString.LengthOfString = Length;
; 2227 :     MessageHeader.Length = sizeof(DBGKD_DEBUG_IO);
; 2228 :     MessageHeader.Buffer = (PCHAR)&DebugIo;

  0008c	8d 4d dc	 lea	 ecx, DWORD PTR _DebugIo$[ebp]

; 2229 : 
; 2230 :     // Construct the print string data and data descriptor.
; 2231 :     //
; 2232 :     MessageData.Length = (UINT16)Length;
; 2233 :     MessageData.Buffer = (PCHAR) KdpMessageBuffer;
; 2234 : 
; 2235 :     // Send packet to the kernel debugger on the host machine.
; 2236 :     //
; 2237 :     KdSendPacket(PACKET_TYPE_KD_DEBUG_IO,
; 2238 :                  &MessageHeader,
; 2239 :                  &MessageData,
; 2240 :                  &KdpContext);

  0008f	68 00 00 00 00	 push	 OFFSET _KdpContext
  00094	8d 55 f4	 lea	 edx, DWORD PTR _MessageData$[ebp]
  00097	89 4d f0	 mov	 DWORD PTR _MessageHeader$[ebp+4], ecx
  0009a	52		 push	 edx
  0009b	8d 55 ec	 lea	 edx, DWORD PTR _MessageHeader$[ebp]
  0009e	b9 03 00 00 00	 mov	 ecx, 3
  000a3	66 89 45 e2	 mov	 WORD PTR _DebugIo$[ebp+6], ax
  000a7	89 75 e4	 mov	 DWORD PTR _DebugIo$[ebp+8], esi
  000aa	66 c7 45 ec 10
	00		 mov	 WORD PTR _MessageHeader$[ebp], 16 ; 00000010H
  000b0	66 89 75 f4	 mov	 WORD PTR _MessageData$[ebp], si
  000b4	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _MessageData$[ebp+4], OFFSET _KdpMessageBuffer
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket

; 2241 : 
; 2242 :     KdpUnlock();

  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdpUnlock@@3P6IXXZA ; KdpUnlock
$LN14@KdPrintStr:
  000c7	5f		 pop	 edi

; 2243 : 
; 2244 :     return FALSE;

  000c8	33 c0		 xor	 eax, eax
  000ca	5e		 pop	 esi

; 2245 : }

  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
?KdPrintString@@YIHPAU_STRING@@H@Z ENDP			; KdPrintString
_TEXT	ENDS
PUBLIC	?g_AddProcessor@Class_Microsoft_Singularity_DebugStub@@SIXH@Z ; Class_Microsoft_Singularity_DebugStub::g_AddProcessor
; Function compile flags: /Ogtp
;	COMDAT ?g_AddProcessor@Class_Microsoft_Singularity_DebugStub@@SIXH@Z
_TEXT	SEGMENT
?g_AddProcessor@Class_Microsoft_Singularity_DebugStub@@SIXH@Z PROC ; Class_Microsoft_Singularity_DebugStub::g_AddProcessor, COMDAT
; _cpuId$ = ecx

; 2318 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2319 :     KdpLock();

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdpLock@@3P6IXXZA ; KdpLock

; 2320 :     if (KeNumberProcessors <= cpuId) {

  00009	39 35 00 00 00
	00		 cmp	 DWORD PTR _KeNumberProcessors, esi
  0000f	7f 09		 jg	 SHORT $LN1@g_AddProce

; 2321 :         KeNumberProcessors = cpuId + 1;

  00011	83 c6 01	 add	 esi, 1
  00014	89 35 00 00 00
	00		 mov	 DWORD PTR _KeNumberProcessors, esi
$LN1@g_AddProce:
  0001a	5e		 pop	 esi

; 2322 :     }
; 2323 :     KdpUnlock();

  0001b	ff 25 00 00 00
	00		 jmp	 DWORD PTR ?KdpUnlock@@3P6IXXZA ; KdpUnlock
?g_AddProcessor@Class_Microsoft_Singularity_DebugStub@@SIXH@Z ENDP ; Class_Microsoft_Singularity_DebugStub::g_AddProcessor
_TEXT	ENDS
PUBLIC	?g_PollForBreak@Class_Microsoft_Singularity_DebugStub@@SI_NXZ ; Class_Microsoft_Singularity_DebugStub::g_PollForBreak
; Function compile flags: /Ogtp
;	COMDAT ?g_PollForBreak@Class_Microsoft_Singularity_DebugStub@@SI_NXZ
_TEXT	SEGMENT
?g_PollForBreak@Class_Microsoft_Singularity_DebugStub@@SI_NXZ PROC ; Class_Microsoft_Singularity_DebugStub::g_PollForBreak, COMDAT

; 2328 :     // Don't re-enter debugger if already debugging.
; 2329 :     if (KdpInDebugger) {

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdpInDebugger
  00005	85 c0		 test	 eax, eax
  00007	74 03		 je	 SHORT $LN3@g_PollForB
$LN6@g_PollForB:

; 2330 :         return FALSE;

  00009	32 c0		 xor	 al, al

; 2351 : }

  0000b	c3		 ret	 0
$LN3@g_PollForB:

; 2331 :     }
; 2332 : 
; 2333 :     // If the debugger is enabled, see if a breakin by the kernel
; 2334 :     // debugger is pending.
; 2335 :     // We might want to enable retry here.  The transports support it.
; 2336 :     if (KdDebuggerNotPresent) {

  0000c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?KdDebuggerNotPresent@@3HA, 0 ; KdDebuggerNotPresent

; 2337 :         return false;

  00013	75 f4		 jne	 SHORT $LN6@g_PollForB

; 2338 :     }
; 2339 : 
; 2340 :     // Did we already record a break from the host?
; 2341 :     if (KdpContext.KdpControlCPending) {

  00015	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR _KdpContext+4, 0
  0001c	74 0d		 je	 SHORT $LN1@g_PollForB

; 2342 :         KdpContext.KdpControlCPending = FALSE;

  0001e	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _KdpContext+4, 0

; 2343 :         return true;

  00028	b0 01		 mov	 al, 1

; 2351 : }

  0002a	c3		 ret	 0
$LN1@g_PollForB:
  0002b	53		 push	 ebx

; 2344 :     }
; 2345 : 
; 2346 :     KdpLock();

  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdpLock@@3P6IXXZA ; KdpLock

; 2347 :     bool success = KdPollBreakIn();

  00032	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdPollBreakIn@@3P6I_NXZA ; KdPollBreakIn
  00038	8a d8		 mov	 bl, al

; 2348 :     KdpUnlock();

  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdpUnlock@@3P6IXXZA ; KdpUnlock

; 2349 : 
; 2350 :     return success;

  00040	8a c3		 mov	 al, bl
  00042	5b		 pop	 ebx

; 2351 : }

  00043	c3		 ret	 0
?g_PollForBreak@Class_Microsoft_Singularity_DebugStub@@SI_NXZ ENDP ; Class_Microsoft_Singularity_DebugStub::g_PollForBreak
_TEXT	ENDS
PUBLIC	?g_LoadedBinary@Class_Microsoft_Singularity_DebugStub@@SI_NPAUuintPtr@@00II_N@Z ; Class_Microsoft_Singularity_DebugStub::g_LoadedBinary
EXTRN	?KdNotifyTrap@@YIXPAUKdDebugTrapData@@@Z:PROC	; KdNotifyTrap
; Function compile flags: /Ogtp
;	COMDAT ?g_LoadedBinary@Class_Microsoft_Singularity_DebugStub@@SI_NPAUuintPtr@@00II_N@Z
_TEXT	SEGMENT
_trapData$ = -28					; size = 28
_name$ = 8						; size = 4
_checksum$ = 12						; size = 4
_timestamp$ = 16					; size = 4
_silent$ = 20						; size = 1
?g_LoadedBinary@Class_Microsoft_Singularity_DebugStub@@SI_NPAUuintPtr@@00II_N@Z PROC ; Class_Microsoft_Singularity_DebugStub::g_LoadedBinary, COMDAT
; _baseAddress$ = ecx
; _bytes$ = edx

; 2374 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 2375 :     if (KdDebuggerNotPresent) {

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?KdDebuggerNotPresent@@3HA, 0 ; KdDebuggerNotPresent
  0000d	74 08		 je	 SHORT $LN1@g_LoadedBi

; 2376 :         return true;

  0000f	b0 01		 mov	 al, 1

; 2390 : }

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 10 00	 ret	 16			; 00000010H
$LN1@g_LoadedBi:

; 2377 :     }
; 2378 : 
; 2379 :     KdDebugTrapData trapData;
; 2380 :     trapData.tag = KdDebugTrapData::LOADED_BINARY;
; 2381 :     trapData.loadedBinary.baseAddress = baseAddress;
; 2382 :     trapData.loadedBinary.bytes = bytes;
; 2383 :     trapData.loadedBinary.name = name;

  00017	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  0001a	89 4d e8	 mov	 DWORD PTR _trapData$[ebp+4], ecx

; 2384 :     trapData.loadedBinary.checksum = checksum;

  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR _checksum$[ebp]
  00020	89 55 ec	 mov	 DWORD PTR _trapData$[ebp+8], edx

; 2385 :     trapData.loadedBinary.timestamp = timestamp;

  00023	8b 55 10	 mov	 edx, DWORD PTR _timestamp$[ebp]
  00026	89 45 f0	 mov	 DWORD PTR _trapData$[ebp+12], eax

; 2386 :     trapData.loadedBinary.silent = silent;

  00029	8a 45 14	 mov	 al, BYTE PTR _silent$[ebp]
  0002c	89 4d f4	 mov	 DWORD PTR _trapData$[ebp+16], ecx

; 2387 :     KdNotifyTrap(&trapData);

  0002f	8d 4d e4	 lea	 ecx, DWORD PTR _trapData$[ebp]
  00032	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _trapData$[ebp], 1
  00039	89 55 f8	 mov	 DWORD PTR _trapData$[ebp+20], edx
  0003c	88 45 fc	 mov	 BYTE PTR _trapData$[ebp+24], al
  0003f	e8 00 00 00 00	 call	 ?KdNotifyTrap@@YIXPAUKdDebugTrapData@@@Z ; KdNotifyTrap

; 2388 : 
; 2389 :     return trapData.loadedBinary.ret;

  00044	8a 45 fd	 mov	 al, BYTE PTR _trapData$[ebp+25]

; 2390 : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 10 00	 ret	 16			; 00000010H
?g_LoadedBinary@Class_Microsoft_Singularity_DebugStub@@SI_NPAUuintPtr@@00II_N@Z ENDP ; Class_Microsoft_Singularity_DebugStub::g_LoadedBinary
_TEXT	ENDS
PUBLIC	?g_UnloadedBinary@Class_Microsoft_Singularity_DebugStub@@SI_NPAUuintPtr@@_N@Z ; Class_Microsoft_Singularity_DebugStub::g_UnloadedBinary
; Function compile flags: /Ogtp
;	COMDAT ?g_UnloadedBinary@Class_Microsoft_Singularity_DebugStub@@SI_NPAUuintPtr@@_N@Z
_TEXT	SEGMENT
_trapData$ = -28					; size = 28
?g_UnloadedBinary@Class_Microsoft_Singularity_DebugStub@@SI_NPAUuintPtr@@_N@Z PROC ; Class_Microsoft_Singularity_DebugStub::g_UnloadedBinary, COMDAT
; _baseAddress$ = ecx
; _silent$ = dl

; 2461 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 2462 :     if (KdDebuggerNotPresent) {

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?KdDebuggerNotPresent@@3HA, 0 ; KdDebuggerNotPresent
  0000d	74 06		 je	 SHORT $LN1@g_Unloaded

; 2463 :         return true;

  0000f	b0 01		 mov	 al, 1

; 2473 : }

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
$LN1@g_Unloaded:

; 2464 :     }
; 2465 : 
; 2466 :     KdDebugTrapData trapData;
; 2467 :     trapData.tag = KdDebugTrapData::UNLOADED_BINARY;
; 2468 :     trapData.unloadedBinary.baseAddress = baseAddress;

  00015	89 4d e8	 mov	 DWORD PTR _trapData$[ebp+4], ecx

; 2469 :     trapData.unloadedBinary.silent = silent;
; 2470 :     KdNotifyTrap(&trapData);

  00018	8d 4d e4	 lea	 ecx, DWORD PTR _trapData$[ebp]
  0001b	c7 45 e4 02 00
	00 00		 mov	 DWORD PTR _trapData$[ebp], 2
  00022	88 55 ec	 mov	 BYTE PTR _trapData$[ebp+8], dl
  00025	e8 00 00 00 00	 call	 ?KdNotifyTrap@@YIXPAUKdDebugTrapData@@@Z ; KdNotifyTrap

; 2471 : 
; 2472 :     return trapData.unloadedBinary.ret;

  0002a	8a 45 ed	 mov	 al, BYTE PTR _trapData$[ebp+9]

; 2473 : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?g_UnloadedBinary@Class_Microsoft_Singularity_DebugStub@@SI_NPAUuintPtr@@_N@Z ENDP ; Class_Microsoft_Singularity_DebugStub::g_UnloadedBinary
_TEXT	ENDS
PUBLIC	?g_IsDebuggerPresent@Class_Microsoft_Singularity_DebugStub@@SI_NXZ ; Class_Microsoft_Singularity_DebugStub::g_IsDebuggerPresent
; Function compile flags: /Ogtp
;	COMDAT ?g_IsDebuggerPresent@Class_Microsoft_Singularity_DebugStub@@SI_NXZ
_TEXT	SEGMENT
?g_IsDebuggerPresent@Class_Microsoft_Singularity_DebugStub@@SI_NXZ PROC ; Class_Microsoft_Singularity_DebugStub::g_IsDebuggerPresent, COMDAT

; 2518 :     return !KdDebuggerNotPresent;

  00000	33 c0		 xor	 eax, eax
  00002	39 05 00 00 00
	00		 cmp	 DWORD PTR ?KdDebuggerNotPresent@@3HA, eax ; KdDebuggerNotPresent
  00008	0f 94 c0	 sete	 al

; 2519 : }

  0000b	c3		 ret	 0
?g_IsDebuggerPresent@Class_Microsoft_Singularity_DebugStub@@SI_NXZ ENDP ; Class_Microsoft_Singularity_DebugStub::g_IsDebuggerPresent
_TEXT	ENDS
PUBLIC	?g_PrintBegin@Class_Microsoft_Singularity_DebugStub@@SIXPAPA_WPAH@Z ; Class_Microsoft_Singularity_DebugStub::g_PrintBegin
; Function compile flags: /Ogtp
;	COMDAT ?g_PrintBegin@Class_Microsoft_Singularity_DebugStub@@SIXPAPA_WPAH@Z
_TEXT	SEGMENT
?g_PrintBegin@Class_Microsoft_Singularity_DebugStub@@SIXPAPA_WPAH@Z PROC ; Class_Microsoft_Singularity_DebugStub::g_PrintBegin, COMDAT
; _buffer$ = ecx
; _length$ = edx

; 2525 :     if (KdDebuggerNotPresent && !KdAlwaysPrintOutput) {

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?KdDebuggerNotPresent@@3HA, 0 ; KdDebuggerNotPresent
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f2		 mov	 esi, edx
  0000b	8b f9		 mov	 edi, ecx
  0000d	74 18		 je	 SHORT $LN2@g_PrintBeg
  0000f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?KdAlwaysPrintOutput@@3HA, 0 ; KdAlwaysPrintOutput
  00016	75 0f		 jne	 SHORT $LN2@g_PrintBeg

; 2526 : 
; 2527 :         *buffer = NULL;

  00018	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  0001e	5f		 pop	 edi

; 2528 :         *length = 0;

  0001f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00025	5e		 pop	 esi

; 2536 :     }
; 2537 : }

  00026	c3		 ret	 0
$LN2@g_PrintBeg:

; 2529 :         return;
; 2530 :     }
; 2531 :     else {
; 2532 :         KdpLock();

  00027	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdpLock@@3P6IXXZA ; KdpLock

; 2533 : 
; 2534 :         *buffer = (WCHAR *)KdpMessageBuffer;

  0002d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET _KdpMessageBuffer
  00033	5f		 pop	 edi

; 2535 :         *length = sizeof(KdpMessageBuffer) / sizeof(WCHAR);

  00034	c7 06 00 08 00
	00		 mov	 DWORD PTR [esi], 2048	; 00000800H
  0003a	5e		 pop	 esi

; 2536 :     }
; 2537 : }

  0003b	c3		 ret	 0
?g_PrintBegin@Class_Microsoft_Singularity_DebugStub@@SIXPAPA_WPAH@Z ENDP ; Class_Microsoft_Singularity_DebugStub::g_PrintBegin
_TEXT	ENDS
PUBLIC	?g_PrintComplete@Class_Microsoft_Singularity_DebugStub@@SIXPA_WH@Z ; Class_Microsoft_Singularity_DebugStub::g_PrintComplete
; Function compile flags: /Ogtp
;	COMDAT ?g_PrintComplete@Class_Microsoft_Singularity_DebugStub@@SIXPA_WH@Z
_TEXT	SEGMENT
_DebugIo$ = -32						; size = 16
_MessageHeader$ = -16					; size = 8
_MessageData$ = -8					; size = 8
?g_PrintComplete@Class_Microsoft_Singularity_DebugStub@@SIXPA_WH@Z PROC ; Class_Microsoft_Singularity_DebugStub::g_PrintComplete, COMDAT
; _buffer$ = ecx
; _length$ = edx

; 2541 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 2542 :     if (KdDebuggerNotPresent && !KdAlwaysPrintOutput) {

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?KdDebuggerNotPresent@@3HA, 0 ; KdDebuggerNotPresent
  0000d	56		 push	 esi
  0000e	8b f2		 mov	 esi, edx
  00010	74 0d		 je	 SHORT $LN6@g_PrintCom
  00012	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?KdAlwaysPrintOutput@@3HA, 0 ; KdAlwaysPrintOutput
  00019	0f 84 8c 00 00
	00		 je	 $LN7@g_PrintCom
$LN6@g_PrintCom:

; 2543 :         return;
; 2544 :     }
; 2545 : 
; 2546 :     CHAR *out = KdpMessageBuffer;
; 2547 :     if (length > arrayof(KdpMessageBuffer)) {

  0001f	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  00025	b8 00 00 00 00	 mov	 eax, OFFSET _KdpMessageBuffer
  0002a	76 05		 jbe	 SHORT $LN5@g_PrintCom

; 2548 :         length = arrayof(KdpMessageBuffer);

  0002c	be 00 10 00 00	 mov	 esi, 4096		; 00001000H
$LN5@g_PrintCom:

; 2549 :     }
; 2550 : 
; 2551 :     for (int i = 0; i < length; i++) {

  00031	85 f6		 test	 esi, esi
  00033	7e 13		 jle	 SHORT $LN2@g_PrintCom
  00035	57		 push	 edi
  00036	8b fe		 mov	 edi, esi
$LL4@g_PrintCom:

; 2552 :         *out++ = (CHAR)*buffer++;

  00038	8a 11		 mov	 dl, BYTE PTR [ecx]
  0003a	88 10		 mov	 BYTE PTR [eax], dl
  0003c	83 c0 01	 add	 eax, 1
  0003f	83 c1 02	 add	 ecx, 2
  00042	83 ef 01	 sub	 edi, 1
  00045	75 f1		 jne	 SHORT $LL4@g_PrintCom
  00047	5f		 pop	 edi
$LN2@g_PrintCom:

; 2553 :     }
; 2554 : 
; 2555 :     // If the total message length is greater than the maximum packet size,
; 2556 :     // then truncate the output string.
; 2557 :     //
; 2558 :     if ((sizeof(DBGKD_DEBUG_IO) + length) > PACKET_MAX_SIZE) {

  00048	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  0004b	3d a0 0f 00 00	 cmp	 eax, 4000		; 00000fa0H
  00050	76 05		 jbe	 SHORT $LN1@g_PrintCom

; 2559 :         length = PACKET_MAX_SIZE - sizeof(DBGKD_DEBUG_IO);

  00052	be 90 0f 00 00	 mov	 esi, 3984		; 00000f90H
$LN1@g_PrintCom:

; 2560 :     }
; 2561 : 
; 2562 :     //
; 2563 :     // Construct the print string message and message descriptor.
; 2564 :     //
; 2565 :     DBGKD_DEBUG_IO DebugIo;
; 2566 :     DebugIo.ApiNumber = DbgKdPrintStringApi;

  00057	c7 45 e0 30 32
	00 00		 mov	 DWORD PTR _DebugIo$[ebp], 12848 ; 00003230H

; 2567 :     DebugIo.ProcessorLevel = KeProcessorLevel;

  0005e	66 c7 45 e4 0f
	00		 mov	 WORD PTR _DebugIo$[ebp+4], 15 ; 0000000fH

; 2568 :     DebugIo.Processor = (UINT16)KdpGetCurrentProcessorNumber();

  00064	e8 00 00 00 00	 call	 ?g_GetCurrentCpu@Class_Microsoft_Singularity_Isal_Isa@@SIPAUStruct_Microsoft_Singularity_Isal_CpuRecord@@XZ ; Class_Microsoft_Singularity_Isal_Isa::g_GetCurrentCpu
  00069	66 8b 88 40 02
	00 00		 mov	 cx, WORD PTR [eax+576]

; 2569 :     DebugIo.PrintString.LengthOfString = length;
; 2570 : 
; 2571 :     STRING MessageHeader;
; 2572 :     MessageHeader.Length = sizeof(DBGKD_DEBUG_IO);
; 2573 :     MessageHeader.Buffer = (PCHAR)&DebugIo;

  00070	8d 55 e0	 lea	 edx, DWORD PTR _DebugIo$[ebp]

; 2574 : 
; 2575 :     //
; 2576 :     // Construct the print string data and data descriptor.
; 2577 :     //
; 2578 :     STRING MessageData;
; 2579 :     MessageData.Length = (UINT16)length;
; 2580 :     MessageData.Buffer = KdpMessageBuffer;
; 2581 : 
; 2582 :     //
; 2583 :     // Send packet to the kernel debugger on the host machine.
; 2584 :     //
; 2585 :     KdSendPacket(PACKET_TYPE_KD_DEBUG_IO,
; 2586 :                  &MessageHeader,
; 2587 :                  &MessageData,
; 2588 :                  &KdpContext);

  00073	68 00 00 00 00	 push	 OFFSET _KdpContext
  00078	8d 45 f8	 lea	 eax, DWORD PTR _MessageData$[ebp]
  0007b	66 89 4d e6	 mov	 WORD PTR _DebugIo$[ebp+6], cx
  0007f	89 55 f4	 mov	 DWORD PTR _MessageHeader$[ebp+4], edx
  00082	50		 push	 eax
  00083	8d 55 f0	 lea	 edx, DWORD PTR _MessageHeader$[ebp]
  00086	b9 03 00 00 00	 mov	 ecx, 3
  0008b	89 75 e8	 mov	 DWORD PTR _DebugIo$[ebp+8], esi
  0008e	66 c7 45 f0 10
	00		 mov	 WORD PTR _MessageHeader$[ebp], 16 ; 00000010H
  00094	66 89 75 f8	 mov	 WORD PTR _MessageData$[ebp], si
  00098	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _MessageData$[ebp+4], OFFSET _KdpMessageBuffer
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket

; 2589 : 
; 2590 :     KdpUnlock();

  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdpUnlock@@3P6IXXZA ; KdpUnlock
$LN7@g_PrintCom:
  000ab	5e		 pop	 esi

; 2591 : }

  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c3		 ret	 0
?g_PrintComplete@Class_Microsoft_Singularity_DebugStub@@SIXPA_WH@Z ENDP ; Class_Microsoft_Singularity_DebugStub::g_PrintComplete
_TEXT	ENDS
PUBLIC	?g_Print@Class_Microsoft_Singularity_DebugStub@@SIXPA_WH@Z ; Class_Microsoft_Singularity_DebugStub::g_Print
; Function compile flags: /Ogtp
;	COMDAT ?g_Print@Class_Microsoft_Singularity_DebugStub@@SIXPA_WH@Z
_TEXT	SEGMENT
?g_Print@Class_Microsoft_Singularity_DebugStub@@SIXPA_WH@Z PROC ; Class_Microsoft_Singularity_DebugStub::g_Print, COMDAT
; _buf$ = ecx
; _len$ = edx

; 2595 :     WCHAR *buffer;
; 2596 :     int length;
; 2597 : 
; 2598 :     if (KdDebuggerNotPresent && !KdAlwaysPrintOutput) {

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?KdDebuggerNotPresent@@3HA, 0 ; KdDebuggerNotPresent
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f2		 mov	 esi, edx
  0000b	8b f9		 mov	 edi, ecx
  0000d	74 09		 je	 SHORT $LN5@g_Print
  0000f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?KdAlwaysPrintOutput@@3HA, 0 ; KdAlwaysPrintOutput
  00016	74 11		 je	 SHORT $LN2@g_Print

; 2599 :         return;
; 2600 :     }
; 2601 : 
; 2602 :     g_PrintBegin(&buffer, &length);

$LN5@g_Print:
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdpLock@@3P6IXXZA ; KdpLock

; 2603 :     g_PrintComplete(buf, len);

  0001e	8b cf		 mov	 ecx, edi
  00020	5f		 pop	 edi
  00021	8b d6		 mov	 edx, esi
  00023	5e		 pop	 esi
  00024	e9 00 00 00 00	 jmp	 ?g_PrintComplete@Class_Microsoft_Singularity_DebugStub@@SIXPA_WH@Z ; Class_Microsoft_Singularity_DebugStub::g_PrintComplete
$LN2@g_Print:
  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi

; 2604 : }

  0002b	c3		 ret	 0
?g_Print@Class_Microsoft_Singularity_DebugStub@@SIXPA_WH@Z ENDP ; Class_Microsoft_Singularity_DebugStub::g_Print
_TEXT	ENDS
PUBLIC	?g_Print@Class_Microsoft_Singularity_DebugStub@@SIXPA_W@Z ; Class_Microsoft_Singularity_DebugStub::g_Print
; Function compile flags: /Ogtp
;	COMDAT ?g_Print@Class_Microsoft_Singularity_DebugStub@@SIXPA_W@Z
_TEXT	SEGMENT
?g_Print@Class_Microsoft_Singularity_DebugStub@@SIXPA_W@Z PROC ; Class_Microsoft_Singularity_DebugStub::g_Print, COMDAT
; _buf$ = ecx

; 2607 : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 2608 :     int len = 0;

  00004	33 f6		 xor	 esi, esi

; 2609 : 
; 2610 :     while (buf[len] != '\0') {

  00006	66 39 37	 cmp	 WORD PTR [edi], si
  00009	74 0f		 je	 SHORT $LN1@g_Print@2
  0000b	eb 03 8d 49 00	 npad	 5
$LL2@g_Print@2:

; 2611 :         len++;

  00010	83 c6 01	 add	 esi, 1
  00013	66 83 3c 77 00	 cmp	 WORD PTR [edi+esi*2], 0
  00018	75 f6		 jne	 SHORT $LL2@g_Print@2
$LN1@g_Print@2:

; 2612 :     }
; 2613 :     g_Print(buf, len);

  0001a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?KdDebuggerNotPresent@@3HA, 0 ; KdDebuggerNotPresent
  00021	74 09		 je	 SHORT $LN9@g_Print@2
  00023	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?KdAlwaysPrintOutput@@3HA, 0 ; KdAlwaysPrintOutput
  0002a	74 11		 je	 SHORT $LN6@g_Print@2
$LN9@g_Print@2:
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdpLock@@3P6IXXZA ; KdpLock
  00032	8b cf		 mov	 ecx, edi
  00034	5f		 pop	 edi
  00035	8b d6		 mov	 edx, esi
  00037	5e		 pop	 esi
  00038	e9 00 00 00 00	 jmp	 ?g_PrintComplete@Class_Microsoft_Singularity_DebugStub@@SIXPA_WH@Z ; Class_Microsoft_Singularity_DebugStub::g_PrintComplete
$LN6@g_Print@2:
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi

; 2614 : }

  0003f	c3		 ret	 0
?g_Print@Class_Microsoft_Singularity_DebugStub@@SIXPA_W@Z ENDP ; Class_Microsoft_Singularity_DebugStub::g_Print
_TEXT	ENDS
PUBLIC	?g_RevertToUniprocessor@Class_Microsoft_Singularity_DebugStub@@SIXXZ ; Class_Microsoft_Singularity_DebugStub::g_RevertToUniprocessor
; Function compile flags: /Ogtp
;	COMDAT ?g_RevertToUniprocessor@Class_Microsoft_Singularity_DebugStub@@SIXXZ
_TEXT	SEGMENT
?g_RevertToUniprocessor@Class_Microsoft_Singularity_DebugStub@@SIXXZ PROC ; Class_Microsoft_Singularity_DebugStub::g_RevertToUniprocessor, COMDAT

; 2618 :     KdpLock();

  00000	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdpLock@@3P6IXXZA ; KdpLock

; 2619 :     KeNumberProcessors = 1;

  00006	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _KeNumberProcessors, 1

; 2620 :     KdpUnlock();

  00010	ff 25 00 00 00
	00		 jmp	 DWORD PTR ?KdpUnlock@@3P6IXXZA ; KdpUnlock
?g_RevertToUniprocessor@Class_Microsoft_Singularity_DebugStub@@SIXXZ ENDP ; Class_Microsoft_Singularity_DebugStub::g_RevertToUniprocessor
_TEXT	ENDS
PUBLIC	?g_SendPacket@Class_Microsoft_Singularity_KernelDebugger_Kd@@SIXIPAEH0H@Z ; Class_Microsoft_Singularity_KernelDebugger_Kd::g_SendPacket
; Function compile flags: /Ogtp
;	COMDAT ?g_SendPacket@Class_Microsoft_Singularity_KernelDebugger_Kd@@SIXIPAEH0H@Z
_TEXT	SEGMENT
_MessageHeaderDesc$ = -16				; size = 8
_MessageDataDesc$ = -8					; size = 8
_MessageHeaderLength$ = 8				; size = 4
_MessageDataBuffer$ = 12				; size = 4
_MessageDataLength$ = 16				; size = 4
?g_SendPacket@Class_Microsoft_Singularity_KernelDebugger_Kd@@SIXIPAEH0H@Z PROC ; Class_Microsoft_Singularity_KernelDebugger_Kd::g_SendPacket, COMDAT
; _PacketType$ = ecx
; _MessageHeaderBuffer$ = edx

; 2629 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 2630 :     ASSERT(MessageHeaderLength >= 0);
; 2631 :     ASSERT(MessageHeaderLength < 0x10000);
; 2632 :     ASSERT(MessageDataLength >= 0);
; 2633 :     ASSERT(MessageDataLength < 0x10000);
; 2634 : 
; 2635 :     STRING MessageHeaderDesc;
; 2636 :     MessageHeaderDesc.Buffer = (PCHAR)MessageHeaderBuffer;
; 2637 :     MessageHeaderDesc.Length = (uint16)MessageHeaderLength;

  00006	8b 45 08	 mov	 eax, DWORD PTR _MessageHeaderLength$[ebp]
  00009	66 89 45 f0	 mov	 WORD PTR _MessageHeaderDesc$[ebp], ax

; 2638 :     MessageHeaderDesc.MaximumLength = (uint16)MessageHeaderLength;

  0000d	66 89 45 f2	 mov	 WORD PTR _MessageHeaderDesc$[ebp+2], ax

; 2639 : 
; 2640 :     STRING MessageDataDesc;
; 2641 :     MessageDataDesc.Buffer = (PCHAR)MessageDataBuffer;

  00011	8b 45 0c	 mov	 eax, DWORD PTR _MessageDataBuffer$[ebp]
  00014	89 55 f4	 mov	 DWORD PTR _MessageHeaderDesc$[ebp+4], edx

; 2642 :     MessageDataDesc.Length = (uint16)MessageDataLength;
; 2643 :     MessageDataDesc.MaximumLength = (uint16)MessageDataLength;
; 2644 : 
; 2645 :     KdSendPacket(
; 2646 :         PacketType,
; 2647 :         &MessageHeaderDesc,
; 2648 :         &MessageDataDesc,
; 2649 :         &KdpContext);

  00017	68 00 00 00 00	 push	 OFFSET _KdpContext
  0001c	8d 55 f8	 lea	 edx, DWORD PTR _MessageDataDesc$[ebp]
  0001f	89 45 fc	 mov	 DWORD PTR _MessageDataDesc$[ebp+4], eax
  00022	8b 45 10	 mov	 eax, DWORD PTR _MessageDataLength$[ebp]
  00025	52		 push	 edx
  00026	8d 55 f0	 lea	 edx, DWORD PTR _MessageHeaderDesc$[ebp]
  00029	66 89 45 f8	 mov	 WORD PTR _MessageDataDesc$[ebp], ax
  0002d	66 89 45 fa	 mov	 WORD PTR _MessageDataDesc$[ebp+2], ax
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA ; KdSendPacket

; 2650 : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 0c 00	 ret	 12			; 0000000cH
?g_SendPacket@Class_Microsoft_Singularity_KernelDebugger_Kd@@SIXIPAEH0H@Z ENDP ; Class_Microsoft_Singularity_KernelDebugger_Kd::g_SendPacket
_TEXT	ENDS
PUBLIC	?g_ReceivePacket@Class_Microsoft_Singularity_KernelDebugger_Kd@@SIIIPAEH0HPAH@Z ; Class_Microsoft_Singularity_KernelDebugger_Kd::g_ReceivePacket
; Function compile flags: /Ogtp
;	COMDAT ?g_ReceivePacket@Class_Microsoft_Singularity_KernelDebugger_Kd@@SIIIPAEH0HPAH@Z
_TEXT	SEGMENT
_MessageHeaderDesc$ = -16				; size = 8
_MessageDataDesc$ = -8					; size = 8
_MessageHeaderLength$ = 8				; size = 4
_MessageDataBuffer$ = 12				; size = 4
_MessageDataBufferLength$ = 16				; size = 4
_DataLength$ = 20					; size = 4
_MessageDataLength$ = 20				; size = 4
?g_ReceivePacket@Class_Microsoft_Singularity_KernelDebugger_Kd@@SIIIPAEH0HPAH@Z PROC ; Class_Microsoft_Singularity_KernelDebugger_Kd::g_ReceivePacket, COMDAT
; _PacketType$ = ecx
; _MessageHeaderBuffer$ = edx

; 2660 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 2661 :     UINT32 DataLength;
; 2662 : 
; 2663 :     ASSERT(MessageDataLength != NULL);
; 2664 :     *MessageDataLength = 0;

  00007	8b 75 14	 mov	 esi, DWORD PTR _MessageDataLength$[ebp]
  0000a	33 c0		 xor	 eax, eax

; 2665 : 
; 2666 :     STRING MessageHeaderDesc;
; 2667 :     MessageHeaderDesc.Buffer = (PCHAR)MessageHeaderBuffer;

  0000c	89 55 f4	 mov	 DWORD PTR _MessageHeaderDesc$[ebp+4], edx

; 2668 :     MessageHeaderDesc.Length = 0;
; 2669 :     MessageHeaderDesc.MaximumLength = (uint16)MessageHeaderLength;

  0000f	66 8b 55 08	 mov	 dx, WORD PTR _MessageHeaderLength$[ebp]
  00013	89 06		 mov	 DWORD PTR [esi], eax
  00015	66 89 45 f0	 mov	 WORD PTR _MessageHeaderDesc$[ebp], ax

; 2670 : 
; 2671 :     STRING MessageDataDesc;
; 2672 :     MessageDataDesc.Buffer = (PCHAR)MessageDataBuffer;
; 2673 :     MessageDataDesc.Length = 0;

  00019	66 89 45 f8	 mov	 WORD PTR _MessageDataDesc$[ebp], ax

; 2674 :     MessageDataDesc.MaximumLength = (uint16)MessageDataBufferLength;

  0001d	8b 45 10	 mov	 eax, DWORD PTR _MessageDataBufferLength$[ebp]
  00020	66 89 55 f2	 mov	 WORD PTR _MessageHeaderDesc$[ebp+2], dx
  00024	8b 55 0c	 mov	 edx, DWORD PTR _MessageDataBuffer$[ebp]
  00027	66 89 45 fa	 mov	 WORD PTR _MessageDataDesc$[ebp+2], ax

; 2675 : 
; 2676 :     DataLength = (uint32)MessageDataBufferLength;

  0002b	89 45 14	 mov	 DWORD PTR _DataLength$[ebp], eax

; 2677 : 
; 2678 :     uint32 Status = KdReceivePacket(
; 2679 :         PacketType,
; 2680 :         &MessageHeaderDesc,
; 2681 :         &MessageDataDesc,
; 2682 :         &DataLength,
; 2683 :         &KdpContext
; 2684 :         );

  0002e	68 00 00 00 00	 push	 OFFSET _KdpContext
  00033	89 55 fc	 mov	 DWORD PTR _MessageDataDesc$[ebp+4], edx
  00036	8d 45 14	 lea	 eax, DWORD PTR _DataLength$[ebp]
  00039	50		 push	 eax
  0003a	8d 55 f8	 lea	 edx, DWORD PTR _MessageDataDesc$[ebp]
  0003d	52		 push	 edx
  0003e	8d 55 f0	 lea	 edx, DWORD PTR _MessageHeaderDesc$[ebp]
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdReceivePacket@@3P6I?AW4KDP_STATUS@@KPAU_STRING@@0PAKPAU_KD_CONTEXT@@@ZA ; KdReceivePacket

; 2685 : 
; 2686 :     *MessageDataLength = (int)DataLength;

  00047	8b 4d 14	 mov	 ecx, DWORD PTR _DataLength$[ebp]
  0004a	89 0e		 mov	 DWORD PTR [esi], ecx
  0004c	5e		 pop	 esi

; 2687 : 
; 2688 :     return Status;
; 2689 : }

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c2 10 00	 ret	 16			; 00000010H
?g_ReceivePacket@Class_Microsoft_Singularity_KernelDebugger_Kd@@SIIIPAEH0HPAH@Z ENDP ; Class_Microsoft_Singularity_KernelDebugger_Kd::g_ReceivePacket
_TEXT	ENDS
PUBLIC	?g_Lock@Class_Microsoft_Singularity_KernelDebugger_Kd@@SIXXZ ; Class_Microsoft_Singularity_KernelDebugger_Kd::g_Lock
; Function compile flags: /Ogtp
;	COMDAT ?g_Lock@Class_Microsoft_Singularity_KernelDebugger_Kd@@SIXXZ
_TEXT	SEGMENT
?g_Lock@Class_Microsoft_Singularity_KernelDebugger_Kd@@SIXXZ PROC ; Class_Microsoft_Singularity_KernelDebugger_Kd::g_Lock, COMDAT

; 2693 :     KdpLock();

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR ?KdpLock@@3P6IXXZA ; KdpLock
?g_Lock@Class_Microsoft_Singularity_KernelDebugger_Kd@@SIXXZ ENDP ; Class_Microsoft_Singularity_KernelDebugger_Kd::g_Lock
_TEXT	ENDS
PUBLIC	?g_Unlock@Class_Microsoft_Singularity_KernelDebugger_Kd@@SIXXZ ; Class_Microsoft_Singularity_KernelDebugger_Kd::g_Unlock
; Function compile flags: /Ogtp
;	COMDAT ?g_Unlock@Class_Microsoft_Singularity_KernelDebugger_Kd@@SIXXZ
_TEXT	SEGMENT
?g_Unlock@Class_Microsoft_Singularity_KernelDebugger_Kd@@SIXXZ PROC ; Class_Microsoft_Singularity_KernelDebugger_Kd::g_Unlock, COMDAT

; 2698 :     KdpUnlock();

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR ?KdpUnlock@@3P6IXXZA ; KdpUnlock
?g_Unlock@Class_Microsoft_Singularity_KernelDebugger_Kd@@SIXXZ ENDP ; Class_Microsoft_Singularity_KernelDebugger_Kd::g_Unlock
_TEXT	ENDS
PUBLIC	??_C@_0FG@MNAMAEEN@CPU?5?$CFd?3?5KdpMpLock?3?5Entered?5Recur@ ; `string'
EXTRN	?KdpPause@@YIXXZ:PROC				; KdpPause
;	COMDAT ??_C@_0FG@MNAMAEEN@CPU?5?$CFd?3?5KdpMpLock?3?5Entered?5Recur@
CONST	SEGMENT
??_C@_0FG@MNAMAEEN@CPU?5?$CFd?3?5KdpMpLock?3?5Entered?5Recur@ DB 'CPU %d:'
	DB	' KdpMpLock: Entered Recursively due to breakpoint or exceptio'
	DB	'n, EnterCount %d', 0aH, 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?KdpMpLock@@YIXXZ
_TEXT	SEGMENT
?KdpMpLock@@YIXXZ PROC					; KdpMpLock, COMDAT

; 358  : {

  00000	53		 push	 ebx

; 359  :     for (;;) {
; 360  :         bool enabled = KdpDisableInterrupts();

  00001	e8 00 00 00 00	 call	 ?KdpDisableInterruptsInline@@YI_NXZ ; KdpDisableInterruptsInline
  00006	8a d8		 mov	 bl, al

; 361  :         if (InterlockedCompareExchange(&KdpInDebugger, 1, 0) == 0) {

  00008	b9 01 00 00 00	 mov	 ecx, 1
  0000d	ba 00 00 00 00	 mov	 edx, OFFSET _KdpInDebugger
  00012	33 c0		 xor	 eax, eax
  00014	f0 0f b1 0a	 lock	  cmpxchg DWORD PTR [edx], ecx
  00018	85 c0		 test	 eax, eax
  0001a	74 40		 je	 SHORT $LN17@KdpMpLock
  0001c	8d 64 24 00	 npad	 4
$LL4@KdpMpLock:

; 366  :             return;
; 367  :         }
; 368  : 
; 369  :         // Check to see if its already us recursively
; 370  :         if (KdpCpuInDebugger == KdCurrentCpuId()) {

  00020	e8 00 00 00 00	 call	 ?g_GetCurrentCpu@Class_Microsoft_Singularity_Isal_Isa@@SIPAUStruct_Microsoft_Singularity_Isal_CpuRecord@@XZ ; Class_Microsoft_Singularity_Isal_Isa::g_GetCurrentCpu
  00025	8b 80 40 02 00
	00		 mov	 eax, DWORD PTR [eax+576]
  0002b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _KdpCpuInDebugger
  00031	3b c8		 cmp	 ecx, eax
  00033	74 46		 je	 SHORT $LN18@KdpMpLock

; 374  :             return;
; 375  :         }
; 376  :         KdpRestoreInterrupts(enabled);

  00035	8a cb		 mov	 cl, bl
  00037	e8 00 00 00 00	 call	 ?KdpRestoreInterruptsInline@@YIX_N@Z ; KdpRestoreInterruptsInline

; 377  :         KdpPause();

  0003c	e8 00 00 00 00	 call	 ?KdpPause@@YIXXZ	; KdpPause
  00041	e8 00 00 00 00	 call	 ?KdpDisableInterruptsInline@@YI_NXZ ; KdpDisableInterruptsInline
  00046	8a d8		 mov	 bl, al
  00048	ba 01 00 00 00	 mov	 edx, 1
  0004d	b9 00 00 00 00	 mov	 ecx, OFFSET _KdpInDebugger
  00052	33 c0		 xor	 eax, eax
  00054	f0 0f b1 11	 lock	  cmpxchg DWORD PTR [ecx], edx
  00058	85 c0		 test	 eax, eax
  0005a	75 c4		 jne	 SHORT $LL4@KdpMpLock
$LN17@KdpMpLock:

; 362  :             KdpInDebuggerIntEnabled = enabled;

  0005c	88 1d 00 00 00
	00		 mov	 BYTE PTR _KdpInDebuggerIntEnabled, bl

; 363  : 
; 364  :             KdpCpuInDebugger = KdCurrentCpuId();

  00062	e8 00 00 00 00	 call	 ?g_GetCurrentCpu@Class_Microsoft_Singularity_Isal_Isa@@SIPAUStruct_Microsoft_Singularity_Isal_CpuRecord@@XZ ; Class_Microsoft_Singularity_Isal_Isa::g_GetCurrentCpu
  00067	8b 80 40 02 00
	00		 mov	 eax, DWORD PTR [eax+576]
  0006d	a3 00 00 00 00	 mov	 DWORD PTR _KdpCpuInDebugger, eax

; 365  :             KdpLockEnterCount++;

  00072	83 05 00 00 00
	00 01		 add	 DWORD PTR _KdpLockEnterCount, 1
  00079	5b		 pop	 ebx

; 378  :     }
; 379  : }

  0007a	c3		 ret	 0
$LN18@KdpMpLock:

; 371  :             KdpLockEnterCount++;

  0007b	83 05 00 00 00
	00 01		 add	 DWORD PTR _KdpLockEnterCount, 1

; 372  :             kdprintf("CPU %d: KdpMpLock: Entered Recursively due to breakpoint or exception, EnterCount %d\n",
; 373  :                       KdpCpuInDebugger, KdpLockEnterCount);

  00082	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _KdpLockEnterCount
  00088	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdpCpuInDebugger
  0008d	52		 push	 edx
  0008e	50		 push	 eax
  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0FG@MNAMAEEN@CPU?5?$CFd?3?5KdpMpLock?3?5Entered?5Recur@
  00094	e8 00 00 00 00	 call	 ?kdprintf@@YAXPBDZZ	; kdprintf
  00099	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009c	5b		 pop	 ebx

; 378  :     }
; 379  : }

  0009d	c3		 ret	 0
?KdpMpLock@@YIXXZ ENDP					; KdpMpLock
_TEXT	ENDS
EXTRN	?g_FreezeAllProcessors@Class_Microsoft_Singularity_MpExecution@@SIXXZ:PROC ; Class_Microsoft_Singularity_MpExecution::g_FreezeAllProcessors
; Function compile flags: /Ogtp
;	COMDAT ?KdpMpEnter@@YIXXZ
_TEXT	SEGMENT
?KdpMpEnter@@YIXXZ PROC					; KdpMpEnter, COMDAT

; 403  :     KdpMpEnterCount++;

  00000	b8 01 00 00 00	 mov	 eax, 1
  00005	01 05 00 00 00
	00		 add	 DWORD PTR _KdpMpEnterCount, eax

; 404  : 
; 405  :     // Only attempt to stop processors on the first entry
; 406  :     if (KdpMpEnterCount == 1) {

  0000b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _KdpMpEnterCount
  00011	3b c8		 cmp	 ecx, eax
  00013	75 0d		 jne	 SHORT $LN1@KdpMpEnter

; 407  :         if (KeNumberProcessors > 1) {

  00015	39 05 00 00 00
	00		 cmp	 DWORD PTR _KeNumberProcessors, eax
  0001b	7e 05		 jle	 SHORT $LN1@KdpMpEnter

; 408  :              KDDBG("CPU %d: KdpMpEnter, calling FreezeAllProcessors...\n", KdCurrentCpuId());
; 409  :              Class_Microsoft_Singularity_MpExecution::g_FreezeAllProcessors();

  0001d	e9 00 00 00 00	 jmp	 ?g_FreezeAllProcessors@Class_Microsoft_Singularity_MpExecution@@SIXXZ ; Class_Microsoft_Singularity_MpExecution::g_FreezeAllProcessors
$LN1@KdpMpEnter:

; 410  :              KDDBG("CPU %d: KdpMpEnter, return from FreezeAllProcessors...\n", KdCurrentCpuId());
; 411  :         }
; 412  :     }
; 413  : }

  00022	c3		 ret	 0
?KdpMpEnter@@YIXXZ ENDP					; KdpMpEnter
_TEXT	ENDS
PUBLIC	?KdpReportLoadSymbolsStateChange@@YI_NPA_WK_KKKKHPAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ; KdpReportLoadSymbolsStateChange
EXTRN	?KdpSetControlReport@@YIXPAUStruct_Microsoft_Singularity_Kd_X86KdControlReport@@PBUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z:PROC ; KdpSetControlReport
; Function compile flags: /Ogtp
;	COMDAT ?KdpReportLoadSymbolsStateChange@@YI_NPA_WK_KKKKHPAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z
_TEXT	SEGMENT
_WaitStateChange$ = -260				; size = 240
_MessageHeader$ = -20					; size = 8
_MessageData$ = -12					; size = 8
_PathNameLength$ = -4					; size = 4
tv160 = 8						; size = 8
_BaseOfDll$ = 8						; size = 8
_ProcessId$ = 16					; size = 4
_CheckSum$ = 20						; size = 4
_SizeOfImage$ = 24					; size = 4
_UnloadSymbols$ = 28					; size = 4
_Context$ = 32						; size = 4
?KdpReportLoadSymbolsStateChange@@YI_NPA_WK_KKKKHPAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z PROC ; KdpReportLoadSymbolsStateChange, COMDAT
; _PathName$ = ecx
; _PathNameLength$ = edx

; 875  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H

; 921  : 
; 922  :     } while (Status == ContinueProcessorReselected) ;

  00009	8b 45 08	 mov	 eax, DWORD PTR _BaseOfDll$[ebp]
  0000c	53		 push	 ebx
  0000d	89 55 fc	 mov	 DWORD PTR _PathNameLength$[ebp], edx
  00010	99		 cdq
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	8b 7d 20	 mov	 edi, DWORD PTR _Context$[ebp]
  00016	8b d9		 mov	 ebx, ecx
  00018	89 45 08	 mov	 DWORD PTR tv160[ebp], eax
  0001b	89 55 0c	 mov	 DWORD PTR tv160[ebp+4], edx
  0001e	8b ff		 npad	 2
$LL5@KdpReportL:
  00020	57		 push	 edi
  00021	8d b5 fc fe ff
	ff		 lea	 esi, DWORD PTR _WaitStateChange$[ebp]
  00027	b8 31 30 00 00	 mov	 eax, 12337		; 00003031H
  0002c	e8 00 00 00 00	 call	 ?KdpSetCommonState@@YIXKPAUStruct_Microsoft_Singularity_Isal_SpillContext@@PAU_DBGKD_ANY_WAIT_STATE_CHANGE@@@Z ; KdpSetCommonState
  00031	8b 45 1c	 mov	 eax, DWORD PTR _UnloadSymbols$[ebp]
  00034	8b 4d 08	 mov	 ecx, DWORD PTR tv160[ebp]
  00037	8b 55 0c	 mov	 edx, DWORD PTR tv160[ebp+4]
  0003a	89 85 3c ff ff
	ff		 mov	 DWORD PTR _WaitStateChange$[ebp+64], eax
  00040	8b 45 10	 mov	 eax, DWORD PTR _ProcessId$[ebp]
  00043	89 85 2c ff ff
	ff		 mov	 DWORD PTR _WaitStateChange$[ebp+48], eax
  00049	33 c0		 xor	 eax, eax
  0004b	85 db		 test	 ebx, ebx
  0004d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR _WaitStateChange$[ebp+40], ecx
  00053	8b 4d 18	 mov	 ecx, DWORD PTR _SizeOfImage$[ebp]
  00056	89 85 30 ff ff
	ff		 mov	 DWORD PTR _WaitStateChange$[ebp+52], eax
  0005c	8b 45 14	 mov	 eax, DWORD PTR _CheckSum$[ebp]
  0005f	89 95 28 ff ff
	ff		 mov	 DWORD PTR _WaitStateChange$[ebp+44], edx
  00065	89 85 34 ff ff
	ff		 mov	 DWORD PTR _WaitStateChange$[ebp+56], eax
  0006b	89 8d 38 ff ff
	ff		 mov	 DWORD PTR _WaitStateChange$[ebp+60], ecx
  00071	74 28		 je	 SHORT $LN2@KdpReportL
  00073	8b 75 fc	 mov	 esi, DWORD PTR _PathNameLength$[ebp]
  00076	85 f6		 test	 esi, esi
  00078	b8 00 00 00 00	 mov	 eax, OFFSET _KdpMessageBuffer
  0007d	8b cb		 mov	 ecx, ebx
  0007f	76 12		 jbe	 SHORT $LN9@KdpReportL

; 876  :     // NB: \nt\sdktools\debuggers\ntsd64\event.cpp
; 877  :     // PathNameLength = 0, ProcessId = 0, BaseOfDll = -1 for reboot.
; 878  :     // PathNameLength = 0, ProcessId = 0, BaseOfDll = -2 for hibernate.
; 879  : 
; 880  :     STRING MessageData;
; 881  :     STRING MessageHeader;
; 882  :     DBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange;
; 883  :     KCONTINUE_STATUS Status;
; 884  : 
; 885  :     KDDBG("KdpReportLoadSymbolsStateChange %p\n", Context);
; 886  : 
; 887  :     do {
; 888  :         //
; 889  :         // Construct the wait state change message and message descriptor.
; 890  :         //
; 891  : 
; 892  :         KdpSetCommonState(DbgKdLoadSymbolsStateChange, Context,
; 893  :                           &WaitStateChange);
; 894  : 
; 895  :         WaitStateChange.LoadSymbols.UnloadSymbols = UnloadSymbols;
; 896  :         WaitStateChange.LoadSymbols.BaseOfDll = SIGN_EXTEND(BaseOfDll);
; 897  :         WaitStateChange.LoadSymbols.ProcessId = ProcessId;
; 898  :         WaitStateChange.LoadSymbols.CheckSum = CheckSum;
; 899  :         WaitStateChange.LoadSymbols.SizeOfImage = SizeOfImage;
; 900  :         if (PathName != NULL) {
; 901  :             WaitStateChange.LoadSymbols.PathNameLength =
; 902  :                 WcsToStr(PathName, PathNameLength, KdpMessageBuffer);

$LL11@KdpReportL:
  00081	8a 11		 mov	 dl, BYTE PTR [ecx]
  00083	88 10		 mov	 BYTE PTR [eax], dl
  00085	83 c0 01	 add	 eax, 1
  00088	83 c1 02	 add	 ecx, 2
  0008b	83 ee 01	 sub	 esi, 1
  0008e	75 f1		 jne	 SHORT $LL11@KdpReportL
  00090	8b 75 fc	 mov	 esi, DWORD PTR _PathNameLength$[ebp]
$LN9@KdpReportL:
  00093	c6 00 00	 mov	 BYTE PTR [eax], 0
  00096	8d 46 01	 lea	 eax, DWORD PTR [esi+1]

; 903  :         }
; 904  :         else {

  00099	eb 02		 jmp	 SHORT $LN17@KdpReportL
$LN2@KdpReportL:

; 905  :             WaitStateChange.LoadSymbols.PathNameLength = 0;

  0009b	33 c0		 xor	 eax, eax
$LN17@KdpReportL:

; 906  :         }
; 907  :         MessageData.Buffer = KdpMessageBuffer;
; 908  :         MessageData.Length = (UINT16)WaitStateChange.LoadSymbols.PathNameLength;
; 909  : 
; 910  :         KdpSetControlReport(&WaitStateChange.ControlReport, Context);

  0009d	8b d7		 mov	 edx, edi
  0009f	8d 4d bc	 lea	 ecx, DWORD PTR _WaitStateChange$[ebp+192]
  000a2	89 85 1c ff ff
	ff		 mov	 DWORD PTR _WaitStateChange$[ebp+32], eax
  000a8	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _MessageData$[ebp+4], OFFSET _KdpMessageBuffer
  000af	66 89 45 f4	 mov	 WORD PTR _MessageData$[ebp], ax
  000b3	e8 00 00 00 00	 call	 ?KdpSetControlReport@@YIXPAUStruct_Microsoft_Singularity_Kd_X86KdControlReport@@PBUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ; KdpSetControlReport

; 911  : 
; 912  :         MessageHeader.Length = sizeof(WaitStateChange);
; 913  :         MessageHeader.Buffer = (PCHAR)&WaitStateChange;
; 914  : 
; 915  :         Status = KdpSendWaitContinue(
; 916  :                     PACKET_TYPE_KD_STATE_CHANGE64,
; 917  :                     &MessageHeader,
; 918  :                     &MessageData,
; 919  :                     Context
; 920  :                     );

  000b8	57		 push	 edi
  000b9	8d 4d f4	 lea	 ecx, DWORD PTR _MessageData$[ebp]
  000bc	51		 push	 ecx
  000bd	8d 55 ec	 lea	 edx, DWORD PTR _MessageHeader$[ebp]
  000c0	52		 push	 edx
  000c1	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _WaitStateChange$[ebp]
  000c7	6a 07		 push	 7
  000c9	66 c7 45 ec f0
	00		 mov	 WORD PTR _MessageHeader$[ebp], 240 ; 000000f0H
  000cf	89 45 f0	 mov	 DWORD PTR _MessageHeader$[ebp+4], eax
  000d2	e8 00 00 00 00	 call	 ?KdpSendWaitContinue@@YI?AW4KCONTINUE_STATUS@@KPAU_STRING@@0PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ; KdpSendWaitContinue

; 921  : 
; 922  :     } while (Status == ContinueProcessorReselected) ;

  000d7	83 f8 02	 cmp	 eax, 2
  000da	0f 84 40 ff ff
	ff		 je	 $LL5@KdpReportL
  000e0	5f		 pop	 edi

; 923  : 
; 924  :     return (Status == ContinueSuccess) ? true : false;

  000e1	83 f8 01	 cmp	 eax, 1
  000e4	5e		 pop	 esi
  000e5	0f 94 c0	 sete	 al
  000e8	5b		 pop	 ebx

; 925  : }

  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c2 1c 00	 ret	 28			; 0000001cH
?KdpReportLoadSymbolsStateChange@@YI_NPA_WK_KKKKHPAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ENDP ; KdpReportLoadSymbolsStateChange
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?KdpReportExceptionStateChange@@YI?AW4KCONTINUE_STATUS@@PAUStruct_Microsoft_Singularity_Kd_ExceptionRecord64@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@H@Z
_TEXT	SEGMENT
_WaitStateChange$ = -256				; size = 240
_MessageData$ = -16					; size = 8
_MessageHeader$ = -8					; size = 8
_ExceptionRecord$ = 8					; size = 4
_FirstChance$ = 12					; size = 4
?KdpReportExceptionStateChange@@YI?AW4KCONTINUE_STATUS@@PAUStruct_Microsoft_Singularity_Kd_ExceptionRecord64@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@H@Z PROC ; KdpReportExceptionStateChange, COMDAT
; _Context$ = ebx

; 947  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	eb 03 8d 49 00	 npad	 5
$LL3@KdpReportE:

; 948  :     STRING MessageData;
; 949  :     STRING MessageHeader;
; 950  :     DBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange;
; 951  :     KCONTINUE_STATUS Status;
; 952  : 
; 953  :     KDDBG("KdpReportExceptionStateChange %p\n", Context);
; 954  : 
; 955  :     do {
; 956  : 
; 957  :         //
; 958  :         // Construct the wait state change message and message descriptor.
; 959  :         //
; 960  : 
; 961  :         KdpSetCommonState(DbgKdExceptionStateChange, Context,
; 962  :                           &WaitStateChange);

  00010	53		 push	 ebx
  00011	8d b5 00 ff ff
	ff		 lea	 esi, DWORD PTR _WaitStateChange$[ebp]
  00017	b8 30 30 00 00	 mov	 eax, 12336		; 00003030H
  0001c	e8 00 00 00 00	 call	 ?KdpSetCommonState@@YIXKPAUStruct_Microsoft_Singularity_Isal_SpillContext@@PAU_DBGKD_ANY_WAIT_STATE_CHANGE@@@Z ; KdpSetCommonState

; 963  : 
; 964  :         WaitStateChange.Exception.ExceptionRecord = *ExceptionRecord;

  00021	8b 75 08	 mov	 esi, DWORD PTR _ExceptionRecord$[ebp]

; 965  :         WaitStateChange.Exception.FirstChance = FirstChance;

  00024	8b 45 0c	 mov	 eax, DWORD PTR _FirstChance$[ebp]
  00027	b9 26 00 00 00	 mov	 ecx, 38			; 00000026H
  0002c	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR _WaitStateChange$[ebp+32]
  00032	f3 a5		 rep movsd

; 966  : 
; 967  :         KdpSetControlReport(&WaitStateChange.ControlReport, Context);

  00034	8b d3		 mov	 edx, ebx
  00036	8d 4d c0	 lea	 ecx, DWORD PTR _WaitStateChange$[ebp+192]
  00039	89 45 b8	 mov	 DWORD PTR _WaitStateChange$[ebp+184], eax
  0003c	e8 00 00 00 00	 call	 ?KdpSetControlReport@@YIXPAUStruct_Microsoft_Singularity_Kd_X86KdControlReport@@PBUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ; KdpSetControlReport

; 968  : 
; 969  :         MessageHeader.Length = sizeof(WaitStateChange);
; 970  :         MessageHeader.Buffer = (PCHAR)&WaitStateChange;
; 971  :         MessageData.Length = 0;
; 972  : 
; 973  :         //
; 974  :         // Send packet to the kernel debugger on the host machine,
; 975  :         // wait for answer.
; 976  :         //
; 977  :         Status = KdpSendWaitContinue(
; 978  :                     PACKET_TYPE_KD_STATE_CHANGE64,
; 979  :                     &MessageHeader,
; 980  :                     &MessageData,
; 981  :                     Context
; 982  :                     );

  00041	53		 push	 ebx
  00042	8d 55 f0	 lea	 edx, DWORD PTR _MessageData$[ebp]
  00045	52		 push	 edx
  00046	8d 45 f8	 lea	 eax, DWORD PTR _MessageHeader$[ebp]
  00049	50		 push	 eax
  0004a	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _WaitStateChange$[ebp]
  00050	6a 07		 push	 7
  00052	66 c7 45 f8 f0
	00		 mov	 WORD PTR _MessageHeader$[ebp], 240 ; 000000f0H
  00058	89 4d fc	 mov	 DWORD PTR _MessageHeader$[ebp+4], ecx
  0005b	66 c7 45 f0 00
	00		 mov	 WORD PTR _MessageData$[ebp], 0
  00061	e8 00 00 00 00	 call	 ?KdpSendWaitContinue@@YI?AW4KCONTINUE_STATUS@@KPAU_STRING@@0PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ; KdpSendWaitContinue

; 983  :     } while (Status == ContinueProcessorReselected) ;

  00066	83 f8 02	 cmp	 eax, 2
  00069	74 a5		 je	 SHORT $LL3@KdpReportE
  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi

; 984  : 
; 985  :     return Status;
; 986  : }

  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 08 00	 ret	 8
?KdpReportExceptionStateChange@@YI?AW4KCONTINUE_STATUS@@PAUStruct_Microsoft_Singularity_Kd_ExceptionRecord64@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@H@Z ENDP ; KdpReportExceptionStateChange
_TEXT	ENDS
PUBLIC	?g_TrapForProcessorSwitch@Class_Microsoft_Singularity_DebugStub@@SI_NPAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ; Class_Microsoft_Singularity_DebugStub::g_TrapForProcessorSwitch
; Function compile flags: /Ogtp
;	COMDAT ?g_TrapForProcessorSwitch@Class_Microsoft_Singularity_DebugStub@@SI_NPAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z
_TEXT	SEGMENT
_er$ = -152						; size = 152
?g_TrapForProcessorSwitch@Class_Microsoft_Singularity_DebugStub@@SI_NPAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z PROC ; Class_Microsoft_Singularity_DebugStub::g_TrapForProcessorSwitch, COMDAT
; _context$ = ecx

; 2296 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00009	53		 push	 ebx

; 2297 :     EXCEPTION_RECORD64 er;
; 2298 : 
; 2299 :     KDDBG("CPU %d: TrapForProcessorSwitch:\n", KdCurrentCpuId());
; 2300 : 
; 2301 :     RtlZeroMemory(&er, sizeof(er));

  0000a	68 98 00 00 00	 push	 152			; 00000098H
  0000f	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _er$[ebp]
  00015	6a 00		 push	 0
  00017	50		 push	 eax
  00018	8b d9		 mov	 ebx, ecx
  0001a	e8 00 00 00 00	 call	 _memset

; 2302 :     er.ExceptionCode    = STATUS_WAKE_SYSTEM_DEBUGGER;
; 2303 :     er.ExceptionRecord  = (UINT64)&er;
; 2304 : 
; 2305 : #if ISA_IX86 || ISA_IX64
; 2306 :     er.ExceptionAddress = context->ip;

  0001f	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  00022	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _er$[ebp]
  00028	99		 cdq
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002c	89 95 74 ff ff
	ff		 mov	 DWORD PTR _er$[ebp+12], edx

; 2307 : #elif ISA_ARM
; 2308 :     er.ExceptionAddress = context->pc;
; 2309 : #endif
; 2310 : 
; 2311 :     // KdSave(FALSE);
; 2312 :     KCONTINUE_STATUS status = KdpReportExceptionStateChange(&er, context, true);

  00032	6a 01		 push	 1
  00034	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR _er$[ebp]
  0003a	52		 push	 edx
  0003b	c7 85 68 ff ff
	ff 07 00 00 80	 mov	 DWORD PTR _er$[ebp], -2147483641 ; 80000007H
  00045	89 85 70 ff ff
	ff		 mov	 DWORD PTR _er$[ebp+8], eax
  0004b	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _er$[ebp+16], ecx
  00051	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _er$[ebp+20], 0
  0005b	e8 00 00 00 00	 call	 ?KdpReportExceptionStateChange@@YI?AW4KCONTINUE_STATUS@@PAUStruct_Microsoft_Singularity_Kd_ExceptionRecord64@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@H@Z ; KdpReportExceptionStateChange

; 2313 :     // KdRestore(FALSE);
; 2314 :     return status == ContinueSuccess;

  00060	83 e8 01	 sub	 eax, 1
  00063	f7 d8		 neg	 eax
  00065	1b c0		 sbb	 eax, eax
  00067	83 c0 01	 add	 eax, 1
  0006a	5b		 pop	 ebx

; 2315 : }

  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
?g_TrapForProcessorSwitch@Class_Microsoft_Singularity_DebugStub@@SI_NPAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ENDP ; Class_Microsoft_Singularity_DebugStub::g_TrapForProcessorSwitch
_TEXT	ENDS
PUBLIC	?g_LoadedBinary@Class_Microsoft_Singularity_DebugStub@@SI_NPAUuintPtr@@0PAUClass_System_String@@II_N@Z ; Class_Microsoft_Singularity_DebugStub::g_LoadedBinary
; Function compile flags: /Ogtp
;	COMDAT ?g_LoadedBinary@Class_Microsoft_Singularity_DebugStub@@SI_NPAUuintPtr@@0PAUClass_System_String@@II_N@Z
_TEXT	SEGMENT
_trapData$13261 = -28					; size = 28
_name$ = 8						; size = 4
_checksum$ = 12						; size = 4
_timestamp$ = 16					; size = 4
_silent$ = 20						; size = 1
?g_LoadedBinary@Class_Microsoft_Singularity_DebugStub@@SI_NPAUuintPtr@@0PAUClass_System_String@@II_N@Z PROC ; Class_Microsoft_Singularity_DebugStub::g_LoadedBinary, COMDAT
; _baseAddress$ = ecx
; _bytes$ = edx

; 2359 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 2360 :     return g_LoadedBinary(baseAddress,
; 2361 :                           bytes,
; 2362 :                           (UIntPtr)&name->m_firstChar,
; 2363 :                           checksum,
; 2364 :                           timestamp,
; 2365 :                           silent);

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?KdDebuggerNotPresent@@3HA, 0 ; KdDebuggerNotPresent
  0000d	74 08		 je	 SHORT $LN3@g_LoadedBi@2
  0000f	b0 01		 mov	 al, 1

; 2366 : }

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 10 00	 ret	 16			; 00000010H

; 2360 :     return g_LoadedBinary(baseAddress,
; 2361 :                           bytes,
; 2362 :                           (UIntPtr)&name->m_firstChar,
; 2363 :                           checksum,
; 2364 :                           timestamp,
; 2365 :                           silent);

$LN3@g_LoadedBi@2:
  00017	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  0001a	89 4d e8	 mov	 DWORD PTR _trapData$13261[ebp+4], ecx
  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR _checksum$[ebp]
  00020	83 c0 0c	 add	 eax, 12			; 0000000cH
  00023	89 55 ec	 mov	 DWORD PTR _trapData$13261[ebp+8], edx
  00026	8b 55 10	 mov	 edx, DWORD PTR _timestamp$[ebp]
  00029	89 45 f0	 mov	 DWORD PTR _trapData$13261[ebp+12], eax
  0002c	8a 45 14	 mov	 al, BYTE PTR _silent$[ebp]
  0002f	89 4d f4	 mov	 DWORD PTR _trapData$13261[ebp+16], ecx
  00032	8d 4d e4	 lea	 ecx, DWORD PTR _trapData$13261[ebp]
  00035	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _trapData$13261[ebp], 1
  0003c	89 55 f8	 mov	 DWORD PTR _trapData$13261[ebp+20], edx
  0003f	88 45 fc	 mov	 BYTE PTR _trapData$13261[ebp+24], al
  00042	e8 00 00 00 00	 call	 ?KdNotifyTrap@@YIXPAUKdDebugTrapData@@@Z ; KdNotifyTrap
  00047	8a 45 fd	 mov	 al, BYTE PTR _trapData$13261[ebp+25]

; 2366 : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 10 00	 ret	 16			; 00000010H
?g_LoadedBinary@Class_Microsoft_Singularity_DebugStub@@SI_NPAUuintPtr@@0PAUClass_System_String@@II_N@Z ENDP ; Class_Microsoft_Singularity_DebugStub::g_LoadedBinary
_TEXT	ENDS
_BSS	SEGMENT
_KdModuleKernelEntry DB 04600H DUP (?)
; Function compile flags: /Ogtp
_BSS	ENDS
;	COMDAT ?LoadedBinary@@YIXPAUKdDebugTrapData@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z
_TEXT	SEGMENT
_pEntry$ = -28						; size = 4
_timestamp$ = -24					; size = 4
_baseAddress$ = -20					; size = 4
_checksum$ = -16					; size = 4
_bytes$ = -12						; size = 4
_pwzBeg$13268 = -8					; size = 4
_silent$ = -2						; size = 1
_good$ = -1						; size = 1
_context$ = 8						; size = 4
?LoadedBinary@@YIXPAUKdDebugTrapData@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z PROC ; LoadedBinary, COMDAT
; _trapData$ = ebx

; 2394 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 2395 :     UIntPtr baseAddress = trapData->loadedBinary.baseAddress;

  00006	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]

; 2396 :     UIntPtr bytes = trapData->loadedBinary.bytes;

  00009	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]

; 2397 :     UIntPtr nameof = trapData->loadedBinary.name;
; 2398 :     uint32 checksum = trapData->loadedBinary.checksum;

  0000c	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  0000f	89 45 ec	 mov	 DWORD PTR _baseAddress$[ebp], eax

; 2399 :     uint32 timestamp = trapData->loadedBinary.timestamp;

  00012	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  00015	89 4d f4	 mov	 DWORD PTR _bytes$[ebp], ecx

; 2400 :     bool silent = trapData->loadedBinary.silent;

  00018	8a 4b 18	 mov	 cl, BYTE PTR [ebx+24]
  0001b	89 45 e8	 mov	 DWORD PTR _timestamp$[ebp], eax

; 2401 : 
; 2402 :     KLDR_DATA_TABLE_ENTRY_WITH_NAME *pEntry;
; 2403 :     bool good = false;
; 2404 :     WCHAR * name = trim((WCHAR *)nameof);

  0001e	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00021	88 4d fe	 mov	 BYTE PTR _silent$[ebp], cl
  00024	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00027	66 85 c9	 test	 cx, cx
  0002a	89 55 f0	 mov	 DWORD PTR _checksum$[ebp], edx
  0002d	8b d0		 mov	 edx, eax
  0002f	c6 45 ff 00	 mov	 BYTE PTR _good$[ebp], 0
  00033	89 55 f8	 mov	 DWORD PTR _pwzBeg$13268[ebp], edx
  00036	74 1b		 je	 SHORT $LN12@LoadedBina
$LL14@LoadedBina:
  00038	66 83 f9 5c	 cmp	 cx, 92			; 0000005cH
  0003c	75 06		 jne	 SHORT $LN13@LoadedBina
  0003e	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
  00041	89 55 f8	 mov	 DWORD PTR _pwzBeg$13268[ebp], edx
$LN13@LoadedBina:
  00044	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  00048	83 c0 02	 add	 eax, 2
  0004b	66 85 c9	 test	 cx, cx
  0004e	75 e8		 jne	 SHORT $LL14@LoadedBina
  00050	8b 55 f8	 mov	 edx, DWORD PTR _pwzBeg$13268[ebp]
$LN12@LoadedBina:

; 2405 :     UINT16 nlen = (UINT16)2 * wcslen(name);

  00053	33 c9		 xor	 ecx, ecx
  00055	66 39 0a	 cmp	 WORD PTR [edx], cx
  00058	8b c2		 mov	 eax, edx
  0005a	74 10		 je	 SHORT $LN28@LoadedBina
  0005c	8d 64 24 00	 npad	 4
$LL18@LoadedBina:
  00060	83 c0 02	 add	 eax, 2
  00063	83 c1 01	 add	 ecx, 1
  00066	66 83 38 00	 cmp	 WORD PTR [eax], 0
  0006a	75 f4		 jne	 SHORT $LL18@LoadedBina
$LN28@LoadedBina:
  0006c	56		 push	 esi
  0006d	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
  00070	57		 push	 edi
  00071	0f b7 f8	 movzx	 edi, ax

; 2406 :     if (nlen > sizeof(pEntry->wzName)) {

  00074	66 83 ff 40	 cmp	 di, 64			; 00000040H
  00078	76 05		 jbe	 SHORT $LN8@LoadedBina

; 2407 :         nlen = sizeof(pEntry->wzName);

  0007a	bf 40 00 00 00	 mov	 edi, 64			; 00000040H
$LN8@LoadedBina:

; 2408 :     }
; 2409 : 
; 2410 :     KdpLock();

  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdpLock@@3P6IXXZA ; KdpLock
  00085	be 00 00 00 00	 mov	 esi, OFFSET _KdModuleKernelEntry

; 2411 : 
; 2412 :     for (int i = 0; i < ARRAYOF(KdModuleKernelEntry); i++) {

  0008a	33 c0		 xor	 eax, eax
  0008c	8d 64 24 00	 npad	 4
$LL7@LoadedBina:

; 2413 :         pEntry = &KdModuleKernelEntry[i];
; 2414 : 
; 2415 :         if (pEntry->DllBase == 0) {

  00090	83 7e 18 00	 cmp	 DWORD PTR [esi+24], 0
  00094	8b ce		 mov	 ecx, esi
  00096	89 4d e4	 mov	 DWORD PTR _pEntry$[ebp], ecx
  00099	74 14		 je	 SHORT $LN26@LoadedBina
  0009b	05 8c 00 00 00	 add	 eax, 140		; 0000008cH
  000a0	81 c6 8c 00 00
	00		 add	 esi, 140		; 0000008cH
  000a6	3d 00 46 00 00	 cmp	 eax, 17920		; 00004600H
  000ab	72 e3		 jb	 SHORT $LL7@LoadedBina
  000ad	eb 68		 jmp	 SHORT $LN5@LoadedBina
$LN26@LoadedBina:

; 2416 :             pEntry->DllBase = (PVOID *)baseAddress;
; 2417 :             pEntry->CheckSum = checksum;

  000af	8b 55 f0	 mov	 edx, DWORD PTR _checksum$[ebp]
  000b2	8b 4d ec	 mov	 ecx, DWORD PTR _baseAddress$[ebp]

; 2418 :             pEntry->TimeDateStamp = timestamp;

  000b5	8b 45 e8	 mov	 eax, DWORD PTR _timestamp$[ebp]
  000b8	89 56 40	 mov	 DWORD PTR [esi+64], edx

; 2419 :             pEntry->LoadCount = 1;
; 2420 :             pEntry->SizeOfImage = (UINT32)bytes;
; 2421 :             memcpy(pEntry->wzName, name, nlen);

  000bb	0f b7 d7	 movzx	 edx, di
  000be	89 4e 18	 mov	 DWORD PTR [esi+24], ecx
  000c1	8b 4d f4	 mov	 ecx, DWORD PTR _bytes$[ebp]
  000c4	89 46 44	 mov	 DWORD PTR [esi+68], eax
  000c7	8b 45 f8	 mov	 eax, DWORD PTR _pwzBeg$13268[ebp]
  000ca	52		 push	 edx
  000cb	89 4e 20	 mov	 DWORD PTR [esi+32], ecx
  000ce	50		 push	 eax
  000cf	8d 4e 4c	 lea	 ecx, DWORD PTR [esi+76]
  000d2	51		 push	 ecx
  000d3	66 c7 46 38 01
	00		 mov	 WORD PTR [esi+56], 1
  000d9	e8 00 00 00 00	 call	 _memcpy

; 2422 :             RtlInitUnicodeString(&pEntry->FullDllName, name, nlen);

  000de	8b 45 f8	 mov	 eax, DWORD PTR _pwzBeg$13268[ebp]

; 2423 :             RtlInitUnicodeString(&pEntry->BaseDllName, name, nlen);
; 2424 : 
; 2425 :             // We should insert in the right order in the list...
; 2426 :             InsertTailList(&PsLoadedModuleList, &pEntry->InLoadOrderLinks);
; 2427 :             good = true;

  000e1	8b 4d e4	 mov	 ecx, DWORD PTR _pEntry$[ebp]
  000e4	89 46 28	 mov	 DWORD PTR [esi+40], eax
  000e7	89 46 30	 mov	 DWORD PTR [esi+48], eax
  000ea	a1 04 00 00 00	 mov	 eax, DWORD PTR _PsLoadedModuleList+4
  000ef	66 89 7e 26	 mov	 WORD PTR [esi+38], di
  000f3	66 89 7e 24	 mov	 WORD PTR [esi+36], di
  000f7	66 89 7e 2e	 mov	 WORD PTR [esi+46], di
  000fb	66 89 7e 2c	 mov	 WORD PTR [esi+44], di
  000ff	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET _PsLoadedModuleList
  00105	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00108	89 30		 mov	 DWORD PTR [eax], esi
  0010a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010d	89 35 04 00 00
	00		 mov	 DWORD PTR _PsLoadedModuleList+4, esi
  00113	c6 45 ff 01	 mov	 BYTE PTR _good$[ebp], 1
$LN5@LoadedBina:

; 2428 :             break;
; 2429 :         }
; 2430 :     }
; 2431 : 
; 2432 :     if (!silent) {

  00117	80 7d fe 00	 cmp	 BYTE PTR _silent$[ebp], 0
  0011b	5f		 pop	 edi
  0011c	5e		 pop	 esi
  0011d	75 43		 jne	 SHORT $LN1@LoadedBina

; 2433 :         if (good) {

  0011f	80 7d ff 00	 cmp	 BYTE PTR _good$[ebp], 0
  00123	74 1e		 je	 SHORT $LN2@LoadedBina

; 2434 :             KdpReportLoadSymbolsStateChange(pEntry->BaseDllName.Buffer,
; 2435 :                                             pEntry->BaseDllName.Length,
; 2436 :                                             (UINT64)baseAddress,
; 2437 :                                             (UINT32)0,
; 2438 :                                             checksum,
; 2439 :                                             (INT32)bytes,
; 2440 :                                             FALSE,
; 2441 :                                             context);

  00125	8b 55 08	 mov	 edx, DWORD PTR _context$[ebp]
  00128	8b 45 f4	 mov	 eax, DWORD PTR _bytes$[ebp]
  0012b	52		 push	 edx
  0012c	8b 55 f0	 mov	 edx, DWORD PTR _checksum$[ebp]
  0012f	6a 00		 push	 0
  00131	50		 push	 eax
  00132	8b 45 ec	 mov	 eax, DWORD PTR _baseAddress$[ebp]
  00135	52		 push	 edx
  00136	99		 cdq
  00137	6a 00		 push	 0
  00139	52		 push	 edx
  0013a	0f b7 51 2c	 movzx	 edx, WORD PTR [ecx+44]
  0013e	8b 49 30	 mov	 ecx, DWORD PTR [ecx+48]

; 2442 :         }
; 2443 :         else {

  00141	eb 19		 jmp	 SHORT $LN31@LoadedBina
$LN2@LoadedBina:

; 2444 :             KdpReportLoadSymbolsStateChange(NULL,
; 2445 :                                             0,
; 2446 :                                             (UINT64)baseAddress,
; 2447 :                                             (UINT32)0,
; 2448 :                                             checksum,
; 2449 :                                             (INT32)bytes,
; 2450 :                                             FALSE,
; 2451 :                                             context);

  00143	8b 45 08	 mov	 eax, DWORD PTR _context$[ebp]
  00146	8b 4d f4	 mov	 ecx, DWORD PTR _bytes$[ebp]
  00149	8b 55 f0	 mov	 edx, DWORD PTR _checksum$[ebp]
  0014c	50		 push	 eax
  0014d	8b 45 ec	 mov	 eax, DWORD PTR _baseAddress$[ebp]
  00150	6a 00		 push	 0
  00152	51		 push	 ecx
  00153	52		 push	 edx
  00154	99		 cdq
  00155	6a 00		 push	 0
  00157	52		 push	 edx
  00158	33 d2		 xor	 edx, edx
  0015a	33 c9		 xor	 ecx, ecx
$LN31@LoadedBina:
  0015c	50		 push	 eax
  0015d	e8 00 00 00 00	 call	 ?KdpReportLoadSymbolsStateChange@@YI_NPA_WK_KKKKHPAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ; KdpReportLoadSymbolsStateChange
$LN1@LoadedBina:

; 2452 :         }
; 2453 :     }
; 2454 :     KdpUnlock();

  00162	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdpUnlock@@3P6IXXZA ; KdpUnlock

; 2455 : 
; 2456 :     trapData->loadedBinary.ret = good;

  00168	8a 45 ff	 mov	 al, BYTE PTR _good$[ebp]
  0016b	88 43 19	 mov	 BYTE PTR [ebx+25], al

; 2457 : }

  0016e	8b e5		 mov	 esp, ebp
  00170	5d		 pop	 ebp
  00171	c2 04 00	 ret	 4
?LoadedBinary@@YIXPAUKdDebugTrapData@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ENDP ; LoadedBinary
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?UnloadedBinary@@YIXPAUKdDebugTrapData@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z
_TEXT	SEGMENT
_good$ = -1						; size = 1
_trapData$ = 8						; size = 4
_context$ = 12						; size = 4
?UnloadedBinary@@YIXPAUKdDebugTrapData@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z PROC ; UnloadedBinary, COMDAT

; 2477 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2478 :     UIntPtr baseAddress = trapData->unloadedBinary.baseAddress;

  00004	8b 45 08	 mov	 eax, DWORD PTR _trapData$[ebp]
  00007	53		 push	 ebx

; 2479 :     bool silent = trapData->unloadedBinary.silent;

  00008	8a 58 08	 mov	 bl, BYTE PTR [eax+8]
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8b 78 04	 mov	 edi, DWORD PTR [eax+4]

; 2480 :     bool good = false;

  00010	c6 45 ff 00	 mov	 BYTE PTR _good$[ebp], 0

; 2481 : 
; 2482 :     KdpLock();

  00014	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdpLock@@3P6IXXZA ; KdpLock
  0001a	be 00 00 00 00	 mov	 esi, OFFSET _KdModuleKernelEntry

; 2483 :     KLDR_DATA_TABLE_ENTRY_WITH_NAME *pEntry = NULL;
; 2484 :     for (int i = 0; i < ARRAYOF(KdModuleKernelEntry); i++) {

  0001f	33 c0		 xor	 eax, eax
$LL6@UnloadedBi:

; 2485 :         pEntry = &KdModuleKernelEntry[i];
; 2486 : 
; 2487 :         if (pEntry->DllBase == (PVOID*)baseAddress) {

  00021	39 7e 18	 cmp	 DWORD PTR [esi+24], edi
  00024	74 14		 je	 SHORT $LN12@UnloadedBi
  00026	05 8c 00 00 00	 add	 eax, 140		; 0000008cH
  0002b	81 c6 8c 00 00
	00		 add	 esi, 140		; 0000008cH
  00031	3d 00 46 00 00	 cmp	 eax, 17920		; 00004600H
  00036	72 e9		 jb	 SHORT $LL6@UnloadedBi
  00038	eb 3f		 jmp	 SHORT $LN2@UnloadedBi
$LN12@UnloadedBi:

; 2488 :             RemoveEntryList(&pEntry->InLoadOrderLinks);
; 2489 :             good = true;
; 2490 :             break;
; 2491 :         }
; 2492 :     }
; 2493 : 
; 2494 :     if (good) {
; 2495 :         if (!silent) {

  0003a	84 db		 test	 bl, bl
  0003c	8b 06		 mov	 eax, DWORD PTR [esi]
  0003e	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00041	89 01		 mov	 DWORD PTR [ecx], eax
  00043	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00046	c6 45 ff 01	 mov	 BYTE PTR _good$[ebp], 1
  0004a	75 1d		 jne	 SHORT $LN1@UnloadedBi

; 2496 :             // Only tell debugger if we found an image name.
; 2497 :             // The debugger ignores unload requests that lack a processId (not us)
; 2498 :             // or a path name.
; 2499 : 
; 2500 :             KdpReportLoadSymbolsStateChange(pEntry->BaseDllName.Buffer,
; 2501 :                                             pEntry->BaseDllName.Length,
; 2502 :                                             (UINT64)baseAddress,
; 2503 :                                             (UINT32)0,
; 2504 :                                             0,
; 2505 :                                             0,
; 2506 :                                             TRUE,
; 2507 :                                             context);

  0004c	8b 45 0c	 mov	 eax, DWORD PTR _context$[ebp]
  0004f	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00052	50		 push	 eax
  00053	6a 01		 push	 1
  00055	6a 00		 push	 0
  00057	6a 00		 push	 0
  00059	8b c7		 mov	 eax, edi
  0005b	99		 cdq
  0005c	6a 00		 push	 0
  0005e	52		 push	 edx
  0005f	0f b7 56 2c	 movzx	 edx, WORD PTR [esi+44]
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 ?KdpReportLoadSymbolsStateChange@@YI_NPA_WK_KKKKHPAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ; KdpReportLoadSymbolsStateChange
$LN1@UnloadedBi:

; 2508 :         }
; 2509 :         RtlZeroMemory(pEntry, sizeof(*pEntry));

  00069	68 8c 00 00 00	 push	 140			; 0000008cH
  0006e	6a 00		 push	 0
  00070	56		 push	 esi
  00071	e8 00 00 00 00	 call	 _memset
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@UnloadedBi:

; 2510 :     }
; 2511 :     KdpUnlock();

  00079	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdpUnlock@@3P6IXXZA ; KdpUnlock

; 2512 : 
; 2513 :     trapData->unloadedBinary.ret = good;

  0007f	8a 4d ff	 mov	 cl, BYTE PTR _good$[ebp]
  00082	8b 55 08	 mov	 edx, DWORD PTR _trapData$[ebp]
  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	88 4a 09	 mov	 BYTE PTR [edx+9], cl
  0008a	5b		 pop	 ebx

; 2514 : }

  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 08 00	 ret	 8
?UnloadedBinary@@YIXPAUKdDebugTrapData@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ENDP ; UnloadedBinary
_TEXT	ENDS
PUBLIC	??_C@_0BC@EPEKKODO@Serial?5Debugger?3?6?$AA@	; `string'
PUBLIC	??_C@_0BA@JEPCIKCF@1394?5Debugger?3?6?$AA@	; `string'
PUBLIC	??_C@_0O@NHAKLCEB@No?5debugger?4?6?$AA@		; `string'
PUBLIC	??_C@_0CA@FLPBLPA@KdInitialize?$CB?5?$FLCpuMaxCount?$DN?$CFd?$FN?6?$AA@ ; `string'
PUBLIC	?KdInitialize@@YIXPAUClass_Microsoft_Singularity_Hal_Platform@@@Z ; KdInitialize
EXTRN	?KdpSerialPollBreakIn@@YI_NXZ:PROC		; KdpSerialPollBreakIn
EXTRN	?KdpSerialReceivePacket@@YI?AW4KDP_STATUS@@KPAU_STRING@@0PAKPAU_KD_CONTEXT@@@Z:PROC ; KdpSerialReceivePacket
EXTRN	?KdpSerialSendPacket@@YIXKPAU_STRING@@0PAU_KD_CONTEXT@@@Z:PROC ; KdpSerialSendPacket
EXTRN	?Kdp1394PollBreakIn@@YI_NXZ:PROC		; Kdp1394PollBreakIn
EXTRN	?Kdp1394ReceivePacket@@YI?AW4KDP_STATUS@@KPAU_STRING@@0PAKPAU_KD_CONTEXT@@@Z:PROC ; Kdp1394ReceivePacket
EXTRN	?Kdp1394SendPacket@@YIXKPAU_STRING@@0PAU_KD_CONTEXT@@@Z:PROC ; Kdp1394SendPacket
;	COMDAT ??_C@_0BC@EPEKKODO@Serial?5Debugger?3?6?$AA@
CONST	SEGMENT
??_C@_0BC@EPEKKODO@Serial?5Debugger?3?6?$AA@ DB 'Serial Debugger:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JEPCIKCF@1394?5Debugger?3?6?$AA@
CONST	SEGMENT
??_C@_0BA@JEPCIKCF@1394?5Debugger?3?6?$AA@ DB '1394 Debugger:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NHAKLCEB@No?5debugger?4?6?$AA@
CONST	SEGMENT
??_C@_0O@NHAKLCEB@No?5debugger?4?6?$AA@ DB 'No debugger.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FLPBLPA@KdInitialize?$CB?5?$FLCpuMaxCount?$DN?$CFd?$FN?6?$AA@
CONST	SEGMENT
??_C@_0CA@FLPBLPA@KdInitialize?$CB?5?$FLCpuMaxCount?$DN?$CFd?$FN?6?$AA@ DB 'K'
	DB	'dInitialize! [CpuMaxCount=%d]', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?KdInitialize@@YIXPAUClass_Microsoft_Singularity_Hal_Platform@@@Z
_TEXT	SEGMENT
?KdInitialize@@YIXPAUClass_Microsoft_Singularity_Hal_Platform@@@Z PROC ; KdInitialize, COMDAT
; _platform$ = ecx

; 278  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 279  :     kdprintf("KdInitialize! [CpuMaxCount=%d]\n", platform->CpuMaxCount);

  00003	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00006	50		 push	 eax
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@FLPBLPA@KdInitialize?$CB?5?$FLCpuMaxCount?$DN?$CFd?$FN?6?$AA@
  0000c	e8 00 00 00 00	 call	 ?kdprintf@@YAXPBDZZ	; kdprintf
  00011	83 c4 08	 add	 esp, 8

; 280  : 
; 281  :     if (platform->CpuMaxCount == 1) {

  00014	83 7e 20 01	 cmp	 DWORD PTR [esi+32], 1
  00018	75 25		 jne	 SHORT $LN7@KdInitiali

; 282  :         KdpLock = KdpUpLock;

  0001a	b8 00 00 00 00	 mov	 eax, OFFSET ?KdpUpLock@@YIXXZ ; KdpUpLock

; 283  :         KdpUnlock = KdpUpUnlock;

  0001f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?KdpUnlock@@3P6IXXZA, OFFSET ?KdpUpUnlock@@YIXXZ ; KdpUnlock, KdpUpUnlock

; 284  :         KdpEnter = KdpUpEnter;

  00029	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?KdpEnter@@3P6IXXZA, OFFSET ?KdpUpEnter@@YIXXZ ; KdpEnter, KdpUpEnter

; 285  :         KdpLeave = KdpUpLeave;

  00033	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?KdpLeave@@3P6IXXZA, OFFSET ?KdpUpLeave@@YIXXZ ; KdpLeave, KdpUpLeave

; 286  :     }
; 287  :     else  {

  0003d	eb 23		 jmp	 SHORT $LN12@KdInitiali
$LN7@KdInitiali:

; 288  :         KdpLock = KdpMpLock;

  0003f	b8 00 00 00 00	 mov	 eax, OFFSET ?KdpMpLock@@YIXXZ ; KdpMpLock

; 289  :         KdpUnlock = KdpMpUnlock;

  00044	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?KdpUnlock@@3P6IXXZA, OFFSET ?KdpMpUnlock@@YIXXZ ; KdpUnlock, KdpMpUnlock

; 290  :         KdpEnter = KdpMpEnter;

  0004e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?KdpEnter@@3P6IXXZA, OFFSET ?KdpMpEnter@@YIXXZ ; KdpEnter, KdpMpEnter

; 291  :         KdpLeave = KdpMpLeave;

  00058	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?KdpLeave@@3P6IXXZA, OFFSET ?KdpMpLeave@@YIXXZ ; KdpLeave, KdpMpLeave
$LN12@KdInitiali:
  00062	a3 00 00 00 00	 mov	 DWORD PTR ?KdpLock@@3P6IXXZA, eax ; KdpLock

; 292  :     }
; 293  : 
; 294  :     KdpLock();

  00067	ff d0		 call	 eax

; 295  : 
; 296  :     //
; 297  :     // Note that this is not quite right - the Hal debugger routines are only called
; 298  :     // if DEBUGGER_SERIAL is configured.  The right thing to do is always go through the HAL,
; 299  :     // and then do the switching between serial/1394 inside the hal.
; 300  :     //  @todo: Fix this when reconciling native HAL.
; 301  :     //
; 302  : 
; 303  :     switch (platform->DebuggerType) {

  00069	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  0006f	83 e8 01	 sub	 eax, 1
  00072	74 6d		 je	 SHORT $LN2@KdInitiali
  00074	83 e8 01	 sub	 eax, 1
  00077	74 3e		 je	 SHORT $LN1@KdInitiali

; 304  : 
; 305  :     default:
; 306  :     case Class_Microsoft_Singularity_Hal_Platform_DEBUGGER_NONE:
; 307  :         kdprintf("No debugger.\n");

  00079	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NHAKLCEB@No?5debugger?4?6?$AA@
  0007e	e8 00 00 00 00	 call	 ?kdprintf@@YAXPBDZZ	; kdprintf

; 308  : 
; 309  :         KdSendPacket = KdpNulSendPacket;

  00083	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA, OFFSET ?KdpNulSendPacket@@YIXKPAU_STRING@@0PAU_KD_CONTEXT@@@Z ; KdSendPacket, KdpNulSendPacket

; 310  :         KdReceivePacket = KdpNulReceivePacket;

  0008d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?KdReceivePacket@@3P6I?AW4KDP_STATUS@@KPAU_STRING@@0PAKPAU_KD_CONTEXT@@@ZA, OFFSET ?KdpNulReceivePacket@@YI?AW4KDP_STATUS@@KPAU_STRING@@0PAKPAU_KD_CONTEXT@@@Z ; KdReceivePacket, KdpNulReceivePacket

; 311  :         KdPollBreakIn = KdpNulPollBreakIn;

  00097	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?KdPollBreakIn@@3P6I_NXZA, OFFSET ?KdpNulPollBreakIn@@YI_NXZ ; KdPollBreakIn, KdpNulPollBreakIn

; 312  : 
; 313  :         KdDebuggerNotPresent = TRUE;

  000a1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?KdDebuggerNotPresent@@3HA, 1 ; KdDebuggerNotPresent

; 314  :         KdAlwaysPrintOutput = TRUE;  // do we really want to do this?

  000ab	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?KdAlwaysPrintOutput@@3HA, 1 ; KdAlwaysPrintOutput

; 315  :         break;

  000b5	eb 5c		 jmp	 SHORT $LN13@KdInitiali
$LN1@KdInitiali:

; 324  :         break;
; 325  : 
; 326  :     case Class_Microsoft_Singularity_Hal_Platform_DEBUGGER_1394:
; 327  :         kdprintf("1394 Debugger:\n");

  000b7	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JEPCIKCF@1394?5Debugger?3?6?$AA@
  000bc	e8 00 00 00 00	 call	 ?kdprintf@@YAXPBDZZ	; kdprintf

; 328  : 
; 329  :         KdSendPacket = Kdp1394SendPacket;

  000c1	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA, OFFSET ?Kdp1394SendPacket@@YIXKPAU_STRING@@0PAU_KD_CONTEXT@@@Z ; KdSendPacket, Kdp1394SendPacket

; 330  :         KdReceivePacket = Kdp1394ReceivePacket;

  000cb	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?KdReceivePacket@@3P6I?AW4KDP_STATUS@@KPAU_STRING@@0PAKPAU_KD_CONTEXT@@@ZA, OFFSET ?Kdp1394ReceivePacket@@YI?AW4KDP_STATUS@@KPAU_STRING@@0PAKPAU_KD_CONTEXT@@@Z ; KdReceivePacket, Kdp1394ReceivePacket

; 331  :         KdPollBreakIn = Kdp1394PollBreakIn;

  000d5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?KdPollBreakIn@@3P6I_NXZA, OFFSET ?Kdp1394PollBreakIn@@YI_NXZ ; KdPollBreakIn, Kdp1394PollBreakIn

; 332  : 
; 333  :         KdDebuggerNotPresent = FALSE;
; 334  :         break;

  000df	eb 28		 jmp	 SHORT $LN14@KdInitiali
$LN2@KdInitiali:

; 316  : 
; 317  :     case Class_Microsoft_Singularity_Hal_Platform_DEBUGGER_SERIAL:
; 318  :         kdprintf("Serial Debugger:\n");

  000e1	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@EPEKKODO@Serial?5Debugger?3?6?$AA@
  000e6	e8 00 00 00 00	 call	 ?kdprintf@@YAXPBDZZ	; kdprintf

; 319  :         KdSendPacket = KdpSerialSendPacket;

  000eb	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?KdSendPacket@@3P6IXKPAU_STRING@@0PAU_KD_CONTEXT@@@ZA, OFFSET ?KdpSerialSendPacket@@YIXKPAU_STRING@@0PAU_KD_CONTEXT@@@Z ; KdSendPacket, KdpSerialSendPacket

; 320  :         KdReceivePacket = KdpSerialReceivePacket;

  000f5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?KdReceivePacket@@3P6I?AW4KDP_STATUS@@KPAU_STRING@@0PAKPAU_KD_CONTEXT@@@ZA, OFFSET ?KdpSerialReceivePacket@@YI?AW4KDP_STATUS@@KPAU_STRING@@0PAKPAU_KD_CONTEXT@@@Z ; KdReceivePacket, KdpSerialReceivePacket

; 321  :         KdPollBreakIn = KdpSerialPollBreakIn;

  000ff	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?KdPollBreakIn@@3P6I_NXZA, OFFSET ?KdpSerialPollBreakIn@@YI_NXZ ; KdPollBreakIn, KdpSerialPollBreakIn
$LN14@KdInitiali:

; 322  : 
; 323  :         KdDebuggerNotPresent = FALSE;

  00109	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?KdDebuggerNotPresent@@3HA, 0 ; KdDebuggerNotPresent
$LN13@KdInitiali:

; 316  : 
; 317  :     case Class_Microsoft_Singularity_Hal_Platform_DEBUGGER_SERIAL:
; 318  :         kdprintf("Serial Debugger:\n");

  00113	83 c4 04	 add	 esp, 4

; 335  :     }
; 336  : 
; 337  :     // Retries are set to this after boot
; 338  :     KdpContext.KdpDefaultRetries = MAXIMUM_RETRIES;

  00116	c7 05 00 00 00
	00 14 00 00 00	 mov	 DWORD PTR _KdpContext, 20 ; 00000014H

; 339  : 
; 340  :     KdpUnlock();

  00120	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdpUnlock@@3P6IXXZA ; KdpUnlock

; 341  : 
; 342  :     KdpFakeOutPsLoadedModuleList(platform);

  00126	8b c6		 mov	 eax, esi
  00128	5e		 pop	 esi
  00129	e9 00 00 00 00	 jmp	 ?KdpFakeOutPsLoadedModuleList@@YIXPAUClass_Microsoft_Singularity_Hal_Platform@@@Z ; KdpFakeOutPsLoadedModuleList
?KdInitialize@@YIXPAUClass_Microsoft_Singularity_Hal_Platform@@@Z ENDP ; KdInitialize
_TEXT	ENDS
PUBLIC	?g_Trap@Class_Microsoft_Singularity_DebugStub@@SI_NPAUStruct_Microsoft_Singularity_Isal_SpillContext@@H@Z ; Class_Microsoft_Singularity_DebugStub::g_Trap
EXTRN	?KdpConvertTrapToException@@YIXPAUStruct_Microsoft_Singularity_Kd_ExceptionRecord64@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@H@Z:PROC ; KdpConvertTrapToException
EXTRN	?KdpIsDebugTrap@@YIPAUKdDebugTrapData@@PBUStruct_Microsoft_Singularity_Isal_SpillContext@@H@Z:PROC ; KdpIsDebugTrap
; Function compile flags: /Ogtp
;	COMDAT ?g_Trap@Class_Microsoft_Singularity_DebugStub@@SI_NPAUStruct_Microsoft_Singularity_Isal_SpillContext@@H@Z
_TEXT	SEGMENT
_er$ = -152						; size = 152
?g_Trap@Class_Microsoft_Singularity_DebugStub@@SI_NPAUStruct_Microsoft_Singularity_Isal_SpillContext@@H@Z PROC ; Class_Microsoft_Singularity_DebugStub::g_Trap, COMDAT
; _context$ = ecx
; _id$ = edx

; 2251 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00009	53		 push	 ebx
  0000a	57		 push	 edi

; 2252 :     EXCEPTION_RECORD64 er;
; 2253 :     bool handled;
; 2254 :     RtlZeroMemory(&er, sizeof(er));

  0000b	68 98 00 00 00	 push	 152			; 00000098H
  00010	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _er$[ebp]
  00016	6a 00		 push	 0
  00018	50		 push	 eax
  00019	8b fa		 mov	 edi, edx
  0001b	8b d9		 mov	 ebx, ecx
  0001d	e8 00 00 00 00	 call	 _memset
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2255 : 
; 2256 :     if (KdDebuggerNotPresent) {

  00025	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?KdDebuggerNotPresent@@3HA, 0 ; KdDebuggerNotPresent
  0002c	74 08		 je	 SHORT $LN8@g_Trap
  0002e	5f		 pop	 edi

; 2257 :         return true;

  0002f	b0 01		 mov	 al, 1
  00031	5b		 pop	 ebx

; 2292 : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
$LN8@g_Trap:
  00036	56		 push	 esi

; 2258 :     }
; 2259 : 
; 2260 :     KdpLock();

  00037	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdpLock@@3P6IXXZA ; KdpLock

; 2261 : 
; 2262 :     KDDBG("CPU %d: In g_Trap num=%d ...", KdCurrentCpuId(), id);
; 2263 : 
; 2264 :     KdDebugTrapData * trapData = KdpIsDebugTrap(context, id);

  0003d	8b d7		 mov	 edx, edi
  0003f	8b cb		 mov	 ecx, ebx
  00041	e8 00 00 00 00	 call	 ?KdpIsDebugTrap@@YIPAUKdDebugTrapData@@PBUStruct_Microsoft_Singularity_Isal_SpillContext@@H@Z ; KdpIsDebugTrap
  00046	8b f0		 mov	 esi, eax

; 2265 : 
; 2266 :     if (trapData != NULL) {

  00048	85 f6		 test	 esi, esi
  0004a	74 39		 je	 SHORT $LN2@g_Trap

; 2267 :         if (trapData->tag == KdDebugTrapData::LOADED_BINARY) {

  0004c	8b 06		 mov	 eax, DWORD PTR [esi]
  0004e	83 f8 01	 cmp	 eax, 1
  00051	75 17		 jne	 SHORT $LN5@g_Trap

; 2268 :             KDDBG("KD: Loaded binary %ls\n", trapData->loadedBinary.name);
; 2269 :             KdpUnlock();

  00053	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdpUnlock@@3P6IXXZA ; KdpUnlock

; 2270 :             LoadedBinary(trapData, context);

  00059	53		 push	 ebx
  0005a	8b de		 mov	 ebx, esi
  0005c	e8 00 00 00 00	 call	 ?LoadedBinary@@YIXPAUKdDebugTrapData@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ; LoadedBinary
  00061	5e		 pop	 esi
  00062	5f		 pop	 edi

; 2271 :             return true;

  00063	b0 01		 mov	 al, 1
  00065	5b		 pop	 ebx

; 2292 : }

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
$LN5@g_Trap:

; 2272 :         }
; 2273 :         else if (trapData->tag == KdDebugTrapData::UNLOADED_BINARY) {

  0006a	83 f8 02	 cmp	 eax, 2
  0006d	75 16		 jne	 SHORT $LN2@g_Trap

; 2274 :             KDDBG("KD: Unloaded binary\n");
; 2275 :             KdpUnlock();

  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdpUnlock@@3P6IXXZA ; KdpUnlock

; 2276 :             UnloadedBinary(trapData, context);

  00075	53		 push	 ebx
  00076	56		 push	 esi
  00077	e8 00 00 00 00	 call	 ?UnloadedBinary@@YIXPAUKdDebugTrapData@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ; UnloadedBinary
  0007c	5e		 pop	 esi
  0007d	5f		 pop	 edi

; 2277 :             return true;

  0007e	b0 01		 mov	 al, 1
  00080	5b		 pop	 ebx

; 2292 : }

  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
$LN2@g_Trap:

; 2278 :         }
; 2279 :     }
; 2280 : 
; 2281 :     KdpConvertTrapToException(&er, context, id);

  00085	57		 push	 edi
  00086	8b d3		 mov	 edx, ebx
  00088	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _er$[ebp]
  0008e	e8 00 00 00 00	 call	 ?KdpConvertTrapToException@@YIXPAUStruct_Microsoft_Singularity_Kd_ExceptionRecord64@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@H@Z ; KdpConvertTrapToException

; 2282 : 
; 2283 :     KdpEnter();

  00093	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdpEnter@@3P6IXXZA ; KdpEnter

; 2284 : 
; 2285 :     handled = (KdpReportExceptionStateChange(&er, context, trapData != NULL) == ContinueSuccess);

  00099	33 c9		 xor	 ecx, ecx
  0009b	85 f6		 test	 esi, esi
  0009d	0f 95 c1	 setne	 cl
  000a0	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR _er$[ebp]
  000a6	51		 push	 ecx
  000a7	52		 push	 edx
  000a8	e8 00 00 00 00	 call	 ?KdpReportExceptionStateChange@@YI?AW4KCONTINUE_STATUS@@PAUStruct_Microsoft_Singularity_Kd_ExceptionRecord64@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@H@Z ; KdpReportExceptionStateChange
  000ad	83 f8 01	 cmp	 eax, 1
  000b0	0f 94 c3	 sete	 bl

; 2286 : 
; 2287 :     KdpLeave();

  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdpLeave@@3P6IXXZA ; KdpLeave

; 2288 : 
; 2289 :     KdpUnlock();

  000b9	ff 15 00 00 00
	00		 call	 DWORD PTR ?KdpUnlock@@3P6IXXZA ; KdpUnlock
  000bf	5e		 pop	 esi
  000c0	5f		 pop	 edi

; 2290 : 
; 2291 :     return handled;

  000c1	8a c3		 mov	 al, bl
  000c3	5b		 pop	 ebx

; 2292 : }

  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
?g_Trap@Class_Microsoft_Singularity_DebugStub@@SI_NPAUStruct_Microsoft_Singularity_Isal_SpillContext@@H@Z ENDP ; Class_Microsoft_Singularity_DebugStub::g_Trap
_TEXT	ENDS
END
