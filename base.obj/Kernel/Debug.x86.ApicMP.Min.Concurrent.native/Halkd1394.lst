; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	C:\Users\cc\source\repos\Singularity-OS\base\Kernel\Native\Halkd1394.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

; Function compile flags: /Ogtp
; File c:\users\cc\source\repos\singularity-os\base\kernel\native\halkd1394.cpp
;	COMDAT ?MmGetPhysicalAddress@@YIIPAX@Z
_TEXT	SEGMENT
?MmGetPhysicalAddress@@YIIPAX@Z PROC			; MmGetPhysicalAddress, COMDAT
; _pv$ = eax

; 91   :     return (ULONG_PTR)pv;
; 92   : }

  00000	c3		 ret	 0
?MmGetPhysicalAddress@@YIIPAX@Z ENDP			; MmGetPhysicalAddress
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Dbg1394_StallExecution@@YIKK@Z
_TEXT	SEGMENT
_b$ = -12						; size = 4
_k$12341 = -8						; size = 4
_i$12345 = -4						; size = 4
?Dbg1394_StallExecution@@YIKK@Z PROC			; Dbg1394_StallExecution, COMDAT
; _LoopCount$ = edx

; 96   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 97   :     volatile UINT32 b = 1;

  00006	b8 01 00 00 00	 mov	 eax, 1
  0000b	89 45 f4	 mov	 DWORD PTR _b$[ebp], eax

; 98   : 
; 99   :     for (volatile UINT32 k = 0; k < LoopCount; k++) {

  0000e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _k$12341[ebp], 0
  00015	8b 4d f8	 mov	 ecx, DWORD PTR _k$12341[ebp]
  00018	3b ca		 cmp	 ecx, edx
  0001a	73 40		 jae	 SHORT $LN13@Dbg1394_St
  0001c	56		 push	 esi
  0001d	8d 49 00	 npad	 3
$LL6@Dbg1394_St:

; 100  :         for (volatile UINT32 i = 1; i < 100000; i++) {

  00020	89 45 fc	 mov	 DWORD PTR _i$12345[ebp], eax
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _i$12345[ebp]
  00026	81 f9 a0 86 01
	00		 cmp	 ecx, 100000		; 000186a0H
  0002c	73 23		 jae	 SHORT $LN5@Dbg1394_St
  0002e	8b ff		 npad	 2
$LL3@Dbg1394_St:

; 101  : #ifdef ISA_IX86
; 102  :             __asm pause;

  00030	f3 90		 pause

; 103  : #endif
; 104  :             b = b * (i>>k);

  00032	8b 75 fc	 mov	 esi, DWORD PTR _i$12345[ebp]
  00035	8a 4d f8	 mov	 cl, BYTE PTR _k$12341[ebp]
  00038	d3 ee		 shr	 esi, cl
  0003a	8b 4d f4	 mov	 ecx, DWORD PTR _b$[ebp]
  0003d	0f af f1	 imul	 esi, ecx
  00040	89 75 f4	 mov	 DWORD PTR _b$[ebp], esi
  00043	01 45 fc	 add	 DWORD PTR _i$12345[ebp], eax
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _i$12345[ebp]
  00049	81 f9 a0 86 01
	00		 cmp	 ecx, 100000		; 000186a0H
  0004f	72 df		 jb	 SHORT $LL3@Dbg1394_St
$LN5@Dbg1394_St:

; 98   : 
; 99   :     for (volatile UINT32 k = 0; k < LoopCount; k++) {

  00051	01 45 f8	 add	 DWORD PTR _k$12341[ebp], eax
  00054	8b 4d f8	 mov	 ecx, DWORD PTR _k$12341[ebp]
  00057	3b ca		 cmp	 ecx, edx
  00059	72 c5		 jb	 SHORT $LL6@Dbg1394_St
  0005b	5e		 pop	 esi
$LN13@Dbg1394_St:

; 105  :         }
; 106  :     }
; 107  : 
; 108  :     return b;

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _b$[ebp]

; 109  : }

  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?Dbg1394_StallExecution@@YIKK@Z ENDP			; Dbg1394_StallExecution
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Dbg1394_ByteSwap@@YIKK@Z
_TEXT	SEGMENT
?Dbg1394_ByteSwap@@YIKK@Z PROC				; Dbg1394_ByteSwap, COMDAT
; _Source$ = ecx

; 114  :     return (((Source)              << (8 * 3)) |
; 115  :             ((Source & 0x0000FF00) << (8 * 1)) |
; 116  :             ((Source & 0x00FF0000) >> (8 * 1)) |
; 117  :             ((Source)              >> (8 * 3)));

  00000	8b c1		 mov	 eax, ecx
  00002	8b d1		 mov	 edx, ecx
  00004	c1 e2 10	 shl	 edx, 16			; 00000010H
  00007	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  0000c	0b c2		 or	 eax, edx
  0000e	8b d1		 mov	 edx, ecx
  00010	81 e2 00 00 ff
	00		 and	 edx, 16711680		; 00ff0000H
  00016	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00019	0b d1		 or	 edx, ecx
  0001b	c1 e0 08	 shl	 eax, 8
  0001e	c1 ea 08	 shr	 edx, 8
  00021	0b c2		 or	 eax, edx

; 118  : }

  00023	c3		 ret	 0
?Dbg1394_ByteSwap@@YIKK@Z ENDP				; Dbg1394_ByteSwap
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Dbg1394_Crc16@@YIKKK@Z
_TEXT	SEGMENT
?Dbg1394_Crc16@@YIKKK@Z PROC				; Dbg1394_Crc16, COMDAT
; _data$ = esi
; _check$ = edx

; 126  :     UINT32 next = check;
; 127  : 
; 128  :     for (INT32 shift = 28; shift >= 0; shift -= 4) {

  00000	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  00005	57		 push	 edi
$LL3@Dbg1394_Cr:

; 129  :         UINT32 sum = ((next >> 12) ^ (data >> shift)) & 0xf;

  00006	8b c6		 mov	 eax, esi
  00008	d3 e8		 shr	 eax, cl
  0000a	8b fa		 mov	 edi, edx
  0000c	c1 ef 0c	 shr	 edi, 12			; 0000000cH
  0000f	33 c7		 xor	 eax, edi
  00011	83 e0 0f	 and	 eax, 15			; 0000000fH

; 130  :         next = (next << 4) ^ (sum << 12) ^ (sum << 5) ^ (sum);

  00014	8b f8		 mov	 edi, eax
  00016	c1 e7 07	 shl	 edi, 7
  00019	33 f8		 xor	 edi, eax
  0001b	03 ff		 add	 edi, edi
  0001d	33 fa		 xor	 edi, edx
  0001f	c1 e7 04	 shl	 edi, 4
  00022	33 f8		 xor	 edi, eax
  00024	83 e9 04	 sub	 ecx, 4
  00027	8b d7		 mov	 edx, edi
  00029	79 db		 jns	 SHORT $LL3@Dbg1394_Cr

; 131  :     }
; 132  :     return (next & 0xFFFF);

  0002b	0f b7 c2	 movzx	 eax, dx
  0002e	5f		 pop	 edi

; 133  : }

  0002f	c3		 ret	 0
?Dbg1394_Crc16@@YIKKK@Z ENDP				; Dbg1394_Crc16
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Dbg1394_CalculateCrc@@YIGPAKK@Z
_TEXT	SEGMENT
_Quadlet$ = 8						; size = 4
_length$ = 12						; size = 4
?Dbg1394_CalculateCrc@@YIGPAKK@Z PROC			; Dbg1394_CalculateCrc, COMDAT

; 139  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 140  :     UINT32 temp = 0;

  00004	33 c0		 xor	 eax, eax

; 141  : 
; 142  :     for (UINT32 index = 0; index < length; index++) {

  00006	33 ff		 xor	 edi, edi
  00008	39 45 0c	 cmp	 DWORD PTR _length$[ebp], eax
  0000b	76 45		 jbe	 SHORT $LN1@Dbg1394_Ca
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	90		 npad	 1
$LL16@Dbg1394_Ca:

; 143  :         temp = Dbg1394_Crc16(Quadlet[index], temp);

  00010	8b d0		 mov	 edx, eax
  00012	8b 45 08	 mov	 eax, DWORD PTR _Quadlet$[ebp]
  00015	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
  00018	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0001d	8d 49 00	 npad	 3
$LL8@Dbg1394_Ca:
  00020	8b c6		 mov	 eax, esi
  00022	d3 e8		 shr	 eax, cl
  00024	8b da		 mov	 ebx, edx
  00026	c1 eb 0c	 shr	 ebx, 12			; 0000000cH
  00029	33 c3		 xor	 eax, ebx
  0002b	83 e0 0f	 and	 eax, 15			; 0000000fH
  0002e	8b d8		 mov	 ebx, eax
  00030	c1 e3 07	 shl	 ebx, 7
  00033	33 d8		 xor	 ebx, eax
  00035	03 db		 add	 ebx, ebx
  00037	33 da		 xor	 ebx, edx
  00039	c1 e3 04	 shl	 ebx, 4
  0003c	33 d8		 xor	 ebx, eax
  0003e	83 e9 04	 sub	 ecx, 4
  00041	8b d3		 mov	 edx, ebx
  00043	79 db		 jns	 SHORT $LL8@Dbg1394_Ca
  00045	83 c7 01	 add	 edi, 1
  00048	3b 7d 0c	 cmp	 edi, DWORD PTR _length$[ebp]
  0004b	0f b7 c2	 movzx	 eax, dx
  0004e	72 c0		 jb	 SHORT $LL16@Dbg1394_Ca
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
$LN1@Dbg1394_Ca:
  00052	5f		 pop	 edi

; 144  :     }
; 145  :     return (UINT16)temp;
; 146  : }

  00053	5d		 pop	 ebp
  00054	c2 08 00	 ret	 8
?Dbg1394_CalculateCrc@@YIGPAKK@Z ENDP			; Dbg1394_CalculateCrc
_TEXT	ENDS
PUBLIC	??_C@_0BG@NFIKFFGB@1394?3?5Init?5Succeeded?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@NOHPBAHD@1394?3?5Hard?5reset?5on?5bus?5failed?6?$AA@ ; `string'
PUBLIC	??_C@_0BK@CNKFCMMN@1394?3?5Read?5on?5bus?5failed?6?$AA@ ; `string'
PUBLIC	??_C@_0BE@JOJNNAMH@1394?3?5Reset?5failed?6?$AA@	; `string'
PUBLIC	??_C@_0BJ@GHDEGGNA@1394?3?5MajorVersion?5?$CB?$DN?51?6?$AA@ ; `string'
PUBLIC	?Kdp1394Init@@YI_NGIIK@Z			; Kdp1394Init
EXTRN	?kdprintf@@YAXPBDZZ:PROC			; kdprintf
EXTRN	_memset:PROC
_BSS	SEGMENT
_KdRegisters DD	01H DUP (?)
_Kd1394Data DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BG@NFIKFFGB@1394?3?5Init?5Succeeded?6?$AA@
CONST	SEGMENT
??_C@_0BG@NFIKFFGB@1394?3?5Init?5Succeeded?6?$AA@ DB '1394: Init Succeede'
	DB	'd', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NOHPBAHD@1394?3?5Hard?5reset?5on?5bus?5failed?6?$AA@
CONST	SEGMENT
??_C@_0CA@NOHPBAHD@1394?3?5Hard?5reset?5on?5bus?5failed?6?$AA@ DB '1394: '
	DB	'Hard reset on bus failed', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CNKFCMMN@1394?3?5Read?5on?5bus?5failed?6?$AA@
CONST	SEGMENT
??_C@_0BK@CNKFCMMN@1394?3?5Read?5on?5bus?5failed?6?$AA@ DB '1394: Read on'
	DB	' bus failed', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JOJNNAMH@1394?3?5Reset?5failed?6?$AA@
CONST	SEGMENT
??_C@_0BE@JOJNNAMH@1394?3?5Reset?5failed?6?$AA@ DB '1394: Reset failed', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GHDEGGNA@1394?3?5MajorVersion?5?$CB?$DN?51?6?$AA@
CONST	SEGMENT
??_C@_0BJ@GHDEGGNA@1394?3?5MajorVersion?5?$CB?$DN?51?6?$AA@ DB '1394: Maj'
	DB	'orVersion != 1', 0aH, 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?Kdp1394Init@@YI_NGIIK@Z
_TEXT	SEGMENT
_DirectoryInfo$ = 8					; size = 4
_ConfigRomHeader$ = 8					; size = 4
_BufferAddr32$ = 8					; size = 4
_BufferSize32$ = 12					; size = 4
?Kdp1394Init@@YI_NGIIK@Z PROC				; Kdp1394Init, COMDAT
; _Channel$ = cx
; _Base$ = edx

; 151  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b fa		 mov	 edi, edx

; 152  :     if (Base == 0 ||
; 153  :         BufferAddr32 == 0 ||
; 154  :         BufferSize32 < sizeof(DEBUG_1394_DATA)) {

  00008	85 ff		 test	 edi, edi
  0000a	66 8b d9	 mov	 bx, cx
  0000d	0f 84 a4 00 00
	00		 je	 $LN18@Kdp1394Ini
  00013	8b 75 08	 mov	 esi, DWORD PTR _BufferAddr32$[ebp]
  00016	85 f6		 test	 esi, esi
  00018	0f 84 99 00 00
	00		 je	 $LN18@Kdp1394Ini
  0001e	81 7d 0c 00 24
	00 00		 cmp	 DWORD PTR _BufferSize32$[ebp], 9216 ; 00002400H
  00025	0f 82 8c 00 00
	00		 jb	 $LN18@Kdp1394Ini

; 155  : 
; 156  :         return false;
; 157  :     }
; 158  : 
; 159  :     // Note: Kd1394Data must be in the low 32-bits of address space due to
; 160  :     //       limits on valid 1394 DMA addresses.  It must also be contiguous.
; 161  : 
; 162  :     Kd1394Data = (DEBUG_1394_DATA *)BufferAddr32;
; 163  :     memset(Kd1394Data, 0, sizeof(*Kd1394Data));

  0002b	68 00 24 00 00	 push	 9216			; 00002400H
  00030	6a 00		 push	 0
  00032	56		 push	 esi
  00033	89 35 00 00 00
	00		 mov	 DWORD PTR _Kd1394Data, esi
  00039	e8 00 00 00 00	 call	 _memset

; 164  : 
; 165  :     // get our base address
; 166  :     KdRegisters = (volatile OHCI_REGISTER_MAP *)Base;
; 167  : 
; 168  :     // initialize our config info for host debugger to read.
; 169  :     Kd1394Data->Config.Tag = DEBUG_1394_CONFIG_TAG;
; 170  :     Kd1394Data->Config.MajorVersion = DEBUG_1394_MAJOR_VERSION;
; 171  :     Kd1394Data->Config.MinorVersion = DEBUG_1394_MINOR_VERSION;

  0003e	33 c9		 xor	 ecx, ecx
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH

; 172  :     Kd1394Data->Config.Id = (Channel < 0x100) ? Channel : 0;

  00043	66 81 fb 00 01	 cmp	 bx, 256			; 00000100H
  00048	89 3d 00 00 00
	00		 mov	 DWORD PTR _KdRegisters, edi
  0004e	c7 86 e0 03 00
	00 ba ba ba ba	 mov	 DWORD PTR [esi+992], -1162167622 ; babababaH
  00058	66 c7 86 e4 03
	00 00 01 00	 mov	 WORD PTR [esi+996], 1
  00061	66 89 8e e6 03
	00 00		 mov	 WORD PTR [esi+998], cx
  00068	73 05		 jae	 SHORT $LN22@Kdp1394Ini
  0006a	0f b7 c3	 movzx	 eax, bx
  0006d	eb 02		 jmp	 SHORT $LN23@Kdp1394Ini
$LN22@Kdp1394Ini:
  0006f	33 c0		 xor	 eax, eax
$LN23@Kdp1394Ini:
  00071	89 86 e8 03 00
	00		 mov	 DWORD PTR [esi+1000], eax

; 173  :     Kd1394Data->Config.BusPresent = false;
; 174  :     Kd1394Data->Config.SendPacket = MmGetPhysicalAddress(&Kd1394Data->SendPacket);

  00077	8d 86 00 04 00
	00		 lea	 eax, DWORD PTR [esi+1024]

; 175  :     Kd1394Data->Config.ReceivePacket = MmGetPhysicalAddress(&Kd1394Data->ReceivePacket);

  0007d	8d 96 00 14 00
	00		 lea	 edx, DWORD PTR [esi+5120]
  00083	89 86 f0 03 00
	00		 mov	 DWORD PTR [esi+1008], eax
  00089	89 8e ec 03 00
	00		 mov	 DWORD PTR [esi+1004], ecx
  0008f	89 8e f4 03 00
	00		 mov	 DWORD PTR [esi+1012], ecx
  00095	89 96 f8 03 00
	00		 mov	 DWORD PTR [esi+1016], edx
  0009b	89 8e fc 03 00
	00		 mov	 DWORD PTR [esi+1020], ecx

; 176  : 
; 177  :     // get our version
; 178  :     UINT32 ulVersion = KdRegisters->Version.all;
; 179  :     UCHAR MajorVersion = (UCHAR)(ulVersion >> 16);

  000a1	8b 07		 mov	 eax, DWORD PTR [edi]
  000a3	c1 e8 10	 shr	 eax, 16			; 00000010H

; 180  : 
; 181  :     // make sure we have a valid version
; 182  :     if (MajorVersion != 1) { // INVESTIGATE

  000a6	3c 01		 cmp	 al, 1
  000a8	74 16		 je	 SHORT $LN17@Kdp1394Ini

; 183  :         kdprintf("1394: MajorVersion != 1\n");

  000aa	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@GHDEGGNA@1394?3?5MajorVersion?5?$CB?$DN?51?6?$AA@

; 200  :         kdprintf("1394: Reset failed\n");

  000af	e8 00 00 00 00	 call	 ?kdprintf@@YAXPBDZZ	; kdprintf
  000b4	83 c4 04	 add	 esp, 4
$LN18@Kdp1394Ini:
  000b7	5f		 pop	 edi
  000b8	5e		 pop	 esi
  000b9	32 c0		 xor	 al, al
  000bb	5b		 pop	 ebx

; 357  : }

  000bc	5d		 pop	 ebp
  000bd	c2 08 00	 ret	 8
$LN17@Kdp1394Ini:

; 184  :         return false;
; 185  :     }
; 186  : 
; 187  :     // soft reset to initialize the controller
; 188  :     HC_CONTROL_REGISTER HCControl;
; 189  :     HCControl.all = 0;
; 190  :     HCControl.SoftReset = true;
; 191  :     KdRegisters->HCControlSet.all = HCControl.all;

  000c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _KdRegisters
  000c6	c7 41 50 00 00
	01 00		 mov	 DWORD PTR [ecx+80], 65536 ; 00010000H

; 192  : 
; 193  :     // wait until reset complete - ??
; 194  :     UINT32 retry = 1000; // ??

  000cd	bf e8 03 00 00	 mov	 edi, 1000		; 000003e8H
$LL16@Kdp1394Ini:

; 195  :     do {
; 196  :         HCControl.all = KdRegisters->HCControlSet.all;

  000d2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _KdRegisters
  000d8	8b 72 50	 mov	 esi, DWORD PTR [edx+80]

; 197  :         Dbg1394_StallExecution(1);

  000db	ba 01 00 00 00	 mov	 edx, 1
  000e0	e8 00 00 00 00	 call	 ?Dbg1394_StallExecution@@YIKK@Z ; Dbg1394_StallExecution

; 198  :     } while ((HCControl.SoftReset) && (--retry));

  000e5	f7 c6 00 00 01
	00		 test	 esi, 65536		; 00010000H
  000eb	74 1a		 je	 SHORT $LN13@Kdp1394Ini
  000ed	2b fa		 sub	 edi, edx
  000ef	75 e1		 jne	 SHORT $LL16@Kdp1394Ini

; 200  :         kdprintf("1394: Reset failed\n");

  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JOJNNAMH@1394?3?5Reset?5failed?6?$AA@
  000f6	e8 00 00 00 00	 call	 ?kdprintf@@YAXPBDZZ	; kdprintf
  000fb	83 c4 04	 add	 esp, 4
  000fe	5f		 pop	 edi
  000ff	5e		 pop	 esi
  00100	32 c0		 xor	 al, al
  00102	5b		 pop	 ebx

; 357  : }

  00103	5d		 pop	 ebp
  00104	c2 08 00	 ret	 8
$LN13@Kdp1394Ini:

; 199  :     if (retry == 0) {

  00107	33 db		 xor	 ebx, ebx
  00109	3b fb		 cmp	 edi, ebx
  0010b	75 16		 jne	 SHORT $LN12@Kdp1394Ini

; 200  :         kdprintf("1394: Reset failed\n");

  0010d	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JOJNNAMH@1394?3?5Reset?5failed?6?$AA@
  00112	e8 00 00 00 00	 call	 ?kdprintf@@YAXPBDZZ	; kdprintf
  00117	83 c4 04	 add	 esp, 4
  0011a	5f		 pop	 edi
  0011b	5e		 pop	 esi
  0011c	32 c0		 xor	 al, al
  0011e	5b		 pop	 ebx

; 357  : }

  0011f	5d		 pop	 ebp
  00120	c2 08 00	 ret	 8
$LN12@Kdp1394Ini:

; 201  :         return false;
; 202  :     }
; 203  : 
; 204  :     // enable link to phy communication.
; 205  :     HCControl.all = 0;
; 206  :     HCControl.Lps = true;
; 207  :     KdRegisters->HCControlSet.all = HCControl.all;

  00123	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdRegisters
  00128	c7 40 50 00 00
	08 00		 mov	 DWORD PTR [eax+80], 524288 ; 00080000H

; 208  : 
; 209  :     Dbg1394_StallExecution(20);

  0012f	ba 14 00 00 00	 mov	 edx, 20			; 00000014H
  00134	e8 00 00 00 00	 call	 ?Dbg1394_StallExecution@@YIKK@Z ; Dbg1394_StallExecution

; 210  : 
; 211  :     // initialize HCControl register
; 212  :     // send data in little-endian order (i.e. do byte swap).
; 213  :     HCControl.all = 0;
; 214  :     HCControl.NoByteSwapData = true;
; 215  :     KdRegisters->HCControlClear.all = HCControl.all;

  00139	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdRegisters

; 216  : 
; 217  :     // enable posted writes.
; 218  :     HCControl.all = 0;
; 219  :     HCControl.PostedWriteEnable = true;
; 220  :     KdRegisters->HCControlSet.all = HCControl.all;
; 221  : 
; 222  :     // setup the link control
; 223  :     LINK_CONTROL_REGISTER LinkControl;
; 224  :     LinkControl.all = 0;
; 225  :     LinkControl.CycleTimerEnable = true;
; 226  :     LinkControl.CycleMaster = true;
; 227  :     LinkControl.RcvPhyPkt = true;
; 228  :     LinkControl.RcvSelfId = true;
; 229  :     KdRegisters->LinkControlClear.all = LinkControl.all;
; 230  : 
; 231  :     LinkControl.all = 0;
; 232  :     LinkControl.CycleTimerEnable = true;
; 233  :     LinkControl.CycleMaster = true;
; 234  :     KdRegisters->LinkControlSet.all = LinkControl.all;
; 235  : 
; 236  :     // set the bus number (hardcoded to 0x3FF) - ??? what about node id??
; 237  :     NODE_ID_REGISTER NodeId;
; 238  :     NodeId.all = 0;
; 239  :     NodeId.BusId = (UINT16)0x3FF;
; 240  :     KdRegisters->NodeId.all = NodeId.all;
; 241  : 
; 242  :     // do something with the crom...
; 243  : 
; 244  :     // 0xf0000404 - bus id register
; 245  :     Kd1394Data->CromBuffer[1] = 0x31333934;

  0013e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  00144	c7 40 54 00 00
	00 40		 mov	 DWORD PTR [eax+84], 1073741824 ; 40000000H
  0014b	c7 40 50 00 00
	04 00		 mov	 DWORD PTR [eax+80], 262144 ; 00040000H
  00152	c7 80 e4 00 00
	00 00 06 30 00	 mov	 DWORD PTR [eax+228], 3147264 ; 00300600H
  0015c	c7 80 e0 00 00
	00 00 00 30 00	 mov	 DWORD PTR [eax+224], 3145728 ; 00300000H
  00166	c7 80 e8 00 00
	00 c0 ff 00 00	 mov	 DWORD PTR [eax+232], 65472 ; 0000ffc0H
  00170	c7 41 04 34 39
	33 31		 mov	 DWORD PTR [ecx+4], 825440564 ; 31333934H

; 246  : 
; 247  :     // 0xf0000408 - bus options register
; 248  :     BUS_OPTIONS_REGISTER BusOptions;
; 249  :     BusOptions.all = Dbg1394_ByteSwap(KdRegisters->BusOptions.all);

  00177	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0017a	e8 00 00 00 00	 call	 ?Dbg1394_ByteSwap@@YIKK@Z ; Dbg1394_ByteSwap

; 250  :     BusOptions.Pmc = false;
; 251  :     BusOptions.Bmc = false;
; 252  :     BusOptions.Isc = false;
; 253  :     BusOptions.Cmc = false;
; 254  :     BusOptions.Irmc = false;
; 255  :     BusOptions.g = 1;

  0017f	8b c8		 mov	 ecx, eax
  00181	81 e1 3f ff ff
	07		 and	 ecx, 134217535		; 07ffff3fH
  00187	83 c9 40	 or	 ecx, 64			; 00000040H

; 256  :     Kd1394Data->CromBuffer[2] = Dbg1394_ByteSwap(BusOptions.all);

  0018a	e8 00 00 00 00	 call	 ?Dbg1394_ByteSwap@@YIKK@Z ; Dbg1394_ByteSwap
  0018f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _Kd1394Data
  00195	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 257  : 
; 258  :     // 0xf000040c - global unique id hi
; 259  :     Kd1394Data->CromBuffer[3] = KdRegisters->GuidHi;

  00198	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdRegisters
  0019d	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  001a0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _Kd1394Data

; 260  : 
; 261  :     // 0xf0000410 - global unique id lo
; 262  :     Kd1394Data->CromBuffer[4] = KdRegisters->GuidLo;

  001a6	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdRegisters
  001ab	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  001ae	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  001b1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _Kd1394Data

; 263  : 
; 264  :     // 0xf0000400 - config ROM header - set last to calculate CRC!
; 265  :     CONFIG_ROM_INFO ConfigRomHeader;
; 266  :     ConfigRomHeader.all = 0;
; 267  :     ConfigRomHeader.CRI_Info_Length = 4;

  001b7	b8 04 00 00 00	 mov	 eax, 4

; 268  :     ConfigRomHeader.CRI_CRC_Length = 4;
; 269  :     ConfigRomHeader.CRI_CRC_Value = Dbg1394_CalculateCrc(&Kd1394Data->CromBuffer[1],
; 270  :                                                          ConfigRomHeader.CRI_CRC_Length);

  001bc	50		 push	 eax
  001bd	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
  001c0	89 5d 08	 mov	 DWORD PTR _ConfigRomHeader$[ebp], ebx
  001c3	52		 push	 edx
  001c4	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  001c7	88 45 0b	 mov	 BYTE PTR _ConfigRomHeader$[ebp+3], al
  001ca	88 45 0a	 mov	 BYTE PTR _ConfigRomHeader$[ebp+2], al
  001cd	e8 00 00 00 00	 call	 ?Dbg1394_CalculateCrc@@YIGPAKK@Z ; Dbg1394_CalculateCrc
  001d2	66 89 45 08	 mov	 WORD PTR _ConfigRomHeader$[ebp], ax

; 271  :     Kd1394Data->CromBuffer[0] = ConfigRomHeader.all;

  001d6	8b 45 08	 mov	 eax, DWORD PTR _ConfigRomHeader$[ebp]

; 272  : 
; 273  :     Kd1394Data->CromBuffer[6] = 0xC083000C; // 0xf0000418 - node capabilities
; 274  :     Kd1394Data->CromBuffer[7] = 0xF2500003; // 0xf000041C - module vendor id
; 275  : 
; 276  :     // KD's state machine looks for 1c w/ 50f2, 1d w/ 02, then 1e w/ address.
; 277  :     Kd1394Data->CromBuffer[8] = 0xF250001C; // 0xf0000420 - extended key (for KD)
; 278  :     Kd1394Data->CromBuffer[9] = 0x0200001D; // 0xf0000424 - debug key (for KD)
; 279  : 
; 280  :     // 0xf0000428 - debug value (for KD)
; 281  :     IMMEDIATE_ENTRY CromEntry;
; 282  :     CromEntry.all = (UINT32)MmGetPhysicalAddress(&Kd1394Data->Config);

  001d9	8d 8e e0 03 00
	00		 lea	 ecx, DWORD PTR [esi+992]

; 283  :     CromEntry.IE_Key = 0x1E;

  001df	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  001e5	8d 7e 18	 lea	 edi, DWORD PTR [esi+24]
  001e8	81 c9 00 00 00
	1e		 or	 ecx, 503316480		; 1e000000H
  001ee	89 06		 mov	 DWORD PTR [esi], eax
  001f0	c7 07 0c 00 83
	c0		 mov	 DWORD PTR [edi], -1065156596 ; c083000cH
  001f6	c7 46 1c 03 00
	50 f2		 mov	 DWORD PTR [esi+28], -229638141 ; f2500003H
  001fd	c7 46 20 1c 00
	50 f2		 mov	 DWORD PTR [esi+32], -229638116 ; f250001cH
  00204	c7 46 24 1d 00
	00 02		 mov	 DWORD PTR [esi+36], 33554461 ; 0200001dH

; 284  :     Kd1394Data->CromBuffer[10] = Dbg1394_ByteSwap(CromEntry.all);

  0020b	e8 00 00 00 00	 call	 ?Dbg1394_ByteSwap@@YIKK@Z ; Dbg1394_ByteSwap

; 285  : 
; 286  :     // 0xf0000414 - root directory header - set last to calculate CRC!
; 287  :     DIRECTORY_INFO DirectoryInfo;
; 288  :     DirectoryInfo.all = 0;
; 289  :     DirectoryInfo.DI_Length = 5;
; 290  :     DirectoryInfo.DI_CRC = Dbg1394_CalculateCrc(&Kd1394Data->CromBuffer[6],
; 291  :                                                 DirectoryInfo.DI_Length);

  00210	6a 05		 push	 5
  00212	89 5d 08	 mov	 DWORD PTR _DirectoryInfo$[ebp], ebx
  00215	57		 push	 edi
  00216	89 46 28	 mov	 DWORD PTR [esi+40], eax
  00219	66 c7 45 0a 05
	00		 mov	 WORD PTR _DirectoryInfo$[ebp+2], 5
  0021f	e8 00 00 00 00	 call	 ?Dbg1394_CalculateCrc@@YIGPAKK@Z ; Dbg1394_CalculateCrc
  00224	66 89 45 08	 mov	 WORD PTR _DirectoryInfo$[ebp], ax

; 292  :     Kd1394Data->CromBuffer[5] = Dbg1394_ByteSwap(DirectoryInfo.all);

  00228	8b 4d 08	 mov	 ecx, DWORD PTR _DirectoryInfo$[ebp]
  0022b	e8 00 00 00 00	 call	 ?Dbg1394_ByteSwap@@YIKK@Z ; Dbg1394_ByteSwap

; 293  : 
; 294  :     // write the first few registers
; 295  :     KdRegisters->ConfigRomHeader.all = Kd1394Data->CromBuffer[0];

  00230	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00232	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00235	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdRegisters
  0023a	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 296  :     KdRegisters->BusId = Kd1394Data->CromBuffer[1];

  0023d	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00240	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 297  :     KdRegisters->BusOptions.all = Kd1394Data->CromBuffer[2];

  00243	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00246	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 298  :     KdRegisters->GuidHi = Kd1394Data->CromBuffer[3];

  00249	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0024c	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 299  :     KdRegisters->GuidLo = Kd1394Data->CromBuffer[4];

  0024f	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00252	89 48 28	 mov	 DWORD PTR [eax+40], ecx

; 300  : 
; 301  :     // set our crom
; 302  :     KdRegisters->ConfigRomMap = (UINT32)MmGetPhysicalAddress(&Kd1394Data->CromBuffer);

  00255	89 70 34	 mov	 DWORD PTR [eax+52], esi

; 303  : 
; 304  :     // disable all interrupts. wdm driver will enable them later - ??
; 305  :     KdRegisters->IntMaskClear.all = 0xFFFFFFFF;

  00258	83 ce ff	 or	 esi, -1
  0025b	89 b0 8c 00 00
	00		 mov	 DWORD PTR [eax+140], esi

; 306  : 
; 307  :     // enable the link
; 308  :     HCControl.all = 0;
; 309  :     HCControl.LinkEnable = true;
; 310  :     KdRegisters->HCControlSet.all = HCControl.all;

  00261	c7 40 50 00 00
	02 00		 mov	 DWORD PTR [eax+80], 131072 ; 00020000H

; 311  : 
; 312  :     Dbg1394_StallExecution(1000);

  00268	ba e8 03 00 00	 mov	 edx, 1000		; 000003e8H
  0026d	e8 00 00 00 00	 call	 ?Dbg1394_StallExecution@@YIKK@Z ; Dbg1394_StallExecution

; 313  : 
; 314  :     // enable access filters to all nodes
; 315  :     KdRegisters->AsynchReqFilterLoSet = 0xFFFFFFFF;

  00272	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdRegisters
  00277	89 b0 08 01 00
	00		 mov	 DWORD PTR [eax+264], esi

; 316  :     KdRegisters->AsynchReqFilterHiSet = 0xFFFFFFFF;

  0027d	89 b0 00 01 00
	00		 mov	 DWORD PTR [eax+256], esi

; 317  :     KdRegisters->PhyReqFilterHiSet = 0xFFFFFFFF;

  00283	89 b0 10 01 00
	00		 mov	 DWORD PTR [eax+272], esi

; 318  :     KdRegisters->PhyReqFilterLoSet = 0xFFFFFFFF;

  00289	89 b0 18 01 00
	00		 mov	 DWORD PTR [eax+280], esi

; 319  : 
; 320  :     // hard reset on the bus (so KD will look for us)
; 321  :     PHY_CONTROL_REGISTER PhyControl;
; 322  :     PhyControl.all = 0;
; 323  :     PhyControl.RdReg = true;
; 324  :     PhyControl.RegAddr = 1;
; 325  : 
; 326  :     KdRegisters->PhyControl.all = PhyControl.all;

  0028f	c7 80 ec 00 00
	00 00 81 00 00	 mov	 DWORD PTR [eax+236], 33024 ; 00008100H

; 327  :     retry = MAX_REGISTER_READS;

  00299	b9 80 1a 06 00	 mov	 ecx, 400000		; 00061a80H
  0029e	eb 05		 jmp	 SHORT $LN11@Kdp1394Ini
$LL39@Kdp1394Ini:
  002a0	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdRegisters
$LN11@Kdp1394Ini:

; 328  :     do {
; 329  :         PhyControl.all = KdRegisters->PhyControl.all;

  002a5	8b 80 ec 00 00
	00		 mov	 eax, DWORD PTR [eax+236]

; 330  :     } while ((!PhyControl.RdDone) && --retry);

  002ab	85 c0		 test	 eax, eax
  002ad	78 1b		 js	 SHORT $LN8@Kdp1394Ini
  002af	83 e9 01	 sub	 ecx, 1
  002b2	75 ec		 jne	 SHORT $LL39@Kdp1394Ini

; 332  :         kdprintf("1394: Read on bus failed\n");

  002b4	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@CNKFCMMN@1394?3?5Read?5on?5bus?5failed?6?$AA@
  002b9	e8 00 00 00 00	 call	 ?kdprintf@@YAXPBDZZ	; kdprintf
  002be	83 c4 04	 add	 esp, 4
  002c1	5f		 pop	 edi
  002c2	5e		 pop	 esi
  002c3	32 c0		 xor	 al, al
  002c5	5b		 pop	 ebx

; 357  : }

  002c6	5d		 pop	 ebp
  002c7	c2 08 00	 ret	 8
$LN8@Kdp1394Ini:

; 331  :     if (retry == 0) {

  002ca	3b cb		 cmp	 ecx, ebx
  002cc	75 16		 jne	 SHORT $LN7@Kdp1394Ini

; 332  :         kdprintf("1394: Read on bus failed\n");

  002ce	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@CNKFCMMN@1394?3?5Read?5on?5bus?5failed?6?$AA@
  002d3	e8 00 00 00 00	 call	 ?kdprintf@@YAXPBDZZ	; kdprintf
  002d8	83 c4 04	 add	 esp, 4
  002db	5f		 pop	 edi
  002dc	5e		 pop	 esi
  002dd	32 c0		 xor	 al, al
  002df	5b		 pop	 ebx

; 357  : }

  002e0	5d		 pop	 ebp
  002e1	c2 08 00	 ret	 8
$LN7@Kdp1394Ini:

; 333  :         return false;
; 334  :     }
; 335  : 
; 336  :     UCHAR Data = ((UCHAR)PhyControl.RdData | PHY_INITIATE_BUS_RESET);

  002e4	c1 e8 10	 shr	 eax, 16			; 00000010H

; 337  : 
; 338  :     PhyControl.all = 0;
; 339  :     PhyControl.WrReg = true;
; 340  :     PhyControl.RegAddr = 1;
; 341  :     PhyControl.WrData = Data;
; 342  : 
; 343  :     KDDBG2("1394: Writing to        PhyControl=%08x\n", PhyControl.all);
; 344  :     KdRegisters->PhyControl.all = PhyControl.all;

  002e7	0f b6 d0	 movzx	 edx, al
  002ea	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdRegisters
  002ef	81 ca 40 41 00
	00		 or	 edx, 16704		; 00004140H
  002f5	89 90 ec 00 00
	00		 mov	 DWORD PTR [eax+236], edx

; 345  : 
; 346  :     retry = MAX_REGISTER_READS;

  002fb	b8 80 1a 06 00	 mov	 eax, 400000		; 00061a80H
$LL5@Kdp1394Ini:

; 347  :     do {
; 348  :         PhyControl.all = KdRegisters->PhyControl.all;
; 349  :     } while (PhyControl.WrReg && --retry);

  00300	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _KdRegisters
  00306	f7 81 ec 00 00
	00 00 40 00 00	 test	 DWORD PTR [ecx+236], 16384 ; 00004000H
  00310	74 1b		 je	 SHORT $LN2@Kdp1394Ini
  00312	83 e8 01	 sub	 eax, 1
  00315	75 e9		 jne	 SHORT $LL5@Kdp1394Ini

; 351  :         kdprintf("1394: Hard reset on bus failed\n");

  00317	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NOHPBAHD@1394?3?5Hard?5reset?5on?5bus?5failed?6?$AA@
  0031c	e8 00 00 00 00	 call	 ?kdprintf@@YAXPBDZZ	; kdprintf
  00321	83 c4 04	 add	 esp, 4
  00324	5f		 pop	 edi
  00325	5e		 pop	 esi
  00326	32 c0		 xor	 al, al
  00328	5b		 pop	 ebx

; 357  : }

  00329	5d		 pop	 ebp
  0032a	c2 08 00	 ret	 8
$LN2@Kdp1394Ini:

; 350  :     if (retry == 0) {

  0032d	3b c3		 cmp	 eax, ebx
  0032f	75 16		 jne	 SHORT $LN1@Kdp1394Ini

; 351  :         kdprintf("1394: Hard reset on bus failed\n");

  00331	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NOHPBAHD@1394?3?5Hard?5reset?5on?5bus?5failed?6?$AA@
  00336	e8 00 00 00 00	 call	 ?kdprintf@@YAXPBDZZ	; kdprintf
  0033b	83 c4 04	 add	 esp, 4
  0033e	5f		 pop	 edi
  0033f	5e		 pop	 esi
  00340	32 c0		 xor	 al, al
  00342	5b		 pop	 ebx

; 357  : }

  00343	5d		 pop	 ebp
  00344	c2 08 00	 ret	 8
$LN1@Kdp1394Ini:

; 352  :         return false;
; 353  :     }
; 354  : 
; 355  :     kdprintf("1394: Init Succeeded\n");

  00347	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@NFIKFFGB@1394?3?5Init?5Succeeded?6?$AA@
  0034c	e8 00 00 00 00	 call	 ?kdprintf@@YAXPBDZZ	; kdprintf
  00351	83 c4 04	 add	 esp, 4
  00354	5f		 pop	 edi
  00355	5e		 pop	 esi

; 356  :     return true;

  00356	b0 01		 mov	 al, 1
  00358	5b		 pop	 ebx

; 357  : }

  00359	5d		 pop	 ebp
  0035a	c2 08 00	 ret	 8
?Kdp1394Init@@YI_NGIIK@Z ENDP				; Kdp1394Init
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Dbg1394_EnablePhysicalAccess@@YIXXZ
_TEXT	SEGMENT
?Dbg1394_EnablePhysicalAccess@@YIXXZ PROC		; Dbg1394_EnablePhysicalAccess, COMDAT

; 361  :     // see if ohci1394 is being loaded...
; 362  :     HC_CONTROL_REGISTER HCControl;
; 363  :     HCControl.all = KdRegisters->HCControlSet.all;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdRegisters
  00005	8b 40 50	 mov	 eax, DWORD PTR [eax+80]

; 364  :     if (!HCControl.LinkEnable || !HCControl.Lps || HCControl.SoftReset) {

  00008	a9 00 00 02 00	 test	 eax, 131072		; 00020000H
  0000d	74 4a		 je	 SHORT $LN4@Dbg1394_En
  0000f	a9 00 00 08 00	 test	 eax, 524288		; 00080000H
  00014	74 43		 je	 SHORT $LN4@Dbg1394_En
  00016	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  0001b	75 3c		 jne	 SHORT $LN4@Dbg1394_En

; 365  :         KDDBG("1394: EnablePhysicalAccess HCControl=%08x!\n", HCControl.all);
; 366  :         return;
; 367  :     }
; 368  : 
; 369  :     // if the bus reset interrupt is not cleared, we have to clear it...
; 370  :     INT_EVENT_MASK_REGISTER IntEvent;
; 371  :     IntEvent.all = KdRegisters->IntEventSet.all;

  0001d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _KdRegisters

; 372  :     if (IntEvent.BusReset) {

  00023	f7 81 80 00 00
	00 00 00 02 00	 test	 DWORD PTR [ecx+128], 131072 ; 00020000H
  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdRegisters
  00032	74 0a		 je	 SHORT $LN2@Dbg1394_En

; 373  :         KDDBG("1394: EnablePhysicalAccess IntEvent =%08x!\n", IntEvent.all);
; 374  :         IntEvent.all = 0;
; 375  :         IntEvent.BusReset = 1;
; 376  :         KdRegisters->IntEventClear.all = IntEvent.all;

  00034	c7 80 84 00 00
	00 00 00 02 00	 mov	 DWORD PTR [eax+132], 131072 ; 00020000H
$LN2@Dbg1394_En:

; 377  :     }
; 378  : 
; 379  :     // we might need to re-enable physical access. If so, do it.
; 380  :     KdRegisters->AsynchReqFilterHiSet = 0xFFFFFFFF;

  0003e	83 c9 ff	 or	 ecx, -1
  00041	89 88 00 01 00
	00		 mov	 DWORD PTR [eax+256], ecx

; 381  :     KdRegisters->AsynchReqFilterLoSet = 0xFFFFFFFF;

  00047	89 88 08 01 00
	00		 mov	 DWORD PTR [eax+264], ecx

; 382  :     KdRegisters->PhyReqFilterHiSet = 0xFFFFFFFF;

  0004d	89 88 10 01 00
	00		 mov	 DWORD PTR [eax+272], ecx

; 383  :     KdRegisters->PhyReqFilterLoSet = 0xFFFFFFFF;

  00053	89 88 18 01 00
	00		 mov	 DWORD PTR [eax+280], ecx
$LN4@Dbg1394_En:

; 384  : }

  00059	c3		 ret	 0
?Dbg1394_EnablePhysicalAccess@@YIXXZ ENDP		; Dbg1394_EnablePhysicalAccess
_TEXT	ENDS
EXTRN	?KdDebuggerNotPresent@@3HA:DWORD		; KdDebuggerNotPresent
EXTRN	?KdpSpin@@YIXXZ:PROC				; KdpSpin
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Dbg1394_ReadPacket@@YI?AW4KDP_STATUS@@PAU_KD_PACKET@@PAU_STRING@@1_N@Z
_TEXT	SEGMENT
_PacketHeader$ = 8					; size = 4
_MessageData$ = 12					; size = 4
_Wait$ = 16						; size = 1
?Dbg1394_ReadPacket@@YI?AW4KDP_STATUS@@PAU_KD_PACKET@@PAU_STRING@@1_N@Z PROC ; Dbg1394_ReadPacket, COMDAT
; _MessageHeader$ = ebx

; 396  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 397  :     UINT32  timeoutLimit = 0;

  00005	33 ff		 xor	 edi, edi
  00007	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL9@Dbg1394_Re:

; 398  : 
; 399  :     do {
; 400  :         // make sure our link is enabled..
; 401  :         Dbg1394_EnablePhysicalAccess();

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdRegisters
  00015	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00018	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0001d	85 c1		 test	 eax, ecx
  0001f	74 42		 je	 SHORT $LN15@Dbg1394_Re
  00021	a9 00 00 08 00	 test	 eax, 524288		; 00080000H
  00026	74 3b		 je	 SHORT $LN15@Dbg1394_Re
  00028	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  0002d	75 34		 jne	 SHORT $LN15@Dbg1394_Re
  0002f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _KdRegisters
  00035	85 8a 80 00 00
	00		 test	 DWORD PTR [edx+128], ecx
  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdRegisters
  00040	74 06		 je	 SHORT $LN13@Dbg1394_Re
  00042	89 88 84 00 00
	00		 mov	 DWORD PTR [eax+132], ecx
$LN13@Dbg1394_Re:
  00048	83 c9 ff	 or	 ecx, -1
  0004b	89 88 00 01 00
	00		 mov	 DWORD PTR [eax+256], ecx
  00051	89 88 08 01 00
	00		 mov	 DWORD PTR [eax+264], ecx
  00057	89 88 10 01 00
	00		 mov	 DWORD PTR [eax+272], ecx
  0005d	89 88 18 01 00
	00		 mov	 DWORD PTR [eax+280], ecx
$LN15@Dbg1394_Re:

; 402  :         KdpSpin();

  00063	e8 00 00 00 00	 call	 ?KdpSpin@@YIXXZ		; KdpSpin

; 403  : 
; 404  :         if (Kd1394Data->ReceivePacket.TransferStatus == STATUS_PENDING) {

  00068	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _Kd1394Data
  0006e	81 be 00 14 00
	00 03 01 00 00	 cmp	 DWORD PTR [esi+5120], 259 ; 00000103H
  00078	74 1c		 je	 SHORT $LN20@Dbg1394_Re

; 437  :         }
; 438  : 
; 439  :         timeoutLimit++;

  0007a	83 c7 01	 add	 edi, 1

; 440  : 
; 441  :         if (Wait == false) {

  0007d	80 7d 10 00	 cmp	 BYTE PTR _Wait$[ebp], 0
  00081	74 50		 je	 SHORT $LN22@Dbg1394_Re

; 442  :             return(KDP_PACKET_RESEND);
; 443  :         }
; 444  : 
; 445  :     } while (timeoutLimit <= TIMEOUT_COUNT);

  00083	81 ff 00 d0 07
	00		 cmp	 edi, 512000		; 0007d000H
  00089	76 85		 jbe	 SHORT $LL9@Dbg1394_Re
  0008b	5f		 pop	 edi

; 446  : 
; 447  :     return(KDP_PACKET_TIMEOUT);

  0008c	b8 01 00 00 00	 mov	 eax, 1
  00091	5e		 pop	 esi

; 448  : }

  00092	5d		 pop	 ebp
  00093	c2 0c 00	 ret	 12			; 0000000cH
$LN20@Dbg1394_Re:

; 405  :             KdDebuggerNotPresent = false;
; 406  : 
; 407  :             memcpy(PacketHeader,
; 408  :                    &Kd1394Data->ReceivePacket.Packet[0],
; 409  :                    sizeof(KD_PACKET));

  00096	8b 45 08	 mov	 eax, DWORD PTR _PacketHeader$[ebp]
  00099	33 ff		 xor	 edi, edi
  0009b	89 3d 00 00 00
	00		 mov	 DWORD PTR ?KdDebuggerNotPresent@@3HA, edi ; KdDebuggerNotPresent
  000a1	8b 8e 08 14 00
	00		 mov	 ecx, DWORD PTR [esi+5128]
  000a7	89 08		 mov	 DWORD PTR [eax], ecx
  000a9	8b 96 0c 14 00
	00		 mov	 edx, DWORD PTR [esi+5132]
  000af	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000b2	8b 8e 10 14 00
	00		 mov	 ecx, DWORD PTR [esi+5136]
  000b8	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000bb	8b 96 14 14 00
	00		 mov	 edx, DWORD PTR [esi+5140]
  000c1	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 410  : 
; 411  :             // make sure we have a valid PacketHeader
; 412  :             if (Kd1394Data->ReceivePacket.Length < sizeof(KD_PACKET)) {

  000c4	83 be 04 14 00
	00 10		 cmp	 DWORD PTR [esi+5124], 16 ; 00000010H
  000cb	73 11		 jae	 SHORT $LN5@Dbg1394_Re

; 413  :                 // short packet, we are done...
; 414  :                 Kd1394Data->ReceivePacket.TransferStatus = STATUS_SUCCESS;

  000cd	89 be 00 14 00
	00		 mov	 DWORD PTR [esi+5120], edi
$LN22@Dbg1394_Re:
  000d3	5f		 pop	 edi

; 415  :                 return(KDP_PACKET_RESEND);

  000d4	b8 02 00 00 00	 mov	 eax, 2
  000d9	5e		 pop	 esi

; 448  : }

  000da	5d		 pop	 ebp
  000db	c2 0c 00	 ret	 12			; 0000000cH
$LN5@Dbg1394_Re:

; 416  :             }
; 417  : 
; 418  :             if (MessageHeader) {

  000de	3b df		 cmp	 ebx, edi
  000e0	74 52		 je	 SHORT $LN2@Dbg1394_Re

; 419  :                 memcpy(MessageHeader->Buffer,
; 420  :                        &Kd1394Data->ReceivePacket.Packet[sizeof(KD_PACKET)],
; 421  :                        MessageHeader->MaximumLength);

  000e2	0f b7 43 02	 movzx	 eax, WORD PTR [ebx+2]
  000e6	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  000e9	50		 push	 eax
  000ea	8d 8e 18 14 00
	00		 lea	 ecx, DWORD PTR [esi+5144]
  000f0	51		 push	 ecx
  000f1	52		 push	 edx
  000f2	e8 00 00 00 00	 call	 _memcpy

; 422  : 
; 423  :                 if (Kd1394Data->ReceivePacket.Length <= (UINT16)(sizeof(KD_PACKET)+MessageHeader->MaximumLength)) {

  000f7	66 8b 4b 02	 mov	 cx, WORD PTR [ebx+2]
  000fb	8b 86 04 14 00
	00		 mov	 eax, DWORD PTR [esi+5124]
  00101	66 83 c1 10	 add	 cx, 16			; 00000010H
  00105	0f b7 d1	 movzx	 edx, cx
  00108	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010b	3b c2		 cmp	 eax, edx

; 424  :                     Kd1394Data->ReceivePacket.TransferStatus = STATUS_SUCCESS;
; 425  :                     return(KDP_PACKET_RECEIVED);

  0010d	76 25		 jbe	 SHORT $LN2@Dbg1394_Re

; 426  :                 }
; 427  : 
; 428  :                 if (MessageData) {

  0010f	8b 55 0c	 mov	 edx, DWORD PTR _MessageData$[ebp]
  00112	3b d7		 cmp	 edx, edi
  00114	74 1e		 je	 SHORT $LN2@Dbg1394_Re

; 429  :                     memcpy(MessageData->Buffer,
; 430  :                            &Kd1394Data->ReceivePacket.Packet[sizeof(KD_PACKET) + MessageHeader->MaximumLength],
; 431  :                            Kd1394Data->ReceivePacket.Length - (sizeof(KD_PACKET) + MessageHeader->MaximumLength));

  00116	0f b7 4b 02	 movzx	 ecx, WORD PTR [ebx+2]
  0011a	2b c1		 sub	 eax, ecx
  0011c	83 e8 10	 sub	 eax, 16			; 00000010H
  0011f	50		 push	 eax
  00120	8d 84 31 18 14
	00 00		 lea	 eax, DWORD PTR [ecx+esi+5144]
  00127	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0012a	50		 push	 eax
  0012b	51		 push	 ecx
  0012c	e8 00 00 00 00	 call	 _memcpy
  00131	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@Dbg1394_Re:

; 432  :                 }
; 433  :             }
; 434  : 
; 435  :             Kd1394Data->ReceivePacket.TransferStatus = STATUS_SUCCESS;

  00134	89 be 00 14 00
	00		 mov	 DWORD PTR [esi+5120], edi
  0013a	5f		 pop	 edi

; 436  :             return(KDP_PACKET_RECEIVED);

  0013b	33 c0		 xor	 eax, eax
  0013d	5e		 pop	 esi

; 448  : }

  0013e	5d		 pop	 ebp
  0013f	c2 0c 00	 ret	 12			; 0000000cH
?Dbg1394_ReadPacket@@YI?AW4KDP_STATUS@@PAU_KD_PACKET@@PAU_STRING@@1_N@Z ENDP ; Dbg1394_ReadPacket
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?KdpSendControlPacket@@YIXG@Z
_TEXT	SEGMENT
_PacketHeader$ = -16					; size = 16
?KdpSendControlPacket@@YIXG@Z PROC			; KdpSendControlPacket, COMDAT
; _PacketType$ = eax

; 457  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 458  :     KD_PACKET   PacketHeader;
; 459  : 
; 460  :     //
; 461  :     // Initialize and send the packet header.
; 462  :     //
; 463  :     PacketHeader.PacketLeader = CONTROL_PACKET_LEADER;
; 464  :     PacketHeader.PacketId = 0;
; 465  :     PacketHeader.ByteCount = 0;
; 466  :     PacketHeader.Checksum = 0;
; 467  :     PacketHeader.PacketType = PacketType;
; 468  : 
; 469  :     // setup our send packet
; 470  :     memset(&Kd1394Data->SendPacket, 0, sizeof(DEBUG_1394_SEND_PACKET));

  00008	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _Kd1394Data
  0000e	57		 push	 edi
  0000f	68 00 10 00 00	 push	 4096			; 00001000H
  00014	8d be 00 04 00
	00		 lea	 edi, DWORD PTR [esi+1024]
  0001a	6a 00		 push	 0
  0001c	57		 push	 edi
  0001d	bb 69 69 69 69	 mov	 ebx, 1768515945		; 69696969H
  00022	66 c7 45 f6 00
	00		 mov	 WORD PTR _PacketHeader$[ebp+6], 0
  00028	66 89 45 f4	 mov	 WORD PTR _PacketHeader$[ebp+4], ax
  0002c	e8 00 00 00 00	 call	 _memset

; 471  :     Kd1394Data->SendPacket.Length = 0;
; 472  : 
; 473  :     memcpy(&Kd1394Data->SendPacket.PacketHeader[0],
; 474  :            &PacketHeader, sizeof(KD_PACKET));

  00031	8b 4d f4	 mov	 ecx, DWORD PTR _PacketHeader$[ebp+4]
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH
  00037	89 9e 04 04 00
	00		 mov	 DWORD PTR [esi+1028], ebx
  0003d	89 8e 08 04 00
	00		 mov	 DWORD PTR [esi+1032], ecx
  00043	33 c0		 xor	 eax, eax
  00045	89 86 0c 04 00
	00		 mov	 DWORD PTR [esi+1036], eax

; 475  : 
; 476  :     Kd1394Data->SendPacket.TransferStatus = STATUS_PENDING;

  0004b	c7 07 03 01 00
	00		 mov	 DWORD PTR [edi], 259	; 00000103H
  00051	5f		 pop	 edi
  00052	c7 86 14 04 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1044], 0
  0005c	89 86 10 04 00
	00		 mov	 DWORD PTR [esi+1040], eax
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx

; 477  : }

  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
?KdpSendControlPacket@@YIXG@Z ENDP			; KdpSendControlPacket
_TEXT	ENDS
PUBLIC	?Kdp1394ReceivePacket@@YI?AW4KDP_STATUS@@KPAU_STRING@@0PAKPAU_KD_CONTEXT@@@Z ; Kdp1394ReceivePacket
EXTRN	?KdpComputeChecksum@@YIKPADK@Z:PROC		; KdpComputeChecksum
EXTRN	?KdCompNumberRetries@@3KA:DWORD			; KdCompNumberRetries
EXTRN	?KdCompRetryCount@@3KA:DWORD			; KdCompRetryCount
; Function compile flags: /Ogtp
;	COMDAT ?Kdp1394ReceivePacket@@YI?AW4KDP_STATUS@@KPAU_STRING@@0PAKPAU_KD_CONTEXT@@@Z
_TEXT	SEGMENT
_PacketHeader$12681 = -40				; size = 16
_PacketHeader$ = -24					; size = 16
_MessageHeader$ = -8					; size = 4
_PacketType$ = -4					; size = 4
_MessageData$ = 8					; size = 4
_DataLength$ = 12					; size = 4
_KdContext$ = 16					; size = 4
?Kdp1394ReceivePacket@@YI?AW4KDP_STATUS@@KPAU_STRING@@0PAKPAU_KD_CONTEXT@@@Z PROC ; Kdp1394ReceivePacket, COMDAT
; _PacketType$ = ecx
; _MessageHeader$ = edx

; 509  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b da		 mov	 ebx, edx
  0000a	57		 push	 edi
  0000b	89 5d f8	 mov	 DWORD PTR _MessageHeader$[ebp], ebx
  0000e	89 4d fc	 mov	 DWORD PTR _PacketType$[ebp], ecx
$WaitForPacketLeader$12481:

; 510  :     UINT32      MessageLength;
; 511  :     KD_PACKET   PacketHeader;
; 512  :     KDP_STATUS  ReturnCode;
; 513  :     UINT32      Checksum;
; 514  : 
; 515  :     KDDBG2("Kdp1394ReceivePacket\n");
; 516  : 
; 517  :     // this dispatch gets called with PacketType != PACKET_TYPE_KD_POLL_BREAKIN for
; 518  :     // the number of times specified in KdCompNumberRetries (??).
; 519  : 
; 520  : WaitForPacketLeader:
; 521  : 
; 522  :     // read in our packet, if available...
; 523  :     ReturnCode = Dbg1394_ReadPacket(&PacketHeader,
; 524  :                                     MessageHeader,
; 525  :                                     MessageData,
; 526  :                                     true);

  00011	8b 75 08	 mov	 esi, DWORD PTR _MessageData$[ebp]
  00014	6a 01		 push	 1
  00016	56		 push	 esi
  00017	8d 45 e8	 lea	 eax, DWORD PTR _PacketHeader$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?Dbg1394_ReadPacket@@YI?AW4KDP_STATUS@@PAU_KD_PACKET@@PAU_STRING@@1_N@Z ; Dbg1394_ReadPacket

; 527  :     //
; 528  :     // If we can successfully read packet leader, it has high possibility that
; 529  :     // kernel debugger is alive.  So reset count.
; 530  :     //
; 531  :     if (ReturnCode != KDP_PACKET_TIMEOUT) {

  00020	83 f8 01	 cmp	 eax, 1
  00023	74 0c		 je	 SHORT $LN11@Kdp1394Rec

; 532  :         KdCompNumberRetries = KdCompRetryCount;

  00025	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?KdCompRetryCount@@3KA ; KdCompRetryCount
  0002b	89 0d 00 00 00
	00		 mov	 DWORD PTR ?KdCompNumberRetries@@3KA, ecx ; KdCompNumberRetries
$LN11@Kdp1394Rec:

; 533  :     }
; 534  : 
; 535  :     if (ReturnCode != KDP_PACKET_RECEIVED) {

  00031	85 c0		 test	 eax, eax
  00033	0f 85 cb 00 00
	00		 jne	 $LN19@Kdp1394Rec

; 540  :         }
; 541  :         return(ReturnCode);
; 542  :     }
; 543  : 
; 544  :     //
; 545  :     // if the packet we received is a resend request, we return true and
; 546  :     // let caller resend the packet.
; 547  :     //
; 548  :     if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER &&
; 549  :         PacketHeader.PacketType == PACKET_TYPE_KD_RESEND) {

  00039	81 7d e8 69 69
	69 69		 cmp	 DWORD PTR _PacketHeader$[ebp], 1768515945 ; 69696969H
  00040	66 8b 55 ec	 mov	 dx, WORD PTR _PacketHeader$[ebp+4]
  00044	75 0a		 jne	 SHORT $LN21@Kdp1394Rec
  00046	66 83 fa 05	 cmp	 dx, 5
  0004a	0f 84 c4 00 00
	00		 je	 $LN20@Kdp1394Rec
$LN21@Kdp1394Rec:

; 550  :         return(KDP_PACKET_RESEND);
; 551  :     }
; 552  : 
; 553  :     //
; 554  :     // Check ByteCount received is valid
; 555  :     //
; 556  :     MessageLength = MessageHeader->MaximumLength;
; 557  : 
; 558  :     if ((PacketHeader.ByteCount > (UINT16)PACKET_MAX_SIZE) ||
; 559  :         (PacketHeader.ByteCount < (UINT16)MessageLength)) {

  00050	66 8b 4d ee	 mov	 cx, WORD PTR _PacketHeader$[ebp+6]
  00054	66 81 f9 a0 0f	 cmp	 cx, 4000		; 00000fa0H
  00059	0f b7 43 02	 movzx	 eax, WORD PTR [ebx+2]
  0005d	77 43		 ja	 SHORT $SendResendPacket$12490
  0005f	66 3b c8	 cmp	 cx, ax
  00062	72 3e		 jb	 SHORT $SendResendPacket$12490

; 560  :         goto SendResendPacket;
; 561  :     }
; 562  :     *DataLength = PacketHeader.ByteCount - MessageLength;

  00064	0f b7 f9	 movzx	 edi, cx
  00067	8b 4d 0c	 mov	 ecx, DWORD PTR _DataLength$[ebp]
  0006a	2b f8		 sub	 edi, eax
  0006c	89 39		 mov	 DWORD PTR [ecx], edi

; 563  : 
; 564  :     MessageData->Length = (UINT16)*DataLength;
; 565  :     MessageHeader->Length = (UINT16)MessageLength;
; 566  : 
; 567  :     //
; 568  :     // Check PacketType is what we are waiting for.
; 569  :     //
; 570  :     if (PacketType != PacketHeader.PacketType) {

  0006e	0f b7 d2	 movzx	 edx, dx
  00071	39 55 fc	 cmp	 DWORD PTR _PacketType$[ebp], edx
  00074	66 8b cf	 mov	 cx, di
  00077	66 89 0e	 mov	 WORD PTR [esi], cx
  0007a	66 89 03	 mov	 WORD PTR [ebx], ax
  0007d	75 23		 jne	 SHORT $SendResendPacket$12490

; 571  :         goto SendResendPacket;
; 572  :     }
; 573  : 
; 574  :     //
; 575  :     // Check checksum is valid.
; 576  :     //
; 577  :     Checksum = KdpComputeChecksum(MessageHeader->Buffer, MessageHeader->Length);

  0007f	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00082	0f b7 d0	 movzx	 edx, ax
  00085	e8 00 00 00 00	 call	 ?KdpComputeChecksum@@YIKPADK@Z ; KdpComputeChecksum

; 578  :     Checksum += KdpComputeChecksum(MessageData->Buffer, MessageData->Length);
; 579  : 
; 580  :     if (Checksum != PacketHeader.Checksum) {

  0008a	0f b7 16	 movzx	 edx, WORD PTR [esi]
  0008d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00090	8b f8		 mov	 edi, eax
  00092	e8 00 00 00 00	 call	 ?KdpComputeChecksum@@YIKPADK@Z ; KdpComputeChecksum
  00097	03 c7		 add	 eax, edi
  00099	3b 45 f4	 cmp	 eax, DWORD PTR _PacketHeader$[ebp+12]
  0009c	0f 84 80 00 00
	00		 je	 $LN2@Kdp1394Rec
$SendResendPacket$12490:

; 585  : 
; 586  : SendResendPacket:
; 587  : 
; 588  :     KdpSendControlPacket(PACKET_TYPE_KD_RESEND);

  000a2	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _Kd1394Data
  000a8	68 00 10 00 00	 push	 4096			; 00001000H
  000ad	8d 9e 00 04 00
	00		 lea	 ebx, DWORD PTR [esi+1024]
  000b3	6a 00		 push	 0
  000b5	53		 push	 ebx
  000b6	bf 69 69 69 69	 mov	 edi, 1768515945		; 69696969H
  000bb	66 c7 45 de 00
	00		 mov	 WORD PTR _PacketHeader$12681[ebp+6], 0
  000c1	66 c7 45 dc 05
	00		 mov	 WORD PTR _PacketHeader$12681[ebp+4], 5
  000c7	e8 00 00 00 00	 call	 _memset
  000cc	8b 45 dc	 mov	 eax, DWORD PTR _PacketHeader$12681[ebp+4]
  000cf	89 be 04 04 00
	00		 mov	 DWORD PTR [esi+1028], edi
  000d5	89 86 08 04 00
	00		 mov	 DWORD PTR [esi+1032], eax
  000db	83 c4 0c	 add	 esp, 12			; 0000000cH
  000de	33 c0		 xor	 eax, eax
  000e0	89 86 0c 04 00
	00		 mov	 DWORD PTR [esi+1036], eax
  000e6	c7 03 03 01 00
	00		 mov	 DWORD PTR [ebx], 259	; 00000103H

; 589  :     goto WaitForPacketLeader;

  000ec	8b 5d f8	 mov	 ebx, DWORD PTR _MessageHeader$[ebp]
  000ef	c7 86 14 04 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1044], 0
  000f9	89 86 10 04 00
	00		 mov	 DWORD PTR [esi+1040], eax
  000ff	e9 0d ff ff ff	 jmp	 $WaitForPacketLeader$12481
$LN19@Kdp1394Rec:

; 536  :         // see if it's a breakin packet...
; 537  :         if ((PacketHeader.PacketLeader & 0xFF) == BREAKIN_PACKET_BYTE) {

  00104	80 7d e8 62	 cmp	 BYTE PTR _PacketHeader$[ebp], 98 ; 00000062H
  00108	75 1a		 jne	 SHORT $LN13@Kdp1394Rec

; 538  :             KdContext->KdpControlCPending = true;

  0010a	8b 4d 10	 mov	 ecx, DWORD PTR _KdContext$[ebp]
  0010d	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [ecx+4], 1
$LN20@Kdp1394Rec:
  00114	5f		 pop	 edi
  00115	5e		 pop	 esi

; 539  :             return(KDP_PACKET_RESEND);

  00116	b8 02 00 00 00	 mov	 eax, 2
  0011b	5b		 pop	 ebx

; 590  : }

  0011c	8b e5		 mov	 esp, ebp
  0011e	5d		 pop	 ebp
  0011f	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Kdp1394Rec:

; 581  :         goto SendResendPacket;
; 582  :     }
; 583  : 
; 584  :     return(KDP_PACKET_RECEIVED);

  00122	33 c0		 xor	 eax, eax
$LN13@Kdp1394Rec:
  00124	5f		 pop	 edi
  00125	5e		 pop	 esi
  00126	5b		 pop	 ebx

; 590  : }

  00127	8b e5		 mov	 esp, ebp
  00129	5d		 pop	 ebp
  0012a	c2 0c 00	 ret	 12			; 0000000cH
?Kdp1394ReceivePacket@@YI?AW4KDP_STATUS@@KPAU_STRING@@0PAKPAU_KD_CONTEXT@@@Z ENDP ; Kdp1394ReceivePacket
_TEXT	ENDS
PUBLIC	?Kdp1394SendPacket@@YIXKPAU_STRING@@0PAU_KD_CONTEXT@@@Z ; Kdp1394SendPacket
EXTRN	?KdPacketId@@3KA:DWORD				; KdPacketId
; Function compile flags: /Ogtp
;	COMDAT ?Kdp1394SendPacket@@YIXKPAU_STRING@@0PAU_KD_CONTEXT@@@Z
_TEXT	SEGMENT
_PacketHeader$ = -28					; size = 16
_MessageHeader$ = -12					; size = 4
_PacketType$ = -8					; size = 4
_bException$ = -1					; size = 1
tv336 = 8						; size = 4
_MessageDataLength$ = 8					; size = 4
_MessageData$ = 8					; size = 4
_KdContext$ = 12					; size = 4
?Kdp1394SendPacket@@YIXKPAU_STRING@@0PAU_KD_CONTEXT@@@Z PROC ; Kdp1394SendPacket, COMDAT
; _PacketType$ = ecx
; _MessageHeader$ = edx

; 613  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	53		 push	 ebx

; 614  :     KD_PACKET                   PacketHeader;
; 615  :     UINT32                      MessageDataLength;
; 616  :     UINT32                      ReturnCode;
; 617  :     bool                        bException = false;
; 618  : 
; 619  :     KDDBG2("Kdp1394SendPacket\n");
; 620  :     PacketHeader.Checksum = 0;
; 621  : 
; 622  :     if (MessageData != NULL) {

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _MessageData$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	33 ff		 xor	 edi, edi
  0000e	3b df		 cmp	 ebx, edi
  00010	8b f2		 mov	 esi, edx
  00012	89 75 f4	 mov	 DWORD PTR _MessageHeader$[ebp], esi
  00015	89 4d f8	 mov	 DWORD PTR _PacketType$[ebp], ecx
  00018	c6 45 ff 00	 mov	 BYTE PTR _bException$[ebp], 0
  0001c	74 12		 je	 SHORT $LN25@Kdp1394Sen

; 623  :         MessageDataLength = MessageData->Length;

  0001e	0f b7 13	 movzx	 edx, WORD PTR [ebx]

; 624  :         PacketHeader.Checksum = KdpComputeChecksum(MessageData->Buffer, MessageData->Length);

  00021	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00024	89 55 08	 mov	 DWORD PTR _MessageDataLength$[ebp], edx
  00027	e8 00 00 00 00	 call	 ?KdpComputeChecksum@@YIKPADK@Z ; KdpComputeChecksum
  0002c	8b f8		 mov	 edi, eax

; 625  :     }
; 626  :     else {

  0002e	eb 03		 jmp	 SHORT $LN24@Kdp1394Sen
$LN25@Kdp1394Sen:

; 627  :         MessageDataLength = 0;

  00030	89 7d 08	 mov	 DWORD PTR _MessageDataLength$[ebp], edi
$LN24@Kdp1394Sen:

; 628  :         PacketHeader.Checksum = 0;
; 629  :     }
; 630  : 
; 631  :     PacketHeader.Checksum += KdpComputeChecksum(MessageHeader->Buffer, MessageHeader->Length);

  00033	0f b7 16	 movzx	 edx, WORD PTR [esi]
  00036	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00039	e8 00 00 00 00	 call	 ?KdpComputeChecksum@@YIKPADK@Z ; KdpComputeChecksum

; 632  : 
; 633  :     //
; 634  :     // Initialize and send the packet header.
; 635  :     //
; 636  :     PacketHeader.PacketLeader = PACKET_LEADER;
; 637  :     PacketHeader.ByteCount = (UINT16)(MessageHeader->Length + MessageDataLength);
; 638  :     PacketHeader.PacketType = (UINT16)PacketType;

  0003e	66 8b 4d f8	 mov	 cx, WORD PTR _PacketType$[ebp]

; 639  :     PacketHeader.PacketId = KdPacketId;
; 640  : 
; 641  :     KdPacketId++;
; 642  : 
; 643  :     KdCompNumberRetries = KdCompRetryCount;

  00042	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?KdCompRetryCount@@3KA ; KdCompRetryCount
  00048	03 f8		 add	 edi, eax
  0004a	66 8b 06	 mov	 ax, WORD PTR [esi]
  0004d	66 03 45 08	 add	 ax, WORD PTR _MessageDataLength$[ebp]

; 644  : 
; 645  :     // setup our send packet
; 646  :     memset(&Kd1394Data->SendPacket, 0, sizeof(DEBUG_1394_SEND_PACKET));

  00051	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _Kd1394Data
  00057	66 89 45 ea	 mov	 WORD PTR _PacketHeader$[ebp+6], ax
  0005b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?KdPacketId@@3KA ; KdPacketId
  00060	89 45 ec	 mov	 DWORD PTR _PacketHeader$[ebp+8], eax
  00063	83 c0 01	 add	 eax, 1
  00066	68 00 10 00 00	 push	 4096			; 00001000H
  0006b	a3 00 00 00 00	 mov	 DWORD PTR ?KdPacketId@@3KA, eax ; KdPacketId
  00070	8d 86 00 04 00
	00		 lea	 eax, DWORD PTR [esi+1024]
  00076	6a 00		 push	 0
  00078	50		 push	 eax
  00079	66 89 4d e8	 mov	 WORD PTR _PacketHeader$[ebp+4], cx
  0007d	89 15 00 00 00
	00		 mov	 DWORD PTR ?KdCompNumberRetries@@3KA, edx ; KdCompNumberRetries
  00083	89 45 08	 mov	 DWORD PTR tv336[ebp], eax
  00086	e8 00 00 00 00	 call	 _memset

; 647  :     Kd1394Data->SendPacket.Length = 0;
; 648  : 
; 649  :     // copy our packet header...
; 650  :     memcpy(&Kd1394Data->SendPacket.PacketHeader[0],
; 651  :            &PacketHeader, sizeof(KD_PACKET));

  0008b	8b 4d ec	 mov	 ecx, DWORD PTR _PacketHeader$[ebp+8]
  0008e	b8 30 30 30 30	 mov	 eax, 808464432		; 30303030H
  00093	89 86 04 04 00
	00		 mov	 DWORD PTR [esi+1028], eax
  00099	8b 45 e8	 mov	 eax, DWORD PTR _PacketHeader$[ebp+4]
  0009c	89 86 08 04 00
	00		 mov	 DWORD PTR [esi+1032], eax
  000a2	89 8e 0c 04 00
	00		 mov	 DWORD PTR [esi+1036], ecx
  000a8	89 be 10 04 00
	00		 mov	 DWORD PTR [esi+1040], edi

; 652  : 
; 653  :     // setup our message header
; 654  :     if (MessageHeader) {
; 655  :         memcpy(&Kd1394Data->SendPacket.Packet[0],
; 656  :                MessageHeader->Buffer, MessageHeader->Length);

  000ae	8b 7d f4	 mov	 edi, DWORD PTR _MessageHeader$[ebp]
  000b1	c7 86 14 04 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1044], 0
  000bb	0f b7 17	 movzx	 edx, WORD PTR [edi]
  000be	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000c1	52		 push	 edx
  000c2	50		 push	 eax
  000c3	8d 8e 18 04 00
	00		 lea	 ecx, DWORD PTR [esi+1048]
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 _memcpy

; 657  :         Kd1394Data->SendPacket.Length += MessageHeader->Length;

  000cf	0f b7 17	 movzx	 edx, WORD PTR [edi]
  000d2	01 96 14 04 00
	00		 add	 DWORD PTR [esi+1044], edx
  000d8	8b 86 14 04 00
	00		 mov	 eax, DWORD PTR [esi+1044]
  000de	83 c4 18	 add	 esp, 24			; 00000018H

; 658  :     }
; 659  : 
; 660  :     // setup our message data
; 661  :     if (MessageData != NULL) {

  000e1	85 db		 test	 ebx, ebx
  000e3	74 21		 je	 SHORT $LN22@Kdp1394Sen

; 662  :         memcpy(&Kd1394Data->SendPacket.Packet[Kd1394Data->SendPacket.Length],
; 663  :                MessageData->Buffer, MessageData->Length);

  000e5	0f b7 0b	 movzx	 ecx, WORD PTR [ebx]
  000e8	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  000eb	51		 push	 ecx
  000ec	52		 push	 edx
  000ed	8d 84 30 18 04
	00 00		 lea	 eax, DWORD PTR [eax+esi+1048]
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 _memcpy

; 664  :         Kd1394Data->SendPacket.Length += MessageData->Length;

  000fa	0f b7 0b	 movzx	 ecx, WORD PTR [ebx]
  000fd	83 c4 0c	 add	 esp, 12			; 0000000cH
  00100	01 8e 14 04 00
	00		 add	 DWORD PTR [esi+1044], ecx
$LN22@Kdp1394Sen:

; 665  :     }
; 666  : 
; 667  :     Kd1394Data->SendPacket.TransferStatus = STATUS_PENDING;

  00106	8b 55 08	 mov	 edx, DWORD PTR tv336[ebp]
  00109	c7 02 03 01 00
	00		 mov	 DWORD PTR [edx], 259	; 00000103H
  0010f	90		 npad	 1
$LL20@Kdp1394Sen:

; 668  : 
; 669  :     //
; 670  :     // We sync on first STATE_CHANGE64 message like NT.  If this
; 671  :     // is the first such message, drain receive pipe as nothing
; 672  :     // said before this instant is interesting (and any buffered
; 673  :     // packets may interact badly with SendWaitContinue).
; 674  :     //
; 675  :     if (PacketType == PACKET_TYPE_KD_STATE_CHANGE64 /* && !KdStateChange64Sent*/) {
; 676  :         // need to do this to fix pre-logging (eventually).
; 677  : #if 0
; 678  :         UCHAR uDummy;
; 679  :         uint32 dwDrained = 0;
; 680  :         KdCompNextPacketIdToSend |= SYNC_PACKET_ID;
; 681  :         KdStateChange64Sent = true;
; 682  : 
; 683  :         while (KdCompGetByte(&uDummy) == CP_GET_SUCCESS) {
; 684  :             dwDrained++;
; 685  :         }
; 686  : #endif // 0
; 687  :     }
; 688  : 
; 689  :     do {
; 690  :         KDDBG2("LOOP %d/%d [SendPacket=%p %08x %08x %08x %02x %02x %02x %02x]\n",
; 691  :                KdCompNumberRetries, KdCompRetryCount,
; 692  :                &Kd1394Data->SendPacket,
; 693  :                Kd1394Data->SendPacket.TransferStatus,
; 694  :                *(UINT32*)&Kd1394Data->SendPacket.PacketHeader,
; 695  :                Kd1394Data->SendPacket.Length,
; 696  :                Kd1394Data->SendPacket.Packet[0],
; 697  :                Kd1394Data->SendPacket.Packet[1],
; 698  :                Kd1394Data->SendPacket.Packet[2],
; 699  :                Kd1394Data->SendPacket.Packet[3]);
; 700  : 
; 701  :         // make sure our link is enabled..
; 702  :         Dbg1394_EnablePhysicalAccess();

  00110	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdRegisters
  00115	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00118	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0011d	85 c1		 test	 eax, ecx
  0011f	74 44		 je	 SHORT $LN56@Kdp1394Sen
  00121	a9 00 00 08 00	 test	 eax, 524288		; 00080000H
  00126	74 3d		 je	 SHORT $LN56@Kdp1394Sen
  00128	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  0012d	75 36		 jne	 SHORT $LN56@Kdp1394Sen
  0012f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _KdRegisters
  00135	85 8a 80 00 00
	00		 test	 DWORD PTR [edx+128], ecx
  0013b	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdRegisters
  00140	74 06		 je	 SHORT $LN30@Kdp1394Sen
  00142	89 88 84 00 00
	00		 mov	 DWORD PTR [eax+132], ecx
$LN30@Kdp1394Sen:
  00148	83 ca ff	 or	 edx, -1
  0014b	89 90 00 01 00
	00		 mov	 DWORD PTR [eax+256], edx
  00151	89 90 08 01 00
	00		 mov	 DWORD PTR [eax+264], edx
  00157	89 90 10 01 00
	00		 mov	 DWORD PTR [eax+272], edx
  0015d	89 90 18 01 00
	00		 mov	 DWORD PTR [eax+280], edx
  00163	eb 08		 jmp	 SHORT $LN32@Kdp1394Sen
$LN56@Kdp1394Sen:
  00165	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdRegisters
  0016a	83 ca ff	 or	 edx, -1
$LN32@Kdp1394Sen:

; 703  : 
; 704  :         if (KdCompNumberRetries == 0) {

  0016d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?KdCompNumberRetries@@3KA, 0 ; KdCompNumberRetries
  00174	0f 85 a3 00 00
	00		 jne	 $LN55@Kdp1394Sen

; 705  :             //
; 706  :             // If the packet is not for reporting exception, we give up
; 707  :             // and declare debugger not present.
; 708  :             //
; 709  :             if (PacketType == PACKET_TYPE_KD_DEBUG_IO) {

  0017a	8b 4d f8	 mov	 ecx, DWORD PTR _PacketType$[ebp]
  0017d	83 f9 03	 cmp	 ecx, 3
  00180	75 31		 jne	 SHORT $LN15@Kdp1394Sen

; 710  :                 PDBGKD_DEBUG_IO DebugIo
; 711  :                     = (PDBGKD_DEBUG_IO)MessageHeader->Buffer;

  00182	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 712  : 
; 713  :                 if (DebugIo->ApiNumber == DbgKdPrintStringApi) {

  00185	81 39 30 32 00
	00		 cmp	 DWORD PTR [ecx], 12848	; 00003230H
  0018b	0f 85 8c 00 00
	00		 jne	 $LN55@Kdp1394Sen

; 714  :                     KdDebuggerNotPresent = true;
; 715  :                     Kd1394Data->SendPacket.TransferStatus = STATUS_SUCCESS;

  00191	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  00196	5f		 pop	 edi
  00197	5e		 pop	 esi
  00198	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?KdDebuggerNotPresent@@3HA, 1 ; KdDebuggerNotPresent
  001a2	c7 80 00 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1024], 0
  001ac	5b		 pop	 ebx

; 785  : }

  001ad	8b e5		 mov	 esp, ebp
  001af	5d		 pop	 ebp
  001b0	c2 08 00	 ret	 8
$LN15@Kdp1394Sen:

; 716  :                     return;
; 717  :                 }
; 718  :             }
; 719  :             else if (PacketType == PACKET_TYPE_KD_STATE_CHANGE64) {

  001b3	83 f9 07	 cmp	 ecx, 7
  001b6	75 2e		 jne	 SHORT $LN12@Kdp1394Sen

; 720  :                 PDBGKD_ANY_WAIT_STATE_CHANGE StateChange
; 721  :                     = (PDBGKD_ANY_WAIT_STATE_CHANGE)MessageHeader->Buffer;

  001b8	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 722  :                 if (StateChange->NewState == DbgKdLoadSymbolsStateChange) {

  001bb	81 39 31 30 00
	00		 cmp	 DWORD PTR [ecx], 12337	; 00003031H
  001c1	75 5a		 jne	 SHORT $LN55@Kdp1394Sen

; 723  :                     KdDebuggerNotPresent = true;
; 724  :                     Kd1394Data->SendPacket.TransferStatus = STATUS_SUCCESS;

  001c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  001c9	5f		 pop	 edi
  001ca	5e		 pop	 esi
  001cb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?KdDebuggerNotPresent@@3HA, 1 ; KdDebuggerNotPresent
  001d5	c7 81 00 04 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1024], 0
  001df	5b		 pop	 ebx

; 785  : }

  001e0	8b e5		 mov	 esp, ebp
  001e2	5d		 pop	 ebp
  001e3	c2 08 00	 ret	 8
$LN12@Kdp1394Sen:

; 725  :                     return;
; 726  :                 }
; 727  :             }
; 728  :             else if (PacketType == PACKET_TYPE_KD_FILE_IO) {

  001e6	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  001e9	75 2e		 jne	 SHORT $LN9@Kdp1394Sen

; 729  :                 PDBGKD_FILE_IO FileIo
; 730  :                     = (PDBGKD_FILE_IO)MessageHeader->Buffer;

  001eb	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 731  :                 if (FileIo->ApiNumber == DbgKdCreateFileApi) {

  001ee	81 39 30 34 00
	00		 cmp	 DWORD PTR [ecx], 13360	; 00003430H
  001f4	75 27		 jne	 SHORT $LN55@Kdp1394Sen

; 732  :                     KdDebuggerNotPresent = true;
; 733  :                     Kd1394Data->SendPacket.TransferStatus = STATUS_SUCCESS;

  001f6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _Kd1394Data
  001fc	5f		 pop	 edi
  001fd	5e		 pop	 esi
  001fe	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?KdDebuggerNotPresent@@3HA, 1 ; KdDebuggerNotPresent
  00208	c7 82 00 04 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+1024], 0
  00212	5b		 pop	 ebx

; 785  : }

  00213	8b e5		 mov	 esp, ebp
  00215	5d		 pop	 ebp
  00216	c2 08 00	 ret	 8
$LN9@Kdp1394Sen:

; 734  :                     return;
; 735  :                 }
; 736  :             }
; 737  :             else {
; 738  :                 bException = true;

  00219	c6 45 ff 01	 mov	 BYTE PTR _bException$[ebp], 1
$LN55@Kdp1394Sen:

; 739  :             }
; 740  :         }
; 741  : 
; 742  :         ReturnCode = KDP_PACKET_TIMEOUT;
; 743  : 
; 744  :         {
; 745  :             UINT32                  count = 0;
; 746  :             volatile NTSTATUS       *pStatus;
; 747  : 
; 748  :             pStatus = &Kd1394Data->ReceivePacket.TransferStatus;

  0021d	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _Kd1394Data
  00223	33 f6		 xor	 esi, esi
  00225	81 c3 00 14 00
	00		 add	 ebx, 5120		; 00001400H
  0022b	eb 0b		 jmp	 SHORT $LN6@Kdp1394Sen
  0022d	8d 49 00	 npad	 3
$LL54@Kdp1394Sen:
  00230	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdRegisters
  00235	83 ca ff	 or	 edx, -1
$LN6@Kdp1394Sen:

; 749  : 
; 750  :             //
; 751  :             // now sit here and poll for a response from the host machine
; 752  :             //
; 753  :             do {
; 754  :                 // make sure our link is enabled..
; 755  :                 Dbg1394_EnablePhysicalAccess();

  00238	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  0023b	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00240	85 c1		 test	 eax, ecx
  00242	74 3e		 je	 SHORT $LN39@Kdp1394Sen
  00244	a9 00 00 08 00	 test	 eax, 524288		; 00080000H
  00249	74 37		 je	 SHORT $LN39@Kdp1394Sen
  0024b	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  00250	75 30		 jne	 SHORT $LN39@Kdp1394Sen
  00252	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdRegisters
  00257	85 88 80 00 00
	00		 test	 DWORD PTR [eax+128], ecx
  0025d	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdRegisters
  00262	74 06		 je	 SHORT $LN37@Kdp1394Sen
  00264	89 88 84 00 00
	00		 mov	 DWORD PTR [eax+132], ecx
$LN37@Kdp1394Sen:
  0026a	89 90 00 01 00
	00		 mov	 DWORD PTR [eax+256], edx
  00270	89 90 08 01 00
	00		 mov	 DWORD PTR [eax+264], edx
  00276	89 90 10 01 00
	00		 mov	 DWORD PTR [eax+272], edx
  0027c	89 90 18 01 00
	00		 mov	 DWORD PTR [eax+280], edx
$LN39@Kdp1394Sen:

; 756  :                 KdpSpin();

  00282	e8 00 00 00 00	 call	 ?KdpSpin@@YIXXZ		; KdpSpin

; 757  : 
; 758  :                 //
; 759  :                 // while in this loop check if the host has submitted a new request.
; 760  :                 // If they did, abort processing of the current request.
; 761  :                 //
; 762  :                 count++;
; 763  :                 if (Kd1394Data->SendPacket.TransferStatus != STATUS_PENDING) {

  00287	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  0028d	83 c6 01	 add	 esi, 1
  00290	81 b9 00 04 00
	00 03 01 00 00	 cmp	 DWORD PTR [ecx+1024], 259 ; 00000103H
  0029a	75 28		 jne	 SHORT $LN48@Kdp1394Sen

; 764  :                     ReturnCode = KDP_PACKET_RECEIVED;
; 765  :                     break;
; 766  :                 }
; 767  : 
; 768  :                 if ((*pStatus == STATUS_PENDING) && (!bException)) {

  0029c	8b 13		 mov	 edx, DWORD PTR [ebx]
  0029e	81 fa 03 01 00
	00		 cmp	 edx, 259		; 00000103H
  002a4	75 06		 jne	 SHORT $LN5@Kdp1394Sen
  002a6	80 7d ff 00	 cmp	 BYTE PTR _bException$[ebp], 0
  002aa	74 18		 je	 SHORT $LN48@Kdp1394Sen
$LN5@Kdp1394Sen:

; 769  :                     ReturnCode = KDP_PACKET_RECEIVED;
; 770  :                     break;
; 771  :                 }
; 772  :             } while (count < TIMEOUT_COUNT);

  002ac	81 fe 00 d0 07
	00		 cmp	 esi, 512000		; 0007d000H
  002b2	0f 82 78 ff ff
	ff		 jb	 $LL54@Kdp1394Sen

; 773  :         }
; 774  : 
; 775  :         if (ReturnCode == KDP_PACKET_TIMEOUT) {
; 776  :             KdCompNumberRetries--;

  002b8	83 2d 00 00 00
	00 01		 sub	 DWORD PTR ?KdCompNumberRetries@@3KA, 1 ; KdCompNumberRetries

; 777  :         }
; 778  :     } while (ReturnCode != KDP_PACKET_RECEIVED);

  002bf	e9 4c fe ff ff	 jmp	 $LL20@Kdp1394Sen
$LN48@Kdp1394Sen:

; 779  : 
; 780  :     //
; 781  :     // Since we are able to talk to debugger, the retrycount is set to
; 782  :     // maximum value.
; 783  :     //
; 784  :     KdCompRetryCount = KdContext->KdpDefaultRetries;

  002c4	8b 45 0c	 mov	 eax, DWORD PTR _KdContext$[ebp]
  002c7	8b 08		 mov	 ecx, DWORD PTR [eax]
  002c9	5f		 pop	 edi
  002ca	5e		 pop	 esi
  002cb	89 0d 00 00 00
	00		 mov	 DWORD PTR ?KdCompRetryCount@@3KA, ecx ; KdCompRetryCount
  002d1	5b		 pop	 ebx

; 785  : }

  002d2	8b e5		 mov	 esp, ebp
  002d4	5d		 pop	 ebp
  002d5	c2 08 00	 ret	 8
?Kdp1394SendPacket@@YIXKPAU_STRING@@0PAU_KD_CONTEXT@@@Z ENDP ; Kdp1394SendPacket
_TEXT	ENDS
PUBLIC	?Kdp1394PollBreakIn@@YI_NXZ			; Kdp1394PollBreakIn
; Function compile flags: /Ogtp
;	COMDAT ?Kdp1394PollBreakIn@@YI_NXZ
_TEXT	SEGMENT
?Kdp1394PollBreakIn@@YI_NXZ PROC			; Kdp1394PollBreakIn, COMDAT

; 791  :     KDDBG2("Kdp1394PollBreakIn\n");
; 792  : 
; 793  :     // make sure our link is enabled..
; 794  :     Dbg1394_EnablePhysicalAccess();

  00000	e8 00 00 00 00	 call	 ?Dbg1394_EnablePhysicalAccess@@YIXXZ ; Dbg1394_EnablePhysicalAccess

; 795  : 
; 796  :     // let's peak into our receive packet and see if it's a breakin
; 797  :     if ((Kd1394Data->ReceivePacket.TransferStatus == STATUS_PENDING) &&
; 798  :         (Kd1394Data->ReceivePacket.Packet[0] == BREAKIN_PACKET_BYTE)) {

  00005	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  0000a	81 b8 00 14 00
	00 03 01 00 00	 cmp	 DWORD PTR [eax+5120], 259 ; 00000103H
  00014	75 1a		 jne	 SHORT $LN1@Kdp1394Pol
  00016	80 b8 08 14 00
	00 62		 cmp	 BYTE PTR [eax+5128], 98	; 00000062H
  0001d	75 11		 jne	 SHORT $LN1@Kdp1394Pol

; 799  : 
; 800  :         KdDebuggerNotPresent = false;

  0001f	33 c9		 xor	 ecx, ecx
  00021	89 0d 00 00 00
	00		 mov	 DWORD PTR ?KdDebuggerNotPresent@@3HA, ecx ; KdDebuggerNotPresent

; 801  : 
; 802  :         // we have a breakin packet
; 803  :         Kd1394Data->ReceivePacket.TransferStatus = STATUS_SUCCESS;

  00027	89 88 00 14 00
	00		 mov	 DWORD PTR [eax+5120], ecx

; 804  :         return true;

  0002d	b0 01		 mov	 al, 1

; 807  : }

  0002f	c3		 ret	 0
$LN1@Kdp1394Pol:

; 805  :     }
; 806  :     return false;

  00030	32 c0		 xor	 al, al

; 807  : }

  00032	c3		 ret	 0
?Kdp1394PollBreakIn@@YI_NXZ ENDP			; Kdp1394PollBreakIn
_TEXT	ENDS
END
