; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	C:\Users\cc\source\repos\Singularity-OS\base\Kernel\Native\EventingKernel.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?strlen@@YIIPAD@Z				; strlen
; Function compile flags: /Ogtp
; File c:\users\cc\source\repos\singularity-os\base\kernel\native\eventing.h
;	COMDAT ?strlen@@YIIPAD@Z
_TEXT	SEGMENT
?strlen@@YIIPAD@Z PROC					; strlen, COMDAT
; _str$ = ecx

; 40   :     uint32 length = 0;

  00000	33 c0		 xor	 eax, eax

; 41   :     while (*str++) length += 1;

  00002	38 01		 cmp	 BYTE PTR [ecx], al
  00004	74 0b		 je	 SHORT $LN6@strlen
$LL2@strlen:
  00006	83 c1 01	 add	 ecx, 1
  00009	83 c0 01	 add	 eax, 1
  0000c	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0000f	75 f5		 jne	 SHORT $LL2@strlen
$LN6@strlen:

; 42   :     return length;
; 43   : }

  00011	c3		 ret	 0
?strlen@@YIIPAD@Z ENDP					; strlen
_TEXT	ENDS
PUBLIC	?GetRecordHeaderSize@@YIIGG@Z			; GetRecordHeaderSize
; Function compile flags: /Ogtp
;	COMDAT ?GetRecordHeaderSize@@YIIGG@Z
_TEXT	SEGMENT
?GetRecordHeaderSize@@YIIGG@Z PROC			; GetRecordHeaderSize, COMDAT
; _Flags$ = cx
; _StackSize$ = edx

; 168  :     uint16 HeaderSize = sizeof(MEMORY_HEADER);
; 169  : 
; 170  :     if (Flags & RECORD_STACK_TRACES) {

  00000	f6 c1 01	 test	 cl, 1
  00003	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00008	74 05		 je	 SHORT $LN4@GetRecordH

; 171  :         
; 172  :         HeaderSize += StackSize;

  0000a	03 d0		 add	 edx, eax
  0000c	0f b7 c2	 movzx	 eax, dx
$LN4@GetRecordH:

; 173  :     }
; 174  : 
; 175  :     return HeaderSize;

  0000f	0f b7 c0	 movzx	 eax, ax

; 176  : }

  00012	c3		 ret	 0
?GetRecordHeaderSize@@YIIGG@Z ENDP			; GetRecordHeaderSize
_TEXT	ENDS
PUBLIC	?GetRecordInternalStructure@@YIPAXPAU_MEMORY_HEADER@@G@Z ; GetRecordInternalStructure
; Function compile flags: /Ogtp
;	COMDAT ?GetRecordInternalStructure@@YIPAXPAU_MEMORY_HEADER@@G@Z
_TEXT	SEGMENT
?GetRecordInternalStructure@@YIPAXPAU_MEMORY_HEADER@@G@Z PROC ; GetRecordInternalStructure, COMDAT
; _Record$ = ecx
; _RecordFlag$ = dx

; 186  :     if (Record->Flags & RecordFlag) {

  00000	66 85 51 06	 test	 WORD PTR [ecx+6], dx
  00004	74 0e		 je	 SHORT $LN2@GetRecordI

; 187  : 
; 188  :         uint16 HeaderSize;
; 189  : 
; 190  :         if (RecordFlag & (RecordFlag - 1)) {

  00006	0f b7 c2	 movzx	 eax, dx
  00009	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
  0000c	85 d0		 test	 edx, eax

; 191  : 
; 192  :             //  A single bit at the time can be set to query the internal layout info.
; 193  :             //  Return failure otherwise.
; 194  : 
; 195  :             return NULL;

  0000e	75 04		 jne	 SHORT $LN2@GetRecordI

; 196  :         }
; 197  : 
; 198  :         //  The structures are allocated in order, as the flags bits decrease
; 199  :         //  We can clear the flags 
; 200  : 
; 201  :         HeaderSize = GetRecordHeaderSize(Record->Flags & (~((RecordFlag << 1) - 1)), 0);
; 202  : 
; 203  :         return (PVOID)((ULONG_PTR)Record + HeaderSize);

  00010	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]

; 207  : }

  00013	c3		 ret	 0
$LN2@GetRecordI:

; 204  :     }
; 205  : 
; 206  :     return NULL;

  00014	33 c0		 xor	 eax, eax

; 207  : }

  00016	c3		 ret	 0
?GetRecordInternalStructure@@YIPAXPAU_MEMORY_HEADER@@G@Z ENDP ; GetRecordInternalStructure
_TEXT	ENDS
PUBLIC	?GetUserRecordStructure@@YIPAXPAU_MEMORY_HEADER@@@Z ; GetUserRecordStructure
; Function compile flags: /Ogtp
;	COMDAT ?GetUserRecordStructure@@YIPAXPAU_MEMORY_HEADER@@@Z
_TEXT	SEGMENT
?GetUserRecordStructure@@YIPAXPAU_MEMORY_HEADER@@@Z PROC ; GetUserRecordStructure, COMDAT
; _Record$ = ecx

; 216  :     if (Record->Flags & RECORD_STACK_TRACES) {

  00000	f6 41 06 01	 test	 BYTE PTR [ecx+6], 1
  00004	74 17		 je	 SHORT $LN2@GetUserRec

; 217  : 
; 218  :         ULONG_PTR * StackSize = (ULONG_PTR *)GetRecordInternalStructure(Record, RECORD_STACK_TRACES);
; 219  :         return (PVOID)((ULONG_PTR)Record + GetRecordHeaderSize(Record->Flags, (uint16)(*StackSize + 1) * sizeof(UIntPtr)));

  00006	66 8b 41 18	 mov	 ax, WORD PTR [ecx+24]
  0000a	66 05 07 00	 add	 ax, 7
  0000e	66 03 c0	 add	 ax, ax
  00011	66 03 c0	 add	 ax, ax
  00014	0f b7 c0	 movzx	 eax, ax
  00017	0f b7 c0	 movzx	 eax, ax
  0001a	03 c1		 add	 eax, ecx

; 224  :     }
; 225  : 
; 226  :     return NULL;
; 227  : }

  0001c	c3		 ret	 0
$LN2@GetUserRec:

; 220  : 
; 221  :     } else {
; 222  : 
; 223  :         return (PVOID)((ULONG_PTR)Record + GetRecordHeaderSize(Record->Flags, 0));

  0001d	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]

; 224  :     }
; 225  : 
; 226  :     return NULL;
; 227  : }

  00020	c3		 ret	 0
?GetUserRecordStructure@@YIPAXPAU_MEMORY_HEADER@@@Z ENDP ; GetUserRecordStructure
_TEXT	ENDS
PUBLIC	?GetLocalRepository@@YIPAU_MEMORY_STORAGE@@XZ	; GetLocalRepository
EXTRN	?SourceController@@3U_SOURCE_CONTROLLER@@A:BYTE	; SourceController
; Function compile flags: /Ogtp
;	COMDAT ?GetLocalRepository@@YIPAU_MEMORY_STORAGE@@XZ
_TEXT	SEGMENT
?GetLocalRepository@@YIPAU_MEMORY_STORAGE@@XZ PROC	; GetLocalRepository, COMDAT

; 367  :     return SourceController.SourceRepository;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SourceController@@3U_SOURCE_CONTROLLER@@A

; 368  : }

  00005	c3		 ret	 0
?GetLocalRepository@@YIPAU_MEMORY_STORAGE@@XZ ENDP	; GetLocalRepository
_TEXT	ENDS
PUBLIC	?GetLocalRepositoryHandle@@YIPAUuintPtr@@XZ	; GetLocalRepositoryHandle
; Function compile flags: /Ogtp
;	COMDAT ?GetLocalRepositoryHandle@@YIPAUuintPtr@@XZ
_TEXT	SEGMENT
?GetLocalRepositoryHandle@@YIPAUuintPtr@@XZ PROC	; GetLocalRepositoryHandle, COMDAT

; 374  :     return (UIntPtr)GetLocalRepository();

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SourceController@@3U_SOURCE_CONTROLLER@@A

; 375  : }

  00005	c3		 ret	 0
?GetLocalRepositoryHandle@@YIPAUuintPtr@@XZ ENDP	; GetLocalRepositoryHandle
_TEXT	ENDS
PUBLIC	?FormatCSOutput@@YIXPAXPAD1HP6IH01HHHDH@ZP6IPAD0H@Z@Z ; FormatCSOutput
; Function compile flags: /Ogtp
; File c:\users\cc\source\repos\singularity-os\base\kernel\native\csformat.inc
;	COMDAT ?FormatCSOutput@@YIXPAXPAD1HP6IH01HHHDH@ZP6IPAD0H@Z@Z
_TEXT	SEGMENT
_pbeg$11457 = -20					; size = 4
_endBuffer$ = -16					; size = 4
_context$ = -12						; size = 4
_fmt$11462 = -8						; size = 1
_pmsg$ = -4						; size = 4
_buffer$ = 8						; size = 4
_bad$11458 = 11						; size = 1
_aln$11460 = 12						; size = 4
_bufferLen$ = 12					; size = 4
_pfprintField$ = 16					; size = 4
_pfStringField$ = 20					; size = 4
?FormatCSOutput@@YIXPAXPAD1HP6IH01HHHDH@ZP6IPAD0H@Z@Z PROC ; FormatCSOutput, COMDAT
; _context$ = ecx
; _format$ = edx

; 15   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 16   :     char * text = format;
; 17   :     char *  pmsg = buffer;
; 18   :     char *  ptxt = text;
; 19   :     char * endBuffer = buffer + bufferLen - 1;
; 20   :     while (*ptxt != '\0') {

  00006	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00009	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	8b 7d 0c	 mov	 edi, DWORD PTR _bufferLen$[ebp]
  00011	89 4d f4	 mov	 DWORD PTR _context$[ebp], ecx
  00014	8b c8		 mov	 ecx, eax
  00016	8d 44 38 ff	 lea	 eax, DWORD PTR [eax+edi-1]
  0001a	89 4d fc	 mov	 DWORD PTR _pmsg$[ebp], ecx
  0001d	8b f2		 mov	 esi, edx
  0001f	89 45 f0	 mov	 DWORD PTR _endBuffer$[ebp], eax
  00022	0f 84 5d 01 00
	00		 je	 $LN45@FormatCSOu
  00028	53		 push	 ebx
  00029	8d a4 24 00 00
	00 00		 npad	 7
$LL32@FormatCSOu:

; 21   :         
; 22   :         if (*ptxt == '{') {

  00030	8a 06		 mov	 al, BYTE PTR [esi]
  00032	3c 7b		 cmp	 al, 123			; 0000007bH
  00034	0f 85 56 01 00
	00		 jne	 $LN30@FormatCSOu

; 23   :             char * pbeg = ptxt;
; 24   :             bool bad = false;
; 25   :             ptxt++;
; 26   : 
; 27   :             int ndx = 0;
; 28   :             int aln = 0;
; 29   :             int wid = 0;
; 30   :             char fmt = 'd';
; 31   : 
; 32   :             if (*ptxt == '{') {

  0003a	8a 46 01	 mov	 al, BYTE PTR [esi+1]
  0003d	89 75 ec	 mov	 DWORD PTR _pbeg$11457[ebp], esi
  00040	83 c6 01	 add	 esi, 1
  00043	33 d2		 xor	 edx, edx
  00045	33 ff		 xor	 edi, edi
  00047	33 db		 xor	 ebx, ebx
  00049	3c 7b		 cmp	 al, 123			; 0000007bH
  0004b	c6 45 0b 00	 mov	 BYTE PTR _bad$11458[ebp], 0
  0004f	89 55 0c	 mov	 DWORD PTR _aln$11460[ebp], edx
  00052	c6 45 f8 64	 mov	 BYTE PTR _fmt$11462[ebp], 100 ; 00000064H
  00056	75 10		 jne	 SHORT $LN29@FormatCSOu

; 33   :                 *pmsg++ = *ptxt++;

  00058	88 01		 mov	 BYTE PTR [ecx], al
  0005a	83 c1 01	 add	 ecx, 1
  0005d	89 4d fc	 mov	 DWORD PTR _pmsg$[ebp], ecx
  00060	83 c6 01	 add	 esi, 1
  00063	e9 13 01 00 00	 jmp	 $LN1@FormatCSOu
$LN29@FormatCSOu:

; 34   :             }
; 35   :             else if (*ptxt >= '0' && *ptxt <= '9') {

  00068	3c 30		 cmp	 al, 48			; 00000030H
  0006a	0f 8c 0b 01 00
	00		 jl	 $LN1@FormatCSOu
  00070	3c 39		 cmp	 al, 57			; 00000039H
  00072	0f 8f 03 01 00
	00		 jg	 $LN1@FormatCSOu
$LL26@FormatCSOu:

; 36   : 
; 37   :                 // {index,alignment:type width}
; 38   :                 // Get Index
; 39   :                 while (*ptxt >= '0' && *ptxt <= '9') {

  00078	3c 39		 cmp	 al, 57			; 00000039H
  0007a	7f 13		 jg	 SHORT $LN25@FormatCSOu

; 40   :                     ndx = ndx * 10 + (*ptxt++ - '0');

  0007c	0f be c0	 movsx	 eax, al
  0007f	8d 3c bf	 lea	 edi, DWORD PTR [edi+edi*4]
  00082	83 c6 01	 add	 esi, 1
  00085	8d 7c 78 d0	 lea	 edi, DWORD PTR [eax+edi*2-48]
  00089	8a 06		 mov	 al, BYTE PTR [esi]
  0008b	3c 30		 cmp	 al, 48			; 00000030H
  0008d	7d e9		 jge	 SHORT $LL26@FormatCSOu
$LN25@FormatCSOu:

; 41   :                 }
; 42   : 
; 43   :                 // Get Alignment
; 44   :                 if (*ptxt == ',') {

  0008f	80 3e 2c	 cmp	 BYTE PTR [esi], 44	; 0000002cH
  00092	75 26		 jne	 SHORT $LN22@FormatCSOu

; 45   :                     ptxt++;
; 46   :                     while (*ptxt >= '0' && *ptxt <= '9') {

  00094	8a 46 01	 mov	 al, BYTE PTR [esi+1]
  00097	83 c6 01	 add	 esi, 1
  0009a	3c 30		 cmp	 al, 48			; 00000030H
  0009c	7c 1c		 jl	 SHORT $LN22@FormatCSOu
  0009e	8b ff		 npad	 2
$LL23@FormatCSOu:
  000a0	3c 39		 cmp	 al, 57			; 00000039H
  000a2	7f 16		 jg	 SHORT $LN22@FormatCSOu

; 47   :                         aln = aln * 10 + (*ptxt++ - '0');

  000a4	0f be c0	 movsx	 eax, al
  000a7	8d 14 92	 lea	 edx, DWORD PTR [edx+edx*4]
  000aa	83 c6 01	 add	 esi, 1
  000ad	8d 54 50 d0	 lea	 edx, DWORD PTR [eax+edx*2-48]
  000b1	8a 06		 mov	 al, BYTE PTR [esi]
  000b3	3c 30		 cmp	 al, 48			; 00000030H
  000b5	89 55 0c	 mov	 DWORD PTR _aln$11460[ebp], edx
  000b8	7d e6		 jge	 SHORT $LL23@FormatCSOu
$LN22@FormatCSOu:

; 48   :                     }
; 49   :                 }
; 50   : 
; 51   :                 // Get FormatString
; 52   :                 if (*ptxt == ':') {

  000ba	80 3e 3a	 cmp	 BYTE PTR [esi], 58	; 0000003aH
  000bd	75 3b		 jne	 SHORT $LN16@FormatCSOu

; 53   :                     ptxt++;
; 54   :                     if (*ptxt >= 'a' && *ptxt <= 'z') {

  000bf	8a 46 01	 mov	 al, BYTE PTR [esi+1]
  000c2	83 c6 01	 add	 esi, 1
  000c5	3c 61		 cmp	 al, 97			; 00000061H
  000c7	7c 04		 jl	 SHORT $LN20@FormatCSOu
  000c9	3c 7a		 cmp	 al, 122			; 0000007aH

; 55   :                         fmt = *ptxt++;

  000cb	7e 0a		 jle	 SHORT $LN49@FormatCSOu
$LN20@FormatCSOu:

; 56   :                     }
; 57   :                     else if (*ptxt >= 'A' && *ptxt <= 'Z') {

  000cd	3c 41		 cmp	 al, 65			; 00000041H
  000cf	7c 0c		 jl	 SHORT $LN39@FormatCSOu
  000d1	3c 5a		 cmp	 al, 90			; 0000005aH
  000d3	7f 08		 jg	 SHORT $LN39@FormatCSOu

; 58   :                         fmt = *ptxt++ - 'A' + 'a';

  000d5	04 20		 add	 al, 32			; 00000020H
$LN49@FormatCSOu:
  000d7	83 c6 01	 add	 esi, 1
  000da	88 45 f8	 mov	 BYTE PTR _fmt$11462[ebp], al
$LN39@FormatCSOu:

; 59   :                     }
; 60   :                     while (*ptxt >= '0' && *ptxt <= '9') {

  000dd	8a 06		 mov	 al, BYTE PTR [esi]
  000df	3c 30		 cmp	 al, 48			; 00000030H
  000e1	7c 17		 jl	 SHORT $LN16@FormatCSOu
$LL17@FormatCSOu:
  000e3	3c 39		 cmp	 al, 57			; 00000039H
  000e5	7f 13		 jg	 SHORT $LN16@FormatCSOu

; 61   :                         wid = wid * 10 + (*ptxt++ - '0');

  000e7	0f be c0	 movsx	 eax, al
  000ea	8d 1c 9b	 lea	 ebx, DWORD PTR [ebx+ebx*4]
  000ed	83 c6 01	 add	 esi, 1
  000f0	8d 5c 58 d0	 lea	 ebx, DWORD PTR [eax+ebx*2-48]
  000f4	8a 06		 mov	 al, BYTE PTR [esi]
  000f6	3c 30		 cmp	 al, 48			; 00000030H
  000f8	7d e9		 jge	 SHORT $LL17@FormatCSOu
$LN16@FormatCSOu:

; 62   :                     }
; 63   :                 }
; 64   : 
; 65   :                 // indirect formatting
; 66   :                 if (*ptxt == '*') {

  000fa	80 3e 2a	 cmp	 BYTE PTR [esi], 42	; 0000002aH
  000fd	75 1f		 jne	 SHORT $LN13@FormatCSOu

; 67   :                     ptxt++;
; 68   : 
; 69   :                     if (pfStringField != NULL) {

  000ff	8b 45 14	 mov	 eax, DWORD PTR _pfStringField$[ebp]
  00102	83 c6 01	 add	 esi, 1
  00105	85 c0		 test	 eax, eax
  00107	74 15		 je	 SHORT $LN13@FormatCSOu

; 70   : 
; 71   :                         text = pfStringField(context, ndx);

  00109	8b 4d f4	 mov	 ecx, DWORD PTR _context$[ebp]
  0010c	8b d7		 mov	 edx, edi
  0010e	ff d0		 call	 eax

; 72   :                         if (text != NULL) {

  00110	85 c0		 test	 eax, eax

; 75   :                             continue;

  00112	8b 4d fc	 mov	 ecx, DWORD PTR _pmsg$[ebp]
  00115	74 04		 je	 SHORT $LN47@FormatCSOu

; 73   : 
; 74   :                             ptxt = text;

  00117	8b f0		 mov	 esi, eax

; 75   :                             continue;

  00119	eb 60		 jmp	 SHORT $LN1@FormatCSOu
$LN47@FormatCSOu:
  0011b	8b 55 0c	 mov	 edx, DWORD PTR _aln$11460[ebp]
$LN13@FormatCSOu:

; 76   :                         }
; 77   :                     }
; 78   : 
; 79   :                 }
; 80   : 
; 81   :                 // Get closing brace.
; 82   :                 if (*ptxt == '}') {

  0011e	80 3e 7d	 cmp	 BYTE PTR [esi], 125	; 0000007dH
  00121	75 05		 jne	 SHORT $LN12@FormatCSOu

; 83   :                     ptxt++;

  00123	83 c6 01	 add	 esi, 1

; 84   :                 }
; 85   :                 else {

  00126	eb 04		 jmp	 SHORT $LN11@FormatCSOu
$LN12@FormatCSOu:

; 86   :                     bad = true;

  00128	c6 45 0b 01	 mov	 BYTE PTR _bad$11458[ebp], 1
$LN11@FormatCSOu:

; 87   :                 }
; 88   : 
; 89   :                 int printLength = pfprintField(context, 
; 90   :                                                pmsg, 
; 91   :                                                (int)(endBuffer - pmsg), 
; 92   :                                                aln, 
; 93   :                                                wid, 
; 94   :                                                fmt, 
; 95   :                                                ndx);

  0012c	8b 45 f8	 mov	 eax, DWORD PTR _fmt$11462[ebp]
  0012f	57		 push	 edi
  00130	50		 push	 eax
  00131	53		 push	 ebx
  00132	52		 push	 edx
  00133	8b 55 f0	 mov	 edx, DWORD PTR _endBuffer$[ebp]
  00136	2b d1		 sub	 edx, ecx
  00138	52		 push	 edx
  00139	8b d1		 mov	 edx, ecx
  0013b	8b 4d f4	 mov	 ecx, DWORD PTR _context$[ebp]
  0013e	ff 55 10	 call	 DWORD PTR _pfprintField$[ebp]

; 96   : 
; 97   :                 if (printLength >= 0) {

  00141	85 c0		 test	 eax, eax
  00143	7c 12		 jl	 SHORT $LN9@FormatCSOu

; 98   : 
; 99   :                     pmsg += printLength;

  00145	8b 4d fc	 mov	 ecx, DWORD PTR _pmsg$[ebp]
  00148	03 c8		 add	 ecx, eax

; 100  : 
; 101  :                     if (pmsg > endBuffer) {

  0014a	8b 45 f0	 mov	 eax, DWORD PTR _endBuffer$[ebp]
  0014d	3b c8		 cmp	 ecx, eax
  0014f	89 4d fc	 mov	 DWORD PTR _pmsg$[ebp], ecx
  00152	76 03		 jbe	 SHORT $LN9@FormatCSOu

; 102  :                         pmsg = endBuffer;

  00154	89 45 fc	 mov	 DWORD PTR _pmsg$[ebp], eax
$LN9@FormatCSOu:

; 103  :                     }
; 104  :                 }
; 105  :                 // If the format was bad, then copy it.
; 106  :                 if (bad) {

  00157	80 7d 0b 00	 cmp	 BYTE PTR _bad$11458[ebp], 0
  0015b	74 1b		 je	 SHORT $LN48@FormatCSOu

; 107  : 
; 108  :                     while (pbeg < ptxt) {

  0015d	8b 45 ec	 mov	 eax, DWORD PTR _pbeg$11457[ebp]
  00160	3b c6		 cmp	 eax, esi
  00162	73 14		 jae	 SHORT $LN48@FormatCSOu
$LL7@FormatCSOu:

; 109  :                         *pmsg++ = *pbeg++;

  00164	8b 4d fc	 mov	 ecx, DWORD PTR _pmsg$[ebp]
  00167	8a 10		 mov	 dl, BYTE PTR [eax]
  00169	88 11		 mov	 BYTE PTR [ecx], dl
  0016b	83 c1 01	 add	 ecx, 1
  0016e	83 c0 01	 add	 eax, 1
  00171	3b c6		 cmp	 eax, esi
  00173	89 4d fc	 mov	 DWORD PTR _pmsg$[ebp], ecx
  00176	72 ec		 jb	 SHORT $LL7@FormatCSOu
$LN48@FormatCSOu:

; 75   :                             continue;

  00178	8b 4d fc	 mov	 ecx, DWORD PTR _pmsg$[ebp]
$LN1@FormatCSOu:

; 16   :     char * text = format;
; 17   :     char *  pmsg = buffer;
; 18   :     char *  ptxt = text;
; 19   :     char * endBuffer = buffer + bufferLen - 1;
; 20   :     while (*ptxt != '\0') {

  0017b	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0017e	0f 85 ac fe ff
	ff		 jne	 $LL32@FormatCSOu
  00184	5b		 pop	 ebx
$LN45@FormatCSOu:
  00185	5f		 pop	 edi

; 122  :             *pmsg++ = *ptxt++;
; 123  :         }
; 124  :     }
; 125  :     *pmsg++ = '\0';

  00186	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00189	5e		 pop	 esi

; 126  : }

  0018a	8b e5		 mov	 esp, ebp
  0018c	5d		 pop	 ebp
  0018d	c2 10 00	 ret	 16			; 00000010H
$LN30@FormatCSOu:

; 110  :                     }
; 111  :                 }
; 112  :             }
; 113  :         }
; 114  :         else if (*ptxt == '}') {

  00190	3c 7d		 cmp	 al, 125			; 0000007dH
  00192	75 13		 jne	 SHORT $LN4@FormatCSOu

; 115  :             ptxt++;
; 116  :             *pmsg++ = *ptxt++;

  00194	8a 46 01	 mov	 al, BYTE PTR [esi+1]
  00197	83 c6 01	 add	 esi, 1
$LN2@FormatCSOu:
  0019a	88 01		 mov	 BYTE PTR [ecx], al
  0019c	83 c1 01	 add	 ecx, 1
  0019f	89 4d fc	 mov	 DWORD PTR _pmsg$[ebp], ecx
  001a2	83 c6 01	 add	 esi, 1
  001a5	eb d4		 jmp	 SHORT $LN1@FormatCSOu
$LN4@FormatCSOu:

; 117  :         }
; 118  :         else if (*ptxt == '\n') {

  001a7	3c 0a		 cmp	 al, 10			; 0000000aH
  001a9	75 ef		 jne	 SHORT $LN2@FormatCSOu

; 119  :             ptxt++;

  001ab	83 c6 01	 add	 esi, 1

; 120  :         }
; 121  :         else {

  001ae	eb cb		 jmp	 SHORT $LN1@FormatCSOu
?FormatCSOutput@@YIXPAXPAD1HP6IH01HHHDH@ZP6IPAD0H@Z@Z ENDP ; FormatCSOutput
; Function compile flags: /Ogtp
; File c:\users\cc\source\repos\singularity-os\base\kernel\native\eventingkernel.cpp
_TEXT	ENDS
;	COMDAT ?snprintfout@@YIXPAXD@Z
_TEXT	SEGMENT
?snprintfout@@YIXPAXD@Z PROC				; snprintfout, COMDAT
; _pContext$ = ecx
; _c$ = dl

; 31   :     SNPRINT_CONTEXT * context = (SNPRINT_CONTEXT *)pContext;
; 32   : 
; 33   :     if (*(context->CrtPos) < context->EndBuffer) {

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	8b 30		 mov	 esi, DWORD PTR [eax]
  00005	3b 71 04	 cmp	 esi, DWORD PTR [ecx+4]
  00008	5e		 pop	 esi
  00009	73 09		 jae	 SHORT $LN1@snprintfou

; 34   : 
; 35   :         *(*context->CrtPos)++ = c;

  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	88 10		 mov	 BYTE PTR [eax], dl
  0000f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00011	83 01 01	 add	 DWORD PTR [ecx], 1
$LN1@snprintfou:

; 36   :     }
; 37   : }

  00014	c3		 ret	 0
?snprintfout@@YIXPAXD@Z ENDP				; snprintfout
_TEXT	ENDS
PUBLIC	?snprintf@@YAHPADHPBDZZ				; snprintf
EXTRN	?strformat@@YIHP6IXPAXD@Z0PBDPAD@Z:PROC		; strformat
; Function compile flags: /Ogtp
;	COMDAT ?snprintf@@YAHPADHPBDZZ
_TEXT	SEGMENT
_context$ = -8						; size = 8
_pszOut$ = 8						; size = 4
_outSize$ = 12						; size = 4
_pszFmt$ = 16						; size = 4
?snprintf@@YAHPADHPBDZZ PROC				; snprintf, COMDAT

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 41   :     int nOut;
; 42   :     va_list args;
; 43   :     SNPRINT_CONTEXT context = {&pszOut, pszOut + outSize - 1};

  00006	8b 55 08	 mov	 edx, DWORD PTR _pszOut$[ebp]
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _outSize$[ebp]
  0000c	8d 45 08	 lea	 eax, DWORD PTR _pszOut$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR _context$[ebp], eax
  00012	8d 44 0a ff	 lea	 eax, DWORD PTR [edx+ecx-1]

; 44   : 
; 45   :     va_start(args, pszFmt);
; 46   :     nOut = strformat(snprintfout, &context, pszFmt, args);

  00016	8b 55 10	 mov	 edx, DWORD PTR _pszFmt$[ebp]
  00019	8d 4d 14	 lea	 ecx, DWORD PTR _pszFmt$[ebp+4]
  0001c	51		 push	 ecx
  0001d	52		 push	 edx
  0001e	8d 55 f8	 lea	 edx, DWORD PTR _context$[ebp]
  00021	b9 00 00 00 00	 mov	 ecx, OFFSET ?snprintfout@@YIXPAXD@Z ; snprintfout
  00026	89 45 fc	 mov	 DWORD PTR _context$[ebp+4], eax
  00029	e8 00 00 00 00	 call	 ?strformat@@YIHP6IXPAXD@Z0PBDPAD@Z ; strformat

; 47   :     va_end(args);
; 48   : 
; 49   :     *pszOut = '\0';

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _pszOut$[ebp]
  00031	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 50   : 
; 51   :     return nOut;
; 52   : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?snprintf@@YAHPADHPBDZZ ENDP				; snprintf
_TEXT	ENDS
PUBLIC	?GetDescriptorField@@YIPAU_EVENT_FIELD_DESCRIPTOR@@PAU_EVENT_DESCRIPTOR@@H@Z ; GetDescriptorField
; Function compile flags: /Ogtp
;	COMDAT ?GetDescriptorField@@YIPAU_EVENT_FIELD_DESCRIPTOR@@PAU_EVENT_DESCRIPTOR@@H@Z
_TEXT	SEGMENT
?GetDescriptorField@@YIPAU_EVENT_FIELD_DESCRIPTOR@@PAU_EVENT_DESCRIPTOR@@H@Z PROC ; GetDescriptorField, COMDAT
; _typeEntry$ = ecx
; _fieldIndex$ = edx

; 57   : {

  00000	56		 push	 esi

; 58   :     PEVENT_FIELD_DESCRIPTOR field;
; 59   : 
; 60   :     //
; 61   :     //  TODO: This needs to be optimized caching the total number of fields
; 62   :     //
; 63   : 
; 64   :     int numFields = 0;
; 65   : 
; 66   :     for (field = typeEntry->fieldsLink; (field != NULL); field = field->fieldsLink) {

  00001	8b 31		 mov	 esi, DWORD PTR [ecx]
  00003	8b ce		 mov	 ecx, esi
  00005	33 c0		 xor	 eax, eax
  00007	85 c9		 test	 ecx, ecx
  00009	74 0e		 je	 SHORT $LN4@GetDescrip
  0000b	eb 03 8d 49 00	 npad	 5
$LL6@GetDescrip:
  00010	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 67   : 
; 68   :         numFields++;

  00012	83 c0 01	 add	 eax, 1
  00015	85 c9		 test	 ecx, ecx
  00017	75 f7		 jne	 SHORT $LL6@GetDescrip
$LN4@GetDescrip:

; 69   :     }
; 70   : 
; 71   :     fieldIndex = numFields - fieldIndex - 1;

  00019	2b c2		 sub	 eax, edx
  0001b	83 e8 01	 sub	 eax, 1
  0001e	8b c8		 mov	 ecx, eax

; 72   : 
; 73   :     for (field = typeEntry->fieldsLink; (field != NULL) && (fieldIndex > 0); field = field->fieldsLink) {

  00020	8b c6		 mov	 eax, esi
  00022	85 c0		 test	 eax, eax
  00024	5e		 pop	 esi
  00025	74 0d		 je	 SHORT $LN1@GetDescrip
$LL3@GetDescrip:
  00027	85 c9		 test	 ecx, ecx
  00029	7e 09		 jle	 SHORT $LN1@GetDescrip
  0002b	8b 00		 mov	 eax, DWORD PTR [eax]

; 74   : 
; 75   :         fieldIndex--;

  0002d	83 e9 01	 sub	 ecx, 1
  00030	85 c0		 test	 eax, eax
  00032	75 f3		 jne	 SHORT $LL3@GetDescrip
$LN1@GetDescrip:

; 76   :     }
; 77   : 
; 78   :     return field;
; 79   : }

  00034	c3		 ret	 0
?GetDescriptorField@@YIPAU_EVENT_FIELD_DESCRIPTOR@@PAU_EVENT_DESCRIPTOR@@H@Z ENDP ; GetDescriptorField
_TEXT	ENDS
PUBLIC	?FindFieldDescriptor@@YIPAU_EVENT_FIELD_DESCRIPTOR@@PAU_EVENT_DESCRIPTOR@@H@Z ; FindFieldDescriptor
; Function compile flags: /Ogtp
;	COMDAT ?FindFieldDescriptor@@YIPAU_EVENT_FIELD_DESCRIPTOR@@PAU_EVENT_DESCRIPTOR@@H@Z
_TEXT	SEGMENT
?FindFieldDescriptor@@YIPAU_EVENT_FIELD_DESCRIPTOR@@PAU_EVENT_DESCRIPTOR@@H@Z PROC ; FindFieldDescriptor, COMDAT
; _typeEntry$ = ecx
; _offset$ = edx

; 84   :     PEVENT_FIELD_DESCRIPTOR field;
; 85   : 
; 86   :     for (field = typeEntry->fieldsLink; field != NULL; field = field->fieldsLink) {

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	85 c0		 test	 eax, eax
  00004	74 0e		 je	 SHORT $LN2@FindFieldD
$LL4@FindFieldD:

; 87   : 
; 88   :         if (field->Offset == offset) {

  00006	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  0000a	3b ca		 cmp	 ecx, edx
  0000c	74 08		 je	 SHORT $LN5@FindFieldD
  0000e	8b 00		 mov	 eax, DWORD PTR [eax]
  00010	85 c0		 test	 eax, eax
  00012	75 f2		 jne	 SHORT $LL4@FindFieldD
$LN2@FindFieldD:

; 89   : 
; 90   :             return field;
; 91   :         }
; 92   :     }
; 93   :     return NULL;

  00014	33 c0		 xor	 eax, eax
$LN5@FindFieldD:

; 94   : }

  00016	c3		 ret	 0
?FindFieldDescriptor@@YIPAU_EVENT_FIELD_DESCRIPTOR@@PAU_EVENT_DESCRIPTOR@@H@Z ENDP ; FindFieldDescriptor
_TEXT	ENDS
PUBLIC	?ReadValueAs@@YI_KPAXHH@Z			; ReadValueAs
; Function compile flags: /Ogtp
;	COMDAT ?ReadValueAs@@YI_KPAXHH@Z
_TEXT	SEGMENT
_type$ = 8						; size = 4
?ReadValueAs@@YI_KPAXHH@Z PROC				; ReadValueAs, COMDAT
; _baseAddress$ = ecx
; _offset$ = edx

; 98   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 99   :     void * memLocation = (char *)baseAddress + offset;
; 100  : 
; 101  :     if (type & EVENT_FIELD_TYPE_arrayType) {

  00003	8b 45 08	 mov	 eax, DWORD PTR _type$[ebp]
  00006	a9 00 80 00 00	 test	 eax, 32768		; 00008000H
  0000b	74 09		 je	 SHORT $LN8@ReadValueA
$LN4@ReadValueA:

; 102  : 
; 103  :         return *(uint16 *)memLocation;

  0000d	0f b7 04 11	 movzx	 eax, WORD PTR [ecx+edx]
  00011	99		 cdq

; 130  : }

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
$LN8@ReadValueA:

; 104  :     }
; 105  : 
; 106  :     switch (type) {

  00016	83 c0 ff	 add	 eax, -1
  00019	83 f8 09	 cmp	 eax, 9
  0001c	77 2c		 ja	 SHORT $LN6@ReadValueA
  0001e	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN12@ReadValueA[eax*4]
$LN5@ReadValueA:

; 107  : 
; 108  :         case EVENT_FIELD_TYPE_int8:
; 109  :         case EVENT_FIELD_TYPE_uint8:
; 110  :             return *(uint8 *)memLocation;

  00025	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  00029	99		 cdq

; 130  : }

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
$LN3@ReadValueA:

; 111  : 
; 112  :         case EVENT_FIELD_TYPE_int16:
; 113  :         case EVENT_FIELD_TYPE_uint16:
; 114  :             return *(uint16 *)memLocation;
; 115  : 
; 116  :         case EVENT_FIELD_TYPE_int32:
; 117  :         case EVENT_FIELD_TYPE_uint32:
; 118  :             return *(uint32 *)memLocation;

  0002e	8b 04 11	 mov	 eax, DWORD PTR [ecx+edx]

; 127  :     }
; 128  : 
; 129  :     return 0;

  00031	33 d2		 xor	 edx, edx

; 130  : }

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
$LN2@ReadValueA:

; 119  : 
; 120  :         case EVENT_FIELD_TYPE_int64:
; 121  :         case EVENT_FIELD_TYPE_uint64:
; 122  :             return *(uint64 *)memLocation;

  00037	8b 04 11	 mov	 eax, DWORD PTR [ecx+edx]
  0003a	8b 54 11 04	 mov	 edx, DWORD PTR [ecx+edx+4]

; 130  : }

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
$LN1@ReadValueA:

; 123  : 
; 124  :         case EVENT_FIELD_TYPE_IntPtr:
; 125  :         case EVENT_FIELD_TYPE_UIntPtr:
; 126  :             return (uint64)(*(UIntPtr *)memLocation);

  00042	8b 04 11	 mov	 eax, DWORD PTR [ecx+edx]
  00045	99		 cdq

; 130  : }

  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
$LN6@ReadValueA:

; 127  :     }
; 128  : 
; 129  :     return 0;

  0004a	33 c0		 xor	 eax, eax
  0004c	33 d2		 xor	 edx, edx

; 130  : }

  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
  00052	8b ff		 npad	 2
$LN12@ReadValueA:
  00054	00 00 00 00	 DD	 $LN5@ReadValueA
  00058	00 00 00 00	 DD	 $LN5@ReadValueA
  0005c	00 00 00 00	 DD	 $LN4@ReadValueA
  00060	00 00 00 00	 DD	 $LN4@ReadValueA
  00064	00 00 00 00	 DD	 $LN3@ReadValueA
  00068	00 00 00 00	 DD	 $LN3@ReadValueA
  0006c	00 00 00 00	 DD	 $LN2@ReadValueA
  00070	00 00 00 00	 DD	 $LN2@ReadValueA
  00074	00 00 00 00	 DD	 $LN1@ReadValueA
  00078	00 00 00 00	 DD	 $LN1@ReadValueA
?ReadValueAs@@YI_KPAXHH@Z ENDP				; ReadValueAs
_TEXT	ENDS
PUBLIC	?GetFieldValue@@YI_KPAUuintPtr@@H@Z		; GetFieldValue
; Function compile flags: /Ogtp
;	COMDAT ?GetFieldValue@@YI_KPAUuintPtr@@H@Z
_TEXT	SEGMENT
?GetFieldValue@@YI_KPAUuintPtr@@H@Z PROC		; GetFieldValue, COMDAT
; _EntryHandle$ = ecx
; _fieldIndex$ = edx

; 133  : {

  00000	56		 push	 esi

; 134  :     PMEMORY_HEADER entry = HANDLE_TO_HEADER(EntryHandle);
; 135  :     PEVENT_DESCRIPTOR typeEntry = HANDLE_TO_TYPE(entry->Type);

  00001	8b 71 10	 mov	 esi, DWORD PTR [ecx+16]
  00004	83 c6 18	 add	 esi, 24			; 00000018H
  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx

; 136  :     PEVENT_FIELD_DESCRIPTOR field = GetDescriptorField(typeEntry, fieldIndex);

  0000a	8b 16		 mov	 edx, DWORD PTR [esi]
  0000c	8b f2		 mov	 esi, edx
  0000e	33 c0		 xor	 eax, eax
  00010	85 f6		 test	 esi, esi
  00012	74 09		 je	 SHORT $LN7@GetFieldVa
$LL9@GetFieldVa:
  00014	8b 36		 mov	 esi, DWORD PTR [esi]
  00016	83 c0 01	 add	 eax, 1
  00019	85 f6		 test	 esi, esi
  0001b	75 f7		 jne	 SHORT $LL9@GetFieldVa
$LN7@GetFieldVa:
  0001d	2b c7		 sub	 eax, edi
  0001f	83 e8 01	 sub	 eax, 1
  00022	85 d2		 test	 edx, edx
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	74 0d		 je	 SHORT $LN1@GetFieldVa
$LL6@GetFieldVa:
  00028	85 c0		 test	 eax, eax
  0002a	7e 0e		 jle	 SHORT $LN4@GetFieldVa
  0002c	8b 12		 mov	 edx, DWORD PTR [edx]
  0002e	83 e8 01	 sub	 eax, 1
  00031	85 d2		 test	 edx, edx
  00033	75 f3		 jne	 SHORT $LL6@GetFieldVa
$LN1@GetFieldVa:

; 143  :     }
; 144  : 
; 145  :     return 0;

  00035	33 c0		 xor	 eax, eax
  00037	33 d2		 xor	 edx, edx

; 146  : }

  00039	c3		 ret	 0

; 136  :     PEVENT_FIELD_DESCRIPTOR field = GetDescriptorField(typeEntry, fieldIndex);

$LN4@GetFieldVa:

; 137  : 
; 138  :     void * base = GetUserRecordStructure(entry);
; 139  : 
; 140  :     if (field != NULL) {

  0003a	85 d2		 test	 edx, edx
  0003c	74 f7		 je	 SHORT $LN1@GetFieldVa

; 141  : 
; 142  :         return ReadValueAs(GetUserRecordStructure(entry), field->Offset, field->Type);

  0003e	f6 41 06 01	 test	 BYTE PTR [ecx+6], 1
  00042	74 18		 je	 SHORT $LN30@GetFieldVa
  00044	66 8b 41 18	 mov	 ax, WORD PTR [ecx+24]
  00048	66 05 07 00	 add	 ax, 7
  0004c	66 03 c0	 add	 ax, ax
  0004f	66 03 c0	 add	 ax, ax
  00052	0f b7 c0	 movzx	 eax, ax
  00055	0f b7 c0	 movzx	 eax, ax
  00058	03 c1		 add	 eax, ecx
  0005a	eb 03		 jmp	 SHORT $LN31@GetFieldVa
$LN30@GetFieldVa:
  0005c	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
$LN31@GetFieldVa:
  0005f	0f b7 4a 06	 movzx	 ecx, WORD PTR [edx+6]
  00063	0f b7 52 04	 movzx	 edx, WORD PTR [edx+4]
  00067	51		 push	 ecx
  00068	8b c8		 mov	 ecx, eax
  0006a	e8 00 00 00 00	 call	 ?ReadValueAs@@YI_KPAXHH@Z ; ReadValueAs

; 146  : }

  0006f	c3		 ret	 0
?GetFieldValue@@YI_KPAUuintPtr@@H@Z ENDP		; GetFieldValue
_TEXT	ENDS
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_02HAOIJKIC@?$CFc?$AA@			; `string'
PUBLIC	?WriteSymbolicValue@@YIHPADHPAU_ENUM_DESCRIPTOR@@_K@Z ; WriteSymbolicValue
EXTRN	?GetExtendedString@@YIPADPAUuintPtr@@H@Z:PROC	; GetExtendedString
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02HAOIJKIC@?$CFc?$AA@
CONST	SEGMENT
??_C@_02HAOIJKIC@?$CFc?$AA@ DB '%c', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?WriteSymbolicValue@@YIHPADHPAU_ENUM_DESCRIPTOR@@_K@Z
_TEXT	SEGMENT
_flags$ = -16						; size = 8
_retValue$ = -8						; size = 4
_bufferSize$ = -4					; size = 4
_enumDescriptor$ = 8					; size = 4
_item$ = 12						; size = 8
_value$ = 12						; size = 8
?WriteSymbolicValue@@YIHPADHPAU_ENUM_DESCRIPTOR@@_K@Z PROC ; WriteSymbolicValue, COMDAT
; _pszOut$ = ecx
; _bufferSize$ = edx

; 155  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	89 55 fc	 mov	 DWORD PTR _bufferSize$[ebp], edx

; 156  :     PEVENT_VALUE_DESCRIPTOR field;
; 157  :     int retValue = 0;
; 158  : 
; 159  :     uint64 flags = value & enumDescriptor->FlagsMask;

  0000b	8b 55 08	 mov	 edx, DWORD PTR _enumDescriptor$[ebp]
  0000e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00011	8b f0		 mov	 esi, eax
  00013	57		 push	 edi
  00014	8b 7d 0c	 mov	 edi, DWORD PTR _value$[ebp]
  00017	23 f7		 and	 esi, edi
  00019	8b d9		 mov	 ebx, ecx
  0001b	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0001e	89 75 f0	 mov	 DWORD PTR _flags$[ebp], esi
  00021	8b f1		 mov	 esi, ecx
  00023	23 75 10	 and	 esi, DWORD PTR _value$[ebp+4]

; 160  :     uint64 item = value & ~enumDescriptor->FlagsMask;

  00026	f7 d1		 not	 ecx
  00028	23 4d 10	 and	 ecx, DWORD PTR _value$[ebp+4]
  0002b	89 75 f4	 mov	 DWORD PTR _flags$[ebp+4], esi

; 161  : 
; 162  :     for (field = enumDescriptor->fieldsLink; field != NULL; field = field->fieldsLink) {

  0002e	8b 32		 mov	 esi, DWORD PTR [edx]
  00030	f7 d0		 not	 eax
  00032	23 c7		 and	 eax, edi
  00034	85 f6		 test	 esi, esi
  00036	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _retValue$[ebp], 0
  0003d	89 45 0c	 mov	 DWORD PTR _item$[ebp], eax
  00040	89 4d 10	 mov	 DWORD PTR _item$[ebp+4], ecx
  00043	74 7d		 je	 SHORT $LN13@WriteSymbo
$LL15@WriteSymbo:

; 163  : 
; 164  :         int ret = 0;
; 165  : 
; 166  :         if ((field->FlagLetter != 0)) {
; 167  : 
; 168  :             //
; 169  :             //  This needs to be elaborated further with using a string for the false case too
; 170  :             //
; 171  : 
; 172  :             char symbol = ((field->Value & flags) == field->Value) ? field->FlagLetter : '.';

  00045	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00048	33 c0		 xor	 eax, eax
  0004a	38 46 04	 cmp	 BYTE PTR [esi+4], al
  0004d	74 38		 je	 SHORT $LN3@WriteSymbo
  0004f	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
  00052	8b c2		 mov	 eax, edx
  00054	23 45 f0	 and	 eax, DWORD PTR _flags$[ebp]
  00057	8b cf		 mov	 ecx, edi
  00059	23 4d f4	 and	 ecx, DWORD PTR _flags$[ebp+4]
  0005c	3b c2		 cmp	 eax, edx
  0005e	75 16		 jne	 SHORT $LN9@WriteSymbo
  00060	3b cf		 cmp	 ecx, edi
  00062	75 12		 jne	 SHORT $LN9@WriteSymbo
  00064	8a 46 04	 mov	 al, BYTE PTR [esi+4]

; 173  : 
; 174  :             ret = snprintf(pszOut, bufferSize, "%c", symbol);

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _bufferSize$[ebp]
  0006a	0f be c0	 movsx	 eax, al
  0006d	50		 push	 eax
  0006e	68 00 00 00 00	 push	 OFFSET ??_C@_02HAOIJKIC@?$CFc?$AA@
  00073	51		 push	 ecx
  00074	eb 35		 jmp	 SHORT $LN16@WriteSymbo
$LN9@WriteSymbo:
  00076	8b 4d fc	 mov	 ecx, DWORD PTR _bufferSize$[ebp]
  00079	b0 2e		 mov	 al, 46			; 0000002eH
  0007b	0f be c0	 movsx	 eax, al
  0007e	50		 push	 eax
  0007f	68 00 00 00 00	 push	 OFFSET ??_C@_02HAOIJKIC@?$CFc?$AA@
  00084	51		 push	 ecx
  00085	eb 24		 jmp	 SHORT $LN16@WriteSymbo
$LN3@WriteSymbo:

; 175  : 
; 176  :         } else if (field->Value == item) {

  00087	3b 55 0c	 cmp	 edx, DWORD PTR _item$[ebp]
  0008a	75 28		 jne	 SHORT $LN14@WriteSymbo
  0008c	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0008f	3b 4d 10	 cmp	 ecx, DWORD PTR _item$[ebp+4]
  00092	75 20		 jne	 SHORT $LN14@WriteSymbo

; 177  : 
; 178  :             char * strValue = GetExtendedString((UIntPtr)((PMEMORY_HEADER)field - 1), 1);

  00094	8d 4e e8	 lea	 ecx, DWORD PTR [esi-24]
  00097	ba 01 00 00 00	 mov	 edx, 1
  0009c	e8 00 00 00 00	 call	 ?GetExtendedString@@YIPADPAUuintPtr@@H@Z ; GetExtendedString

; 179  : 
; 180  :             ret = snprintf(pszOut, bufferSize, "%s", strValue);

  000a1	8b 55 fc	 mov	 edx, DWORD PTR _bufferSize$[ebp]
  000a4	50		 push	 eax
  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  000aa	52		 push	 edx
$LN16@WriteSymbo:
  000ab	53		 push	 ebx
  000ac	e8 00 00 00 00	 call	 ?snprintf@@YAHPADHPBDZZ	; snprintf
  000b1	83 c4 10	 add	 esp, 16			; 00000010H
$LN14@WriteSymbo:
  000b4	8b 36		 mov	 esi, DWORD PTR [esi]

; 181  : 
; 182  :         }
; 183  : 
; 184  :         //
; 185  :         //  Advance the output buffer, updating the current number of bytes written
; 186  :         //
; 187  : 
; 188  :         retValue += ret;

  000b6	01 45 f8	 add	 DWORD PTR _retValue$[ebp], eax

; 189  :         pszOut += ret;
; 190  :         bufferSize -= ret;

  000b9	29 45 fc	 sub	 DWORD PTR _bufferSize$[ebp], eax
  000bc	03 d8		 add	 ebx, eax
  000be	85 f6		 test	 esi, esi
  000c0	75 83		 jne	 SHORT $LL15@WriteSymbo
$LN13@WriteSymbo:

; 191  :     }
; 192  : 
; 193  :     return retValue;

  000c2	8b 45 f8	 mov	 eax, DWORD PTR _retValue$[ebp]
  000c5	5f		 pop	 edi
  000c6	5e		 pop	 esi
  000c7	5b		 pop	 ebx

; 194  : 
; 195  : }

  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c2 0c 00	 ret	 12			; 0000000cH
?WriteSymbolicValue@@YIHPADHPAU_ENUM_DESCRIPTOR@@_K@Z ENDP ; WriteSymbolicValue
_TEXT	ENDS
PUBLIC	?GetStringField@@YIPADPAXH@Z			; GetStringField
; Function compile flags: /Ogtp
;	COMDAT ?GetStringField@@YIPADPAXH@Z
_TEXT	SEGMENT
?GetStringField@@YIPADPAXH@Z PROC			; GetStringField, COMDAT
; _context$ = ecx
; _argIdx$ = edx

; 198  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx

; 199  :     PRINT_EVENT_CONTEXT * eventContext = (PRINT_EVENT_CONTEXT*) context;
; 200  : 
; 201  :     argIdx += eventContext->ArgOffset;
; 202  : 
; 203  :     PMEMORY_HEADER entry = HANDLE_TO_HEADER(eventContext->EntryHandle);

  00005	8b 1f		 mov	 ebx, DWORD PTR [edi]

; 204  :     PEVENT_DESCRIPTOR typeEntry = HANDLE_TO_TYPE(entry->Type);

  00007	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  0000a	83 c1 18	 add	 ecx, 24			; 00000018H
  0000d	8b f2		 mov	 esi, edx

; 205  : 
; 206  :     PEVENT_FIELD_DESCRIPTOR field = GetDescriptorField(typeEntry, argIdx);

  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	03 77 04	 add	 esi, DWORD PTR [edi+4]
  00014	8b ca		 mov	 ecx, edx
  00016	33 c0		 xor	 eax, eax
  00018	85 c9		 test	 ecx, ecx
  0001a	74 0d		 je	 SHORT $LN8@GetStringF
  0001c	8d 64 24 00	 npad	 4
$LL10@GetStringF:
  00020	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00022	83 c0 01	 add	 eax, 1
  00025	85 c9		 test	 ecx, ecx
  00027	75 f7		 jne	 SHORT $LL10@GetStringF
$LN8@GetStringF:
  00029	2b c6		 sub	 eax, esi
  0002b	8b ca		 mov	 ecx, edx
  0002d	83 e8 01	 sub	 eax, 1
  00030	85 c9		 test	 ecx, ecx
  00032	74 0d		 je	 SHORT $LN5@GetStringF
$LL7@GetStringF:
  00034	85 c0		 test	 eax, eax
  00036	7e 09		 jle	 SHORT $LN5@GetStringF
  00038	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003a	83 e8 01	 sub	 eax, 1
  0003d	85 c9		 test	 ecx, ecx
  0003f	75 f3		 jne	 SHORT $LL7@GetStringF
$LN5@GetStringF:

; 207  : 
; 208  :     if (field->Type & (Class_Microsoft_Singularity_Eventing_DataType___string |
; 209  :                        Class_Microsoft_Singularity_Eventing_DataType___szChar)) {

  00041	66 f7 41 06 00
	60		 test	 WORD PTR [ecx+6], 24576	; 00006000H
  00047	74 20		 je	 SHORT $LN1@GetStringF

; 210  : 
; 211  :         int extendedIndex = (int)GetFieldValue(eventContext->EntryHandle, argIdx);

  00049	8b d6		 mov	 edx, esi
  0004b	8b cb		 mov	 ecx, ebx
  0004d	e8 00 00 00 00	 call	 ?GetFieldValue@@YI_KPAUuintPtr@@H@Z ; GetFieldValue

; 212  : 
; 213  :         if (extendedIndex > 0) {

  00052	85 c0		 test	 eax, eax
  00054	7e 13		 jle	 SHORT $LN1@GetStringF

; 214  : 
; 215  :             char * str = GetExtendedString(eventContext->EntryHandle, extendedIndex);

  00056	8b d0		 mov	 edx, eax
  00058	8b cb		 mov	 ecx, ebx
  0005a	e8 00 00 00 00	 call	 ?GetExtendedString@@YIPADPAUuintPtr@@H@Z ; GetExtendedString

; 216  : 
; 217  :             //
; 218  :             //  From this point all formating is relative to this string
; 219  :             //
; 220  : 
; 221  :             eventContext->ArgOffset = argIdx + 1;

  0005f	83 c6 01	 add	 esi, 1
  00062	89 77 04	 mov	 DWORD PTR [edi+4], esi
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx

; 228  : }

  00068	c3		 ret	 0
$LN1@GetStringF:
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi

; 222  : 
; 223  :             return str;
; 224  :         }
; 225  :     }
; 226  : 
; 227  :     return NULL;

  0006b	33 c0		 xor	 eax, eax
  0006d	5b		 pop	 ebx

; 228  : }

  0006e	c3		 ret	 0
?GetStringField@@YIPADPAXH@Z ENDP			; GetStringField
_TEXT	ENDS
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_02NJNOFBBI@?$CFx?$AA@			; `string'
PUBLIC	??_C@_03IKNKGJIB@?$CF0x?$AA@			; `string'
PUBLIC	??_C@_0BH@PLMLNIMH@?$CIinvalid?5string?5index?$CJ?$AA@ ; `string'
PUBLIC	??_C@_09GPGAJHPD@?$CIunknown?$CJ?$AA@		; `string'
PUBLIC	??_C@_0BE@DNJEKBOI@?$CIunsupported?5field?$CJ?$AA@ ; `string'
PUBLIC	?PrintEventField@@YIHPAXPADHHHDH@Z		; PrintEventField
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
; File c:\users\cc\source\repos\singularity-os\base\kernel\native\eventing.h
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02NJNOFBBI@?$CFx?$AA@
CONST	SEGMENT
??_C@_02NJNOFBBI@?$CFx?$AA@ DB '%x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03IKNKGJIB@?$CF0x?$AA@
CONST	SEGMENT
??_C@_03IKNKGJIB@?$CF0x?$AA@ DB '%0x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PLMLNIMH@?$CIinvalid?5string?5index?$CJ?$AA@
CONST	SEGMENT
??_C@_0BH@PLMLNIMH@?$CIinvalid?5string?5index?$CJ?$AA@ DB '(invalid strin'
	DB	'g index)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09GPGAJHPD@?$CIunknown?$CJ?$AA@
CONST	SEGMENT
??_C@_09GPGAJHPD@?$CIunknown?$CJ?$AA@ DB '(unknown)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DNJEKBOI@?$CIunsupported?5field?$CJ?$AA@
CONST	SEGMENT
??_C@_0BE@DNJEKBOI@?$CIunsupported?5field?$CJ?$AA@ DB '(unsupported field'
	DB	')', 00H					; `string'
; Function compile flags: /Ogtp
; File c:\users\cc\source\repos\singularity-os\base\kernel\native\eventingkernel.cpp
CONST	ENDS
;	COMDAT ?PrintEventField@@YIHPAXPADHHHDH@Z
_TEXT	SEGMENT
_bufferSize$ = 8					; size = 4
_aln$ = 12						; size = 4
_wid$ = 16						; size = 4
tv445 = 20						; size = 4
_fmt$ = 20						; size = 1
_argIdx$ = 24						; size = 4
?PrintEventField@@YIHPAXPADHHHDH@Z PROC			; PrintEventField, COMDAT
; _context$ = ecx
; _pszOut$ = edx

; 231  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 232  :     PRINT_EVENT_CONTEXT * eventContext = (PRINT_EVENT_CONTEXT*) context;
; 233  :     argIdx += eventContext->ArgOffset;
; 234  : 
; 235  :     PMEMORY_HEADER entry = HANDLE_TO_HEADER(eventContext->EntryHandle);

  00006	8b 39		 mov	 edi, DWORD PTR [ecx]

; 236  :     PEVENT_DESCRIPTOR typeEntry = HANDLE_TO_TYPE(entry->Type);

  00008	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0000b	83 c0 18	 add	 eax, 24			; 00000018H

; 237  : 
; 238  :     PEVENT_FIELD_DESCRIPTOR field = GetDescriptorField(typeEntry, argIdx);

  0000e	8b 00		 mov	 eax, DWORD PTR [eax]
  00010	8b da		 mov	 ebx, edx
  00012	8b 55 18	 mov	 edx, DWORD PTR _argIdx$[ebp]
  00015	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00018	8b f0		 mov	 esi, eax
  0001a	33 c9		 xor	 ecx, ecx
  0001c	85 f6		 test	 esi, esi
  0001e	74 09		 je	 SHORT $LN23@PrintEvent
$LL25@PrintEvent:
  00020	8b 36		 mov	 esi, DWORD PTR [esi]
  00022	83 c1 01	 add	 ecx, 1
  00025	85 f6		 test	 esi, esi
  00027	75 f7		 jne	 SHORT $LL25@PrintEvent
$LN23@PrintEvent:
  00029	2b ca		 sub	 ecx, edx
  0002b	83 e9 01	 sub	 ecx, 1
  0002e	85 c0		 test	 eax, eax
  00030	74 18		 je	 SHORT $LN49@PrintEvent
$LL22@PrintEvent:
  00032	85 c9		 test	 ecx, ecx
  00034	7e 10		 jle	 SHORT $LN20@PrintEvent
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	83 e9 01	 sub	 ecx, 1
  0003b	85 c0		 test	 eax, eax
  0003d	75 f3		 jne	 SHORT $LL22@PrintEvent
  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx

; 329  : }

  00042	5d		 pop	 ebp
  00043	c2 14 00	 ret	 20			; 00000014H

; 237  : 
; 238  :     PEVENT_FIELD_DESCRIPTOR field = GetDescriptorField(typeEntry, argIdx);

$LN20@PrintEvent:

; 239  : 
; 240  :     if (field == NULL) return 0;

  00046	85 c0		 test	 eax, eax
  00048	75 09		 jne	 SHORT $LN17@PrintEvent
$LN49@PrintEvent:
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	33 c0		 xor	 eax, eax
  0004e	5b		 pop	 ebx

; 329  : }

  0004f	5d		 pop	 ebp
  00050	c2 14 00	 ret	 20			; 00000014H
$LN17@PrintEvent:

; 241  : 
; 242  :     int retValue = 0;
; 243  :     char * str = NULL;
; 244  : 
; 245  :     if (field->Type == GENERIC_TYPE_SIGNATURE) {

  00053	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  00057	33 f6		 xor	 esi, esi
  00059	66 83 f9 01	 cmp	 cx, 1
  0005d	0f 85 9f 00 00
	00		 jne	 $LN16@PrintEvent

; 246  : 
; 247  :         //
; 248  :         //  This might be a nested structure or an enum. The process of retrieving the
; 249  :         //  actual value becomes a bit more complicated. The existing entry will be placed
; 250  :         //  at a known offset in the parent structure, but we cannot interpret the value unless
; 251  :         //  we find out the descriptor for this field.
; 252  :         //
; 253  : 
; 254  :         if (((PMEMORY_HEADER)field - 1)->Flags == RECORD_EVENT_GENERIC_FIELD) {

  00063	66 81 78 ee 00
	90		 cmp	 WORD PTR [eax-18], 36864 ; 00009000H
  00069	75 7c		 jne	 SHORT $LN15@PrintEvent

; 255  : 
; 256  :             //
; 257  :             //  After validating the descriptor version agains the nested type, we can safely
; 258  :             //  cast to a generic field
; 259  :             //
; 260  : 
; 261  :             PEVENT_GENERIC_TYPE_DESCRIPTOR genericType = (PEVENT_GENERIC_TYPE_DESCRIPTOR)field;
; 262  :             UIntPtr typeHandle = genericType->GenericTypeHandle;

  0006b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]

; 263  :             PEVENT_DESCRIPTOR descriptor = (PEVENT_DESCRIPTOR)GetUserRecordStructure(HANDLE_TO_HEADER(typeHandle));

  0006e	f6 41 06 01	 test	 BYTE PTR [ecx+6], 1
  00072	74 18		 je	 SHORT $LN29@PrintEvent
  00074	66 8b 51 18	 mov	 dx, WORD PTR [ecx+24]
  00078	66 83 c2 07	 add	 dx, 7
  0007c	66 03 d2	 add	 dx, dx
  0007f	66 03 d2	 add	 dx, dx
  00082	0f b7 d2	 movzx	 edx, dx
  00085	0f b7 f2	 movzx	 esi, dx
  00088	03 f1		 add	 esi, ecx
  0008a	eb 03		 jmp	 SHORT $LN30@PrintEvent
$LN29@PrintEvent:
  0008c	8d 71 18	 lea	 esi, DWORD PTR [ecx+24]
$LN30@PrintEvent:

; 264  : 
; 265  :             if (((PMEMORY_HEADER)descriptor - 1)->Flags == RECORD_EVENT_ENUM) {

  0008f	66 81 7e ee 00
	a0		 cmp	 WORD PTR [esi-18], 40960 ; 0000a000H
  00095	75 35		 jne	 SHORT $LN14@PrintEvent

; 266  : 
; 267  :                 //
; 268  :                 //  The field is an enum. Handle here the symbolic
; 269  :                 //
; 270  : 
; 271  :                 PENUM_DESCRIPTOR enumDescriptor = (PENUM_DESCRIPTOR)descriptor;
; 272  :                 uint16 valueBasicType = enumDescriptor->Type;
; 273  :                 uint64 value = ReadValueAs(GetUserRecordStructure(entry), field->Offset, valueBasicType);

  00097	0f b7 4e 04	 movzx	 ecx, WORD PTR [esi+4]
  0009b	0f b7 40 04	 movzx	 eax, WORD PTR [eax+4]
  0009f	51		 push	 ecx
  000a0	8b cf		 mov	 ecx, edi
  000a2	89 45 14	 mov	 DWORD PTR tv445[ebp], eax
  000a5	e8 00 00 00 00	 call	 ?GetUserRecordStructure@@YIPAXPAU_MEMORY_HEADER@@@Z ; GetUserRecordStructure
  000aa	8b 4d 14	 mov	 ecx, DWORD PTR tv445[ebp]
  000ad	8b d1		 mov	 edx, ecx
  000af	8b c8		 mov	 ecx, eax
  000b1	e8 00 00 00 00	 call	 ?ReadValueAs@@YI_KPAXHH@Z ; ReadValueAs

; 274  : 
; 275  :                 retValue = WriteSymbolicValue(pszOut, bufferSize, enumDescriptor, value);

  000b6	52		 push	 edx
  000b7	8b 55 08	 mov	 edx, DWORD PTR _bufferSize$[ebp]
  000ba	50		 push	 eax
  000bb	56		 push	 esi
  000bc	8b cb		 mov	 ecx, ebx
  000be	e8 00 00 00 00	 call	 ?WriteSymbolicValue@@YIHPADHPAU_ENUM_DESCRIPTOR@@_K@Z ; WriteSymbolicValue
  000c3	5f		 pop	 edi

; 320  :             }
; 321  :         }
; 322  :         else {
; 323  :             retValue = snprintf(pszOut, bufferSize, "%d", value);

  000c4	8b f0		 mov	 esi, eax
  000c6	5e		 pop	 esi
  000c7	5b		 pop	 ebx

; 329  : }

  000c8	5d		 pop	 ebp
  000c9	c2 14 00	 ret	 20			; 00000014H
$LN14@PrintEvent:

; 276  : 
; 277  :             } else {
; 278  : 
; 279  :                 retValue = snprintf(pszOut, bufferSize, "(unsupported field)");

  000cc	8b 55 08	 mov	 edx, DWORD PTR _bufferSize$[ebp]
  000cf	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@DNJEKBOI@?$CIunsupported?5field?$CJ?$AA@
  000d4	52		 push	 edx
  000d5	53		 push	 ebx
  000d6	e8 00 00 00 00	 call	 ?snprintf@@YAHPADHPBDZZ	; snprintf
  000db	83 c4 0c	 add	 esp, 12			; 0000000cH
  000de	5f		 pop	 edi

; 320  :             }
; 321  :         }
; 322  :         else {
; 323  :             retValue = snprintf(pszOut, bufferSize, "%d", value);

  000df	8b f0		 mov	 esi, eax
  000e1	5e		 pop	 esi
  000e2	5b		 pop	 ebx

; 329  : }

  000e3	5d		 pop	 ebp
  000e4	c2 14 00	 ret	 20			; 00000014H
$LN15@PrintEvent:

; 280  :             }
; 281  : 
; 282  :         } else {
; 283  : 
; 284  :             retValue = snprintf(pszOut, bufferSize, "(unknown)");

  000e7	8b 45 08	 mov	 eax, DWORD PTR _bufferSize$[ebp]
  000ea	68 00 00 00 00	 push	 OFFSET ??_C@_09GPGAJHPD@?$CIunknown?$CJ?$AA@
  000ef	50		 push	 eax
  000f0	53		 push	 ebx
  000f1	e8 00 00 00 00	 call	 ?snprintf@@YAHPADHPBDZZ	; snprintf
  000f6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f9	5f		 pop	 edi

; 320  :             }
; 321  :         }
; 322  :         else {
; 323  :             retValue = snprintf(pszOut, bufferSize, "%d", value);

  000fa	8b f0		 mov	 esi, eax
  000fc	5e		 pop	 esi
  000fd	5b		 pop	 ebx

; 329  : }

  000fe	5d		 pop	 ebp
  000ff	c2 14 00	 ret	 20			; 00000014H
$LN16@PrintEvent:

; 285  :         }
; 286  : 
; 287  :     } else if (field->Type &
; 288  :                     (Class_Microsoft_Singularity_Eventing_DataType___string |
; 289  :                      Class_Microsoft_Singularity_Eventing_DataType___szChar)) {

  00102	f7 c1 00 60 00
	00		 test	 ecx, 24576		; 00006000H

; 290  : 
; 291  :         int extendedIndex = (int)GetFieldValue(eventContext->EntryHandle, argIdx);

  00108	8b cf		 mov	 ecx, edi
  0010a	74 51		 je	 SHORT $LN10@PrintEvent
  0010c	e8 00 00 00 00	 call	 ?GetFieldValue@@YI_KPAUuintPtr@@H@Z ; GetFieldValue

; 292  : 
; 293  :         if (extendedIndex > 0) {

  00111	85 c0		 test	 eax, eax
  00113	0f 8e a1 00 00
	00		 jle	 $LN1@PrintEvent

; 294  : 
; 295  :             char * str = GetExtendedString(eventContext->EntryHandle, extendedIndex);

  00119	8b d0		 mov	 edx, eax
  0011b	8b cf		 mov	 ecx, edi
  0011d	e8 00 00 00 00	 call	 ?GetExtendedString@@YIPADPAUuintPtr@@H@Z ; GetExtendedString

; 296  : 
; 297  :             if (str != NULL) {

  00122	85 c0		 test	 eax, eax
  00124	74 1c		 je	 SHORT $LN8@PrintEvent

; 298  : 
; 299  :                 retValue = snprintf(pszOut, bufferSize, "%s", str);

  00126	8b 4d 08	 mov	 ecx, DWORD PTR _bufferSize$[ebp]
  00129	50		 push	 eax
  0012a	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  0012f	51		 push	 ecx
  00130	53		 push	 ebx
  00131	e8 00 00 00 00	 call	 ?snprintf@@YAHPADHPBDZZ	; snprintf
  00136	83 c4 10	 add	 esp, 16			; 00000010H
  00139	5f		 pop	 edi

; 320  :             }
; 321  :         }
; 322  :         else {
; 323  :             retValue = snprintf(pszOut, bufferSize, "%d", value);

  0013a	8b f0		 mov	 esi, eax
  0013c	5e		 pop	 esi
  0013d	5b		 pop	 ebx

; 329  : }

  0013e	5d		 pop	 ebp
  0013f	c2 14 00	 ret	 20			; 00000014H
$LN8@PrintEvent:

; 300  :             } else {
; 301  : 
; 302  :                 retValue = snprintf(pszOut, bufferSize, "(invalid string index)");

  00142	8b 55 08	 mov	 edx, DWORD PTR _bufferSize$[ebp]
  00145	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@PLMLNIMH@?$CIinvalid?5string?5index?$CJ?$AA@
  0014a	52		 push	 edx
  0014b	53		 push	 ebx
  0014c	e8 00 00 00 00	 call	 ?snprintf@@YAHPADHPBDZZ	; snprintf
  00151	83 c4 0c	 add	 esp, 12			; 0000000cH
  00154	5f		 pop	 edi

; 320  :             }
; 321  :         }
; 322  :         else {
; 323  :             retValue = snprintf(pszOut, bufferSize, "%d", value);

  00155	8b f0		 mov	 esi, eax
  00157	5e		 pop	 esi
  00158	5b		 pop	 ebx

; 329  : }

  00159	5d		 pop	 ebp
  0015a	c2 14 00	 ret	 20			; 00000014H
$LN10@PrintEvent:

; 303  :             }
; 304  :         }
; 305  : 
; 306  :     } else {
; 307  : 
; 308  :         uint64 value = GetFieldValue(eventContext->EntryHandle, argIdx);

  0015d	e8 00 00 00 00	 call	 ?GetFieldValue@@YI_KPAUuintPtr@@H@Z ; GetFieldValue

; 309  : 
; 310  :         if (aln < wid) {
; 311  :             aln = wid;
; 312  :         }
; 313  : 
; 314  :         if (fmt == 'x') {

  00162	80 7d 14 78	 cmp	 BYTE PTR _fmt$[ebp], 120 ; 00000078H

; 316  :                 retValue = snprintf(pszOut, bufferSize, "%0x", value);

  00166	52		 push	 edx
  00167	50		 push	 eax
  00168	75 3c		 jne	 SHORT $LN4@PrintEvent

; 315  :             if (wid > 0) {

  0016a	83 7d 10 00	 cmp	 DWORD PTR _wid$[ebp], 0
  0016e	7e 1b		 jle	 SHORT $LN3@PrintEvent

; 316  :                 retValue = snprintf(pszOut, bufferSize, "%0x", value);

  00170	8b 45 08	 mov	 eax, DWORD PTR _bufferSize$[ebp]
  00173	68 00 00 00 00	 push	 OFFSET ??_C@_03IKNKGJIB@?$CF0x?$AA@
  00178	50		 push	 eax

; 320  :             }
; 321  :         }
; 322  :         else {
; 323  :             retValue = snprintf(pszOut, bufferSize, "%d", value);

  00179	53		 push	 ebx
  0017a	e8 00 00 00 00	 call	 ?snprintf@@YAHPADHPBDZZ	; snprintf
  0017f	83 c4 14	 add	 esp, 20			; 00000014H
  00182	5f		 pop	 edi
  00183	8b f0		 mov	 esi, eax
  00185	5e		 pop	 esi
  00186	5b		 pop	 ebx

; 329  : }

  00187	5d		 pop	 ebp
  00188	c2 14 00	 ret	 20			; 00000014H
$LN3@PrintEvent:

; 317  :             }
; 318  :             else {
; 319  :                 retValue = snprintf(pszOut, bufferSize, "%x", value);

  0018b	8b 4d 08	 mov	 ecx, DWORD PTR _bufferSize$[ebp]
  0018e	68 00 00 00 00	 push	 OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
  00193	51		 push	 ecx

; 320  :             }
; 321  :         }
; 322  :         else {
; 323  :             retValue = snprintf(pszOut, bufferSize, "%d", value);

  00194	53		 push	 ebx
  00195	e8 00 00 00 00	 call	 ?snprintf@@YAHPADHPBDZZ	; snprintf
  0019a	83 c4 14	 add	 esp, 20			; 00000014H
  0019d	5f		 pop	 edi
  0019e	8b f0		 mov	 esi, eax
  001a0	5e		 pop	 esi
  001a1	5b		 pop	 ebx

; 329  : }

  001a2	5d		 pop	 ebp
  001a3	c2 14 00	 ret	 20			; 00000014H
$LN4@PrintEvent:

; 320  :             }
; 321  :         }
; 322  :         else {
; 323  :             retValue = snprintf(pszOut, bufferSize, "%d", value);

  001a6	8b 55 08	 mov	 edx, DWORD PTR _bufferSize$[ebp]
  001a9	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  001ae	52		 push	 edx
  001af	53		 push	 ebx
  001b0	e8 00 00 00 00	 call	 ?snprintf@@YAHPADHPBDZZ	; snprintf
  001b5	83 c4 14	 add	 esp, 20			; 00000014H
  001b8	8b f0		 mov	 esi, eax
$LN1@PrintEvent:
  001ba	5f		 pop	 edi

; 324  :         }
; 325  : 
; 326  :     }
; 327  : 
; 328  :     return retValue;

  001bb	8b c6		 mov	 eax, esi
  001bd	5e		 pop	 esi
  001be	5b		 pop	 ebx

; 329  : }

  001bf	5d		 pop	 ebp
  001c0	c2 14 00	 ret	 20			; 00000014H
?PrintEventField@@YIHPAXPADHHHDH@Z ENDP			; PrintEventField
_TEXT	ENDS
PUBLIC	?DebugPrintEvent@@YIXPAUuintPtr@@@Z		; DebugPrintEvent
EXTRN	?g_Print@Class_Microsoft_Singularity_DebugStub@@SIXPA_WH@Z:PROC ; Class_Microsoft_Singularity_DebugStub::g_Print
; Function compile flags: /Ogtp
;	COMDAT ?DebugPrintEvent@@YIXPAUuintPtr@@@Z
_TEXT	SEGMENT
_wmsg$ = -776						; size = 512
_msg$ = -264						; size = 256
_printContext$ = -8					; size = 8
?DebugPrintEvent@@YIXPAUuintPtr@@@Z PROC		; DebugPrintEvent, COMDAT
; _eventHandle$ = ecx

; 332  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 03 00
	00		 sub	 esp, 776		; 00000308H

; 333  :     char msg[256];
; 334  :     PRINT_EVENT_CONTEXT printContext = {eventHandle, 0};

  00009	89 4d f8	 mov	 DWORD PTR _printContext$[ebp], ecx

; 335  : 
; 336  :     PMEMORY_HEADER entry = HANDLE_TO_HEADER(eventHandle);
; 337  :     char * frmt = GetExtendedString(entry->Type, 2);

  0000c	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0000f	ba 02 00 00 00	 mov	 edx, 2
  00014	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _printContext$[ebp+4], 0
  0001b	e8 00 00 00 00	 call	 ?GetExtendedString@@YIPADPAUuintPtr@@H@Z ; GetExtendedString

; 338  : 
; 339  :     if (frmt != NULL) {

  00020	85 c0		 test	 eax, eax
  00022	74 20		 je	 SHORT $LN5@DebugPrint

; 340  : 
; 341  :         FormatCSOutput(&printContext, frmt, msg, sizeof(msg),PrintEventField, GetStringField);

  00024	68 00 00 00 00	 push	 OFFSET ?GetStringField@@YIPADPAXH@Z ; GetStringField
  00029	68 00 00 00 00	 push	 OFFSET ?PrintEventField@@YIHPAXPADHHHDH@Z ; PrintEventField
  0002e	68 00 01 00 00	 push	 256			; 00000100H
  00033	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _msg$[ebp]
  00039	51		 push	 ecx
  0003a	8b d0		 mov	 edx, eax
  0003c	8d 4d f8	 lea	 ecx, DWORD PTR _printContext$[ebp]
  0003f	e8 00 00 00 00	 call	 ?FormatCSOutput@@YIXPAXPAD1HP6IH01HHHDH@ZP6IPAD0H@Z@Z ; FormatCSOutput
$LN5@DebugPrint:

; 342  :     }
; 343  : 
; 344  :     bartok_char wmsg[256];
; 345  :     int lMsg = strlen(msg);

  00044	33 c0		 xor	 eax, eax
  00046	38 85 f8 fe ff
	ff		 cmp	 BYTE PTR _msg$[ebp], al
  0004c	74 0f		 je	 SHORT $LN14@DebugPrint
  0004e	8b ff		 npad	 2
$LL9@DebugPrint:
  00050	83 c0 01	 add	 eax, 1
  00053	80 bc 05 f8 fe
	ff ff 00	 cmp	 BYTE PTR _msg$[ebp+eax], 0
  0005b	75 f3		 jne	 SHORT $LL9@DebugPrint
$LN14@DebugPrint:

; 346  : 
; 347  :     if (lMsg < (sizeof(msg) - 1)) {

  0005d	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00062	8b d0		 mov	 edx, eax
  00064	73 13		 jae	 SHORT $LN4@DebugPrint

; 348  : 
; 349  :         msg[lMsg] = '\n';
; 350  :         lMsg += 1;

  00066	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00069	c6 84 05 f8 fe
	ff ff 0a	 mov	 BYTE PTR _msg$[ebp+eax], 10 ; 0000000aH

; 351  :         msg[lMsg] = 0;

  00071	c6 84 15 f8 fe
	ff ff 00	 mov	 BYTE PTR _msg$[ebp+edx], 0
$LN4@DebugPrint:

; 352  :     }
; 353  : 
; 354  :     for (int i = 0; i < lMsg; i++) {

  00079	33 c0		 xor	 eax, eax
  0007b	85 d2		 test	 edx, edx
  0007d	7e 19		 jle	 SHORT $LN1@DebugPrint
  0007f	90		 npad	 1
$LL3@DebugPrint:

; 355  : 
; 356  :         wmsg[i] = msg[i];

  00080	66 0f be 8c 05
	f8 fe ff ff	 movsx	 cx, BYTE PTR _msg$[ebp+eax]
  00089	66 89 8c 45 f8
	fc ff ff	 mov	 WORD PTR _wmsg$[ebp+eax*2], cx
  00091	83 c0 01	 add	 eax, 1
  00094	3b c2		 cmp	 eax, edx
  00096	7c e8		 jl	 SHORT $LL3@DebugPrint
$LN1@DebugPrint:

; 357  :     }
; 358  :     Class_Microsoft_Singularity_DebugStub::g_Print(wmsg, lMsg);

  00098	8d 8d f8 fc ff
	ff		 lea	 ecx, DWORD PTR _wmsg$[ebp]
  0009e	e8 00 00 00 00	 call	 ?g_Print@Class_Microsoft_Singularity_DebugStub@@SIXPA_WH@Z ; Class_Microsoft_Singularity_DebugStub::g_Print

; 359  :     //kdprints(msg);
; 360  : }

  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
?DebugPrintEvent@@YIXPAUuintPtr@@@Z ENDP		; DebugPrintEvent
_TEXT	ENDS
PUBLIC	?g_DebugPrintLogEntry@Class_Microsoft_Singularity_Eventing_KernelController@@SI_NPAUuintPtr@@0@Z ; Class_Microsoft_Singularity_Eventing_KernelController::g_DebugPrintLogEntry
; Function compile flags: /Ogtp
;	COMDAT ?g_DebugPrintLogEntry@Class_Microsoft_Singularity_Eventing_KernelController@@SI_NPAUuintPtr@@0@Z
_TEXT	SEGMENT
?g_DebugPrintLogEntry@Class_Microsoft_Singularity_Eventing_KernelController@@SI_NPAUuintPtr@@0@Z PROC ; Class_Microsoft_Singularity_Eventing_KernelController::g_DebugPrintLogEntry, COMDAT
; _controllerHandle$ = ecx
; _entryHandle$ = edx

; 365  : {

  00000	8b ca		 mov	 ecx, edx

; 366  :     //
; 367  :     //  TODO: Handle the paging case with apporpriate access as
; 368  :     //
; 369  : 
; 370  :     DebugPrintEvent(entryHandle);

  00002	e8 00 00 00 00	 call	 ?DebugPrintEvent@@YIXPAUuintPtr@@@Z ; DebugPrintEvent

; 371  :     return true;

  00007	b0 01		 mov	 al, 1

; 372  : }

  00009	c3		 ret	 0
?g_DebugPrintLogEntry@Class_Microsoft_Singularity_Eventing_KernelController@@SI_NPAUuintPtr@@0@Z ENDP ; Class_Microsoft_Singularity_Eventing_KernelController::g_DebugPrintLogEntry
_TEXT	ENDS
PUBLIC	?g_RegisterExternalController@Class_Microsoft_Singularity_Eventing_KernelController@@SI_NPAUuintPtr@@0@Z ; Class_Microsoft_Singularity_Eventing_KernelController::g_RegisterExternalController
EXTRN	?InternalLogFixedRecord@@YIPAU_MEMORY_HEADER@@PAUuintPtr@@I0PAXI@Z:PROC ; InternalLogFixedRecord
EXTRN	?RegisterExternalController@@YIXPAU_EXTERNAL_CONTROLLER_DESCRIPTOR@@@Z:PROC ; RegisterExternalController
; Function compile flags: /Ogtp
;	COMDAT ?g_RegisterExternalController@Class_Microsoft_Singularity_Eventing_KernelController@@SI_NPAUuintPtr@@0@Z
_TEXT	SEGMENT
_source$ = -12						; size = 12
?g_RegisterExternalController@Class_Microsoft_Singularity_Eventing_KernelController@@SI_NPAUuintPtr@@0@Z PROC ; Class_Microsoft_Singularity_Eventing_KernelController::g_RegisterExternalController, COMDAT
; _storageHandle$ = ecx
; _contextHandle$ = edx

; 376  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 377  :     //  The external caller is responsible with the synchronization
; 378  : 
; 379  :     EXTERNAL_CONTROLLER_DESCRIPTOR source = {NULL, storageHandle, contextHandle};

  00006	89 4d f8	 mov	 DWORD PTR _source$[ebp+4], ecx

; 380  : 
; 381  :     if (SourceController.FreeControllerList != NULL) {

  00009	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR ?SourceController@@3U_SOURCE_CONTROLLER@@A+16
  0000f	33 c0		 xor	 eax, eax
  00011	85 c9		 test	 ecx, ecx
  00013	89 45 f4	 mov	 DWORD PTR _source$[ebp], eax
  00016	89 55 fc	 mov	 DWORD PTR _source$[ebp+8], edx
  00019	74 21		 je	 SHORT $LN3@g_Register

; 382  : 
; 383  :         PEXTERNAL_CONTROLLER_DESCRIPTOR controller = SourceController.FreeControllerList;
; 384  :         SourceController.FreeControllerList = controller->Link;

  0001b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001d	89 15 10 00 00
	00		 mov	 DWORD PTR ?SourceController@@3U_SOURCE_CONTROLLER@@A+16, edx

; 385  :         *controller = source;

  00023	89 01		 mov	 DWORD PTR [ecx], eax
  00025	8b 45 f8	 mov	 eax, DWORD PTR _source$[ebp+4]
  00028	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0002b	8b 55 fc	 mov	 edx, DWORD PTR _source$[ebp+8]
  0002e	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 401  :         RegisterExternalController(newSource);

  00031	e8 00 00 00 00	 call	 ?RegisterExternalController@@YIXPAU_EXTERNAL_CONTROLLER_DESCRIPTOR@@@Z ; RegisterExternalController

; 402  :     }
; 403  : 
; 404  :     return true;

  00036	b0 01		 mov	 al, 1

; 405  : }

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
$LN3@g_Register:

; 386  :         RegisterExternalController(controller);
; 387  : 
; 388  :     } else {
; 389  : 
; 390  :         PMEMORY_HEADER Entry = InternalLogFixedRecord( GetLocalRepositoryHandle(),
; 391  :             RECORD_EVENT_CONTROLLER,
; 392  :             0,
; 393  :             &source,
; 394  :             sizeof(source));

  0003c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?SourceController@@3U_SOURCE_CONTROLLER@@A
  00042	6a 0c		 push	 12			; 0000000cH
  00044	8d 45 f4	 lea	 eax, DWORD PTR _source$[ebp]
  00047	50		 push	 eax
  00048	6a 00		 push	 0
  0004a	ba 00 84 00 00	 mov	 edx, 33792		; 00008400H
  0004f	e8 00 00 00 00	 call	 ?InternalLogFixedRecord@@YIPAU_MEMORY_HEADER@@PAUuintPtr@@I0PAXI@Z ; InternalLogFixedRecord

; 395  : 
; 396  :         if (Entry == NULL) {

  00054	85 c0		 test	 eax, eax
  00056	75 06		 jne	 SHORT $LN1@g_Register

; 397  :             return false;

  00058	32 c0		 xor	 al, al

; 405  : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
$LN1@g_Register:

; 398  :         }
; 399  : 
; 400  :         PEXTERNAL_CONTROLLER_DESCRIPTOR newSource = (PEXTERNAL_CONTROLLER_DESCRIPTOR)GetUserRecordStructure(Entry);

  0005e	f6 40 06 01	 test	 BYTE PTR [eax+6], 1
  00062	74 21		 je	 SHORT $LN11@g_Register
  00064	66 8b 48 18	 mov	 cx, WORD PTR [eax+24]
  00068	66 83 c1 07	 add	 cx, 7
  0006c	66 03 c9	 add	 cx, cx
  0006f	66 03 c9	 add	 cx, cx
  00072	0f b7 c9	 movzx	 ecx, cx
  00075	0f b7 c9	 movzx	 ecx, cx
  00078	03 c8		 add	 ecx, eax

; 401  :         RegisterExternalController(newSource);

  0007a	e8 00 00 00 00	 call	 ?RegisterExternalController@@YIXPAU_EXTERNAL_CONTROLLER_DESCRIPTOR@@@Z ; RegisterExternalController

; 402  :     }
; 403  : 
; 404  :     return true;

  0007f	b0 01		 mov	 al, 1

; 405  : }

  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0

; 398  :         }
; 399  : 
; 400  :         PEXTERNAL_CONTROLLER_DESCRIPTOR newSource = (PEXTERNAL_CONTROLLER_DESCRIPTOR)GetUserRecordStructure(Entry);

$LN11@g_Register:
  00085	8d 48 18	 lea	 ecx, DWORD PTR [eax+24]

; 401  :         RegisterExternalController(newSource);

  00088	e8 00 00 00 00	 call	 ?RegisterExternalController@@YIXPAU_EXTERNAL_CONTROLLER_DESCRIPTOR@@@Z ; RegisterExternalController

; 402  :     }
; 403  : 
; 404  :     return true;

  0008d	b0 01		 mov	 al, 1

; 405  : }

  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
?g_RegisterExternalController@Class_Microsoft_Singularity_Eventing_KernelController@@SI_NPAUuintPtr@@0@Z ENDP ; Class_Microsoft_Singularity_Eventing_KernelController::g_RegisterExternalController
_TEXT	ENDS
PUBLIC	?g_UnRegisterExternalController@Class_Microsoft_Singularity_Eventing_KernelController@@SIXPAUuintPtr@@0@Z ; Class_Microsoft_Singularity_Eventing_KernelController::g_UnRegisterExternalController
EXTRN	?UnRegisterExternalController@@YIXPAU_EXTERNAL_CONTROLLER_DESCRIPTOR@@@Z:PROC ; UnRegisterExternalController
; Function compile flags: /Ogtp
;	COMDAT ?g_UnRegisterExternalController@Class_Microsoft_Singularity_Eventing_KernelController@@SIXPAUuintPtr@@0@Z
_TEXT	SEGMENT
?g_UnRegisterExternalController@Class_Microsoft_Singularity_Eventing_KernelController@@SIXPAUuintPtr@@0@Z PROC ; Class_Microsoft_Singularity_Eventing_KernelController::g_UnRegisterExternalController, COMDAT
; _controllerHandle$ = ecx
; _contextHandle$ = edx

; 410  :     //  Note the caller of this function needs to assure mutual exclusion
; 411  : 
; 412  :     PEXTERNAL_CONTROLLER_DESCRIPTOR tmpController = SourceController.ExternalControllers;
; 413  : 
; 414  :     for (tmpController = SourceController.ExternalControllers;

  00000	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?SourceController@@3U_SOURCE_CONTROLLER@@A+12

; 415  :          tmpController != NULL;
; 416  :          tmpController = tmpController->Link) {

  00005	85 c0		 test	 eax, eax
  00007	74 17		 je	 SHORT $LN2@g_UnRegist
  00009	8d a4 24 00 00
	00 00		 npad	 7
$LL4@g_UnRegist:

; 417  : 
; 418  :         if ((tmpController->ContextHandle == contextHandle) &&
; 419  :             (tmpController->ControllerHandle == controllerHandle)){

  00010	39 50 08	 cmp	 DWORD PTR [eax+8], edx
  00013	75 05		 jne	 SHORT $LN3@g_UnRegist
  00015	39 48 04	 cmp	 DWORD PTR [eax+4], ecx
  00018	74 07		 je	 SHORT $LN8@g_UnRegist
$LN3@g_UnRegist:

; 415  :          tmpController != NULL;
; 416  :          tmpController = tmpController->Link) {

  0001a	8b 00		 mov	 eax, DWORD PTR [eax]
  0001c	85 c0		 test	 eax, eax
  0001e	75 f0		 jne	 SHORT $LL4@g_UnRegist
$LN2@g_UnRegist:

; 422  : 
; 423  :             return;
; 424  :         }
; 425  :     }
; 426  : }

  00020	c3		 ret	 0
$LN8@g_UnRegist:

; 420  : 
; 421  :             UnRegisterExternalController(tmpController);

  00021	8b c8		 mov	 ecx, eax
  00023	e9 00 00 00 00	 jmp	 ?UnRegisterExternalController@@YIXPAU_EXTERNAL_CONTROLLER_DESCRIPTOR@@@Z ; UnRegisterExternalController
?g_UnRegisterExternalController@Class_Microsoft_Singularity_Eventing_KernelController@@SIXPAUuintPtr@@0@Z ENDP ; Class_Microsoft_Singularity_Eventing_KernelController::g_UnRegisterExternalController
_TEXT	ENDS
END
