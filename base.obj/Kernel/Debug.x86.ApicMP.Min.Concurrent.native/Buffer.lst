; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	C:\Users\cc\source\repos\Singularity-OS\base\Kernel\Native\Buffer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?g_MoveMemory@Class_System_Buffer@@SIXPAE0H@Z	; Class_System_Buffer::g_MoveMemory
EXTRN	?g_CopyPages@Class_System_Buffer@@SIXPAE0H@Z:PROC ; Class_System_Buffer::g_CopyPages
; Function compile flags: /Ogtp
; File c:\users\cc\source\repos\singularity-os\base\kernel\native\buffer.cpp
;	COMDAT ?g_MoveMemory@Class_System_Buffer@@SIXPAE0H@Z
_TEXT	SEGMENT
_size$ = 8						; size = 4
?g_MoveMemory@Class_System_Buffer@@SIXPAE0H@Z PROC	; Class_System_Buffer::g_MoveMemory, COMDAT
; _dmem$ = ecx
; _smem$ = edx

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17   :     if (size % 64 == 0 && size >= 64 && (uintptr)dmem % 64 == 0 && (uintptr)smem % 64 == 0) {

  00003	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  00006	56		 push	 esi
  00007	8b f0		 mov	 esi, eax
  00009	81 e6 3f 00 00
	80		 and	 esi, -2147483585	; 8000003fH
  0000f	79 05		 jns	 SHORT $LN33@g_MoveMemo
  00011	4e		 dec	 esi
  00012	83 ce c0	 or	 esi, -64		; ffffffc0H
  00015	46		 inc	 esi
$LN33@g_MoveMemo:
  00016	75 1a		 jne	 SHORT $LN23@g_MoveMemo
  00018	83 f8 40	 cmp	 eax, 64			; 00000040H
  0001b	7c 15		 jl	 SHORT $LN23@g_MoveMemo
  0001d	f6 c1 3f	 test	 cl, 63			; 0000003fH
  00020	75 10		 jne	 SHORT $LN23@g_MoveMemo
  00022	f6 c2 3f	 test	 dl, 63			; 0000003fH
  00025	75 0b		 jne	 SHORT $LN23@g_MoveMemo

; 18   :         g_CopyPages(dmem, smem, size);

  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?g_CopyPages@Class_System_Buffer@@SIXPAE0H@Z ; Class_System_Buffer::g_CopyPages
  0002d	5e		 pop	 esi

; 122  :         }
; 123  :     }
; 124  : }

  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
$LN23@g_MoveMemo:

; 19   :         return;
; 20   :     }
; 21   : 
; 22   :     if (dmem <= smem) {

  00032	3b ca		 cmp	 ecx, edx
  00034	53		 push	 ebx
  00035	0f 87 8a 00 00
	00		 ja	 $LN22@g_MoveMemo

; 23   :         // make sure the destination is dword aligned
; 24   :         while ((((int)dmem ) & 0x3) != 0 && size >= 3) {

  0003b	f6 c1 03	 test	 cl, 3
  0003e	74 17		 je	 SHORT $LN20@g_MoveMemo
$LL21@g_MoveMemo:
  00040	83 f8 03	 cmp	 eax, 3
  00043	7c 12		 jl	 SHORT $LN20@g_MoveMemo

; 25   :             *dmem++ = *smem++;

  00045	8a 1a		 mov	 bl, BYTE PTR [edx]
  00047	88 19		 mov	 BYTE PTR [ecx], bl
  00049	83 c1 01	 add	 ecx, 1
  0004c	83 c2 01	 add	 edx, 1

; 26   :             size -= 1;

  0004f	83 e8 01	 sub	 eax, 1
  00052	f6 c1 03	 test	 cl, 3
  00055	75 e9		 jne	 SHORT $LL21@g_MoveMemo
$LN20@g_MoveMemo:

; 27   :         }
; 28   : 
; 29   :         // copy 16 bytes at a time
; 30   :         if (size >= 16) {

  00057	83 f8 10	 cmp	 eax, 16			; 00000010H
  0005a	7c 25		 jl	 SHORT $LN16@g_MoveMemo

; 31   :             size -= 16;

  0005c	83 e8 10	 sub	 eax, 16			; 00000010H
  0005f	90		 npad	 1
$LL18@g_MoveMemo:

; 32   :             do {
; 33   :                 ((int *)dmem)[0] = ((int *)smem)[0];

  00060	8b 32		 mov	 esi, DWORD PTR [edx]
  00062	89 31		 mov	 DWORD PTR [ecx], esi

; 34   :                 ((int *)dmem)[1] = ((int *)smem)[1];

  00064	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00067	89 71 04	 mov	 DWORD PTR [ecx+4], esi

; 35   :                 ((int *)dmem)[2] = ((int *)smem)[2];

  0006a	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  0006d	89 71 08	 mov	 DWORD PTR [ecx+8], esi

; 36   :                 ((int *)dmem)[3] = ((int *)smem)[3];

  00070	8b 72 0c	 mov	 esi, DWORD PTR [edx+12]
  00073	89 71 0c	 mov	 DWORD PTR [ecx+12], esi

; 37   :                 dmem += 16;

  00076	83 c1 10	 add	 ecx, 16			; 00000010H

; 38   :                 smem += 16;

  00079	83 c2 10	 add	 edx, 16			; 00000010H

; 39   :             }
; 40   :             while ((size -= 16) >= 0);

  0007c	83 e8 10	 sub	 eax, 16			; 00000010H
  0007f	79 df		 jns	 SHORT $LL18@g_MoveMemo
$LN16@g_MoveMemo:

; 41   :         }
; 42   : 
; 43   :         // still 8 bytes or more left to copy?
; 44   :         if ((size & 8) != 0) {

  00081	a8 08		 test	 al, 8
  00083	74 10		 je	 SHORT $LN15@g_MoveMemo

; 45   :             ((int *)dmem)[0] = ((int *)smem)[0];

  00085	8b 32		 mov	 esi, DWORD PTR [edx]
  00087	89 31		 mov	 DWORD PTR [ecx], esi

; 46   :             ((int *)dmem)[1] = ((int *)smem)[1];

  00089	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0008c	89 71 04	 mov	 DWORD PTR [ecx+4], esi

; 47   :             dmem += 8;

  0008f	83 c1 08	 add	 ecx, 8

; 48   :             smem += 8;

  00092	83 c2 08	 add	 edx, 8
$LN15@g_MoveMemo:

; 49   :         }
; 50   : 
; 51   :         // still 4 bytes or more left to copy?
; 52   :         if ((size & 4) != 0) {

  00095	a8 04		 test	 al, 4
  00097	74 0a		 je	 SHORT $LN14@g_MoveMemo

; 53   :             ((int *)dmem)[0] = ((int *)smem)[0];

  00099	8b 32		 mov	 esi, DWORD PTR [edx]
  0009b	89 31		 mov	 DWORD PTR [ecx], esi

; 54   :             dmem += 4;

  0009d	83 c1 04	 add	 ecx, 4

; 55   :             smem += 4;

  000a0	83 c2 04	 add	 edx, 4
$LN14@g_MoveMemo:

; 56   :         }
; 57   : 
; 58   :         // still 2 bytes or more left to copy?
; 59   :         if ((size & 2) != 0) {

  000a3	a8 02		 test	 al, 2
  000a5	74 0c		 je	 SHORT $LN13@g_MoveMemo

; 60   :             ((short *)dmem)[0] = ((short *)smem)[0];

  000a7	66 8b 32	 mov	 si, WORD PTR [edx]
  000aa	66 89 31	 mov	 WORD PTR [ecx], si

; 61   :             dmem += 2;

  000ad	83 c1 02	 add	 ecx, 2

; 62   :             smem += 2;

  000b0	83 c2 02	 add	 edx, 2
$LN13@g_MoveMemo:

; 63   :         }
; 64   : 
; 65   :         // still 1 byte left to copy?
; 66   :         if ((size & 1) != 0) {

  000b3	a8 01		 test	 al, 1
  000b5	0f 84 94 00 00
	00		 je	 $LN32@g_MoveMemo

; 67   :             dmem[0] = smem[0];

  000bb	8a 02		 mov	 al, BYTE PTR [edx]
  000bd	5b		 pop	 ebx
  000be	88 01		 mov	 BYTE PTR [ecx], al
  000c0	5e		 pop	 esi

; 122  :         }
; 123  :     }
; 124  : }

  000c1	5d		 pop	 ebp
  000c2	c2 04 00	 ret	 4
$LN22@g_MoveMemo:

; 68   :             dmem += 1;
; 69   :             smem += 1;
; 70   :         }
; 71   :     } else {
; 72   :         smem += size;
; 73   :         dmem += size;

  000c5	03 c8		 add	 ecx, eax
  000c7	03 d0		 add	 edx, eax

; 74   : 
; 75   :         // make sure the destination is dword aligned
; 76   :         while ((((int)dmem) & 0x3) != 0 && size >= 3) {

  000c9	f6 c1 03	 test	 cl, 3
  000cc	74 1a		 je	 SHORT $LN9@g_MoveMemo
  000ce	8b ff		 npad	 2
$LL10@g_MoveMemo:
  000d0	83 f8 03	 cmp	 eax, 3
  000d3	7c 13		 jl	 SHORT $LN9@g_MoveMemo

; 77   :             *--dmem = *--smem;

  000d5	8a 5a ff	 mov	 bl, BYTE PTR [edx-1]
  000d8	83 ea 01	 sub	 edx, 1
  000db	83 e9 01	 sub	 ecx, 1

; 78   :             size -= 1;

  000de	83 e8 01	 sub	 eax, 1
  000e1	f6 c1 03	 test	 cl, 3
  000e4	88 19		 mov	 BYTE PTR [ecx], bl
  000e6	75 e8		 jne	 SHORT $LL10@g_MoveMemo
$LN9@g_MoveMemo:

; 79   :         }
; 80   : 
; 81   :         // copy 16 bytes at a time
; 82   :         if (size >= 16) {

  000e8	83 f8 10	 cmp	 eax, 16			; 00000010H
  000eb	7c 24		 jl	 SHORT $LN5@g_MoveMemo

; 83   :             size -= 16;

  000ed	83 e8 10	 sub	 eax, 16			; 00000010H
$LL7@g_MoveMemo:

; 84   :             do {
; 85   :                 dmem -= 16;
; 86   :                 smem -= 16;
; 87   :                 ((int *)dmem)[3] = ((int *)smem)[3];

  000f0	8b 72 fc	 mov	 esi, DWORD PTR [edx-4]
  000f3	83 ea 10	 sub	 edx, 16			; 00000010H
  000f6	83 e9 10	 sub	 ecx, 16			; 00000010H

; 88   :                 ((int *)dmem)[2] = ((int *)smem)[2];
; 89   :                 ((int *)dmem)[1] = ((int *)smem)[1];
; 90   :                 ((int *)dmem)[0] = ((int *)smem)[0];
; 91   :             }
; 92   :             while ((size -= 16) >= 0);

  000f9	83 e8 10	 sub	 eax, 16			; 00000010H
  000fc	89 71 0c	 mov	 DWORD PTR [ecx+12], esi
  000ff	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00102	89 71 08	 mov	 DWORD PTR [ecx+8], esi
  00105	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00108	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  0010b	8b 32		 mov	 esi, DWORD PTR [edx]
  0010d	89 31		 mov	 DWORD PTR [ecx], esi
  0010f	79 df		 jns	 SHORT $LL7@g_MoveMemo
$LN5@g_MoveMemo:

; 93   :         }
; 94   : 
; 95   :         // still 8 bytes or more left to copy?
; 96   :         if ((size & 8) != 0) {

  00111	a8 08		 test	 al, 8
  00113	74 10		 je	 SHORT $LN4@g_MoveMemo

; 97   :             dmem -= 8;
; 98   :             smem -= 8;
; 99   :             ((int *)dmem)[1] = ((int *)smem)[1];

  00115	8b 72 fc	 mov	 esi, DWORD PTR [edx-4]
  00118	83 e9 08	 sub	 ecx, 8
  0011b	83 ea 08	 sub	 edx, 8
  0011e	89 71 04	 mov	 DWORD PTR [ecx+4], esi

; 100  :             ((int *)dmem)[0] = ((int *)smem)[0];

  00121	8b 32		 mov	 esi, DWORD PTR [edx]
  00123	89 31		 mov	 DWORD PTR [ecx], esi
$LN4@g_MoveMemo:

; 101  :         }
; 102  : 
; 103  :         // still 4 bytes or more left to copy?
; 104  :         if ((size & 4) != 0) {

  00125	a8 04		 test	 al, 4
  00127	74 0b		 je	 SHORT $LN3@g_MoveMemo

; 105  :             dmem -= 4;
; 106  :             smem -= 4;
; 107  :             ((int *)dmem)[0] = ((int *)smem)[0];

  00129	8b 72 fc	 mov	 esi, DWORD PTR [edx-4]
  0012c	83 e9 04	 sub	 ecx, 4
  0012f	83 ea 04	 sub	 edx, 4
  00132	89 31		 mov	 DWORD PTR [ecx], esi
$LN3@g_MoveMemo:

; 108  :         }
; 109  : 
; 110  :         // still 2 bytes or more left to copy?
; 111  :         if ((size & 2) != 0) {

  00134	a8 02		 test	 al, 2
  00136	74 0d		 je	 SHORT $LN2@g_MoveMemo

; 112  :             dmem -= 2;
; 113  :             smem -= 2;
; 114  :             ((short *)dmem)[0] = ((short *)smem)[0];

  00138	66 8b 72 fe	 mov	 si, WORD PTR [edx-2]
  0013c	83 e9 02	 sub	 ecx, 2
  0013f	83 ea 02	 sub	 edx, 2
  00142	66 89 31	 mov	 WORD PTR [ecx], si
$LN2@g_MoveMemo:

; 115  :         }
; 116  : 
; 117  :         // still 1 byte left to copy?
; 118  :         if ((size & 1) != 0) {

  00145	a8 01		 test	 al, 1
  00147	74 06		 je	 SHORT $LN32@g_MoveMemo

; 119  :             dmem -= 1;
; 120  :             smem -= 1;
; 121  :             dmem[0] = smem[0];

  00149	8a 52 ff	 mov	 dl, BYTE PTR [edx-1]
  0014c	88 51 ff	 mov	 BYTE PTR [ecx-1], dl
$LN32@g_MoveMemo:
  0014f	5b		 pop	 ebx
  00150	5e		 pop	 esi

; 122  :         }
; 123  :     }
; 124  : }

  00151	5d		 pop	 ebp
  00152	c2 04 00	 ret	 4
?g_MoveMemory@Class_System_Buffer@@SIXPAE0H@Z ENDP	; Class_System_Buffer::g_MoveMemory
_TEXT	ENDS
PUBLIC	?g_ZeroMemory@Class_System_Buffer@@SIXPAEH@Z	; Class_System_Buffer::g_ZeroMemory
EXTRN	?g_ZeroPages@Class_System_Buffer@@SIXPAEH@Z:PROC ; Class_System_Buffer::g_ZeroPages
; Function compile flags: /Ogtp
;	COMDAT ?g_ZeroMemory@Class_System_Buffer@@SIXPAEH@Z
_TEXT	SEGMENT
_size$ = -4						; size = 4
?g_ZeroMemory@Class_System_Buffer@@SIXPAEH@Z PROC	; Class_System_Buffer::g_ZeroMemory, COMDAT
; _dmem$ = ecx
; _size$ = edx

; 127  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b d9		 mov	 ebx, ecx

; 128  :     // Align dmem to 8-bytes for g_ZeroPages
; 129  :     while ((((int)dmem) & 0x7) != 0 && size > 0) {

  00007	f6 c3 07	 test	 bl, 7
  0000a	57		 push	 edi
  0000b	89 55 fc	 mov	 DWORD PTR _size$[ebp], edx
  0000e	0f 84 7f 00 00
	00		 je	 $LN17@g_ZeroMemo
$LL11@g_ZeroMemo:
  00014	33 ff		 xor	 edi, edi
  00016	3b d7		 cmp	 edx, edi
  00018	7e 0e		 jle	 SHORT $LN19@g_ZeroMemo

; 130  :         *dmem++ = 0;

  0001a	c6 03 00	 mov	 BYTE PTR [ebx], 0
  0001d	83 c3 01	 add	 ebx, 1

; 131  :         size   -= 1;

  00020	83 ea 01	 sub	 edx, 1
  00023	f6 c3 07	 test	 bl, 7
  00026	75 ec		 jne	 SHORT $LL11@g_ZeroMemo
$LN19@g_ZeroMemo:
  00028	89 55 fc	 mov	 DWORD PTR _size$[ebp], edx
$LN10@g_ZeroMemo:

; 132  :     }
; 133  : 
; 134  :     if (size >= 64) {

  0002b	83 fa 40	 cmp	 edx, 64			; 00000040H
  0002e	7c 18		 jl	 SHORT $LN9@g_ZeroMemo
  00030	56		 push	 esi

; 135  :         // g_ZeroPages expects 8-byte alignment and a block size of n*64 bytes.
; 136  :         int toZero = size & ~63;

  00031	8b f2		 mov	 esi, edx
  00033	83 e6 c0	 and	 esi, -64		; ffffffc0H

; 137  :         g_ZeroPages(dmem, toZero);

  00036	8b d6		 mov	 edx, esi
  00038	8b cb		 mov	 ecx, ebx
  0003a	e8 00 00 00 00	 call	 ?g_ZeroPages@Class_System_Buffer@@SIXPAEH@Z ; Class_System_Buffer::g_ZeroPages

; 138  :         dmem += toZero;

  0003f	03 de		 add	 ebx, esi

; 139  :         size -= toZero;

  00041	29 75 fc	 sub	 DWORD PTR _size$[ebp], esi
  00044	8b 55 fc	 mov	 edx, DWORD PTR _size$[ebp]
  00047	5e		 pop	 esi
$LN9@g_ZeroMemo:

; 140  :     }
; 141  : 
; 142  :     if (size >= 16) {

  00048	83 fa 10	 cmp	 edx, 16			; 00000010H
  0004b	7c 16		 jl	 SHORT $LN5@g_ZeroMemo

; 143  :         size -= 16;

  0004d	83 ea 10	 sub	 edx, 16			; 00000010H
$LL7@g_ZeroMemo:

; 144  :         do {
; 145  :             ((int*)dmem)[0] = 0;

  00050	89 3b		 mov	 DWORD PTR [ebx], edi

; 146  :             ((int*)dmem)[1] = 0;

  00052	89 7b 04	 mov	 DWORD PTR [ebx+4], edi

; 147  :             ((int*)dmem)[2] = 0;

  00055	89 7b 08	 mov	 DWORD PTR [ebx+8], edi

; 148  :             ((int*)dmem)[3] = 0;

  00058	89 7b 0c	 mov	 DWORD PTR [ebx+12], edi

; 149  :             dmem += 16;

  0005b	83 c3 10	 add	 ebx, 16			; 00000010H

; 150  :         } while ((size -= 16) >= 0);

  0005e	83 ea 10	 sub	 edx, 16			; 00000010H
  00061	79 ed		 jns	 SHORT $LL7@g_ZeroMemo
$LN5@g_ZeroMemo:

; 151  :     }
; 152  :     if ((size & 8) > 0) {

  00063	f6 c2 08	 test	 dl, 8
  00066	7e 08		 jle	 SHORT $LN4@g_ZeroMemo

; 153  :         ((int*)dmem)[0] = 0;

  00068	89 3b		 mov	 DWORD PTR [ebx], edi

; 154  :         ((int*)dmem)[1] = 0;

  0006a	89 7b 04	 mov	 DWORD PTR [ebx+4], edi

; 155  :         dmem += 8;

  0006d	83 c3 08	 add	 ebx, 8
$LN4@g_ZeroMemo:

; 156  :     }
; 157  :     if ((size & 4) > 0) {

  00070	f6 c2 04	 test	 dl, 4
  00073	7e 05		 jle	 SHORT $LN3@g_ZeroMemo

; 158  :         ((int*)dmem)[0] = 0;

  00075	89 3b		 mov	 DWORD PTR [ebx], edi

; 159  :         dmem += 4;

  00077	83 c3 04	 add	 ebx, 4
$LN3@g_ZeroMemo:

; 160  :     }
; 161  :     if ((size & 2) != 0) {

  0007a	f6 c2 02	 test	 dl, 2
  0007d	74 06		 je	 SHORT $LN2@g_ZeroMemo

; 162  :         ((short*)dmem)[0] = 0;

  0007f	66 89 3b	 mov	 WORD PTR [ebx], di

; 163  :         dmem += 2;

  00082	83 c3 02	 add	 ebx, 2
$LN2@g_ZeroMemo:

; 164  :     }
; 165  :     if ((size & 1) != 0) {

  00085	f6 c2 01	 test	 dl, 1
  00088	74 03		 je	 SHORT $LN1@g_ZeroMemo

; 166  :         *dmem++ = 0;

  0008a	c6 03 00	 mov	 BYTE PTR [ebx], 0
$LN1@g_ZeroMemo:
  0008d	5f		 pop	 edi
  0008e	5b		 pop	 ebx

; 167  :     }
; 168  : }

  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
$LN17@g_ZeroMemo:

; 128  :     // Align dmem to 8-bytes for g_ZeroPages
; 129  :     while ((((int)dmem) & 0x7) != 0 && size > 0) {

  00093	33 ff		 xor	 edi, edi
  00095	eb 94		 jmp	 SHORT $LN10@g_ZeroMemo
?g_ZeroMemory@Class_System_Buffer@@SIXPAEH@Z ENDP	; Class_System_Buffer::g_ZeroMemory
_TEXT	ENDS
END
