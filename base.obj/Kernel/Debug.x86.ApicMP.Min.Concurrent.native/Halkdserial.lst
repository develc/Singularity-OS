; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	C:\Users\cc\source\repos\Singularity-OS\base\Kernel\Native\Halkdserial.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
_KdStateChange64Sent DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_KdCompPacketIdExpected DD 080800000H
_KdCompNextPacketIdToSend DD 080800800H
_DATA	ENDS
EXTRN	?KdpSerialGetByte@@YI?AW4KDP_STATUS@@PAEH@Z:PROC ; KdpSerialGetByte
EXTRN	?KdpSpin@@YIXXZ:PROC				; KdpSpin
; Function compile flags: /Ogtp
; File c:\users\cc\source\repos\singularity-os\base\kernel\native\halkdserial.cpp
;	COMDAT ?KdpSerialReceiveString@@YI?AW4KDP_STATUS@@PAEKH@Z
_TEXT	SEGMENT
_Input$ = -1						; size = 1
?KdpSerialReceiveString@@YI?AW4KDP_STATUS@@PAEKH@Z PROC	; KdpSerialReceiveString, COMDAT
; _Destination$ = ecx
; _Length$ = eax
; _WaitForInput$ = ebx

; 54   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f8		 mov	 edi, eax

; 55   :     KDDBG2("KdpSerialReceiveString len %d\n", Length);
; 56   : 
; 57   :     UCHAR Input;
; 58   :     UINT32 ReqLength = Length;
; 59   :     UINT32 ReturnCode;
; 60   : 
; 61   :     //
; 62   :     // Read bytes until either a error is encountered or the entire string
; 63   :     // has been read.
; 64   :     //
; 65   :     while (Length > 0) {

  00008	85 ff		 test	 edi, edi
  0000a	8b f1		 mov	 esi, ecx
  0000c	76 22		 jbe	 SHORT $LN11@KdpSerialR
  0000e	8b ff		 npad	 2
$LL5@KdpSerialR:

; 66   :         KdpSpin();

  00010	e8 00 00 00 00	 call	 ?KdpSpin@@YIXXZ		; KdpSpin

; 67   : 
; 68   :         ReturnCode = KdpSerialGetByte(&Input, WaitForInput);

  00015	8b d3		 mov	 edx, ebx
  00017	8d 4d ff	 lea	 ecx, DWORD PTR _Input$[ebp]
  0001a	e8 00 00 00 00	 call	 ?KdpSerialGetByte@@YI?AW4KDP_STATUS@@PAEH@Z ; KdpSerialGetByte

; 69   :         if (ReturnCode != KDP_PACKET_RECEIVED) {

  0001f	85 c0		 test	 eax, eax
  00021	75 0d		 jne	 SHORT $LN11@KdpSerialR

; 70   :             break;
; 71   :         }
; 72   :         else {
; 73   :             *Destination++ = Input;

  00023	8a 45 ff	 mov	 al, BYTE PTR _Input$[ebp]
  00026	88 06		 mov	 BYTE PTR [esi], al
  00028	83 c6 01	 add	 esi, 1

; 74   :             Length -= 1;

  0002b	83 ef 01	 sub	 edi, 1
  0002e	75 e0		 jne	 SHORT $LL5@KdpSerialR
$LN11@KdpSerialR:

; 75   :         }
; 76   :     }
; 77   : 
; 78   :     KDDBG2("KdpSerialReceiveString left %d\n", Length);
; 79   : 
; 80   :     return (Length == 0) ? KDP_PACKET_RECEIVED : KDP_PACKET_TIMEOUT;

  00030	33 c0		 xor	 eax, eax
  00032	85 ff		 test	 edi, edi
  00034	5f		 pop	 edi
  00035	0f 95 c0	 setne	 al
  00038	5e		 pop	 esi

; 81   : }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?KdpSerialReceiveString@@YI?AW4KDP_STATUS@@PAEKH@Z ENDP	; KdpSerialReceiveString
_TEXT	ENDS
EXTRN	?KdpSerialPutByte@@YIXE@Z:PROC			; KdpSerialPutByte
; Function compile flags: /Ogtp
;	COMDAT ?KdpSerialSendString@@YIXPAEK@Z
_TEXT	SEGMENT
?KdpSerialSendString@@YIXPAEK@Z PROC			; KdpSerialSendString, COMDAT
; _Source$ = ecx
; _Length$ = eax

; 102  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f8		 mov	 edi, eax

; 103  : 
; 104  :     KDDBG2("KdpSerialSendString len %d\n", Length);
; 105  : 
; 106  :     UINT32 ReqLength = (UINT32)Length;
; 107  : 
; 108  :     //
; 109  :     // Write bytes to the kernel debugger port.
; 110  :     //
; 111  : 
; 112  :     UCHAR Output;
; 113  : 
; 114  :     while (Length > 0) {

  00004	85 ff		 test	 edi, edi
  00006	8b f1		 mov	 esi, ecx
  00008	76 15		 jbe	 SHORT $LN2@KdpSerialS
  0000a	8d 9b 00 00 00
	00		 npad	 6
$LL3@KdpSerialS:

; 115  :         Output = *Source++;

  00010	8a 0e		 mov	 cl, BYTE PTR [esi]
  00012	83 c6 01	 add	 esi, 1

; 116  :         KdpSerialPutByte(Output);

  00015	e8 00 00 00 00	 call	 ?KdpSerialPutByte@@YIXE@Z ; KdpSerialPutByte

; 117  :         Length -= 1;

  0001a	83 ef 01	 sub	 edi, 1
  0001d	75 f1		 jne	 SHORT $LL3@KdpSerialS
$LN2@KdpSerialS:
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi

; 118  :     }
; 119  : 
; 120  :     KDDBG2("KdpSerialSendString done\n");
; 121  : }

  00021	c3		 ret	 0
?KdpSerialSendString@@YIXPAEK@Z ENDP			; KdpSerialSendString
_TEXT	ENDS
EXTRN	?KdDebuggerNotPresent@@3HA:DWORD		; KdDebuggerNotPresent
; Function compile flags: /Ogtp
;	COMDAT ?KdCompReceivePacketLeader@@YI?AW4KDP_STATUS@@PAKPAU_KD_CONTEXT@@@Z
_TEXT	SEGMENT
_BreakinDetected$ = -8					; size = 4
_Input$ = -3						; size = 1
_Input$11798 = -2					; size = 1
_PreviousByte$ = -1					; size = 1
_PacketLeader$ = 8					; size = 4
_KdContext$ = 12					; size = 4
?KdCompReceivePacketLeader@@YI?AW4KDP_STATUS@@PAKPAU_KD_CONTEXT@@@Z PROC ; KdCompReceivePacketLeader, COMDAT

; 140  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 141  : 
; 142  :     UCHAR Input;
; 143  :     UCHAR PreviousByte = 0;
; 144  :     UINT32 PacketId = 0;
; 145  :     UINT32 Index;
; 146  :     KDP_STATUS ReturnCode;
; 147  :     BOOLEAN BreakinDetected = false;

  00008	33 db		 xor	 ebx, ebx
  0000a	57		 push	 edi
  0000b	c6 45 ff 00	 mov	 BYTE PTR _PreviousByte$[ebp], 0
  0000f	89 5d f8	 mov	 DWORD PTR _BreakinDetected$[ebp], ebx
$LL22@KdCompRece:

; 148  : 
; 149  :     KDDBG2("KdCompReceivePacketLeader\n");
; 150  :     //
; 151  :     // NOTE - With all the interrupts being off, it is very hard
; 152  :     // to implement the actual timeout code. (Maybe, by reading the CMOS.)
; 153  :     // Here we use a loop count to wait about 3 seconds.  The CpGetByte
; 154  :     // will return with error code = KDP_PACKET_TIMEOUT if it cannot find data
; 155  :     // byte within 1 second. Kernel debugger's timeout period is 5 seconds.
; 156  :     //
; 157  : 
; 158  :     Index = 0;
; 159  :     do {
; 160  :         ReturnCode = KdpSerialReceiveString(&Input, 1);

  00012	bf 01 00 00 00	 mov	 edi, 1
  00017	8d 75 fd	 lea	 esi, DWORD PTR _Input$[ebp]
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL30@KdCompRece:
  00020	e8 00 00 00 00	 call	 ?KdpSpin@@YIXXZ		; KdpSpin
  00025	ba 01 00 00 00	 mov	 edx, 1
  0002a	8d 4d fe	 lea	 ecx, DWORD PTR _Input$11798[ebp]
  0002d	e8 00 00 00 00	 call	 ?KdpSerialGetByte@@YI?AW4KDP_STATUS@@PAEH@Z ; KdpSerialGetByte
  00032	85 c0		 test	 eax, eax
  00034	75 0d		 jne	 SHORT $LN36@KdCompRece
  00036	8a 45 fe	 mov	 al, BYTE PTR _Input$11798[ebp]
  00039	88 06		 mov	 BYTE PTR [esi], al
  0003b	83 c6 01	 add	 esi, 1
  0003e	83 ef 01	 sub	 edi, 1
  00041	75 dd		 jne	 SHORT $LL30@KdCompRece
$LN36@KdCompRece:
  00043	33 c0		 xor	 eax, eax
  00045	85 ff		 test	 edi, edi
  00047	0f 95 c0	 setne	 al

; 161  :         if (ReturnCode == KDP_PACKET_TIMEOUT) {

  0004a	83 f8 01	 cmp	 eax, 1
  0004d	74 77		 je	 SHORT $LN37@KdCompRece

; 169  :             }
; 170  :         }
; 171  :         else if (ReturnCode == KDP_PACKET_RESEND) {

  0004f	83 f8 02	 cmp	 eax, 2
  00052	75 04		 jne	 SHORT $LN14@KdCompRece

; 172  :             Index = 0;

  00054	33 db		 xor	 ebx, ebx

; 173  :             continue;

  00056	eb ba		 jmp	 SHORT $LL22@KdCompRece
$LN14@KdCompRece:

; 174  :         }
; 175  :         else {                    // if (ReturnCode == KDP_PACKET_RECEIVED)
; 176  :             if ( Input == PACKET_LEADER_BYTE ||
; 177  :                  Input == CONTROL_PACKET_LEADER_BYTE ) {

  00058	8a 45 fd	 mov	 al, BYTE PTR _Input$[ebp]
  0005b	3c 30		 cmp	 al, 48			; 00000030H
  0005d	74 12		 je	 SHORT $LN11@KdCompRece
  0005f	3c 69		 cmp	 al, 105			; 00000069H
  00061	74 0e		 je	 SHORT $LN11@KdCompRece

; 184  :                 }
; 185  :                 else {
; 186  :                     PreviousByte = Input;
; 187  :                     Index = 1;
; 188  :                 }
; 189  :             }
; 190  :             else {
; 191  : 
; 192  :                 //
; 193  :                 // If we detect breakin character, we need to verify it
; 194  :                 // validity.  (It is possible that we missed a packet leader
; 195  :                 // and the breakin character is simply a data byte in the
; 196  :                 // packet.)
; 197  :                 // Since kernel debugger send out breakin character ONLY
; 198  :                 // when it is waiting for State Change packet.  The breakin
; 199  :                 // character should not be followed by any other character
; 200  :                 // except packet leader byte.
; 201  :                 //
; 202  : 
; 203  :                 if ( Input == BREAKIN_PACKET_BYTE ) {

  00063	33 c9		 xor	 ecx, ecx
  00065	3c 62		 cmp	 al, 98			; 00000062H
  00067	0f 94 c1	 sete	 cl

; 204  :                     BreakinDetected = true;
; 205  :                 }
; 206  :                 else {
; 207  : 
; 208  :                     //
; 209  :                     // The following statement is ABSOLUTELY necessary.
; 210  :                     //
; 211  : 
; 212  :                     BreakinDetected = false;
; 213  :                 }
; 214  :                 Index = 0;

  0006a	33 db		 xor	 ebx, ebx
  0006c	89 4d f8	 mov	 DWORD PTR _BreakinDetected$[ebp], ecx
  0006f	eb a1		 jmp	 SHORT $LL22@KdCompRece
$LN11@KdCompRece:

; 178  :                 if ( Index == 0 ) {

  00071	85 db		 test	 ebx, ebx
  00073	75 0a		 jne	 SHORT $LN10@KdCompRece
$LN8@KdCompRece:

; 179  :                     PreviousByte = Input;

  00075	88 45 ff	 mov	 BYTE PTR _PreviousByte$[ebp], al

; 180  :                     Index++;

  00078	bb 01 00 00 00	 mov	 ebx, 1
  0007d	eb 93		 jmp	 SHORT $LL22@KdCompRece
$LN10@KdCompRece:

; 181  :                 }
; 182  :                 else if (Input == PreviousByte) {

  0007f	3a 45 ff	 cmp	 al, BYTE PTR _PreviousByte$[ebp]
  00082	75 f1		 jne	 SHORT $LN8@KdCompRece

; 183  :                     Index++;

  00084	83 c3 01	 add	 ebx, 1

; 215  :             }
; 216  :         }
; 217  :     } while ( Index < 4 );

  00087	83 fb 04	 cmp	 ebx, 4
  0008a	72 86		 jb	 SHORT $LL22@KdCompRece

; 218  : 
; 219  :     if (BreakinDetected) {

  0008c	83 7d f8 00	 cmp	 DWORD PTR _BreakinDetected$[ebp], 0
  00090	74 0a		 je	 SHORT $LN3@KdCompRece

; 220  :         KdContext->KdpControlCPending = true;

  00092	8b 4d 0c	 mov	 ecx, DWORD PTR _KdContext$[ebp]
  00095	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [ecx+4], 1
$LN3@KdCompRece:

; 221  :     }
; 222  : 
; 223  :     //
; 224  :     // return the packet leader and false to indicate no resend is needed.
; 225  :     //
; 226  : 
; 227  :     if ( Input == PACKET_LEADER_BYTE ) {

  0009c	8b 55 08	 mov	 edx, DWORD PTR _PacketLeader$[ebp]
  0009f	2c 30		 sub	 al, 48			; 00000030H
  000a1	f6 d8		 neg	 al
  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
  000a5	5b		 pop	 ebx
  000a6	1b c0		 sbb	 eax, eax
  000a8	25 39 39 39 39	 and	 eax, 960051513		; 39393939H
  000ad	05 30 30 30 30	 add	 eax, 808464432		; 30303030H
  000b2	89 02		 mov	 DWORD PTR [edx], eax

; 228  :         *PacketLeader = PACKET_LEADER;
; 229  :     }
; 230  :     else {
; 231  :         *PacketLeader = CONTROL_PACKET_LEADER;
; 232  :     }
; 233  :     KdDebuggerNotPresent = false;

  000b4	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?KdDebuggerNotPresent@@3HA, 0 ; KdDebuggerNotPresent

; 234  : #if 0
; 235  :     SharedUserData->KdDebuggerEnabled |= 0x00000002;
; 236  : #endif
; 237  : 
; 238  :     return KDP_PACKET_RECEIVED;

  000be	33 c0		 xor	 eax, eax

; 239  : }

  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c2 08 00	 ret	 8
$LN37@KdCompRece:

; 162  :             if (BreakinDetected) {

  000c6	83 7d f8 00	 cmp	 DWORD PTR _BreakinDetected$[ebp], 0
  000ca	74 18		 je	 SHORT $LN18@KdCompRece

; 163  :                 KdContext->KdpControlCPending = true;

  000cc	8b 55 0c	 mov	 edx, DWORD PTR _KdContext$[ebp]
  000cf	5f		 pop	 edi
  000d0	5e		 pop	 esi
  000d1	c7 42 04 01 00
	00 00		 mov	 DWORD PTR [edx+4], 1

; 164  :                 return KDP_PACKET_RESEND;

  000d8	b8 02 00 00 00	 mov	 eax, 2
  000dd	5b		 pop	 ebx

; 239  : }

  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c2 08 00	 ret	 8
$LN18@KdCompRece:
  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi

; 165  :             }
; 166  :             else {
; 167  :                 KDDBG2("KdCompReceivePackerLeader returning KDP_PACKET_TIMEOUT\n");
; 168  :                 return KDP_PACKET_TIMEOUT;

  000e6	b8 01 00 00 00	 mov	 eax, 1
  000eb	5b		 pop	 ebx

; 239  : }

  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c2 08 00	 ret	 8
?KdCompReceivePacketLeader@@YI?AW4KDP_STATUS@@PAKPAU_KD_CONTEXT@@@Z ENDP ; KdCompReceivePacketLeader
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?KdpSendControlPacket@@YIXGK@Z
_TEXT	SEGMENT
_PacketHeader$ = -16					; size = 16
_PacketType$ = 8					; size = 2
?KdpSendControlPacket@@YIXGK@Z PROC			; KdpSendControlPacket, COMDAT
; _PacketId$ = eax

; 258  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 259  : 
; 260  :     KD_PACKET PacketHeader;
; 261  : 
; 262  :     //
; 263  :     // Initialize and send the packet header.
; 264  :     //
; 265  : 
; 266  :     PacketHeader.PacketLeader = CONTROL_PACKET_LEADER;
; 267  :     if (PacketId != 0) {

  00006	33 c9		 xor	 ecx, ecx
  00008	3b c1		 cmp	 eax, ecx
  0000a	c7 45 f0 69 69
	69 69		 mov	 DWORD PTR _PacketHeader$[ebp], 1768515945 ; 69696969H
  00011	74 03		 je	 SHORT $LN1@KdpSendCon

; 268  :         PacketHeader.PacketId = PacketId;

  00013	89 45 f8	 mov	 DWORD PTR _PacketHeader$[ebp+8], eax
$LN1@KdpSendCon:

; 269  :     }
; 270  :     PacketHeader.ByteCount = 0;
; 271  :     PacketHeader.Checksum = 0;
; 272  :     PacketHeader.PacketType = PacketType;

  00016	66 8b 45 08	 mov	 ax, WORD PTR _PacketType$[ebp]
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	66 89 4d f6	 mov	 WORD PTR _PacketHeader$[ebp+6], cx
  00020	89 4d fc	 mov	 DWORD PTR _PacketHeader$[ebp+12], ecx
  00023	66 89 45 f4	 mov	 WORD PTR _PacketHeader$[ebp+4], ax

; 273  :     KdpSerialSendString((PUCHAR)&PacketHeader, sizeof(KD_PACKET));

  00027	bf 10 00 00 00	 mov	 edi, 16			; 00000010H
  0002c	8d 75 f0	 lea	 esi, DWORD PTR _PacketHeader$[ebp]
  0002f	90		 npad	 1
$LL6@KdpSendCon:
  00030	8a 0e		 mov	 cl, BYTE PTR [esi]
  00032	83 c6 01	 add	 esi, 1
  00035	e8 00 00 00 00	 call	 ?KdpSerialPutByte@@YIXE@Z ; KdpSerialPutByte
  0003a	83 ef 01	 sub	 edi, 1
  0003d	75 f1		 jne	 SHORT $LL6@KdpSendCon
  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi

; 274  : 
; 275  :     return;
; 276  : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?KdpSendControlPacket@@YIXGK@Z ENDP			; KdpSendControlPacket
_TEXT	ENDS
PUBLIC	?KdpSerialReceivePacket@@YI?AW4KDP_STATUS@@KPAU_STRING@@0PAKPAU_KD_CONTEXT@@@Z ; KdpSerialReceivePacket
EXTRN	?KdpComputeChecksum@@YIKPADK@Z:PROC		; KdpComputeChecksum
EXTRN	?KdCompNumberRetries@@3KA:DWORD			; KdCompNumberRetries
EXTRN	?KdCompRetryCount@@3KA:DWORD			; KdCompRetryCount
; Function compile flags: /Ogtp
;	COMDAT ?KdpSerialReceivePacket@@YI?AW4KDP_STATUS@@KPAU_STRING@@0PAKPAU_KD_CONTEXT@@@Z
_TEXT	SEGMENT
_PacketHeader$11915 = -44				; size = 16
_PacketHeader$ = -28					; size = 16
_PacketType$ = -12					; size = 4
_Input$ = -6						; size = 1
_Input$11891 = -5					; size = 1
_Input$11877 = -4					; size = 1
_Input$11863 = -3					; size = 1
_Input$11849 = -2					; size = 1
_Input$11835 = -1					; size = 1
_MessageData$ = 8					; size = 4
_DataLength$ = 12					; size = 4
_KdContext$ = 16					; size = 4
?KdpSerialReceivePacket@@YI?AW4KDP_STATUS@@KPAU_STRING@@0PAKPAU_KD_CONTEXT@@@Z PROC ; KdpSerialReceivePacket, COMDAT
; _PacketType$ = ecx
; _MessageHeader$ = edx

; 488  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b fa		 mov	 edi, edx
  0000b	89 4d f4	 mov	 DWORD PTR _PacketType$[ebp], ecx
  0000e	8b ff		 npad	 2
$WaitForPacketLeader$11665:

; 489  : 
; 490  :     UCHAR Input;
; 491  :     UINT32 MessageLength;
; 492  :     KD_PACKET PacketHeader;
; 493  :     KDP_STATUS ReturnCode;
; 494  :     UINT32 Checksum;
; 495  : 
; 496  :     KDDBG2("KdpSerialReceivePacket %d\n", PacketType);
; 497  : 
; 498  :   WaitForPacketLeader:
; 499  : 
; 500  :     //
; 501  :     // Read Packet Leader
; 502  :     //
; 503  :     ReturnCode = KdCompReceivePacketLeader(&PacketHeader.PacketLeader, KdContext);

  00010	8b 45 10	 mov	 eax, DWORD PTR _KdContext$[ebp]
  00013	50		 push	 eax
  00014	8d 4d e4	 lea	 ecx, DWORD PTR _PacketHeader$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?KdCompReceivePacketLeader@@YI?AW4KDP_STATUS@@PAKPAU_KD_CONTEXT@@@Z ; KdCompReceivePacketLeader

; 504  :     KDDBG2("KdCompReceivePacketLeader returned %d\n", ReturnCode);
; 505  : 
; 506  :     //
; 507  :     // If we can successfully read packet leader, it has high possibility that
; 508  :     // kernel debugger is alive.  So reset count.
; 509  :     //
; 510  :     if (ReturnCode != KDP_PACKET_TIMEOUT) {

  0001d	83 f8 01	 cmp	 eax, 1
  00020	74 0c		 je	 SHORT $LN61@KdpSerialR@2

; 511  :         KdCompNumberRetries = KdCompRetryCount;

  00022	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?KdCompRetryCount@@3KA ; KdCompRetryCount
  00028	89 15 00 00 00
	00		 mov	 DWORD PTR ?KdCompNumberRetries@@3KA, edx ; KdCompNumberRetries
$LN61@KdpSerialR@2:

; 512  :     }
; 513  :     if (ReturnCode != KDP_PACKET_RECEIVED) {

  0002e	85 c0		 test	 eax, eax
  00030	0f 85 6f 03 00
	00		 jne	 $LN64@KdpSerialR@2

; 514  :         return ReturnCode;
; 515  :     }
; 516  : 
; 517  :     //
; 518  :     // Read packet type.
; 519  :     //
; 520  : 
; 521  :     ReturnCode = KdpSerialReceiveString((PUCHAR)&PacketHeader.PacketType,
; 522  :                                         sizeof(PacketHeader.PacketType));

  00036	8d 58 02	 lea	 ebx, DWORD PTR [eax+2]
  00039	8d 75 e8	 lea	 esi, DWORD PTR _PacketHeader$[ebp+4]
  0003c	8d 64 24 00	 npad	 4
$LL70@KdpSerialR@2:
  00040	e8 00 00 00 00	 call	 ?KdpSpin@@YIXXZ		; KdpSpin
  00045	ba 01 00 00 00	 mov	 edx, 1
  0004a	8d 4d ff	 lea	 ecx, DWORD PTR _Input$11835[ebp]
  0004d	e8 00 00 00 00	 call	 ?KdpSerialGetByte@@YI?AW4KDP_STATUS@@PAEH@Z ; KdpSerialGetByte
  00052	85 c0		 test	 eax, eax
  00054	75 0d		 jne	 SHORT $LN133@KdpSerialR@2
  00056	8a 45 ff	 mov	 al, BYTE PTR _Input$11835[ebp]
  00059	88 06		 mov	 BYTE PTR [esi], al
  0005b	83 c6 01	 add	 esi, 1
  0005e	83 eb 01	 sub	 ebx, 1
  00061	75 dd		 jne	 SHORT $LL70@KdpSerialR@2
$LN133@KdpSerialR@2:
  00063	33 c0		 xor	 eax, eax
  00065	85 db		 test	 ebx, ebx
  00067	0f 95 c0	 setne	 al

; 523  : 
; 524  :     if (ReturnCode == KDP_PACKET_TIMEOUT) {

  0006a	83 f8 01	 cmp	 eax, 1
  0006d	0f 84 d1 02 00
	00		 je	 $LN139@KdpSerialR@2

; 526  :     }
; 527  :     else if (ReturnCode == KDP_PACKET_RESEND) {

  00073	83 f8 02	 cmp	 eax, 2
  00076	75 0e		 jne	 SHORT $LN55@KdpSerialR@2

; 528  :         if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {

  00078	81 7d e4 69 69
	69 69		 cmp	 DWORD PTR _PacketHeader$[ebp], 1768515945 ; 69696969H
  0007f	74 8f		 je	 SHORT $WaitForPacketLeader$11665

; 529  :             //
; 530  :             // If read error and it is for a control packet, simply
; 531  :             // pretend that we have not seen this packet.  Hopefully
; 532  :             // we will receive the packet we desire which automatically acks
; 533  :             // the packet we just sent.
; 534  :             //
; 535  :             goto WaitForPacketLeader;
; 536  :         }
; 537  :         else {
; 538  :             //
; 539  :             // if read error while reading data packet, we have to ask
; 540  :             // kernel debugger to resend us the packet.
; 541  :             //
; 542  :             goto SendResendPacket;

  00081	e9 8e 02 00 00	 jmp	 $SendResendPacket$11676
$LN55@KdpSerialR@2:

; 543  :         }
; 544  :     }
; 545  : 
; 546  :     //
; 547  :     // if the packet we received is a resend request, we return true and
; 548  :     // let caller resend the packet.
; 549  :     //
; 550  :     if ( PacketHeader.PacketLeader == CONTROL_PACKET_LEADER &&
; 551  :          PacketHeader.PacketType == PACKET_TYPE_KD_RESEND ) {

  00086	81 7d e4 69 69
	69 69		 cmp	 DWORD PTR _PacketHeader$[ebp], 1768515945 ; 69696969H
  0008d	75 0b		 jne	 SHORT $LN53@KdpSerialR@2
  0008f	66 83 7d e8 05	 cmp	 WORD PTR _PacketHeader$[ebp+4], 5
  00094	0f 84 d0 02 00
	00		 je	 $LN140@KdpSerialR@2
$LN53@KdpSerialR@2:

; 552  :         return KDP_PACKET_RESEND;
; 553  :     }
; 554  : 
; 555  :     //
; 556  :     // Read data length.
; 557  :     //
; 558  :     ReturnCode = KdpSerialReceiveString((PUCHAR)&PacketHeader.ByteCount,
; 559  :                                         sizeof(PacketHeader.ByteCount));

  0009a	bb 02 00 00 00	 mov	 ebx, 2
  0009f	8d 75 ea	 lea	 esi, DWORD PTR _PacketHeader$[ebp+6]
$LL78@KdpSerialR@2:
  000a2	e8 00 00 00 00	 call	 ?KdpSpin@@YIXXZ		; KdpSpin
  000a7	ba 01 00 00 00	 mov	 edx, 1
  000ac	8d 4d fe	 lea	 ecx, DWORD PTR _Input$11849[ebp]
  000af	e8 00 00 00 00	 call	 ?KdpSerialGetByte@@YI?AW4KDP_STATUS@@PAEH@Z ; KdpSerialGetByte
  000b4	85 c0		 test	 eax, eax
  000b6	75 0d		 jne	 SHORT $LN134@KdpSerialR@2
  000b8	8a 4d fe	 mov	 cl, BYTE PTR _Input$11849[ebp]
  000bb	88 0e		 mov	 BYTE PTR [esi], cl
  000bd	83 c6 01	 add	 esi, 1
  000c0	83 eb 01	 sub	 ebx, 1
  000c3	75 dd		 jne	 SHORT $LL78@KdpSerialR@2
$LN134@KdpSerialR@2:
  000c5	33 c0		 xor	 eax, eax
  000c7	85 db		 test	 ebx, ebx
  000c9	0f 95 c0	 setne	 al

; 560  :     if (ReturnCode == KDP_PACKET_TIMEOUT) {

  000cc	83 f8 01	 cmp	 eax, 1
  000cf	0f 84 6f 02 00
	00		 je	 $LN139@KdpSerialR@2

; 561  :         return KDP_PACKET_TIMEOUT;
; 562  :     }
; 563  :     else if (ReturnCode == KDP_PACKET_RESEND) {

  000d5	83 f8 02	 cmp	 eax, 2
  000d8	75 12		 jne	 SHORT $LN48@KdpSerialR@2

; 564  :         if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {

  000da	81 7d e4 69 69
	69 69		 cmp	 DWORD PTR _PacketHeader$[ebp], 1768515945 ; 69696969H
  000e1	0f 84 29 ff ff
	ff		 je	 $WaitForPacketLeader$11665

; 769  : 
; 770  :   SendResendPacket:

  000e7	e9 28 02 00 00	 jmp	 $SendResendPacket$11676
$LN48@KdpSerialR@2:

; 565  :             goto WaitForPacketLeader;
; 566  :         }
; 567  :         else {
; 568  :             goto SendResendPacket;
; 569  :         }
; 570  :     }
; 571  : 
; 572  :     //
; 573  :     // Read Packet Id.
; 574  :     //
; 575  :     ReturnCode = KdpSerialReceiveString((PUCHAR)&PacketHeader.PacketId,
; 576  :                                         sizeof(PacketHeader.PacketId));

  000ec	bb 04 00 00 00	 mov	 ebx, 4
  000f1	8d 75 ec	 lea	 esi, DWORD PTR _PacketHeader$[ebp+8]
$LL86@KdpSerialR@2:
  000f4	e8 00 00 00 00	 call	 ?KdpSpin@@YIXXZ		; KdpSpin
  000f9	ba 01 00 00 00	 mov	 edx, 1
  000fe	8d 4d fd	 lea	 ecx, DWORD PTR _Input$11863[ebp]
  00101	e8 00 00 00 00	 call	 ?KdpSerialGetByte@@YI?AW4KDP_STATUS@@PAEH@Z ; KdpSerialGetByte
  00106	85 c0		 test	 eax, eax
  00108	75 0d		 jne	 SHORT $LN135@KdpSerialR@2
  0010a	8a 55 fd	 mov	 dl, BYTE PTR _Input$11863[ebp]
  0010d	88 16		 mov	 BYTE PTR [esi], dl
  0010f	83 c6 01	 add	 esi, 1
  00112	83 eb 01	 sub	 ebx, 1
  00115	75 dd		 jne	 SHORT $LL86@KdpSerialR@2
$LN135@KdpSerialR@2:
  00117	33 c0		 xor	 eax, eax
  00119	85 db		 test	 ebx, ebx
  0011b	0f 95 c0	 setne	 al

; 577  : 
; 578  :     if (ReturnCode == KDP_PACKET_TIMEOUT) {

  0011e	83 f8 01	 cmp	 eax, 1
  00121	0f 84 1d 02 00
	00		 je	 $LN139@KdpSerialR@2

; 579  :         return KDP_PACKET_TIMEOUT;
; 580  :     }
; 581  :     else if (ReturnCode == KDP_PACKET_RESEND) {

  00127	83 f8 02	 cmp	 eax, 2
  0012a	75 12		 jne	 SHORT $LN42@KdpSerialR@2

; 582  :         if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {

  0012c	81 7d e4 69 69
	69 69		 cmp	 DWORD PTR _PacketHeader$[ebp], 1768515945 ; 69696969H
  00133	0f 84 d7 fe ff
	ff		 je	 $WaitForPacketLeader$11665

; 769  : 
; 770  :   SendResendPacket:

  00139	e9 d6 01 00 00	 jmp	 $SendResendPacket$11676
$LN42@KdpSerialR@2:

; 583  :             goto WaitForPacketLeader;
; 584  :         }
; 585  :         else {
; 586  :             goto SendResendPacket;
; 587  :         }
; 588  :     }
; 589  : 
; 590  :     //
; 591  :     // Read packet checksum.
; 592  :     //
; 593  :     ReturnCode = KdpSerialReceiveString((PUCHAR)&PacketHeader.Checksum,
; 594  :                                         sizeof(PacketHeader.Checksum));

  0013e	bb 04 00 00 00	 mov	 ebx, 4
  00143	8d 75 f0	 lea	 esi, DWORD PTR _PacketHeader$[ebp+12]
$LL94@KdpSerialR@2:
  00146	e8 00 00 00 00	 call	 ?KdpSpin@@YIXXZ		; KdpSpin
  0014b	ba 01 00 00 00	 mov	 edx, 1
  00150	8d 4d fc	 lea	 ecx, DWORD PTR _Input$11877[ebp]
  00153	e8 00 00 00 00	 call	 ?KdpSerialGetByte@@YI?AW4KDP_STATUS@@PAEH@Z ; KdpSerialGetByte
  00158	85 c0		 test	 eax, eax
  0015a	75 0d		 jne	 SHORT $LN136@KdpSerialR@2
  0015c	8a 45 fc	 mov	 al, BYTE PTR _Input$11877[ebp]
  0015f	88 06		 mov	 BYTE PTR [esi], al
  00161	83 c6 01	 add	 esi, 1
  00164	83 eb 01	 sub	 ebx, 1
  00167	75 dd		 jne	 SHORT $LL94@KdpSerialR@2
$LN136@KdpSerialR@2:
  00169	33 c0		 xor	 eax, eax
  0016b	85 db		 test	 ebx, ebx
  0016d	0f 95 c0	 setne	 al

; 595  :     if (ReturnCode == KDP_PACKET_TIMEOUT) {

  00170	83 f8 01	 cmp	 eax, 1
  00173	0f 84 cb 01 00
	00		 je	 $LN139@KdpSerialR@2

; 596  :         return KDP_PACKET_TIMEOUT;
; 597  :     }
; 598  :     else if (ReturnCode == KDP_PACKET_RESEND) {

  00179	83 f8 02	 cmp	 eax, 2
  0017c	75 12		 jne	 SHORT $LN36@KdpSerialR@2

; 599  :         if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {

  0017e	81 7d e4 69 69
	69 69		 cmp	 DWORD PTR _PacketHeader$[ebp], 1768515945 ; 69696969H
  00185	0f 84 85 fe ff
	ff		 je	 $WaitForPacketLeader$11665

; 769  : 
; 770  :   SendResendPacket:

  0018b	e9 84 01 00 00	 jmp	 $SendResendPacket$11676
$LN36@KdpSerialR@2:

; 600  :             goto WaitForPacketLeader;
; 601  :         }
; 602  :         else {
; 603  :             goto SendResendPacket;
; 604  :         }
; 605  :     }
; 606  : 
; 607  :     //
; 608  :     // A complete packet header is received.  Check its validity and
; 609  :     // perform appropriate action depending on packet type.
; 610  :     //
; 611  :     if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER ) {

  00190	81 7d e4 69 69
	69 69		 cmp	 DWORD PTR _PacketHeader$[ebp], 1768515945 ; 69696969H
  00197	75 5d		 jne	 SHORT $LN34@KdpSerialR@2

; 612  :         if (PacketHeader.PacketType == PACKET_TYPE_KD_ACKNOWLEDGE ) {

  00199	66 8b 45 e8	 mov	 ax, WORD PTR _PacketHeader$[ebp+4]
  0019d	66 3d 04 00	 cmp	 ax, 4
  001a1	75 31		 jne	 SHORT $LN33@KdpSerialR@2

; 613  :             //
; 614  :             // If we received an expected ACK packet and we are not
; 615  :             // waiting for any new packet, update outgoing packet id
; 616  :             // and return.  If we are NOT waiting for ACK packet
; 617  :             // we will keep on waiting.  If the ACK packet
; 618  :             // is not for the packet we send, ignore it and keep on waiting.
; 619  :             //
; 620  :             if (PacketHeader.PacketId !=
; 621  :                 (KdCompNextPacketIdToSend & ~SYNC_PACKET_ID))  {

  001a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _KdCompNextPacketIdToSend
  001a9	81 e1 ff f7 ff
	ff		 and	 ecx, -2049		; fffff7ffH
  001af	39 4d ec	 cmp	 DWORD PTR _PacketHeader$[ebp+8], ecx
  001b2	0f 85 58 fe ff
	ff		 jne	 $WaitForPacketLeader$11665

; 622  :                 goto WaitForPacketLeader;
; 623  :             }
; 624  :             else if (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE) {

  001b8	83 7d f4 04	 cmp	 DWORD PTR _PacketType$[ebp], 4
  001bc	0f 85 4e fe ff
	ff		 jne	 $WaitForPacketLeader$11665

; 665  :             KdCompNextPacketIdToSend ^= 1;

  001c2	83 35 00 00 00
	00 01		 xor	 DWORD PTR _KdCompNextPacketIdToSend, 1
  001c9	5f		 pop	 edi
  001ca	5e		 pop	 esi

; 767  :     KDDBG2("KdpSerialReceivePacket - got one!\n");
; 768  :     return KDP_PACKET_RECEIVED;

  001cb	33 c0		 xor	 eax, eax
  001cd	5b		 pop	 ebx

; 773  : }

  001ce	8b e5		 mov	 esp, ebp
  001d0	5d		 pop	 ebp
  001d1	c2 0c 00	 ret	 12			; 0000000cH
$LN33@KdpSerialR@2:

; 625  :                 KdCompNextPacketIdToSend ^= 1;
; 626  :                 return KDP_PACKET_RECEIVED;
; 627  :             } else {
; 628  :                 goto WaitForPacketLeader;
; 629  :             }
; 630  :         }
; 631  :         else if (PacketHeader.PacketType == PACKET_TYPE_KD_RESET) {

  001d4	66 3d 06 00	 cmp	 ax, 6
  001d8	0f 84 74 01 00
	00		 je	 $LN145@KdpSerialR@2

; 640  :         }
; 641  :         else if (PacketHeader.PacketType == PACKET_TYPE_KD_RESEND) {

  001de	66 3d 05 00	 cmp	 ax, 5
  001e2	0f 85 28 fe ff
	ff		 jne	 $WaitForPacketLeader$11665
  001e8	5f		 pop	 edi
  001e9	5e		 pop	 esi
  001ea	b8 02 00 00 00	 mov	 eax, 2
  001ef	5b		 pop	 ebx

; 773  : }

  001f0	8b e5		 mov	 esp, ebp
  001f2	5d		 pop	 ebp
  001f3	c2 0c 00	 ret	 12			; 0000000cH
$LN34@KdpSerialR@2:

; 642  :             return KDP_PACKET_RESEND;
; 643  :         }
; 644  :         else {
; 645  :             //
; 646  :             // Invalid packet header, ignore it.
; 647  :             //
; 648  :             goto WaitForPacketLeader;
; 649  :         }
; 650  : 
; 651  :         //
; 652  :         // The packet header is for data packet (not control packet).
; 653  :         //
; 654  : 
; 655  :     }
; 656  :     else if (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE) {

  001f6	83 7d f4 04	 cmp	 DWORD PTR _PacketType$[ebp], 4
  001fa	75 1b		 jne	 SHORT $LN20@KdpSerialR@2

; 657  :         //
; 658  :         // if we are waiting for ACK packet ONLY
; 659  :         // and we receive a data packet header, check if the packet id
; 660  :         // is what we expected.  If yes, assume the acknowledge is lost (but
; 661  :         // sent), ask sender to resend and return with PACKET_RECEIVED.
; 662  :         //
; 663  :         if (PacketHeader.PacketId == KdCompPacketIdExpected) {

  001fc	8b 45 ec	 mov	 eax, DWORD PTR _PacketHeader$[ebp+8]
  001ff	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _KdCompPacketIdExpected
  00205	0f 84 6d 01 00
	00		 je	 $LN147@KdpSerialR@2

; 666  :             return KDP_PACKET_RECEIVED;
; 667  :         }
; 668  :         else {
; 669  :             KdpSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
; 670  :                                  PacketHeader.PacketId);

  0020b	6a 04		 push	 4
  0020d	e8 00 00 00 00	 call	 ?KdpSendControlPacket@@YIXGK@Z ; KdpSendControlPacket

; 671  :             goto WaitForPacketLeader;

  00212	e9 f9 fd ff ff	 jmp	 $WaitForPacketLeader$11665
$LN20@KdpSerialR@2:

; 672  :         }
; 673  :     }
; 674  : 
; 675  :     //
; 676  :     // we are waiting for data packet and we received the packet header
; 677  :     // for data packet. Perform the following checks to make sure
; 678  :     // it is the packet we are waiting for.
; 679  :     //
; 680  : 
; 681  :     //
; 682  :     // Check ByteCount received is valid
; 683  :     //
; 684  :     MessageLength = MessageHeader->MaximumLength;
; 685  :     if ((PacketHeader.ByteCount > (UINT16)PACKET_MAX_SIZE) ||
; 686  :         (PacketHeader.ByteCount < (UINT16)MessageLength)) {

  00217	66 8b 45 ea	 mov	 ax, WORD PTR _PacketHeader$[ebp+6]
  0021b	66 3d a0 0f	 cmp	 ax, 4000		; 00000fa0H
  0021f	0f b7 77 02	 movzx	 esi, WORD PTR [edi+2]
  00223	0f 87 eb 00 00
	00		 ja	 $SendResendPacket$11676
  00229	66 3b c6	 cmp	 ax, si
  0022c	0f 82 e2 00 00
	00		 jb	 $SendResendPacket$11676

; 687  :         goto SendResendPacket;
; 688  :     }
; 689  :     *DataLength = PacketHeader.ByteCount - MessageLength;

  00232	0f b7 d0	 movzx	 edx, ax
  00235	8b 45 0c	 mov	 eax, DWORD PTR _DataLength$[ebp]
  00238	2b d6		 sub	 edx, esi
  0023a	89 10		 mov	 DWORD PTR [eax], edx

; 690  : 
; 691  :     //
; 692  :     // Read the message header.
; 693  :     //
; 694  : 
; 695  :     ReturnCode = KdpSerialReceiveString((PUCHAR)MessageHeader->Buffer, MessageLength);

  0023c	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0023f	bb 01 00 00 00	 mov	 ebx, 1
  00244	8b c6		 mov	 eax, esi
  00246	e8 00 00 00 00	 call	 ?KdpSerialReceiveString@@YI?AW4KDP_STATUS@@PAEKH@Z ; KdpSerialReceiveString

; 696  :     if (ReturnCode != KDP_PACKET_RECEIVED) {

  0024b	85 c0		 test	 eax, eax
  0024d	0f 85 c1 00 00
	00		 jne	 $SendResendPacket$11676

; 697  :         goto SendResendPacket;
; 698  :     }
; 699  :     MessageHeader->Length = (UINT16)MessageLength;
; 700  : 
; 701  :     //
; 702  :     // Read the message data.
; 703  :     //
; 704  : 
; 705  :     ReturnCode = KdpSerialReceiveString((PUCHAR)MessageData->Buffer, *DataLength);

  00253	8b 4d 08	 mov	 ecx, DWORD PTR _MessageData$[ebp]
  00256	66 89 37	 mov	 WORD PTR [edi], si
  00259	8b 75 0c	 mov	 esi, DWORD PTR _DataLength$[ebp]
  0025c	8b 06		 mov	 eax, DWORD PTR [esi]
  0025e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00261	e8 00 00 00 00	 call	 ?KdpSerialReceiveString@@YI?AW4KDP_STATUS@@PAEKH@Z ; KdpSerialReceiveString

; 706  :     if (ReturnCode != KDP_PACKET_RECEIVED) {

  00266	85 c0		 test	 eax, eax
  00268	0f 85 a6 00 00
	00		 jne	 $SendResendPacket$11676

; 707  :         goto SendResendPacket;
; 708  :     }
; 709  :     MessageData->Length = (UINT16)*DataLength;

  0026e	66 8b 16	 mov	 dx, WORD PTR [esi]
  00271	8b 45 08	 mov	 eax, DWORD PTR _MessageData$[ebp]
  00274	66 89 10	 mov	 WORD PTR [eax], dx

; 710  : 
; 711  :     //
; 712  :     // Read packet trailing byte
; 713  :     //
; 714  : 
; 715  :     ReturnCode = KdpSerialReceiveString(&Input, 1);

  00277	8d 75 fa	 lea	 esi, DWORD PTR _Input$[ebp]
  0027a	8d 9b 00 00 00
	00		 npad	 6
$LL102@KdpSerialR@2:
  00280	e8 00 00 00 00	 call	 ?KdpSpin@@YIXXZ		; KdpSpin
  00285	ba 01 00 00 00	 mov	 edx, 1
  0028a	8d 4d fb	 lea	 ecx, DWORD PTR _Input$11891[ebp]
  0028d	e8 00 00 00 00	 call	 ?KdpSerialGetByte@@YI?AW4KDP_STATUS@@PAEH@Z ; KdpSerialGetByte
  00292	85 c0		 test	 eax, eax
  00294	75 0d		 jne	 SHORT $LN137@KdpSerialR@2
  00296	8a 4d fb	 mov	 cl, BYTE PTR _Input$11891[ebp]
  00299	88 0e		 mov	 BYTE PTR [esi], cl
  0029b	83 c6 01	 add	 esi, 1
  0029e	83 eb 01	 sub	 ebx, 1
  002a1	75 dd		 jne	 SHORT $LL102@KdpSerialR@2
$LN137@KdpSerialR@2:
  002a3	85 db		 test	 ebx, ebx

; 716  :     if (ReturnCode != KDP_PACKET_RECEIVED || Input != PACKET_TRAILING_BYTE) {

  002a5	75 6d		 jne	 SHORT $SendResendPacket$11676
  002a7	80 7d fa aa	 cmp	 BYTE PTR _Input$[ebp], 170 ; 000000aaH
  002ab	75 67		 jne	 SHORT $SendResendPacket$11676

; 717  :         goto SendResendPacket;
; 718  :     }
; 719  : 
; 720  :     //
; 721  :     // Check PacketType is what we are waiting for.
; 722  :     //
; 723  :     if (PacketType != PacketHeader.PacketType) {

  002ad	0f b7 55 e8	 movzx	 edx, WORD PTR _PacketHeader$[ebp+4]
  002b1	39 55 f4	 cmp	 DWORD PTR _PacketType$[ebp], edx
  002b4	74 0f		 je	 SHORT $LN9@KdpSerialR@2

; 724  :         KdpSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
; 725  :                              PacketHeader.PacketId);

  002b6	8b 45 ec	 mov	 eax, DWORD PTR _PacketHeader$[ebp+8]
  002b9	6a 04		 push	 4
  002bb	e8 00 00 00 00	 call	 ?KdpSendControlPacket@@YIXGK@Z ; KdpSendControlPacket

; 726  :         goto WaitForPacketLeader;

  002c0	e9 4b fd ff ff	 jmp	 $WaitForPacketLeader$11665
$LN9@KdpSerialR@2:

; 727  :     }
; 728  : 
; 729  :     //
; 730  :     // Check PacketId is valid.
; 731  :     //
; 732  :     if (PacketHeader.PacketId == INITIAL_PACKET_ID ||
; 733  :         PacketHeader.PacketId == (INITIAL_PACKET_ID ^ 1)) {

  002c5	8b 75 ec	 mov	 esi, DWORD PTR _PacketHeader$[ebp+8]
  002c8	81 fe 00 00 80
	80		 cmp	 esi, -2139095040	; 80800000H
  002ce	74 08		 je	 SHORT $LN7@KdpSerialR@2
  002d0	81 fe 01 00 80
	80		 cmp	 esi, -2139095039	; 80800001H
  002d6	75 3c		 jne	 SHORT $SendResendPacket$11676
$LN7@KdpSerialR@2:

; 734  :         if (PacketHeader.PacketId != KdCompPacketIdExpected) {

  002d8	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR _KdCompPacketIdExpected
  002de	74 0e		 je	 SHORT $LN6@KdpSerialR@2

; 735  :             KdpSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
; 736  :                                  PacketHeader.PacketId);

  002e0	6a 04		 push	 4
  002e2	8b c6		 mov	 eax, esi
  002e4	e8 00 00 00 00	 call	 ?KdpSendControlPacket@@YIXGK@Z ; KdpSendControlPacket

; 737  :             goto WaitForPacketLeader;

  002e9	e9 22 fd ff ff	 jmp	 $WaitForPacketLeader$11665
$LN6@KdpSerialR@2:

; 738  :         }
; 739  :     }
; 740  :     else {
; 741  :         goto SendResendPacket;
; 742  :     }
; 743  : 
; 744  :     //
; 745  :     // Check checksum is valid.
; 746  :     //
; 747  :     Checksum = KdpComputeChecksum(MessageHeader->Buffer,
; 748  :                                   MessageHeader->Length);

  002ee	0f b7 17	 movzx	 edx, WORD PTR [edi]
  002f1	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  002f4	e8 00 00 00 00	 call	 ?KdpComputeChecksum@@YIKPADK@Z ; KdpComputeChecksum
  002f9	8b d8		 mov	 ebx, eax

; 749  :     Checksum += KdpComputeChecksum(MessageData->Buffer,
; 750  :                                    MessageData->Length);
; 751  :     if (Checksum != PacketHeader.Checksum) {

  002fb	8b 45 08	 mov	 eax, DWORD PTR _MessageData$[ebp]
  002fe	0f b7 10	 movzx	 edx, WORD PTR [eax]
  00301	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00304	e8 00 00 00 00	 call	 ?KdpComputeChecksum@@YIKPADK@Z ; KdpComputeChecksum
  00309	03 c3		 add	 eax, ebx
  0030b	3b 45 f0	 cmp	 eax, DWORD PTR _PacketHeader$[ebp+12]
  0030e	0f 84 7f 00 00
	00		 je	 $LN3@KdpSerialR@2
$SendResendPacket$11676:

; 771  :     KdpSendControlPacket(PACKET_TYPE_KD_RESEND, 0L);

  00314	33 c0		 xor	 eax, eax
  00316	c7 45 d4 69 69
	69 69		 mov	 DWORD PTR _PacketHeader$11915[ebp], 1768515945 ; 69696969H
  0031d	66 89 45 da	 mov	 WORD PTR _PacketHeader$11915[ebp+6], ax
  00321	89 45 e0	 mov	 DWORD PTR _PacketHeader$11915[ebp+12], eax
  00324	66 c7 45 d8 05
	00		 mov	 WORD PTR _PacketHeader$11915[ebp+4], 5
  0032a	8d 58 10	 lea	 ebx, DWORD PTR [eax+16]
  0032d	8d 75 d4	 lea	 esi, DWORD PTR _PacketHeader$11915[ebp]
$LL111@KdpSerialR@2:
  00330	8a 0e		 mov	 cl, BYTE PTR [esi]
  00332	83 c6 01	 add	 esi, 1
  00335	e8 00 00 00 00	 call	 ?KdpSerialPutByte@@YIXE@Z ; KdpSerialPutByte
  0033a	83 eb 01	 sub	 ebx, 1
  0033d	75 f1		 jne	 SHORT $LL111@KdpSerialR@2

; 772  :     goto WaitForPacketLeader;

  0033f	e9 cc fc ff ff	 jmp	 $WaitForPacketLeader$11665
$LN139@KdpSerialR@2:
  00344	5f		 pop	 edi
  00345	5e		 pop	 esi

; 525  :         return KDP_PACKET_TIMEOUT;

  00346	b8 01 00 00 00	 mov	 eax, 1
  0034b	5b		 pop	 ebx

; 773  : }

  0034c	8b e5		 mov	 esp, ebp
  0034e	5d		 pop	 ebp
  0034f	c2 0c 00	 ret	 12			; 0000000cH
$LN145@KdpSerialR@2:

; 632  :             //
; 633  :             // if we received Reset packet, reset the packet control variables
; 634  :             // and resend earlier packet.
; 635  :             //
; 636  :             KdCompNextPacketIdToSend = INITIAL_PACKET_ID;

  00352	b8 00 00 80 80	 mov	 eax, -2139095040	; 80800000H
  00357	a3 00 00 00 00	 mov	 DWORD PTR _KdCompNextPacketIdToSend, eax

; 637  :             KdCompPacketIdExpected = INITIAL_PACKET_ID;

  0035c	a3 00 00 00 00	 mov	 DWORD PTR _KdCompPacketIdExpected, eax

; 638  :             KdpSendControlPacket(PACKET_TYPE_KD_RESET, 0L);

  00361	6a 06		 push	 6
  00363	33 c0		 xor	 eax, eax
  00365	e8 00 00 00 00	 call	 ?KdpSendControlPacket@@YIXGK@Z ; KdpSendControlPacket
$LN140@KdpSerialR@2:
  0036a	5f		 pop	 edi
  0036b	5e		 pop	 esi

; 639  :             return KDP_PACKET_RESEND;

  0036c	b8 02 00 00 00	 mov	 eax, 2
  00371	5b		 pop	 ebx

; 773  : }

  00372	8b e5		 mov	 esp, ebp
  00374	5d		 pop	 ebp
  00375	c2 0c 00	 ret	 12			; 0000000cH
$LN147@KdpSerialR@2:

; 664  :             KdpSendControlPacket(PACKET_TYPE_KD_RESEND, 0L);

  00378	6a 05		 push	 5
  0037a	33 c0		 xor	 eax, eax
  0037c	e8 00 00 00 00	 call	 ?KdpSendControlPacket@@YIXGK@Z ; KdpSendControlPacket

; 665  :             KdCompNextPacketIdToSend ^= 1;

  00381	83 35 00 00 00
	00 01		 xor	 DWORD PTR _KdCompNextPacketIdToSend, 1
  00388	5f		 pop	 edi
  00389	5e		 pop	 esi

; 767  :     KDDBG2("KdpSerialReceivePacket - got one!\n");
; 768  :     return KDP_PACKET_RECEIVED;

  0038a	33 c0		 xor	 eax, eax
  0038c	5b		 pop	 ebx

; 773  : }

  0038d	8b e5		 mov	 esp, ebp
  0038f	5d		 pop	 ebp
  00390	c2 0c 00	 ret	 12			; 0000000cH
$LN3@KdpSerialR@2:

; 752  :         goto SendResendPacket;
; 753  :     }
; 754  : 
; 755  :     //
; 756  :     // Send Acknowledge byte and the Id of the packet received.
; 757  :     // Then, update the ExpectId for next incoming packet.
; 758  :     //
; 759  :     KdpSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
; 760  :                          PacketHeader.PacketId);

  00393	6a 04		 push	 4
  00395	8b c6		 mov	 eax, esi
  00397	e8 00 00 00 00	 call	 ?KdpSendControlPacket@@YIXGK@Z ; KdpSendControlPacket

; 761  : 
; 762  :     //
; 763  :     // We have successfully received the packet so update the
; 764  :     // packet control variables and return success.
; 765  :     //
; 766  :     KdCompPacketIdExpected ^= 1;

  0039c	83 35 00 00 00
	00 01		 xor	 DWORD PTR _KdCompPacketIdExpected, 1

; 767  :     KDDBG2("KdpSerialReceivePacket - got one!\n");
; 768  :     return KDP_PACKET_RECEIVED;

  003a3	33 c0		 xor	 eax, eax
$LN64@KdpSerialR@2:
  003a5	5f		 pop	 edi
  003a6	5e		 pop	 esi
  003a7	5b		 pop	 ebx

; 773  : }

  003a8	8b e5		 mov	 esp, ebp
  003aa	5d		 pop	 ebp
  003ab	c2 0c 00	 ret	 12			; 0000000cH
?KdpSerialReceivePacket@@YI?AW4KDP_STATUS@@KPAU_STRING@@0PAKPAU_KD_CONTEXT@@@Z ENDP ; KdpSerialReceivePacket
_TEXT	ENDS
PUBLIC	?KdpSerialPollBreakIn@@YI_NXZ			; KdpSerialPollBreakIn
; Function compile flags: /Ogtp
;	COMDAT ?KdpSerialPollBreakIn@@YI_NXZ
_TEXT	SEGMENT
_Input$ = -2						; size = 1
_Input$11968 = -1					; size = 1
?KdpSerialPollBreakIn@@YI_NXZ PROC			; KdpSerialPollBreakIn, COMDAT

; 778  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 779  :     KDDBG2("KdpSerialPollBreakIn\n");
; 780  :     UCHAR Input;
; 781  :     UINT32 Status = KdpSerialReceiveString(&Input, 1, false);

  00006	bf 01 00 00 00	 mov	 edi, 1
  0000b	8d 75 fe	 lea	 esi, DWORD PTR _Input$[ebp]
  0000e	8b ff		 npad	 2
$LL11@KdpSerialP:
  00010	e8 00 00 00 00	 call	 ?KdpSpin@@YIXXZ		; KdpSpin
  00015	33 d2		 xor	 edx, edx
  00017	8d 4d ff	 lea	 ecx, DWORD PTR _Input$11968[ebp]
  0001a	e8 00 00 00 00	 call	 ?KdpSerialGetByte@@YI?AW4KDP_STATUS@@PAEH@Z ; KdpSerialGetByte
  0001f	85 c0		 test	 eax, eax
  00021	75 0d		 jne	 SHORT $LN16@KdpSerialP
  00023	8a 45 ff	 mov	 al, BYTE PTR _Input$11968[ebp]
  00026	88 06		 mov	 BYTE PTR [esi], al
  00028	83 c6 01	 add	 esi, 1
  0002b	83 ef 01	 sub	 edi, 1
  0002e	75 e0		 jne	 SHORT $LL11@KdpSerialP
$LN16@KdpSerialP:
  00030	85 ff		 test	 edi, edi
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi

; 782  :     KDDBG2("KdpSerialPollByte STATUS %d Input %02x\n", Status, Input);
; 783  :     if ((Status == KDP_PACKET_RECEIVED) && (Input == BREAKIN_PACKET_BYTE)) {

  00034	75 16		 jne	 SHORT $LN2@KdpSerialP
  00036	80 7d fe 62	 cmp	 BYTE PTR _Input$[ebp], 98 ; 00000062H
  0003a	75 10		 jne	 SHORT $LN2@KdpSerialP

; 784  :         KDDBG("KDP_PACKET_RECEIVED\n");
; 785  :         KdDebuggerNotPresent = false;

  0003c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?KdDebuggerNotPresent@@3HA, 0 ; KdDebuggerNotPresent

; 786  :         return true;

  00046	b0 01		 mov	 al, 1

; 789  : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
$LN2@KdpSerialP:

; 787  :     }
; 788  :     return false;

  0004c	32 c0		 xor	 al, al

; 789  : }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
?KdpSerialPollBreakIn@@YI_NXZ ENDP			; KdpSerialPollBreakIn
_TEXT	ENDS
PUBLIC	?KdpSerialSendPacket@@YIXKPAU_STRING@@0PAU_KD_CONTEXT@@@Z ; KdpSerialSendPacket
; Function compile flags: /Ogtp
;	COMDAT ?KdpSerialSendPacket@@YIXKPAU_STRING@@0PAU_KD_CONTEXT@@@Z
_TEXT	SEGMENT
_PacketHeader$ = -28					; size = 16
_PacketType$ = -12					; size = 4
_MessageDataLength$ = -8				; size = 4
_uDummy$11611 = -2					; size = 1
_Input$11986 = -1					; size = 1
_MessageData$ = 8					; size = 4
_KdContext$ = 12					; size = 4
?KdpSerialSendPacket@@YIXKPAU_STRING@@0PAU_KD_CONTEXT@@@Z PROC ; KdpSerialSendPacket, COMDAT
; _PacketType$ = ecx
; _MessageHeader$ = edx

; 301  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 302  : 
; 303  :     KD_PACKET PacketHeader;
; 304  :     UINT32 MessageDataLength;
; 305  :     KDP_STATUS ReturnCode;
; 306  :     KDDBG2("KdpSerialSendPacket %d\n", PacketType);
; 307  : 
; 308  :     if (MessageData != NULL) {

  00006	8b 45 08	 mov	 eax, DWORD PTR _MessageData$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	33 f6		 xor	 esi, esi
  0000e	3b c6		 cmp	 eax, esi
  00010	8b f9		 mov	 edi, ecx
  00012	8b da		 mov	 ebx, edx
  00014	89 7d f4	 mov	 DWORD PTR _PacketType$[ebp], edi
  00017	74 12		 je	 SHORT $LN24@KdpSerialS@2

; 309  :         MessageDataLength = MessageData->Length;

  00019	0f b7 10	 movzx	 edx, WORD PTR [eax]

; 310  :         PacketHeader.Checksum = KdpComputeChecksum(MessageData->Buffer,
; 311  :                                                    MessageData->Length);

  0001c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001f	89 55 f8	 mov	 DWORD PTR _MessageDataLength$[ebp], edx
  00022	e8 00 00 00 00	 call	 ?KdpComputeChecksum@@YIKPADK@Z ; KdpComputeChecksum
  00027	8b f0		 mov	 esi, eax

; 312  :     }
; 313  :     else {

  00029	eb 03		 jmp	 SHORT $LN23@KdpSerialS@2
$LN24@KdpSerialS@2:

; 314  :         MessageDataLength = 0;

  0002b	89 75 f8	 mov	 DWORD PTR _MessageDataLength$[ebp], esi
$LN23@KdpSerialS@2:

; 315  :         PacketHeader.Checksum = 0;
; 316  :     }
; 317  :     PacketHeader.Checksum += KdpComputeChecksum(MessageHeader->Buffer,
; 318  :                                                 MessageHeader->Length);

  0002e	0f b7 13	 movzx	 edx, WORD PTR [ebx]
  00031	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00034	e8 00 00 00 00	 call	 ?KdpComputeChecksum@@YIKPADK@Z ; KdpComputeChecksum

; 319  : 
; 320  :     //
; 321  :     // Initialize and send the packet header.
; 322  :     //
; 323  : 
; 324  :     PacketHeader.PacketLeader = PACKET_LEADER;
; 325  :     PacketHeader.ByteCount = (UINT16)(MessageHeader->Length + MessageDataLength);
; 326  :     PacketHeader.PacketType = (UINT16)PacketType;
; 327  : 
; 328  :     KdCompNumberRetries = KdCompRetryCount;

  00039	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?KdCompRetryCount@@3KA ; KdCompRetryCount
  0003f	03 f0		 add	 esi, eax
  00041	66 8b 03	 mov	 ax, WORD PTR [ebx]
  00044	66 03 45 f8	 add	 ax, WORD PTR _MessageDataLength$[ebp]

; 329  : 
; 330  :     //
; 331  :     // We sync on first STATE_CHANGE64 message like NT.  If this
; 332  :     // is the first such message, drain receive pipe as nothing
; 333  :     // said before this instant is interesting (and any buffered
; 334  :     // packets may interact badly with SendWaitContinue).
; 335  :     //
; 336  :     if (PacketType == PACKET_TYPE_KD_STATE_CHANGE64 && !KdStateChange64Sent) {

  00048	83 ff 07	 cmp	 edi, 7
  0004b	89 75 f0	 mov	 DWORD PTR _PacketHeader$[ebp+12], esi
  0004e	c7 45 e4 30 30
	30 30		 mov	 DWORD PTR _PacketHeader$[ebp], 808464432 ; 30303030H
  00055	66 89 45 ea	 mov	 WORD PTR _PacketHeader$[ebp+6], ax
  00059	66 89 7d e8	 mov	 WORD PTR _PacketHeader$[ebp+4], di
  0005d	89 0d 00 00 00
	00		 mov	 DWORD PTR ?KdCompNumberRetries@@3KA, ecx ; KdCompNumberRetries
  00063	75 50		 jne	 SHORT $LL19@KdpSerialS@2
  00065	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _KdStateChange64Sent, 0
  0006c	75 47		 jne	 SHORT $LL19@KdpSerialS@2

; 337  :         //
; 338  :         UCHAR uDummy;
; 339  :         uint32 dwDrained = 0;
; 340  :         KdCompNextPacketIdToSend |= SYNC_PACKET_ID;

  0006e	81 0d 00 00 00
	00 00 08 00 00	 or	 DWORD PTR _KdCompNextPacketIdToSend, 2048 ; 00000800H

; 341  :         KdStateChange64Sent = true;

  00078	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _KdStateChange64Sent, 1
$LL21@KdpSerialS@2:

; 342  : 
; 343  :         while (KdpSerialReceiveString(&uDummy, 1, false) == KDP_PACKET_RECEIVED) {

  00082	bf 01 00 00 00	 mov	 edi, 1
  00087	8d 75 fe	 lea	 esi, DWORD PTR _uDummy$11611[ebp]
  0008a	8d 9b 00 00 00
	00		 npad	 6
$LL32@KdpSerialS@2:
  00090	e8 00 00 00 00	 call	 ?KdpSpin@@YIXXZ		; KdpSpin
  00095	33 d2		 xor	 edx, edx
  00097	8d 4d ff	 lea	 ecx, DWORD PTR _Input$11986[ebp]
  0009a	e8 00 00 00 00	 call	 ?KdpSerialGetByte@@YI?AW4KDP_STATUS@@PAEH@Z ; KdpSerialGetByte
  0009f	85 c0		 test	 eax, eax
  000a1	75 0b		 jne	 SHORT $LN67@KdpSerialS@2
  000a3	8a 55 ff	 mov	 dl, BYTE PTR _Input$11986[ebp]
  000a6	83 c6 01	 add	 esi, 1
  000a9	83 ef 01	 sub	 edi, 1
  000ac	75 e2		 jne	 SHORT $LL32@KdpSerialS@2
$LN67@KdpSerialS@2:
  000ae	85 ff		 test	 edi, edi
  000b0	74 d0		 je	 SHORT $LL21@KdpSerialS@2
$LN96@KdpSerialS@2:
  000b2	8b 7d f4	 mov	 edi, DWORD PTR _PacketType$[ebp]
$LL19@KdpSerialS@2:

; 344  :             dwDrained++;
; 345  :         }
; 346  :     }
; 347  : 
; 348  :     do {
; 349  :         KDDBG2("LOOP %d/%d\n", KdCompNumberRetries, KdCompRetryCount);
; 350  :         if (KdCompNumberRetries == 0) {

  000b5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?KdCompNumberRetries@@3KA, 0 ; KdCompNumberRetries
  000bc	75 34		 jne	 SHORT $LN6@KdpSerialS@2

; 351  :             KDDBG("KdCompNumberRetries == 0\n");
; 352  :             //
; 353  :             // If the packet is not for reporting exception, we give up
; 354  :             // and declare debugger not present.
; 355  :             //
; 356  :             if (PacketType == PACKET_TYPE_KD_STATE_CHANGE64) {

  000be	83 ff 07	 cmp	 edi, 7
  000c1	75 0b		 jne	 SHORT $LN13@KdpSerialS@2

; 357  :                 PDBGKD_ANY_WAIT_STATE_CHANGE StateChange
; 358  :                     = (PDBGKD_ANY_WAIT_STATE_CHANGE)MessageHeader->Buffer;

  000c3	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]

; 359  :                 if (StateChange->NewState == DbgKdLoadSymbolsStateChange) {

  000c6	81 38 31 30 00
	00		 cmp	 DWORD PTR [eax], 12337	; 00003031H

; 364  :                     return;
; 365  :                 }
; 366  :             }

  000cc	eb 1e		 jmp	 SHORT $LN97@KdpSerialS@2
$LN13@KdpSerialS@2:

; 367  :             else if (PacketType == PACKET_TYPE_KD_DEBUG_IO) {

  000ce	83 ff 03	 cmp	 edi, 3
  000d1	75 0b		 jne	 SHORT $LN10@KdpSerialS@2

; 368  :                 PDBGKD_DEBUG_IO DebugIo
; 369  :                     = (PDBGKD_DEBUG_IO)MessageHeader->Buffer;

  000d3	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]

; 370  :                 if (DebugIo->ApiNumber == DbgKdPrintStringApi) {

  000d6	81 39 30 32 00
	00		 cmp	 DWORD PTR [ecx], 12848	; 00003230H

; 371  :                     KdDebuggerNotPresent = true;
; 372  :                     //SharedUserData->KdDebuggerEnabled &= ~0x00000002;
; 373  :                     KdCompNextPacketIdToSend = INITIAL_PACKET_ID | SYNC_PACKET_ID;
; 374  :                     KdCompPacketIdExpected = INITIAL_PACKET_ID;
; 375  :                     return;
; 376  :                 }
; 377  :             }

  000dc	eb 0e		 jmp	 SHORT $LN97@KdpSerialS@2
$LN10@KdpSerialS@2:

; 378  :             else if (PacketType == PACKET_TYPE_KD_FILE_IO) {

  000de	83 ff 0b	 cmp	 edi, 11			; 0000000bH
  000e1	75 0f		 jne	 SHORT $LN6@KdpSerialS@2

; 379  :                 PDBGKD_FILE_IO FileIo;
; 380  : 
; 381  :                 FileIo = (PDBGKD_FILE_IO)MessageHeader->Buffer;

  000e3	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]

; 382  :                 if (FileIo->ApiNumber == DbgKdCreateFileApi) {

  000e6	81 3a 30 34 00
	00		 cmp	 DWORD PTR [edx], 13360	; 00003430H
$LN97@KdpSerialS@2:
  000ec	0f 84 ab 00 00
	00		 je	 $LN68@KdpSerialS@2
$LN6@KdpSerialS@2:

; 383  :                     KdDebuggerNotPresent = true;
; 384  :                     //SharedUserData->KdDebuggerEnabled &= ~0x00000002;
; 385  :                     KdCompNextPacketIdToSend = INITIAL_PACKET_ID | SYNC_PACKET_ID;
; 386  :                     KdCompPacketIdExpected = INITIAL_PACKET_ID;
; 387  :                     return;
; 388  :                 }
; 389  :             }
; 390  :         }
; 391  :         //
; 392  :         // Setting PacketId has to be in the do loop in case Packet Id was
; 393  :         // reset.
; 394  :         //
; 395  : 
; 396  :         PacketHeader.PacketId = KdCompNextPacketIdToSend;

  000f2	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdCompNextPacketIdToSend
  000f7	89 45 ec	 mov	 DWORD PTR _PacketHeader$[ebp+8], eax

; 397  :         KdpSerialSendString((PUCHAR)&PacketHeader, sizeof(KD_PACKET));

  000fa	bf 10 00 00 00	 mov	 edi, 16			; 00000010H
  000ff	8d 75 e4	 lea	 esi, DWORD PTR _PacketHeader$[ebp]
$LL38@KdpSerialS@2:
  00102	8a 0e		 mov	 cl, BYTE PTR [esi]
  00104	83 c6 01	 add	 esi, 1
  00107	e8 00 00 00 00	 call	 ?KdpSerialPutByte@@YIXE@Z ; KdpSerialPutByte
  0010c	83 ef 01	 sub	 edi, 1
  0010f	75 f1		 jne	 SHORT $LL38@KdpSerialS@2

; 398  : 
; 399  :         //
; 400  :         // Output message header.
; 401  :         //
; 402  : 
; 403  :         KdpSerialSendString((PUCHAR)MessageHeader->Buffer, MessageHeader->Length);

  00111	0f b7 3b	 movzx	 edi, WORD PTR [ebx]
  00114	85 ff		 test	 edi, edi
  00116	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00119	76 14		 jbe	 SHORT $LN43@KdpSerialS@2
  0011b	eb 03 8d 49 00	 npad	 5
$LL44@KdpSerialS@2:
  00120	8a 0e		 mov	 cl, BYTE PTR [esi]
  00122	83 c6 01	 add	 esi, 1
  00125	e8 00 00 00 00	 call	 ?KdpSerialPutByte@@YIXE@Z ; KdpSerialPutByte
  0012a	83 ef 01	 sub	 edi, 1
  0012d	75 f1		 jne	 SHORT $LL44@KdpSerialS@2
$LN43@KdpSerialS@2:

; 404  : 
; 405  :         //
; 406  :         // Output message data.
; 407  :         //
; 408  : 
; 409  :         if ( MessageDataLength ) {

  0012f	83 7d f8 00	 cmp	 DWORD PTR _MessageDataLength$[ebp], 0
  00133	74 1c		 je	 SHORT $LL56@KdpSerialS@2

; 410  :             KdpSerialSendString((PUCHAR)MessageData->Buffer, MessageData->Length);

  00135	8b 45 08	 mov	 eax, DWORD PTR _MessageData$[ebp]
  00138	0f b7 38	 movzx	 edi, WORD PTR [eax]
  0013b	85 ff		 test	 edi, edi
  0013d	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00140	76 0f		 jbe	 SHORT $LL56@KdpSerialS@2
$LL50@KdpSerialS@2:
  00142	8a 0e		 mov	 cl, BYTE PTR [esi]
  00144	83 c6 01	 add	 esi, 1
  00147	e8 00 00 00 00	 call	 ?KdpSerialPutByte@@YIXE@Z ; KdpSerialPutByte
  0014c	83 ef 01	 sub	 edi, 1
  0014f	75 f1		 jne	 SHORT $LL50@KdpSerialS@2

; 411  :         }
; 412  : 
; 413  :         //
; 414  :         // Output a packet trailing byte
; 415  :         //
; 416  : 
; 417  :         {
; 418  :             UCHAR b = PACKET_TRAILING_BYTE;
; 419  :             KdpSerialSendString(&b, 1);

$LL56@KdpSerialS@2:
  00151	b1 aa		 mov	 cl, 170			; 000000aaH
  00153	e8 00 00 00 00	 call	 ?KdpSerialPutByte@@YIXE@Z ; KdpSerialPutByte

; 420  :         }
; 421  : 
; 422  :         //
; 423  :         // Wait for the Ack Packet
; 424  :         //
; 425  : 
; 426  :         ReturnCode = KdpSerialReceivePacket(
; 427  :                                             PACKET_TYPE_KD_ACKNOWLEDGE,
; 428  :                                             NULL,
; 429  :                                             NULL,
; 430  :                                             NULL,
; 431  :                                             KdContext
; 432  :                                             );

  00158	8b 75 0c	 mov	 esi, DWORD PTR _KdContext$[ebp]
  0015b	56		 push	 esi
  0015c	6a 00		 push	 0
  0015e	33 d2		 xor	 edx, edx
  00160	6a 00		 push	 0
  00162	8d 4a 04	 lea	 ecx, DWORD PTR [edx+4]
  00165	e8 00 00 00 00	 call	 ?KdpSerialReceivePacket@@YI?AW4KDP_STATUS@@KPAU_STRING@@0PAKPAU_KD_CONTEXT@@@Z ; KdpSerialReceivePacket

; 433  :         if (ReturnCode == KDP_PACKET_TIMEOUT) {

  0016a	83 f8 01	 cmp	 eax, 1
  0016d	75 0b		 jne	 SHORT $LN18@KdpSerialS@2

; 434  :             KDDBG2("TIMEOUT\n");
; 435  :             KdCompNumberRetries--;

  0016f	29 05 00 00 00
	00		 sub	 DWORD PTR ?KdCompNumberRetries@@3KA, eax ; KdCompNumberRetries

; 436  :         }
; 437  :     } while (ReturnCode != KDP_PACKET_RECEIVED);

  00175	e9 38 ff ff ff	 jmp	 $LN96@KdpSerialS@2
$LN18@KdpSerialS@2:
  0017a	85 c0		 test	 eax, eax
  0017c	0f 85 30 ff ff
	ff		 jne	 $LN96@KdpSerialS@2

; 438  : 
; 439  :     KDDBG2("KD: PACKET_RECEIVED\n");
; 440  :     //
; 441  :     // Reset Sync bit in packet id.  The packet we sent may have Sync bit set
; 442  :     //
; 443  : 
; 444  :     KdCompNextPacketIdToSend &= ~SYNC_PACKET_ID;
; 445  : 
; 446  :     //
; 447  :     // Since we are able to talk to debugger, the retrycount is set to
; 448  :     // maximum value.
; 449  :     //
; 450  : 
; 451  :     KdCompRetryCount = KdContext->KdpDefaultRetries;

  00182	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00184	81 25 00 00 00
	00 ff f7 ff ff	 and	 DWORD PTR _KdCompNextPacketIdToSend, -2049 ; fffff7ffH
  0018e	5f		 pop	 edi
  0018f	5e		 pop	 esi
  00190	89 0d 00 00 00
	00		 mov	 DWORD PTR ?KdCompRetryCount@@3KA, ecx ; KdCompRetryCount
  00196	5b		 pop	 ebx

; 452  : 
; 453  :     KDDBG2("KdpSerialSendPacket %d done\n", PacketType);
; 454  : }

  00197	8b e5		 mov	 esp, ebp
  00199	5d		 pop	 ebp
  0019a	c2 08 00	 ret	 8
$LN68@KdpSerialS@2:
  0019d	5f		 pop	 edi
  0019e	5e		 pop	 esi

; 360  :                     KdDebuggerNotPresent = true;

  0019f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?KdDebuggerNotPresent@@3HA, 1 ; KdDebuggerNotPresent

; 361  :                     //SharedUserData->KdDebuggerEnabled &= ~0x00000002;
; 362  :                     KdCompNextPacketIdToSend = INITIAL_PACKET_ID | SYNC_PACKET_ID;

  001a9	c7 05 00 00 00
	00 00 08 80 80	 mov	 DWORD PTR _KdCompNextPacketIdToSend, -2139092992 ; 80800800H

; 363  :                     KdCompPacketIdExpected = INITIAL_PACKET_ID;

  001b3	c7 05 00 00 00
	00 00 00 80 80	 mov	 DWORD PTR _KdCompPacketIdExpected, -2139095040 ; 80800000H
  001bd	5b		 pop	 ebx

; 452  : 
; 453  :     KDDBG2("KdpSerialSendPacket %d done\n", PacketType);
; 454  : }

  001be	8b e5		 mov	 esp, ebp
  001c0	5d		 pop	 ebp
  001c1	c2 08 00	 ret	 8
?KdpSerialSendPacket@@YIXKPAU_STRING@@0PAU_KD_CONTEXT@@@Z ENDP ; KdpSerialSendPacket
_TEXT	ENDS
END
