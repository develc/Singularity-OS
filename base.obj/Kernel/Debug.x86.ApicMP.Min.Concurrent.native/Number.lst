; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	C:\Users\cc\source\repos\Singularity-OS\base\Kernel\Native\Number.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	__fltused
_DATA	SEGMENT
__fltused DD	09875H
; Function compile flags: /Ogtp
; File c:\users\cc\source\repos\singularity-os\base\kernel\native\number.cpp
_DATA	ENDS
;	COMDAT ?dtold12@@YIXPAU_LDBL12@@PBN@Z
_TEXT	SEGMENT
_sign$ = -4						; size = 2
?dtold12@@YIXPAU_LDBL12@@PBN@Z PROC			; dtold12, COMDAT
; _pld$ = eax
; _px$ = ecx

; 140  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx

; 141  :     uint32 msb = MSB_ULONG;
; 142  :     uint16 ldexp = 0;
; 143  :     uint16 exp = (*UINT164_D(px) & (uint16)0x7ff0) >> 4;

  00009	0f b7 57 06	 movzx	 edx, WORD PTR [edi+6]

; 144  :     uint16 sign = *UINT164_D(px) & (uint16)0x8000;
; 145  :     uint32 manhi = *UL_HI_D(px) & 0xfffff;

  0000d	8b 77 04	 mov	 esi, DWORD PTR [edi+4]

; 146  :     uint32 manlo = *UL_LO_D(px);

  00010	8b 3f		 mov	 edi, DWORD PTR [edi]
  00012	8b ca		 mov	 ecx, edx
  00014	c1 e9 04	 shr	 ecx, 4
  00017	81 e2 00 80 00
	00		 and	 edx, 32768		; 00008000H
  0001d	81 e1 ff 07 00
	00		 and	 ecx, 2047		; 000007ffH
  00023	89 55 fc	 mov	 DWORD PTR _sign$[ebp], edx

; 147  : 
; 148  :     switch (exp) {

  00026	0f b7 d1	 movzx	 edx, cx
  00029	81 e6 ff ff 0f
	00		 and	 esi, 1048575		; 000fffffH
  0002f	85 d2		 test	 edx, edx
  00031	bb 00 00 00 80	 mov	 ebx, -2147483648	; 80000000H
  00036	74 17		 je	 SHORT $LN5@dtold12
  00038	81 fa ff 07 00
	00		 cmp	 edx, 2047		; 000007ffH
  0003e	74 08		 je	 SHORT $LN6@dtold12

; 163  :         msb = 0;
; 164  :         break;
; 165  :       default:
; 166  :         exp -= D_BIAS;
; 167  :         ldexp = (uint16) ((int16)exp + LD_BIAS);

  00040	81 c1 00 3c 00
	00		 add	 ecx, 15360		; 00003c00H

; 168  :         break;

  00046	eb 2b		 jmp	 SHORT $LN13@dtold12
$LN6@dtold12:

; 149  :       case D_MAXEXP:
; 150  :         ldexp = LD_MAXEXP;

  00048	ba ff 7f 00 00	 mov	 edx, 32767		; 00007fffH

; 151  :         break;

  0004d	eb 27		 jmp	 SHORT $LN7@dtold12
$LN5@dtold12:

; 152  :       case 0:
; 153  :         // check for zero
; 154  :         if (manhi == 0 && manlo == 0) {

  0004f	33 db		 xor	 ebx, ebx
  00051	3b f3		 cmp	 esi, ebx
  00053	75 18		 jne	 SHORT $LN4@dtold12
  00055	3b fb		 cmp	 edi, ebx
  00057	75 14		 jne	 SHORT $LN4@dtold12
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi

; 155  :             *UL_MANHI_12(pld) = 0;

  0005b	89 58 06	 mov	 DWORD PTR [eax+6], ebx

; 156  :             *UL_MANLO_12(pld) = 0;

  0005e	89 58 02	 mov	 DWORD PTR [eax+2], ebx

; 157  :             *U_XT_12(pld) = 0;

  00061	66 89 18	 mov	 WORD PTR [eax], bx

; 158  :             *U_EXP_12(pld) = 0;

  00064	66 89 58 0a	 mov	 WORD PTR [eax+10], bx
  00068	5b		 pop	 ebx

; 184  : }

  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
$LN4@dtold12:

; 159  :             return;
; 160  :         }
; 161  :         // we have a denormal -- we'll normalize later
; 162  :         ldexp = (uint16) ((int16)exp - D_BIAS + LD_BIAS + 1);

  0006d	81 c1 01 3c 00
	00		 add	 ecx, 15361		; 00003c01H
$LN13@dtold12:
  00073	0f b7 d1	 movzx	 edx, cx
$LN7@dtold12:

; 169  :     }
; 170  : 
; 171  :     *UL_MANHI_12(pld) = msb | (manhi << 11) | (manlo >> 21);

  00076	8b cf		 mov	 ecx, edi
  00078	c1 e9 15	 shr	 ecx, 21			; 00000015H
  0007b	c1 e6 0b	 shl	 esi, 11			; 0000000bH
  0007e	0b ce		 or	 ecx, esi
  00080	0b cb		 or	 ecx, ebx

; 172  :     *UL_MANLO_12(pld) = manlo << 11;

  00082	c1 e7 0b	 shl	 edi, 11			; 0000000bH

; 173  : 
; 174  :     // normalize if necessary
; 175  :     while ((*UL_MANHI_12(pld) & MSB_ULONG) == 0) {

  00085	be 00 00 00 80	 mov	 esi, -2147483648	; 80000000H
  0008a	85 ce		 test	 ecx, esi
  0008c	89 48 06	 mov	 DWORD PTR [eax+6], ecx
  0008f	89 78 02	 mov	 DWORD PTR [eax+2], edi
  00092	75 21		 jne	 SHORT $LN1@dtold12
$LL2@dtold12:

; 176  :         // shift left
; 177  :         *UL_MANHI_12(pld) = (*UL_MANHI_12(pld) << 1) |
; 178  :             (MSB_ULONG & *UL_MANLO_12(pld) ? 1: 0);

  00094	8b 48 02	 mov	 ecx, DWORD PTR [eax+2]
  00097	8b 78 06	 mov	 edi, DWORD PTR [eax+6]
  0009a	8b d9		 mov	 ebx, ecx
  0009c	03 ff		 add	 edi, edi
  0009e	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  000a1	0b fb		 or	 edi, ebx

; 179  :         (*UL_MANLO_12(pld)) <<= 1;

  000a3	03 c9		 add	 ecx, ecx

; 180  :         ldexp --;

  000a5	81 c2 ff ff 00
	00		 add	 edx, 65535		; 0000ffffH
  000ab	85 fe		 test	 edi, esi
  000ad	89 78 06	 mov	 DWORD PTR [eax+6], edi
  000b0	89 48 02	 mov	 DWORD PTR [eax+2], ecx
  000b3	74 df		 je	 SHORT $LL2@dtold12
$LN1@dtold12:

; 181  :     }
; 182  :     *U_EXP_12(pld) = sign | ldexp;

  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _sign$[ebp]
  000b8	5f		 pop	 edi
  000b9	0b ca		 or	 ecx, edx
  000bb	5e		 pop	 esi
  000bc	66 89 48 0a	 mov	 WORD PTR [eax+10], cx

; 183  :     *U_XT_12(pld) = 0;

  000c0	66 c7 00 00 00	 mov	 WORD PTR [eax], 0
  000c5	5b		 pop	 ebx

; 184  : }

  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c3		 ret	 0
?dtold12@@YIXPAU_LDBL12@@PBN@Z ENDP			; dtold12
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?addl@@YIHIIPAI@Z
_TEXT	SEGMENT
?addl@@YIHIIPAI@Z PROC					; addl, COMDAT
; _x$ = ecx
; _y$ = edx
; _sum$ = esi

; 198  :     uint32 r = x + y;

  00000	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]

; 199  :     *sum = r;
; 200  :     return (r < x || r < y);

  00003	3b c1		 cmp	 eax, ecx
  00005	89 06		 mov	 DWORD PTR [esi], eax
  00007	72 07		 jb	 SHORT $LN3@addl
  00009	3b c2		 cmp	 eax, edx
  0000b	72 03		 jb	 SHORT $LN3@addl
  0000d	33 c0		 xor	 eax, eax

; 201  : }

  0000f	c3		 ret	 0
$LN3@addl:

; 199  :     *sum = r;
; 200  :     return (r < x || r < y);

  00010	b8 01 00 00 00	 mov	 eax, 1

; 201  : }

  00015	c3		 ret	 0
?addl@@YIHIIPAI@Z ENDP					; addl
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?add_12@@YIXPAU_LDBL12@@0@Z
_TEXT	SEGMENT
?add_12@@YIXPAU_LDBL12@@0@Z PROC			; add_12, COMDAT
; _x$ = eax
; _y$ = ecx

; 214  :     if (addl(*UL_LO_12(x),*UL_LO_12(y),UL_LO_12(x))) {

  00000	8b 10		 mov	 edx, DWORD PTR [eax]
  00002	56		 push	 esi
  00003	57		 push	 edi
  00004	8b f9		 mov	 edi, ecx
  00006	8b 37		 mov	 esi, DWORD PTR [edi]
  00008	8d 0c 32	 lea	 ecx, DWORD PTR [edx+esi]
  0000b	3b ca		 cmp	 ecx, edx
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	72 04		 jb	 SHORT $LN8@add_12
  00011	3b ce		 cmp	 ecx, esi
  00013	73 16		 jae	 SHORT $LN2@add_12
$LN8@add_12:

; 215  :         if (addl(*UL_MED_12(x),(uint32)1,UL_MED_12(x))) {

  00015	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00018	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
  0001b	3b ca		 cmp	 ecx, edx
  0001d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00020	72 05		 jb	 SHORT $LN12@add_12
  00022	83 f9 01	 cmp	 ecx, 1
  00025	73 04		 jae	 SHORT $LN2@add_12
$LN12@add_12:

; 216  :             (*UL_HI_12(x))++;

  00027	83 40 08 01	 add	 DWORD PTR [eax+8], 1
$LN2@add_12:

; 217  :         }
; 218  :     }
; 219  :     if (addl(*UL_MED_12(x),*UL_MED_12(y),UL_MED_12(x))) {

  0002b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0002e	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00031	8d 0c 32	 lea	 ecx, DWORD PTR [edx+esi]
  00034	3b ca		 cmp	 ecx, edx
  00036	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00039	72 04		 jb	 SHORT $LN16@add_12
  0003b	3b ce		 cmp	 ecx, esi
  0003d	73 04		 jae	 SHORT $LN1@add_12
$LN16@add_12:

; 220  :         (*UL_HI_12(x))++;

  0003f	83 40 08 01	 add	 DWORD PTR [eax+8], 1
$LN1@add_12:

; 221  :     }
; 222  :     // ignore next carry -- assume no overflow will occur
; 223  :     (void)addl(*UL_HI_12(x),*UL_HI_12(y),UL_HI_12(x));

  00043	8b 7f 08	 mov	 edi, DWORD PTR [edi+8]
  00046	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00049	03 cf		 add	 ecx, edi
  0004b	5f		 pop	 edi
  0004c	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0004f	5e		 pop	 esi

; 224  : }

  00050	c3		 ret	 0
?add_12@@YIXPAU_LDBL12@@0@Z ENDP			; add_12
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?shl_12@@YIXPAU_LDBL12@@@Z
_TEXT	SEGMENT
?shl_12@@YIXPAU_LDBL12@@@Z PROC				; shl_12, COMDAT
; _p$ = eax

; 236  : {

  00000	56		 push	 esi

; 237  :     uint32 c0 = (*UL_LO_12(p) & MSB_ULONG) ? 1: 0;

  00001	8b 30		 mov	 esi, DWORD PTR [eax]
  00003	8b ce		 mov	 ecx, esi

; 238  :     uint32 c1 = (*UL_MED_12(p) & MSB_ULONG) ? 1: 0;
; 239  :     *UL_LO_12(p) <<= 1;

  00005	03 f6		 add	 esi, esi
  00007	57		 push	 edi
  00008	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  0000b	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0000e	89 30		 mov	 DWORD PTR [eax], esi

; 240  :     *UL_MED_12(p) = (*UL_MED_12(p) << 1) | c0;

  00010	8d 34 3f	 lea	 esi, DWORD PTR [edi+edi]
  00013	0b f1		 or	 esi, ecx

; 241  :     *UL_HI_12(p) = (*UL_HI_12(p) << 1) | c1;

  00015	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00018	8b d7		 mov	 edx, edi
  0001a	c1 ea 1f	 shr	 edx, 31			; 0000001fH
  0001d	03 c9		 add	 ecx, ecx
  0001f	0b ca		 or	 ecx, edx
  00021	5f		 pop	 edi
  00022	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00025	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00028	5e		 pop	 esi

; 242  : }

  00029	c3		 ret	 0
?shl_12@@YIXPAU_LDBL12@@@Z ENDP				; shl_12
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?shr_12@@YIXPAU_LDBL12@@@Z
_TEXT	SEGMENT
?shr_12@@YIXPAU_LDBL12@@@Z PROC				; shr_12, COMDAT
; _p$ = eax

; 246  :     uint32 c2 = (*UL_HI_12(p) & 0x1) ? MSB_ULONG: 0;

  00000	8b 50 08	 mov	 edx, DWORD PTR [eax+8]

; 247  :     uint32 c1 = (*UL_MED_12(p) & 0x1) ? MSB_ULONG: 0;

  00003	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	8b f2		 mov	 esi, edx

; 248  :     *UL_HI_12(p) >>= 1;
; 249  :     *UL_MED_12(p) = (*UL_MED_12(p) >> 1) | c2;

  0000c	d1 e9		 shr	 ecx, 1
  0000e	c1 e6 1f	 shl	 esi, 31			; 0000001fH
  00011	0b ce		 or	 ecx, esi
  00013	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 250  :     *UL_LO_12(p) = (*UL_LO_12(p) >> 1) | c1;

  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	c1 e7 1f	 shl	 edi, 31			; 0000001fH
  0001b	d1 e9		 shr	 ecx, 1
  0001d	0b cf		 or	 ecx, edi
  0001f	d1 ea		 shr	 edx, 1
  00021	5f		 pop	 edi
  00022	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00025	89 08		 mov	 DWORD PTR [eax], ecx
  00027	5e		 pop	 esi

; 251  : }

  00028	c3		 ret	 0
?shr_12@@YIXPAU_LDBL12@@@Z ENDP				; shr_12
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?ld12mul@@YIXPAU_LDBL12@@0@Z
_TEXT	SEGMENT
_tempman$ = -32						; size = 12
tv650 = -20						; size = 4
tv257 = -20						; size = 4
_j$11087 = -16						; size = 4
_i$11081 = -12						; size = 4
_sign$ = -8						; size = 2
_expsum$ = -4						; size = 2
_px$ = 8						; size = 4
_py$ = 12						; size = 4
_sticky$11120 = 15					; size = 1
?ld12mul@@YIXPAU_LDBL12@@0@Z PROC			; ld12mul, COMDAT

; 262  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 263  :     _LDBL12 tempman; // this is actually a 12-byte mantissa, not a 12-byte long double
; 264  : 
; 265  :     *UL_LO_12(&tempman) = 0;
; 266  :     *UL_MED_12(&tempman) = 0;
; 267  :     *UL_HI_12(&tempman) = 0;
; 268  : 
; 269  :     uint16 expx = *U_EXP_12(px);

  00006	8b 55 08	 mov	 edx, DWORD PTR _px$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	33 c0		 xor	 eax, eax
  0000d	57		 push	 edi

; 270  :     uint16 expy = *U_EXP_12(py);

  0000e	8b 7d 0c	 mov	 edi, DWORD PTR _py$[ebp]
  00011	0f b7 77 0a	 movzx	 esi, WORD PTR [edi+10]
  00015	89 45 e0	 mov	 DWORD PTR _tempman$[ebp], eax
  00018	89 45 e4	 mov	 DWORD PTR _tempman$[ebp+4], eax
  0001b	89 45 e8	 mov	 DWORD PTR _tempman$[ebp+8], eax
  0001e	0f b7 42 0a	 movzx	 eax, WORD PTR [edx+10]

; 271  :     uint16 sign = (expx ^ expy) & (uint16)0x8000;

  00022	8b ce		 mov	 ecx, esi
  00024	33 c8		 xor	 ecx, eax

; 272  :     expx &= 0x7fff;

  00026	25 ff 7f 00 00	 and	 eax, 32767		; 00007fffH

; 273  :     expy &= 0x7fff;

  0002b	81 e6 ff 7f 00
	00		 and	 esi, 32767		; 00007fffH

; 274  :     uint16 expsum = expx + expy;

  00031	8d 1c 06	 lea	 ebx, DWORD PTR [esi+eax]
  00034	0f b7 db	 movzx	 ebx, bx
  00037	81 e1 00 80 00
	00		 and	 ecx, 32768		; 00008000H

; 275  :     if (expx >= LD_MAXEXP
; 276  :         || expy >= LD_MAXEXP
; 277  :         || expsum > LD_MAXEXP + LD_BIASM1) {

  0003d	66 3d ff 7f	 cmp	 ax, 32767		; 00007fffH
  00041	89 4d f8	 mov	 DWORD PTR _sign$[ebp], ecx
  00044	89 5d fc	 mov	 DWORD PTR _expsum$[ebp], ebx
  00047	0f 83 3a 02 00
	00		 jae	 $LN29@ld12mul
  0004d	66 81 fe ff 7f	 cmp	 si, 32767		; 00007fffH
  00052	0f 83 2f 02 00
	00		 jae	 $LN29@ld12mul
  00058	66 81 fb fd bf	 cmp	 bx, 49149		; 0000bffdH
  0005d	0f 87 24 02 00
	00		 ja	 $LN29@ld12mul

; 280  :         return;
; 281  :     }
; 282  :     if (expsum <= LD_BIASM1 - 63) {

  00063	66 81 fb bf 3f	 cmp	 bx, 16319		; 00003fbfH
  00068	77 13		 ja	 SHORT $LN28@ld12mul

; 283  :         // underflow to zero
; 284  :         PUT_ZERO_12(px);

  0006a	33 c0		 xor	 eax, eax
$LN61@ld12mul:
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00071	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00074	89 02		 mov	 DWORD PTR [edx], eax
  00076	5b		 pop	 ebx

; 389  : }

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 08 00	 ret	 8
$LN28@ld12mul:

; 285  :         return;
; 286  :     }
; 287  :     if (expx == 0) {

  0007d	66 85 c0	 test	 ax, ax
  00080	75 27		 jne	 SHORT $LN53@ld12mul

; 288  :         // If this is a denormal temp real then the mantissa
; 289  :         // was shifted right once to set bit 63 to zero.
; 290  :         expsum++; // Correct for this

  00082	83 c3 01	 add	 ebx, 1

; 291  :         if (ISZERO_12(px)) {

  00085	33 c0		 xor	 eax, eax
  00087	f7 42 08 ff ff
	ff 7f		 test	 DWORD PTR [edx+8], 2147483647 ; 7fffffffH
  0008e	89 5d fc	 mov	 DWORD PTR _expsum$[ebp], ebx
  00091	75 18		 jne	 SHORT $LN26@ld12mul
  00093	39 42 04	 cmp	 DWORD PTR [edx+4], eax
  00096	75 13		 jne	 SHORT $LN26@ld12mul
  00098	39 02		 cmp	 DWORD PTR [edx], eax
  0009a	75 0f		 jne	 SHORT $LN26@ld12mul
  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi

; 292  :             // put positive sign
; 293  :             *U_EXP_12(px) = 0;

  0009e	66 89 42 0a	 mov	 WORD PTR [edx+10], ax
  000a2	5b		 pop	 ebx

; 389  : }

  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c2 08 00	 ret	 8
$LN53@ld12mul:

; 294  :             return;

  000a9	33 c0		 xor	 eax, eax
$LN26@ld12mul:

; 295  :         }
; 296  :     }
; 297  :     if (expy == 0) {

  000ab	66 3b f0	 cmp	 si, ax
  000ae	75 18		 jne	 SHORT $LN24@ld12mul

; 298  :         expsum++; // because arg2 is denormal

  000b0	83 c3 01	 add	 ebx, 1

; 299  :         if (ISZERO_12(py)) {

  000b3	f7 47 08 ff ff
	ff 7f		 test	 DWORD PTR [edi+8], 2147483647 ; 7fffffffH
  000ba	89 5d fc	 mov	 DWORD PTR _expsum$[ebp], ebx
  000bd	75 09		 jne	 SHORT $LN24@ld12mul
  000bf	39 47 04	 cmp	 DWORD PTR [edi+4], eax
  000c2	75 04		 jne	 SHORT $LN24@ld12mul
  000c4	39 07		 cmp	 DWORD PTR [edi], eax

; 300  :             PUT_ZERO_12(px);
; 301  :             return;

  000c6	74 a4		 je	 SHORT $LN61@ld12mul
$LN24@ld12mul:

; 306  :     for (int i = 0; i < 5; i++) {

  000c8	89 45 f4	 mov	 DWORD PTR _i$11081[ebp], eax
  000cb	b8 05 00 00 00	 mov	 eax, 5
  000d0	8d 75 e4	 lea	 esi, DWORD PTR _tempman$[ebp+4]
  000d3	89 45 ec	 mov	 DWORD PTR tv650[ebp], eax
  000d6	eb 03		 jmp	 SHORT $LN23@ld12mul
$LL58@ld12mul:

; 302  :         }
; 303  :     }
; 304  : 
; 305  :     int roffs = 0;

  000d8	8b 7d 0c	 mov	 edi, DWORD PTR _py$[ebp]
$LN23@ld12mul:

; 307  :         int poffs = i << 1;
; 308  :         int qoffs = 8;
; 309  :         for (int j = 5 - i; j > 0; j--) {

  000db	85 c0		 test	 eax, eax
  000dd	89 45 f0	 mov	 DWORD PTR _j$11087[ebp], eax
  000e0	7e 4b		 jle	 SHORT $LN18@ld12mul
  000e2	8b 45 f4	 mov	 eax, DWORD PTR _i$11081[ebp]
  000e5	8d 5f 08	 lea	 ebx, DWORD PTR [edi+8]
  000e8	8d 3c 42	 lea	 edi, DWORD PTR [edx+eax*2]
  000eb	eb 03 8d 49 00	 npad	 5
$LL20@ld12mul:

; 310  :             uint32 prod;
; 311  :             int carry;
; 312  :             uint16 *p, *q;
; 313  :             uint32 *r;
; 314  :             p = USHORT_12(px,poffs);
; 315  :             q = USHORT_12(py,qoffs);
; 316  :             r = ULONG_12(&tempman,roffs);
; 317  :             prod = (uint32)*p * (uint32)*q;

  000f0	0f b7 0b	 movzx	 ecx, WORD PTR [ebx]
  000f3	0f b7 07	 movzx	 eax, WORD PTR [edi]

; 318  :             carry = addl(*r,prod,r);

  000f6	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  000f9	0f af c1	 imul	 eax, ecx
  000fc	8d 0c 02	 lea	 ecx, DWORD PTR [edx+eax]
  000ff	3b ca		 cmp	 ecx, edx
  00101	89 4e fc	 mov	 DWORD PTR [esi-4], ecx
  00104	72 04		 jb	 SHORT $LN35@ld12mul
  00106	3b c8		 cmp	 ecx, eax
  00108	73 04		 jae	 SHORT $LN54@ld12mul
$LN35@ld12mul:

; 319  :             if (carry) {
; 320  :                 // roffs should be less than 8 in this case
; 321  :                 (*USHORT_12(&tempman,roffs+4))++;

  0010a	66 83 06 01	 add	 WORD PTR [esi], 1
$LN54@ld12mul:

; 307  :         int poffs = i << 1;
; 308  :         int qoffs = 8;
; 309  :         for (int j = 5 - i; j > 0; j--) {

  0010e	8b 45 f0	 mov	 eax, DWORD PTR _j$11087[ebp]
  00111	83 e8 01	 sub	 eax, 1

; 322  :             }
; 323  :             poffs += 2;

  00114	83 c7 02	 add	 edi, 2

; 324  :             qoffs -= 2;

  00117	83 eb 02	 sub	 ebx, 2
  0011a	85 c0		 test	 eax, eax
  0011c	89 45 f0	 mov	 DWORD PTR _j$11087[ebp], eax
  0011f	7f cf		 jg	 SHORT $LL20@ld12mul
  00121	8b 55 08	 mov	 edx, DWORD PTR _px$[ebp]
  00124	8b 5d fc	 mov	 ebx, DWORD PTR _expsum$[ebp]
  00127	8b 4d f8	 mov	 ecx, DWORD PTR _sign$[ebp]
  0012a	8b 45 ec	 mov	 eax, DWORD PTR tv650[ebp]
$LN18@ld12mul:
  0012d	83 45 f4 01	 add	 DWORD PTR _i$11081[ebp], 1
  00131	83 e8 01	 sub	 eax, 1

; 325  :         }
; 326  :         roffs += 2;

  00134	83 c6 02	 add	 esi, 2
  00137	85 c0		 test	 eax, eax
  00139	89 45 ec	 mov	 DWORD PTR tv650[ebp], eax
  0013c	7f 9a		 jg	 SHORT $LL58@ld12mul

; 327  :     }
; 328  : 
; 329  :     expsum -= LD_BIASM1;
; 330  : 
; 331  :     // normalize
; 332  :     while ((int16)expsum > 0 &&
; 333  :            ((*UL_HI_12(&tempman) & MSB_ULONG) == 0)) {

  0013e	8b 75 e8	 mov	 esi, DWORD PTR _tempman$[ebp+8]
  00141	8b 45 e4	 mov	 eax, DWORD PTR _tempman$[ebp+4]
  00144	8b 7d e0	 mov	 edi, DWORD PTR _tempman$[ebp]
  00147	81 c3 02 c0 00
	00		 add	 ebx, 49154		; 0000c002H
  0014d	66 85 db	 test	 bx, bx
  00150	89 5d fc	 mov	 DWORD PTR _expsum$[ebp], ebx
  00153	7e 4d		 jle	 SHORT $LN49@ld12mul
  00155	eb 03		 jmp	 SHORT $LN16@ld12mul
$LL55@ld12mul:
  00157	8b 5d fc	 mov	 ebx, DWORD PTR _expsum$[ebp]
$LN16@ld12mul:
  0015a	85 f6		 test	 esi, esi
  0015c	78 36		 js	 SHORT $LN15@ld12mul

; 334  :         shl_12(&tempman);

  0015e	8b cf		 mov	 ecx, edi
  00160	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00163	8b d0		 mov	 edx, eax
  00165	03 c0		 add	 eax, eax
  00167	0b c1		 or	 eax, ecx

; 335  :         expsum--;

  00169	8b 4d fc	 mov	 ecx, DWORD PTR _expsum$[ebp]
  0016c	c1 ea 1f	 shr	 edx, 31			; 0000001fH
  0016f	03 f6		 add	 esi, esi
  00171	81 c1 ff ff 00
	00		 add	 ecx, 65535		; 0000ffffH
  00177	0b f2		 or	 esi, edx

; 336  :     }
; 337  : 
; 338  :     if ((int16)expsum <= 0) {

  00179	8b 55 08	 mov	 edx, DWORD PTR _px$[ebp]
  0017c	03 ff		 add	 edi, edi
  0017e	89 4d fc	 mov	 DWORD PTR _expsum$[ebp], ecx
  00181	66 85 c9	 test	 cx, cx
  00184	8b 4d f8	 mov	 ecx, DWORD PTR _sign$[ebp]
  00187	7f ce		 jg	 SHORT $LL55@ld12mul
  00189	89 75 e8	 mov	 DWORD PTR _tempman$[ebp+8], esi
  0018c	89 45 e4	 mov	 DWORD PTR _tempman$[ebp+4], eax
  0018f	89 7d e0	 mov	 DWORD PTR _tempman$[ebp], edi
  00192	eb 0e		 jmp	 SHORT $LN49@ld12mul
$LN15@ld12mul:
  00194	66 85 db	 test	 bx, bx
  00197	89 75 e8	 mov	 DWORD PTR _tempman$[ebp+8], esi
  0019a	89 45 e4	 mov	 DWORD PTR _tempman$[ebp+4], eax
  0019d	89 7d e0	 mov	 DWORD PTR _tempman$[ebp], edi
  001a0	7f 64		 jg	 SHORT $LN52@ld12mul
$LN49@ld12mul:

; 339  :         bool sticky = false;
; 340  :         expsum--;

  001a2	8b 5d fc	 mov	 ebx, DWORD PTR _expsum$[ebp]
  001a5	81 c3 ff ff 00
	00		 add	 ebx, 65535		; 0000ffffH

; 341  :         while ((int16)expsum < 0) {

  001ab	66 85 db	 test	 bx, bx
  001ae	c6 45 0f 00	 mov	 BYTE PTR _sticky$11120[ebp], 0
  001b2	7d 52		 jge	 SHORT $LN52@ld12mul
  001b4	8b d3		 mov	 edx, ebx
  001b6	f7 da		 neg	 edx
  001b8	0f b7 ca	 movzx	 ecx, dx
  001bb	03 d9		 add	 ebx, ecx
  001bd	89 5d fc	 mov	 DWORD PTR _expsum$[ebp], ebx
  001c0	8a 5d 0f	 mov	 bl, BYTE PTR _sticky$11120[ebp]
  001c3	89 4d ec	 mov	 DWORD PTR tv257[ebp], ecx
$LL13@ld12mul:

; 342  :             if (*U_XT_12(&tempman) & 0x1) {

  001c6	f6 45 e0 01	 test	 BYTE PTR _tempman$[ebp], 1
  001ca	74 02		 je	 SHORT $LN11@ld12mul

; 343  :                 sticky = true;

  001cc	b3 01		 mov	 bl, 1
$LN11@ld12mul:

; 344  :             }
; 345  :             shr_12(&tempman);

  001ce	8b d0		 mov	 edx, eax
  001d0	8b ce		 mov	 ecx, esi
  001d2	c1 e1 1f	 shl	 ecx, 31			; 0000001fH
  001d5	c1 e2 1f	 shl	 edx, 31			; 0000001fH
  001d8	d1 e8		 shr	 eax, 1
  001da	d1 ef		 shr	 edi, 1
  001dc	0b fa		 or	 edi, edx
  001de	d1 ee		 shr	 esi, 1
  001e0	0b c1		 or	 eax, ecx
  001e2	83 6d ec 01	 sub	 DWORD PTR tv257[ebp], 1
  001e6	89 7d e0	 mov	 DWORD PTR _tempman$[ebp], edi
  001e9	75 db		 jne	 SHORT $LL13@ld12mul

; 346  :             expsum++;
; 347  :         }
; 348  :         if (sticky) {
; 349  :             *U_XT_12(&tempman) |= 0x1;

  001eb	8b 55 08	 mov	 edx, DWORD PTR _px$[ebp]
  001ee	8b 4d f8	 mov	 ecx, DWORD PTR _sign$[ebp]
  001f1	84 db		 test	 bl, bl
  001f3	8b 5d fc	 mov	 ebx, DWORD PTR _expsum$[ebp]
  001f6	89 45 e4	 mov	 DWORD PTR _tempman$[ebp+4], eax
  001f9	89 75 e8	 mov	 DWORD PTR _tempman$[ebp+8], esi
  001fc	74 08		 je	 SHORT $LN52@ld12mul
  001fe	66 83 4d e0 01	 or	 WORD PTR _tempman$[ebp], 1
  00203	8b 7d e0	 mov	 edi, DWORD PTR _tempman$[ebp]
$LN52@ld12mul:

; 350  :         }
; 351  :     }
; 352  : 
; 353  :     if (*U_XT_12(&tempman) > 0x8000 ||
; 354  :         ((*UL_LO_12(&tempman) & 0x1ffff) == 0x18000)) {

  00206	66 81 7d e0 00
	80		 cmp	 WORD PTR _tempman$[ebp], 32768 ; 00008000H
  0020c	77 0e		 ja	 SHORT $LN8@ld12mul
  0020e	81 e7 ff ff 01
	00		 and	 edi, 131071		; 0001ffffH
  00214	81 ff 00 80 01
	00		 cmp	 edi, 98304		; 00018000H
  0021a	75 48		 jne	 SHORT $LN57@ld12mul
$LN8@ld12mul:

; 355  :         // round up
; 356  :         if (*UL_MANLO_12(&tempman) == MAX_ULONG) {

  0021c	83 cf ff	 or	 edi, -1
  0021f	39 7d e2	 cmp	 DWORD PTR _tempman$[ebp+2], edi
  00222	75 39		 jne	 SHORT $LN7@ld12mul

; 357  :             *UL_MANLO_12(&tempman) = 0;

  00224	33 c0		 xor	 eax, eax

; 358  :             if (*UL_MANHI_12(&tempman) == MAX_ULONG) {

  00226	39 7d e6	 cmp	 DWORD PTR _tempman$[ebp+6], edi
  00229	89 45 e2	 mov	 DWORD PTR _tempman$[ebp+2], eax
  0022c	75 26		 jne	 SHORT $LN6@ld12mul

; 359  :                 *UL_MANHI_12(&tempman) = 0;
; 360  :                 if (*U_EXP_12(&tempman) == MAX_USHORT) {

  0022e	66 81 7d ea ff
	ff		 cmp	 WORD PTR _tempman$[ebp+10], 65535 ; 0000ffffH
  00234	89 45 e6	 mov	 DWORD PTR _tempman$[ebp+6], eax

; 361  :                     // 12-byte mantissa overflow
; 362  :                     *U_EXP_12(&tempman) = MSB_USHORT;
; 363  :                     expsum++;
; 364  :                 }
; 365  :                 else {

  00237	8b 45 e4	 mov	 eax, DWORD PTR _tempman$[ebp+4]
  0023a	75 0e		 jne	 SHORT $LN5@ld12mul
  0023c	66 c7 45 ea 00
	80		 mov	 WORD PTR _tempman$[ebp+10], 32768 ; 00008000H
  00242	8b 75 e8	 mov	 esi, DWORD PTR _tempman$[ebp+8]
  00245	83 c3 01	 add	 ebx, 1
  00248	eb 1a		 jmp	 SHORT $LN57@ld12mul
$LN5@ld12mul:

; 366  :                     (*U_EXP_12(&tempman))++;

  0024a	66 83 45 ea 01	 add	 WORD PTR _tempman$[ebp+10], 1

; 367  :                 }
; 368  :             }
; 369  :             else {

  0024f	8b 75 e8	 mov	 esi, DWORD PTR _tempman$[ebp+8]
  00252	eb 10		 jmp	 SHORT $LN57@ld12mul
$LN6@ld12mul:

; 370  :                 (*UL_MANHI_12(&tempman))++;

  00254	83 45 e6 01	 add	 DWORD PTR _tempman$[ebp+6], 1

; 371  :             }
; 372  :         }
; 373  :         else {

  00258	8b 75 e8	 mov	 esi, DWORD PTR _tempman$[ebp+8]
  0025b	eb 04		 jmp	 SHORT $LN60@ld12mul
$LN7@ld12mul:

; 374  :             (*UL_MANLO_12(&tempman))++;

  0025d	83 45 e2 01	 add	 DWORD PTR _tempman$[ebp+2], 1
$LN60@ld12mul:
  00261	8b 45 e4	 mov	 eax, DWORD PTR _tempman$[ebp+4]
$LN57@ld12mul:

; 375  :         }
; 376  :     }
; 377  : 
; 378  :     // check for exponent overflow
; 379  :     if (expsum >= 0x7fff) {

  00264	66 81 fb ff 7f	 cmp	 bx, 32767		; 00007fffH

; 380  :         PUT_INF_12(px, sign);
; 381  :         return;

  00269	73 1c		 jae	 SHORT $LN29@ld12mul

; 382  :     }
; 383  : 
; 384  :     // put result in px
; 385  :     *U_XT_12(px) = *USHORT_12(&tempman,2);

  0026b	66 8b 7d e2	 mov	 di, WORD PTR _tempman$[ebp+2]
  0026f	66 89 3a	 mov	 WORD PTR [edx], di
  00272	5f		 pop	 edi

; 386  :     *UL_MANLO_12(px) = *UL_MED_12(&tempman);
; 387  :     *UL_MANHI_12(px) = *UL_HI_12(&tempman);
; 388  :     *U_EXP_12(px) = expsum | sign;

  00273	0b d9		 or	 ebx, ecx
  00275	89 72 06	 mov	 DWORD PTR [edx+6], esi
  00278	5e		 pop	 esi
  00279	66 89 5a 0a	 mov	 WORD PTR [edx+10], bx
  0027d	89 42 02	 mov	 DWORD PTR [edx+2], eax
  00280	5b		 pop	 ebx

; 389  : }

  00281	8b e5		 mov	 esp, ebp
  00283	5d		 pop	 ebp
  00284	c2 08 00	 ret	 8
$LN29@ld12mul:

; 278  :         // overflow to infinity
; 279  :         PUT_INF_12(px,sign);

  00287	66 f7 d9	 neg	 cx
  0028a	5f		 pop	 edi
  0028b	5e		 pop	 esi
  0028c	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  00292	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
  00299	5b		 pop	 ebx
  0029a	1b c9		 sbb	 ecx, ecx
  0029c	81 e1 00 00 00
	80		 and	 ecx, -2147483648	; 80000000H
  002a2	81 c1 00 80 ff
	7f		 add	 ecx, 2147450880		; 7fff8000H
  002a8	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 389  : }

  002ab	8b e5		 mov	 esp, ebp
  002ad	5d		 pop	 ebp
  002ae	c2 08 00	 ret	 8
?ld12mul@@YIXPAU_LDBL12@@0@Z ENDP			; ld12mul
_TEXT	ENDS
;	COMDAT ?_pow10neg@?1??multtenpow12@@YIXPAU_LDBL12@@H@Z@4PAU2@A
_DATA	SEGMENT
?_pow10neg@?1??multtenpow12@@YIXPAU_LDBL12@@H@Z@4PAU2@A DB 0cdH ; `multtenpow12'::`2'::_pow10neg
	DB	0ccH
	DB	0cdH
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	0fbH
	DB	03fH
	DB	071H
	DB	03dH
	DB	0aH
	DB	0d7H
	DB	0a3H
	DB	070H
	DB	03dH
	DB	0aH
	DB	0d7H
	DB	0a3H
	DB	0f8H
	DB	03fH
	DB	05aH
	DB	064H
	DB	03bH
	DB	0dfH
	DB	04fH
	DB	08dH
	DB	097H
	DB	06eH
	DB	012H
	DB	083H
	DB	0f5H
	DB	03fH
	DB	0c3H
	DB	0d3H
	DB	02cH
	DB	065H
	DB	019H
	DB	0e2H
	DB	058H
	DB	017H
	DB	0b7H
	DB	0d1H
	DB	0f1H
	DB	03fH
	DB	0d0H
	DB	0fH
	DB	023H
	DB	084H
	DB	047H
	DB	01bH
	DB	047H
	DB	0acH
	DB	0c5H
	DB	0a7H
	DB	0eeH
	DB	03fH
	DB	040H
	DB	0a6H
	DB	0b6H
	DB	069H
	DB	06cH
	DB	0afH
	DB	05H
	DB	0bdH
	DB	037H
	DB	086H
	DB	0ebH
	DB	03fH
	DB	033H
	DB	03dH
	DB	0bcH
	DB	042H
	DB	07aH
	DB	0e5H
	DB	0d5H
	DB	094H
	DB	0bfH
	DB	0d6H
	DB	0e7H
	DB	03fH
	DB	0c2H
	DB	0fdH
	DB	0fdH
	DB	0ceH
	DB	061H
	DB	084H
	DB	011H
	DB	077H
	DB	0ccH
	DB	0abH
	DB	0e4H
	DB	03fH
	DB	02fH
	DB	04cH
	DB	05bH
	DB	0e1H
	DB	04dH
	DB	0c4H
	DB	0beH
	DB	094H
	DB	095H
	DB	0e6H
	DB	0c9H
	DB	03fH
	DB	092H
	DB	0c4H
	DB	053H
	DB	03bH
	DB	075H
	DB	044H
	DB	0cdH
	DB	014H
	DB	0beH
	DB	09aH
	DB	0afH
	DB	03fH
	DB	0deH
	DB	067H
	DB	0baH
	DB	094H
	DB	039H
	DB	045H
	DB	0adH
	DB	01eH
	DB	0b1H
	DB	0cfH
	DB	094H
	DB	03fH
	DB	024H
	DB	023H
	DB	0c6H
	DB	0e2H
	DB	0bcH
	DB	0baH
	DB	03bH
	DB	031H
	DB	061H
	DB	08bH
	DB	07aH
	DB	03fH
	DB	061H
	DB	055H
	DB	059H
	DB	0c1H
	DB	07eH
	DB	0b1H
	DB	053H
	DB	07cH
	DB	012H
	DB	0bbH
	DB	05fH
	DB	03fH
	DB	0d7H
	DB	0eeH
	DB	02fH
	DB	08dH
	DB	06H
	DB	0beH
	DB	092H
	DB	085H
	DB	015H
	DB	0fbH
	DB	044H
	DB	03fH
	DB	024H
	DB	03fH
	DB	0a5H
	DB	0e9H
	DB	039H
	DB	0a5H
	DB	027H
	DB	0eaH
	DB	07fH
	DB	0a8H
	DB	02aH
	DB	03fH
	DB	07dH
	DB	0acH
	DB	0a1H
	DB	0e4H
	DB	0bcH
	DB	064H
	DB	07cH
	DB	046H
	DB	0d0H
	DB	0ddH
	DB	055H
	DB	03eH
	DB	063H
	DB	07bH
	DB	06H
	DB	0ccH
	DB	023H
	DB	054H
	DB	077H
	DB	083H
	DB	0ffH
	DB	091H
	DB	081H
	DB	03dH
	DB	091H
	DB	0faH
	DB	03aH
	DB	019H
	DB	07aH
	DB	063H
	DB	025H
	DB	043H
	DB	031H
	DB	0c0H
	DB	0acH
	DB	03cH
	DB	021H
	DB	089H
	DB	0d1H
	DB	038H
	DB	082H
	DB	047H
	DB	097H
	DB	0b8H
	DB	00H
	DB	0fdH
	DB	0d7H
	DB	03bH
	DB	0dcH
	DB	088H
	DB	058H
	DB	08H
	DB	01bH
	DB	0b1H
	DB	0e8H
	DB	0e3H
	DB	086H
	DB	0a6H
	DB	03H
	DB	03bH
	DB	0c6H
	DB	084H
	DB	045H
	DB	042H
	DB	07H
	DB	0b6H
	DB	099H
	DB	075H
	DB	037H
	DB	0dbH
	DB	02eH
	DB	03aH
	DB	033H
	DB	071H
	DB	01cH
	DB	0d2H
	DB	023H
	DB	0dbH
	DB	032H
	DB	0eeH
	DB	049H
	DB	090H
	DB	05aH
	DB	039H
	DB	0a6H
	DB	087H
	DB	0beH
	DB	0c0H
	DB	057H
	DB	0daH
	DB	0a5H
	DB	082H
	DB	0a6H
	DB	0a2H
	DB	0b5H
	DB	032H
	DB	0e2H
	DB	068H
	DB	0b2H
	DB	011H
	DB	0a7H
	DB	052H
	DB	09fH
	DB	044H
	DB	059H
	DB	0b7H
	DB	010H
	DB	02cH
	DB	025H
	DB	049H
	DB	0e4H
	DB	02dH
	DB	036H
	DB	034H
	DB	04fH
	DB	053H
	DB	0aeH
	DB	0ceH
	DB	06bH
	DB	025H
	DB	08fH
	DB	059H
	DB	04H
	DB	0a4H
	DB	0c0H
	DB	0deH
	DB	0c2H
	DB	07dH
	DB	0fbH
	DB	0e8H
	DB	0c6H
	DB	01eH
	DB	09eH
	DB	0e7H
	DB	088H
	DB	05aH
	DB	057H
	DB	091H
	DB	03cH
	DB	0bfH
	DB	050H
	DB	083H
	DB	022H
	DB	018H
	DB	04eH
	DB	04bH
	DB	065H
	DB	062H
	DB	0fdH
	DB	083H
	DB	08fH
	DB	0afH
	DB	06H
	DB	094H
	DB	07dH
	DB	011H
	DB	0e4H
	DB	02dH
	DB	0deH
	DB	09fH
	DB	0ceH
	DB	0d2H
	DB	0c8H
	DB	04H
	DB	0ddH
	DB	0a6H
	DB	0d8H
	DB	0aH
_DATA	ENDS
;	COMDAT ?_pow10pos@?1??multtenpow12@@YIXPAU_LDBL12@@H@Z@4PAU2@A
_DATA	SEGMENT
?_pow10pos@?1??multtenpow12@@YIXPAU_LDBL12@@H@Z@4PAU2@A DB 00H ; `multtenpow12'::`2'::_pow10pos
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0a0H
	DB	02H
	DB	040H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0c8H
	DB	05H
	DB	040H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0faH
	DB	08H
	DB	040H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	040H
	DB	09cH
	DB	0cH
	DB	040H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	050H
	DB	0c3H
	DB	0fH
	DB	040H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	024H
	DB	0f4H
	DB	012H
	DB	040H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	080H
	DB	096H
	DB	098H
	DB	016H
	DB	040H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	020H
	DB	0bcH
	DB	0beH
	DB	019H
	DB	040H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	04H
	DB	0bfH
	DB	0c9H
	DB	01bH
	DB	08eH
	DB	034H
	DB	040H
	DB	00H
	DB	00H
	DB	00H
	DB	0a1H
	DB	0edH
	DB	0ccH
	DB	0ceH
	DB	01bH
	DB	0c2H
	DB	0d3H
	DB	04eH
	DB	040H
	DB	020H
	DB	0f0H
	DB	09eH
	DB	0b5H
	DB	070H
	DB	02bH
	DB	0a8H
	DB	0adH
	DB	0c5H
	DB	09dH
	DB	069H
	DB	040H
	DB	0d0H
	DB	05dH
	DB	0fdH
	DB	025H
	DB	0e5H
	DB	01aH
	DB	08eH
	DB	04fH
	DB	019H
	DB	0ebH
	DB	083H
	DB	040H
	DB	071H
	DB	096H
	DB	0d7H
	DB	095H
	DB	043H
	DB	0eH
	DB	05H
	DB	08dH
	DB	029H
	DB	0afH
	DB	09eH
	DB	040H
	DB	0f9H
	DB	0bfH
	DB	0a0H
	DB	044H
	DB	0edH
	DB	081H
	DB	012H
	DB	08fH
	DB	081H
	DB	082H
	DB	0b9H
	DB	040H
	DB	0bfH
	DB	03cH
	DB	0d5H
	DB	0a6H
	DB	0cfH
	DB	0ffH
	DB	049H
	DB	01fH
	DB	078H
	DB	0c2H
	DB	0d3H
	DB	040H
	DB	06fH
	DB	0c6H
	DB	0e0H
	DB	08cH
	DB	0e9H
	DB	080H
	DB	0c9H
	DB	047H
	DB	0baH
	DB	093H
	DB	0a8H
	DB	041H
	DB	0bcH
	DB	085H
	DB	06bH
	DB	055H
	DB	027H
	DB	039H
	DB	08dH
	DB	0f7H
	DB	070H
	DB	0e0H
	DB	07cH
	DB	042H
	DB	0bcH
	DB	0ddH
	DB	08eH
	DB	0deH
	DB	0f9H
	DB	09dH
	DB	0fbH
	DB	0ebH
	DB	07eH
	DB	0aaH
	DB	051H
	DB	043H
	DB	0a1H
	DB	0e6H
	DB	076H
	DB	0e3H
	DB	0ccH
	DB	0f2H
	DB	029H
	DB	02fH
	DB	084H
	DB	081H
	DB	026H
	DB	044H
	DB	028H
	DB	010H
	DB	017H
	DB	0aaH
	DB	0f8H
	DB	0aeH
	DB	010H
	DB	0e3H
	DB	0c5H
	DB	0c4H
	DB	0faH
	DB	044H
	DB	0ebH
	DB	0a7H
	DB	0d4H
	DB	0f3H
	DB	0f7H
	DB	0ebH
	DB	0e1H
	DB	04aH
	DB	07aH
	DB	095H
	DB	0cfH
	DB	045H
	DB	065H
	DB	0ccH
	DB	0c7H
	DB	091H
	DB	0eH
	DB	0a6H
	DB	0aeH
	DB	0a0H
	DB	019H
	DB	0e3H
	DB	0a3H
	DB	046H
	DB	0dH
	DB	065H
	DB	017H
	DB	0cH
	DB	075H
	DB	081H
	DB	086H
	DB	075H
	DB	076H
	DB	0c9H
	DB	048H
	DB	04dH
	DB	058H
	DB	042H
	DB	0e4H
	DB	0a7H
	DB	093H
	DB	039H
	DB	03bH
	DB	035H
	DB	0b8H
	DB	0b2H
	DB	0edH
	DB	053H
	DB	04dH
	DB	0a7H
	DB	0e5H
	DB	05dH
	DB	03dH
	DB	0c5H
	DB	05dH
	DB	03bH
	DB	08bH
	DB	09eH
	DB	092H
	DB	05aH
	DB	0ffH
	DB	05dH
	DB	0a6H
	DB	0f0H
	DB	0a1H
	DB	020H
	DB	0c0H
	DB	054H
	DB	0a5H
	DB	08cH
	DB	037H
	DB	061H
	DB	0d1H
	DB	0fdH
	DB	08bH
	DB	05aH
	DB	08bH
	DB	0d8H
	DB	025H
	DB	05dH
	DB	089H
	DB	0f9H
	DB	0dbH
	DB	067H
	DB	0aaH
	DB	095H
	DB	0f8H
	DB	0f3H
	DB	027H
	DB	0bfH
	DB	0a2H
	DB	0c8H
	DB	05dH
	DB	0ddH
	DB	080H
	DB	06eH
	DB	04cH
	DB	0c9H
	DB	09bH
	DB	097H
	DB	020H
	DB	08aH
	DB	02H
	DB	052H
	DB	060H
	DB	0c4H
	DB	025H
	DB	075H
; Function compile flags: /Ogtp
_DATA	ENDS
;	COMDAT ?multtenpow12@@YIXPAU_LDBL12@@H@Z
_TEXT	SEGMENT
_unround$11207 = -12					; size = 12
?multtenpow12@@YIXPAU_LDBL12@@H@Z PROC			; multtenpow12, COMDAT
; _pld12$ = ebx
; _pow$ = eax

; 392  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi

; 393  :     //////////////////////////////////////////////////////////////////////////////
; 394  :     //
; 395  :     // Format: A 10 byte long double + 2 bytes of extra precision
; 396  :     // If the extra precision is desired, the 10-byte long double
; 397  :     // should be "unrounded" first.
; 398  :     //
; 399  :     static _LDBL12 _pow10pos[] = {
; 400  : #if defined(LITTLE_ENDIAN)
; 401  :         {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x02,0x40}},   // P0001
; 402  :         {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x05,0x40}},   // P0002
; 403  :         {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFA,0x08,0x40}},   // P0003
; 404  :         {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x9C,0x0C,0x40}},   // P0004
; 405  :         {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x50,0xC3,0x0F,0x40}},   // P0005
; 406  :         {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x24,0xF4,0x12,0x40}},   // P0006
; 407  :         {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x80,0x96,0x98,0x16,0x40}},   // P0007
; 408  :         {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x20,0xBC,0xBE,0x19,0x40}},   // P0008
; 409  :         {{0x00,0x00, 0x00,0x00,0x00,0x04,0xBF,0xC9,0x1B,0x8E,0x34,0x40}},   // P0016
; 410  :         {{0x00,0x00, 0x00,0xA1,0xED,0xCC,0xCE,0x1B,0xC2,0xD3,0x4E,0x40}},   // P0024
; 411  :         {{0x20,0xF0, 0x9E,0xB5,0x70,0x2B,0xA8,0xAD,0xC5,0x9D,0x69,0x40}},   // P0032
; 412  :         {{0xD0,0x5D, 0xFD,0x25,0xE5,0x1A,0x8E,0x4F,0x19,0xEB,0x83,0x40}},   // P0040
; 413  :         {{0x71,0x96, 0xD7,0x95,0x43,0x0E,0x05,0x8D,0x29,0xAF,0x9E,0x40}},   // P0048
; 414  :         {{0xF9,0xBF, 0xA0,0x44,0xED,0x81,0x12,0x8F,0x81,0x82,0xB9,0x40}},   // P0056
; 415  :         {{0xBF,0x3C, 0xD5,0xA6,0xCF,0xFF,0x49,0x1F,0x78,0xC2,0xD3,0x40}},   // P0064
; 416  :         {{0x6F,0xC6, 0xE0,0x8C,0xE9,0x80,0xC9,0x47,0xBA,0x93,0xA8,0x41}},   // P0128
; 417  :         {{0xBC,0x85, 0x6B,0x55,0x27,0x39,0x8D,0xF7,0x70,0xE0,0x7C,0x42}},   // P0192
; 418  :         {{0xBC,0xDD, 0x8E,0xDE,0xF9,0x9D,0xFB,0xEB,0x7E,0xAA,0x51,0x43}},   // P0256
; 419  :         {{0xA1,0xE6, 0x76,0xE3,0xCC,0xF2,0x29,0x2F,0x84,0x81,0x26,0x44}},   // P0320
; 420  :         {{0x28,0x10, 0x17,0xAA,0xF8,0xAE,0x10,0xE3,0xC5,0xC4,0xFA,0x44}},   // P0384
; 421  :         {{0xEB,0xA7, 0xD4,0xF3,0xF7,0xEB,0xE1,0x4A,0x7A,0x95,0xCF,0x45}},   // P0448
; 422  :         {{0x65,0xCC, 0xC7,0x91,0x0E,0xA6,0xAE,0xA0,0x19,0xE3,0xA3,0x46}},   // P0512
; 423  :         {{0x0D,0x65, 0x17,0x0C,0x75,0x81,0x86,0x75,0x76,0xC9,0x48,0x4D}},   // P1024
; 424  :         {{0x58,0x42, 0xE4,0xA7,0x93,0x39,0x3B,0x35,0xB8,0xB2,0xED,0x53}},   // P1536
; 425  :         {{0x4D,0xA7, 0xE5,0x5D,0x3D,0xC5,0x5D,0x3B,0x8B,0x9E,0x92,0x5A}},   // P2048
; 426  :         {{0xFF,0x5D, 0xA6,0xF0,0xA1,0x20,0xC0,0x54,0xA5,0x8C,0x37,0x61}},   // P2560
; 427  :         {{0xD1,0xFD, 0x8B,0x5A,0x8B,0xD8,0x25,0x5D,0x89,0xF9,0xDB,0x67}},   // P3072
; 428  :         {{0xAA,0x95, 0xF8,0xF3,0x27,0xBF,0xA2,0xC8,0x5D,0xDD,0x80,0x6E}},   // P3584
; 429  :         {{0x4C,0xC9, 0x9B,0x97,0x20,0x8A,0x02,0x52,0x60,0xC4,0x25,0x75}}    // P4096
; 430  : #endif
; 431  : #if defined(BIG_ENDIAN)
; 432  :         {{0x40,0x02,0xA0,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},   // P0001
; 433  :         {{0x40,0x05,0xC8,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},   // P0002
; 434  :         {{0x40,0x08,0xFA,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},   // P0003
; 435  :         {{0x40,0x0C,0x9C,0x40,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},   // P0004
; 436  :         {{0x40,0x0F,0xC3,0x50,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},   // P0005
; 437  :         {{0x40,0x12,0xF4,0x24,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},   // P0006
; 438  :         {{0x40,0x16,0x98,0x96,0x80,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},   // P0007
; 439  :         {{0x40,0x19,0xBE,0xBC,0x20,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},   // P0008
; 440  :         {{0x40,0x34,0x8E,0x1B,0xC9,0xBF,0x04,0x00,0x00,0x00, 0x00,0x00}},   // P0016
; 441  :         {{0x40,0x4E,0xD3,0xC2,0x1B,0xCE,0xCC,0xED,0xA1,0x00, 0x00,0x00}},   // P0024
; 442  :         {{0x40,0x69,0x9D,0xC5,0xAD,0xA8,0x2B,0x70,0xB5,0x9E, 0xF0,0x20}},   // P0032
; 443  :         {{0x40,0x83,0xEB,0x19,0x4F,0x8E,0x1A,0xE5,0x25,0xFD, 0x5D,0xD0}},   // P0040
; 444  :         {{0x40,0x9E,0xAF,0x29,0x8D,0x05,0x0E,0x43,0x95,0xD7, 0x96,0x71}},   // P0048
; 445  :         {{0x40,0xB9,0x82,0x81,0x8F,0x12,0x81,0xED,0x44,0xA0, 0xBF,0xF9}},   // P0056
; 446  :         {{0x40,0xD3,0xC2,0x78,0x1F,0x49,0xFF,0xCF,0xA6,0xD5, 0x3C,0xBF}},   // P0064
; 447  :         {{0x41,0xA8,0x93,0xBA,0x47,0xC9,0x80,0xE9,0x8C,0xE0, 0xC6,0x6F}},   // P0128
; 448  :         {{0x42,0x7C,0xE0,0x70,0xF7,0x8D,0x39,0x27,0x55,0x6B, 0x85,0xBC}},   // P0192
; 449  :         {{0x43,0x51,0xAA,0x7E,0xEB,0xFB,0x9D,0xF9,0xDE,0x8E, 0xDD,0xBC}},   // P0256
; 450  :         {{0x44,0x26,0x81,0x84,0x2F,0x29,0xF2,0xCC,0xE3,0x76, 0xE6,0xA1}},   // P0320
; 451  :         {{0x44,0xFA,0xC4,0xC5,0xE3,0x10,0xAE,0xF8,0xAA,0x17, 0x10,0x28}},   // P0384
; 452  :         {{0x45,0xCF,0x95,0x7A,0x4A,0xE1,0xEB,0xF7,0xF3,0xD4, 0xA7,0xEB}},   // P0448
; 453  :         {{0x46,0xA3,0xE3,0x19,0xA0,0xAE,0xA6,0x0E,0x91,0xC7, 0xCC,0x65}},   // P0512
; 454  :         {{0x4D,0x48,0xC9,0x76,0x75,0x86,0x81,0x75,0x0C,0x17, 0x65,0x0D}},   // P1024
; 455  :         {{0x53,0xED,0xB2,0xB8,0x35,0x3B,0x39,0x93,0xA7,0xE4, 0x42,0x58}},   // P1536
; 456  :         {{0x5A,0x92,0x9E,0x8B,0x3B,0x5D,0xC5,0x3D,0x5D,0xE5, 0xA7,0x4D}},   // P2048
; 457  :         {{0x61,0x37,0x8C,0xA5,0x54,0xC0,0x20,0xA1,0xF0,0xA6, 0x5D,0xFF}},   // P2560
; 458  :         {{0x67,0xDB,0xF9,0x89,0x5D,0x25,0xD8,0x8B,0x5A,0x8B, 0xFD,0xD1}},   // P3072
; 459  :         {{0x6E,0x80,0xDD,0x5D,0xC8,0xA2,0xBF,0x27,0xF3,0xF8, 0x95,0xAA}},   // P3584
; 460  :         {{0x75,0x25,0xC4,0x60,0x52,0x02,0x8A,0x20,0x97,0x9B, 0xC9,0x4C}}    // P4096
; 461  : #endif
; 462  :     };
; 463  : 
; 464  :     static _LDBL12 _pow10neg[] = {
; 465  : #if defined(LITTLE_ENDIAN)
; 466  :         {{0xCD,0xCC, 0xCD,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xFB,0x3F}},   // N0001
; 467  :         {{0x71,0x3D, 0x0A,0xD7,0xA3,0x70,0x3D,0x0A,0xD7,0xA3,0xF8,0x3F}},   // N0002
; 468  :         {{0x5A,0x64, 0x3B,0xDF,0x4F,0x8D,0x97,0x6E,0x12,0x83,0xF5,0x3F}},   // N0003
; 469  :         {{0xC3,0xD3, 0x2C,0x65,0x19,0xE2,0x58,0x17,0xB7,0xD1,0xF1,0x3F}},   // N0004
; 470  :         {{0xD0,0x0F, 0x23,0x84,0x47,0x1B,0x47,0xAC,0xC5,0xA7,0xEE,0x3F}},   // N0005
; 471  :         {{0x40,0xA6, 0xB6,0x69,0x6C,0xAF,0x05,0xBD,0x37,0x86,0xEB,0x3F}},   // N0006
; 472  :         {{0x33,0x3D, 0xBC,0x42,0x7A,0xE5,0xD5,0x94,0xBF,0xD6,0xE7,0x3F}},   // N0007
; 473  :         {{0xC2,0xFD, 0xFD,0xCE,0x61,0x84,0x11,0x77,0xCC,0xAB,0xE4,0x3F}},   // N0008
; 474  :         {{0x2F,0x4C, 0x5B,0xE1,0x4D,0xC4,0xBE,0x94,0x95,0xE6,0xC9,0x3F}},   // N0016
; 475  :         {{0x92,0xC4, 0x53,0x3B,0x75,0x44,0xCD,0x14,0xBE,0x9A,0xAF,0x3F}},   // N0024
; 476  :         {{0xDE,0x67, 0xBA,0x94,0x39,0x45,0xAD,0x1E,0xB1,0xCF,0x94,0x3F}},   // N0032
; 477  :         {{0x24,0x23, 0xC6,0xE2,0xBC,0xBA,0x3B,0x31,0x61,0x8B,0x7A,0x3F}},   // N0040
; 478  :         {{0x61,0x55, 0x59,0xC1,0x7E,0xB1,0x53,0x7C,0x12,0xBB,0x5F,0x3F}},   // N0048
; 479  :         {{0xD7,0xEE, 0x2F,0x8D,0x06,0xBE,0x92,0x85,0x15,0xFB,0x44,0x3F}},   // N0056
; 480  :         {{0x24,0x3F, 0xA5,0xE9,0x39,0xA5,0x27,0xEA,0x7F,0xA8,0x2A,0x3F}},   // N0064
; 481  :         {{0x7D,0xAC, 0xA1,0xE4,0xBC,0x64,0x7C,0x46,0xD0,0xDD,0x55,0x3E}},   // N0128
; 482  :         {{0x63,0x7B, 0x06,0xCC,0x23,0x54,0x77,0x83,0xFF,0x91,0x81,0x3D}},   // N0192
; 483  :         {{0x91,0xFA, 0x3A,0x19,0x7A,0x63,0x25,0x43,0x31,0xC0,0xAC,0x3C}},   // N0256
; 484  :         {{0x21,0x89, 0xD1,0x38,0x82,0x47,0x97,0xB8,0x00,0xFD,0xD7,0x3B}},   // N0320
; 485  :         {{0xDC,0x88, 0x58,0x08,0x1B,0xB1,0xE8,0xE3,0x86,0xA6,0x03,0x3B}},   // N0384
; 486  :         {{0xC6,0x84, 0x45,0x42,0x07,0xB6,0x99,0x75,0x37,0xDB,0x2E,0x3A}},   // N0448
; 487  :         {{0x33,0x71, 0x1C,0xD2,0x23,0xDB,0x32,0xEE,0x49,0x90,0x5A,0x39}},   // N0512
; 488  :         {{0xA6,0x87, 0xBE,0xC0,0x57,0xDA,0xA5,0x82,0xA6,0xA2,0xB5,0x32}},   // N1024
; 489  :         {{0xE2,0x68, 0xB2,0x11,0xA7,0x52,0x9F,0x44,0x59,0xB7,0x10,0x2C}},   // N1536
; 490  :         {{0x25,0x49, 0xE4,0x2D,0x36,0x34,0x4F,0x53,0xAE,0xCE,0x6B,0x25}},   // N2048
; 491  :         {{0x8F,0x59, 0x04,0xA4,0xC0,0xDE,0xC2,0x7D,0xFB,0xE8,0xC6,0x1E}},   // N2560
; 492  :         {{0x9E,0xE7, 0x88,0x5A,0x57,0x91,0x3C,0xBF,0x50,0x83,0x22,0x18}},   // N3072
; 493  :         {{0x4E,0x4B, 0x65,0x62,0xFD,0x83,0x8F,0xAF,0x06,0x94,0x7D,0x11}},   // N3584
; 494  :         {{0xE4,0x2D, 0xDE,0x9F,0xCE,0xD2,0xC8,0x04,0xDD,0xA6,0xD8,0x0A}}    // N4096
; 495  : #endif
; 496  : #if defined(BIG_ENDIAN)
; 497  :         {{0x3F,0xFB,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCD, 0xCC,0xCD}},   // N0001
; 498  :         {{0x3F,0xF8,0xA3,0xD7,0x0A,0x3D,0x70,0xA3,0xD7,0x0A, 0x3D,0x71}},   // N0002
; 499  :         {{0x3F,0xF5,0x83,0x12,0x6E,0x97,0x8D,0x4F,0xDF,0x3B, 0x64,0x5A}},   // N0003
; 500  :         {{0x3F,0xF1,0xD1,0xB7,0x17,0x58,0xE2,0x19,0x65,0x2C, 0xD3,0xC3}},   // N0004
; 501  :         {{0x3F,0xEE,0xA7,0xC5,0xAC,0x47,0x1B,0x47,0x84,0x23, 0x0F,0xD0}},   // N0005
; 502  :         {{0x3F,0xEB,0x86,0x37,0xBD,0x05,0xAF,0x6C,0x69,0xB6, 0xA6,0x40}},   // N0006
; 503  :         {{0x3F,0xE7,0xD6,0xBF,0x94,0xD5,0xE5,0x7A,0x42,0xBC, 0x3D,0x33}},   // N0007
; 504  :         {{0x3F,0xE4,0xAB,0xCC,0x77,0x11,0x84,0x61,0xCE,0xFD, 0xFD,0xC2}},   // N0008
; 505  :         {{0x3F,0xC9,0xE6,0x95,0x94,0xBE,0xC4,0x4D,0xE1,0x5B, 0x4C,0x2F}},   // N0016
; 506  :         {{0x3F,0xAF,0x9A,0xBE,0x14,0xCD,0x44,0x75,0x3B,0x53, 0xC4,0x92}},   // N0024
; 507  :         {{0x3F,0x94,0xCF,0xB1,0x1E,0xAD,0x45,0x39,0x94,0xBA, 0x67,0xDE}},   // N0032
; 508  :         {{0x3F,0x7A,0x8B,0x61,0x31,0x3B,0xBA,0xBC,0xE2,0xC6, 0x23,0x24}},   // N0040
; 509  :         {{0x3F,0x5F,0xBB,0x12,0x7C,0x53,0xB1,0x7E,0xC1,0x59, 0x55,0x61}},   // N0048
; 510  :         {{0x3F,0x44,0xFB,0x15,0x85,0x92,0xBE,0x06,0x8D,0x2F, 0xEE,0xD7}},   // N0056
; 511  :         {{0x3F,0x2A,0xA8,0x7F,0xEA,0x27,0xA5,0x39,0xE9,0xA5, 0x3F,0x24}},   // N0064
; 512  :         {{0x3E,0x55,0xDD,0xD0,0x46,0x7C,0x64,0xBC,0xE4,0xA1, 0xAC,0x7D}},   // N0128
; 513  :         {{0x3D,0x81,0x91,0xFF,0x83,0x77,0x54,0x23,0xCC,0x06, 0x7B,0x63}},   // N0192
; 514  :         {{0x3C,0xAC,0xC0,0x31,0x43,0x25,0x63,0x7A,0x19,0x3A, 0xFA,0x91}},   // N0256
; 515  :         {{0x3B,0xD7,0xFD,0x00,0xB8,0x97,0x47,0x82,0x38,0xD1, 0x89,0x21}},   // N0320
; 516  :         {{0x3B,0x03,0xA6,0x86,0xE3,0xE8,0xB1,0x1B,0x08,0x58, 0x88,0xDC}},   // N0384
; 517  :         {{0x3A,0x2E,0xDB,0x37,0x75,0x99,0xB6,0x07,0x42,0x45, 0x84,0xC6}},   // N0448
; 518  :         {{0x39,0x5A,0x90,0x49,0xEE,0x32,0xDB,0x23,0xD2,0x1C, 0x71,0x33}},   // N0512
; 519  :         {{0x32,0xB5,0xA2,0xA6,0x82,0xA5,0xDA,0x57,0xC0,0xBE, 0x87,0xA6}},   // N1024
; 520  :         {{0x2C,0x10,0xB7,0x59,0x44,0x9F,0x52,0xA7,0x11,0xB2, 0x68,0xE2}},   // N1536
; 521  :         {{0x25,0x6B,0xCE,0xAE,0x53,0x4F,0x34,0x36,0x2D,0xE4, 0x49,0x25}},   // N2048
; 522  :         {{0x1E,0xC6,0xE8,0xFB,0x7D,0xC2,0xDE,0xC0,0xA4,0x04, 0x59,0x8F}},   // N2560
; 523  :         {{0x18,0x22,0x83,0x50,0xBF,0x3C,0x91,0x57,0x5A,0x88, 0xE7,0x9E}},   // N3072
; 524  :         {{0x11,0x7D,0x94,0x06,0xAF,0x8F,0x83,0xFD,0x62,0x65, 0x4B,0x4E}},   // N3584
; 525  :         {{0x0A,0xD8,0xA6,0xDD,0x04,0xC8,0xD2,0xCE,0x9F,0xDE, 0x2D,0xE4}}    // N4096
; 526  : #endif
; 527  :     };
; 528  : 
; 529  :     _LDBL12 *pow_10p = _pow10pos - 8;

  00008	be 00 00 00 00	 mov	 esi, OFFSET ?_pow10pos@?1??multtenpow12@@YIXPAU_LDBL12@@H@Z@4PAU2@A
  0000d	8b f8		 mov	 edi, eax
  0000f	83 ee 60	 sub	 esi, 96			; 00000060H

; 530  :     if (pow == 0) {

  00012	85 ff		 test	 edi, edi
  00014	74 50		 je	 SHORT $LN3@multtenpow

; 531  :         return;
; 532  :     }
; 533  :     if (pow < 0) {

  00016	7d 0a		 jge	 SHORT $LN10@multtenpow

; 534  :         pow = -pow;
; 535  :         pow_10p = _pow10neg - 8;

  00018	be 00 00 00 00	 mov	 esi, OFFSET ?_pow10neg@?1??multtenpow12@@YIXPAU_LDBL12@@H@Z@4PAU2@A
  0001d	f7 df		 neg	 edi
  0001f	83 ee 60	 sub	 esi, 96			; 00000060H
$LN10@multtenpow:

; 536  :     }
; 537  : 
; 538  :     while (pow) {

  00022	85 ff		 test	 edi, edi
  00024	74 40		 je	 SHORT $LN3@multtenpow
$LL4@multtenpow:

; 539  :         pow_10p += 7;
; 540  :         int last3 = pow & 0x7;  // the 3 LSBits of pow

  00026	8b c7		 mov	 eax, edi
  00028	83 e0 07	 and	 eax, 7
  0002b	83 c6 54	 add	 esi, 84			; 00000054H

; 541  :         pow >>= 3;

  0002e	c1 ff 03	 sar	 edi, 3

; 542  :         if (last3 == 0) {

  00031	85 c0		 test	 eax, eax
  00033	74 2d		 je	 SHORT $LN11@multtenpow

; 543  :             continue;
; 544  :         }
; 545  :         _LDBL12 *py = pow_10p + last3;

  00035	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]

; 546  : 
; 547  :         // do an exact 12 byte multiplication
; 548  :         if (*U_XT_12(py) >= 0x8000) {

  00038	66 81 3c 86 00
	80		 cmp	 WORD PTR [esi+eax*4], 32768 ; 00008000H
  0003e	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  00041	72 18		 jb	 SHORT $LN1@multtenpow

; 549  : 
; 550  :             _LDBL12 unround = *py;      // copy number

  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00048	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0004b	89 4d f4	 mov	 DWORD PTR _unround$11207[ebp], ecx
  0004e	89 55 f8	 mov	 DWORD PTR _unround$11207[ebp+4], edx

; 551  :             (*UL_MANLO_12(&unround))--; // unround adjacent byte

  00051	83 6d f6 01	 sub	 DWORD PTR _unround$11207[ebp+2], 1
  00055	89 45 fc	 mov	 DWORD PTR _unround$11207[ebp+8], eax

; 552  :             py = &unround;              // point to new operand

  00058	8d 45 f4	 lea	 eax, DWORD PTR _unround$11207[ebp]
$LN1@multtenpow:

; 553  :         }
; 554  :         ld12mul(pld12, py);

  0005b	50		 push	 eax
  0005c	53		 push	 ebx
  0005d	e8 00 00 00 00	 call	 ?ld12mul@@YIXPAU_LDBL12@@0@Z ; ld12mul
$LN11@multtenpow:

; 536  :     }
; 537  : 
; 538  :     while (pow) {

  00062	85 ff		 test	 edi, edi
  00064	75 c0		 jne	 SHORT $LL4@multtenpow
$LN3@multtenpow:
  00066	5f		 pop	 edi
  00067	5e		 pop	 esi

; 555  :     }
; 556  : }

  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?multtenpow12@@YIXPAU_LDBL12@@H@Z ENDP			; multtenpow12
_TEXT	ENDS
PUBLIC	?g_ecvt@Class_System_Number@@SI_NNHPAUClassVector_bartok_char@@PAHPA_N@Z ; Class_System_Number::g_ecvt
; Function compile flags: /Ogtp
;	COMDAT ?g_ecvt@Class_System_Number@@SI_NNHPAUClassVector_bartok_char@@PAHPA_N@Z
_TEXT	SEGMENT
_ld12$ = -40						; size = 12
_tmp12$11277 = -24					; size = 12
_ld12_one_tenth$ = -24					; size = 12
_r$11503 = -12						; size = 4
_r$11493 = -8						; size = 4
_digits$ = -8						; size = 4
_man$ = -4						; size = 4
_value$ = 8						; size = 8
_digcount$11273 = 12					; size = 4
_decpt$ = 16						; size = 4
_negative$ = 20						; size = 4
?g_ecvt@Class_System_Number@@SI_NNHPAUClassVector_bartok_char@@PAHPA_N@Z PROC ; Class_System_Number::g_ecvt, COMDAT
; _digits$ = ecx
; _buf$ = edx

; 584  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 585  :     if ((uint32)digits > buf->length - 1) {

  00006	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8d 70 ff	 lea	 esi, DWORD PTR [eax-1]
  0000e	3b ce		 cmp	 ecx, esi
  00010	89 4d f8	 mov	 DWORD PTR _digits$[ebp], ecx
  00013	76 06		 jbe	 SHORT $LN26@g_ecvt

; 586  :         digits = buf->length - 1;

  00015	83 c0 ff	 add	 eax, -1
  00018	89 45 f8	 mov	 DWORD PTR _digits$[ebp], eax
$LN26@g_ecvt:

; 587  :     }
; 588  :     bartok_char *man = buf->values;
; 589  : 
; 590  :     // useful constants (see algorithm explanation below)
; 591  :     const uint16 log2hi = 0x4d10;
; 592  :     const uint16 log2lo = 0x4d;
; 593  :     const uint16 log4hi = 0x9a;
; 594  :     const uint32 c = 0x134312f4;
; 595  : #if defined(LITTLE_ENDIAN)
; 596  :     _LDBL12 ld12_one_tenth = {
; 597  :         {0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xfb,0x3f}

  0001b	b0 cc		 mov	 al, 204			; 000000ccH
  0001d	8d 72 08	 lea	 esi, DWORD PTR [edx+8]
  00020	88 45 e8	 mov	 BYTE PTR _ld12_one_tenth$[ebp], al
  00023	88 45 e9	 mov	 BYTE PTR _ld12_one_tenth$[ebp+1], al
  00026	88 45 ea	 mov	 BYTE PTR _ld12_one_tenth$[ebp+2], al
  00029	88 45 eb	 mov	 BYTE PTR _ld12_one_tenth$[ebp+3], al
  0002c	88 45 ec	 mov	 BYTE PTR _ld12_one_tenth$[ebp+4], al
  0002f	88 45 ed	 mov	 BYTE PTR _ld12_one_tenth$[ebp+5], al
  00032	88 45 ee	 mov	 BYTE PTR _ld12_one_tenth$[ebp+6], al
  00035	88 45 ef	 mov	 BYTE PTR _ld12_one_tenth$[ebp+7], al
  00038	88 45 f0	 mov	 BYTE PTR _ld12_one_tenth$[ebp+8], al
  0003b	88 45 f1	 mov	 BYTE PTR _ld12_one_tenth$[ebp+9], al

; 598  :     };
; 599  : #endif
; 600  : #if defined(BIG_ENDIAN)
; 601  :     _LDBL12 ld12_one_tenth = {
; 602  :         {0x3f,0xfb,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc}
; 603  :     };
; 604  : #endif
; 605  : 
; 606  :     // convert the double into a 12-byte long double.
; 607  :     _LDBL12 ld12;
; 608  :     dtold12(&ld12, &value);

  0003e	8d 4d 08	 lea	 ecx, DWORD PTR _value$[ebp]
  00041	8d 45 d8	 lea	 eax, DWORD PTR _ld12$[ebp]
  00044	89 75 fc	 mov	 DWORD PTR _man$[ebp], esi
  00047	c6 45 f2 fb	 mov	 BYTE PTR _ld12_one_tenth$[ebp+10], 251 ; 000000fbH
  0004b	c6 45 f3 3f	 mov	 BYTE PTR _ld12_one_tenth$[ebp+11], 63 ; 0000003fH
  0004f	e8 00 00 00 00	 call	 ?dtold12@@YIXPAU_LDBL12@@PBN@Z ; dtold12

; 609  : 
; 610  :     uint16 expn = *U_EXP_12(&ld12);
; 611  :     uint32 manhi = *UL_MANHI_12(&ld12);
; 612  :     uint32 manlo = *UL_MANLO_12(&ld12);
; 613  :     uint16 sign = expn & MSB_USHORT;

  00054	8b 45 e2	 mov	 eax, DWORD PTR _ld12$[ebp+10]

; 614  :     expn &= 0x7fff;
; 615  :     *U_EXP_12(&ld12) = expn;
; 616  : 
; 617  :     *negative = (sign != 0);

  00057	8b 55 14	 mov	 edx, DWORD PTR _negative$[ebp]
  0005a	8b c8		 mov	 ecx, eax
  0005c	81 e1 00 80 00
	00		 and	 ecx, 32768		; 00008000H
  00062	25 ff 7f 00 00	 and	 eax, 32767		; 00007fffH
  00067	66 85 c9	 test	 cx, cx
  0006a	0f 95 c1	 setne	 cl

; 618  : 
; 619  :     if (expn == 0 && manhi == 0 && manlo == 0) {

  0006d	66 85 c0	 test	 ax, ax
  00070	88 0a		 mov	 BYTE PTR [edx], cl
  00072	8b 4d de	 mov	 ecx, DWORD PTR _ld12$[ebp+6]
  00075	66 89 45 e2	 mov	 WORD PTR _ld12$[ebp+10], ax
  00079	0f 85 54 01 00
	00		 jne	 $LN25@g_ecvt
  0007f	85 c9		 test	 ecx, ecx
  00081	75 09		 jne	 SHORT $LN24@g_ecvt
  00083	39 4d da	 cmp	 DWORD PTR _ld12$[ebp+2], ecx
  00086	0f 84 9b 02 00
	00		 je	 $zero_fos$11240
$LN24@g_ecvt:

; 635  :     }
; 636  :     else {
; 637  :         // * Algorithm for the decoding of a valid real number x *
; 638  :         //
; 639  :         // In the following INT(r) is the largest integer less than or
; 640  :         // equal to r (i.e. r rounded toward -infinity). We want a result
; 641  :         // r equal to 1 + log(x), because then x = mantissa
; 642  :         // * 10^(INT(r)) so that .1 <= mantissa < 1.  Unfortunately,
; 643  :         // we cannot compute s exactly so we must alter the procedure
; 644  :         // slightly.  We will instead compute an estimate r of 1 +
; 645  :         // log(x) which is always low.  This will either result
; 646  :         // in the correctly normalized number on the top of the stack
; 647  :         // or perhaps a number which is a factor of 10 too large.  We
; 648  :         // will then check to see that if x is larger  than one
; 649  :         // and if so multiply x by 1/10.
; 650  :         //
; 651  :         // We will use a low precision (fixed point 24 bit) estimate
; 652  :         // of of 1 + log base 10 of x.  We have approximately .mm
; 653  :         // * 2^hhll on the top of the stack where m, h, and l represent
; 654  :         // hex digits, mm represents the high 2 hex digits of the
; 655  :         // mantissa, hh represents the high 2 hex digits of the exponent,
; 656  :         // and ll represents the low 2 hex digits of the exponent.  Since
; 657  :         // .mm is a truncated representation of the mantissa, using it
; 658  :         // in this monotonically increasing  polynomial approximation
; 659  :         // of the logarithm will naturally give a low result. Let's
; 660  :         // derive a formula for a lower bound r on 1 + log(x):
; 661  :         //
; 662  :         //      .4D104D42H < log(2)=.30102999...(base 10) < .4D104D43H
; 663  :         //     .9A20H < log(4)=.60205999...(base 10) < .9A21H
; 664  :         //
; 665  :         //  1/2 <= .mm < 1
; 666  :         //  ==>  log(.mm) >= .mm * log(4) - log(4)
; 667  :         //
; 668  :         // Substituting in truncated hex constants in the formula above
; 669  :         // gives r = 1 + .4D104DH * hhll. + .9AH * .mm - .9A21H.  Now
; 670  :         // multiplication of hex digits 5 and 6 of log(2) by ll has an
; 671  :         // insignificant effect on the first 24 bits of the result so
; 672  :         // it will not be calculated.  This gives the expression r =
; 673  :         // 1 + .4D10H * hhll. + .4DH * .hh + .9A * .mm - .9A21H.
; 674  :         // Finally we must add terms to our formula to subtract out the
; 675  :         // effect of the exponent bias.  We obtain the following formula:
; 676  :         //
; 677  :         //           (implied decimal point)
; 678  :         //   <                 >.<                  >
; 679  :         //   |3|3|2|2|2|2|2|2|2|2|2|2|1|1|1|1|1|1|1|1|1|1|0|0|0|0|0|0|0|0|0|0|
; 680  :         //   |1|0|9|8|7|6|5|4|3|2|1|0|9|8|7|6|5|4|3|2|1|0|9|8|7|6|5|4|3|2|1|0|
; 681  :         // + <         1       >
; 682  :         // + <               .4D10H * hhll.             >
; 683  :         // +                 <       .00004DH * hh00.       >
; 684  :         // +                 <          .9AH * .mm      >
; 685  :         // -                 <        .9A21H        >
; 686  :         // - <               .4D10H * 3FFEH             >
; 687  :         // -                 <       .00004DH * 3F00H       >
; 688  :         //
; 689  :         //  ==>  r = .4D10H * hhll. + .4DH * .hh + .9AH * .mm - 1343.12F4H
; 690  :         //
; 691  :         // The difference between the lower bound r and the upper bound
; 692  :         // s is calculated as follows:
; 693  :         //
; 694  :         //  .937EH < 1/ln(10)-log(1/ln(4))=.57614993...(base 10) < .937FH
; 695  :         //
; 696  :         //  1/2 <= .mm < 1
; 697  :         //  ==>  log(.mm) <= .mm * log(4) - [1/ln(10) - log(1/ln(4))]
; 698  :         //
; 699  :         // so tentatively s = r + log(4) - [1/ln(10) - log(1/ln(4))],
; 700  :         // but we must also add in terms to ensure we will have an upper
; 701  :         // bound even after the truncation of various values.  Because
; 702  :         // log(2) * hh00. is truncated to .4D104DH * hh00.  we must
; 703  :         // add .0043H, because log(2) * ll. is truncated to .4D10H *
; 704  :         // ll. we must add .0005H, because <mantissa> * log(4) is
; 705  :         // truncated to .mm * .9AH we must add .009AH and .0021H.
; 706  :         //
; 707  :         // Thus s = r - .937EH + .9A21H + .0043H + .0005H + .009AH + .0021H
; 708  :         //   = r + .07A6H
; 709  :         //  ==>  s = .4D10H * hhll. + .4DH * .hh + .9AH * .mm - 1343.0B4EH
; 710  :         //
; 711  :         // r is equal to 1 + log(x) more than (10000H - 7A6H) /
; 712  :         // 10000H = 97% of the time.
; 713  :         //
; 714  :         // In the above formula, a uint32 is use to accommodate r, and
; 715  :         // there is an implied decimal point in the middle.
; 716  : 
; 717  :         uint16 hh = expn >> 8;
; 718  :         uint16 ll = expn & (uint16)0xff;
; 719  :         uint16 mm = (uint16) (manhi >> 24);   // the two most significant bytes of the mantissa.
; 720  :         int32 r = (int32)log2hi*(int32)expn + log2lo*hh + log4hi*mm - c;
; 721  :         // the corresponding power of 10
; 722  :         int32 ir = (int16)(r >> 16); // ir = floor(r)

  0008c	0f b7 c0	 movzx	 eax, ax
  0008f	8b d0		 mov	 edx, eax
  00091	69 c0 10 4d 00
	00		 imul	 eax, 19728		; 00004d10H
  00097	c1 ea 08	 shr	 edx, 8
  0009a	c1 e9 18	 shr	 ecx, 24			; 00000018H
  0009d	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  000a0	6b c9 4d	 imul	 ecx, 77			; 0000004dH
  000a3	8d 94 01 0c ed
	bc ec		 lea	 edx, DWORD PTR [ecx+eax-323162868]
  000aa	c1 fa 10	 sar	 edx, 16			; 00000010H
  000ad	0f bf f2	 movsx	 esi, dx

; 723  : 
; 724  :         // We stated that we wanted to normalize x so that
; 725  :         //
; 726  :         //  .1 <= x < 1
; 727  :         //
; 728  :         // This was a slight oversimplification.  Actually we want a
; 729  :         // number which when rounded to 16 significant digits is in the
; 730  :         // desired range.  To do this we must normalize x so that
; 731  :         //
; 732  :         //  .1 - 5*10^(-18) <= x < 1 - 5*10^(-17)
; 733  :         //
; 734  :         // and then round.
; 735  :         //
; 736  :         // If we had f = INT(1+log(x)) we could multiply by 10^(-f)
; 737  :         // to get x into the desired range.  We do not quite have
; 738  :         // f but we do have INT(r) from the last step which is equal
; 739  :         // to f 97% of the time and 1 less than f the rest of the time.
; 740  :         // We can multiply by 10^-[INT(r)] and if the result is greater
; 741  :         // than 1 - 5*10^(-17) we can then multiply by 1/10.  This final
; 742  :         // result will lie in the proper range.
; 743  : 
; 744  :         // multiply by 10^(-ir)
; 745  :         multtenpow12(&ld12,-ir);

  000b0	8b c6		 mov	 eax, esi
  000b2	f7 d8		 neg	 eax
  000b4	8d 5d d8	 lea	 ebx, DWORD PTR _ld12$[ebp]
  000b7	e8 00 00 00 00	 call	 ?multtenpow12@@YIXPAU_LDBL12@@H@Z ; multtenpow12

; 746  : 
; 747  :         // if ld12 >= 1.0 then divide by 10.0
; 748  :         if (*U_EXP_12(&ld12) >= 0x3fff) {

  000bc	66 81 7d e2 ff
	3f		 cmp	 WORD PTR _ld12$[ebp+10], 16383 ; 00003fffH
  000c2	72 0f		 jb	 SHORT $LN83@g_ecvt

; 749  :             ir++;
; 750  :             ld12mul(&ld12,&ld12_one_tenth);

  000c4	8d 45 e8	 lea	 eax, DWORD PTR _ld12_one_tenth$[ebp]
  000c7	50		 push	 eax
  000c8	8b cb		 mov	 ecx, ebx
  000ca	51		 push	 ecx
  000cb	83 c6 01	 add	 esi, 1
  000ce	e8 00 00 00 00	 call	 ?ld12mul@@YIXPAU_LDBL12@@0@Z ; ld12mul
$LN83@g_ecvt:

; 751  :         }
; 752  : 
; 753  :         *decpt = ir;

  000d3	8b 55 10	 mov	 edx, DWORD PTR _decpt$[ebp]

; 754  : 
; 755  :         int ub_exp = *U_EXP_12(&ld12) - 0x3ffe; // unbias exponent
; 756  :         *U_EXP_12(&ld12) = 0;
; 757  : 
; 758  :         // Now the mantissa has to be converted to fixed point.
; 759  :         // Then we will use the MSB of ld12 for generating
; 760  :         // the decimal digits. The next 11 bytes will hold
; 761  :         // the mantissa (after it has been converted to
; 762  :         // fixed point).
; 763  : 
; 764  :         for (int i = 0; i < 8; i++) {
; 765  :             shl_12(&ld12);

  000d6	8b 45 d8	 mov	 eax, DWORD PTR _ld12$[ebp]
  000d9	8b 4d dc	 mov	 ecx, DWORD PTR _ld12$[ebp+4]
  000dc	89 32		 mov	 DWORD PTR [edx], esi
  000de	0f b7 75 e2	 movzx	 esi, WORD PTR _ld12$[ebp+10]
  000e2	8b d9		 mov	 ebx, ecx
  000e4	03 c9		 add	 ecx, ecx
  000e6	8b d0		 mov	 edx, eax
  000e8	c1 ea 1f	 shr	 edx, 31			; 0000001fH
  000eb	0b ca		 or	 ecx, edx
  000ed	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  000f0	57		 push	 edi
  000f1	8b f9		 mov	 edi, ecx
  000f3	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  000f6	03 c9		 add	 ecx, ecx
  000f8	03 c0		 add	 eax, eax
  000fa	66 c7 45 e2 00
	00		 mov	 WORD PTR _ld12$[ebp+10], 0
  00100	8b 55 e0	 mov	 edx, DWORD PTR _ld12$[ebp+8]
  00103	03 d2		 add	 edx, edx
  00105	0b d3		 or	 edx, ebx
  00107	03 d2		 add	 edx, edx
  00109	0b d7		 or	 edx, edi
  0010b	8b d8		 mov	 ebx, eax
  0010d	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  00110	0b cb		 or	 ecx, ebx
  00112	8b d9		 mov	 ebx, ecx
  00114	03 c0		 add	 eax, eax
  00116	03 c9		 add	 ecx, ecx
  00118	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  0011b	03 d2		 add	 edx, edx
  0011d	0b d3		 or	 edx, ebx
  0011f	8b f8		 mov	 edi, eax
  00121	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00124	0b cf		 or	 ecx, edi
  00126	8b d9		 mov	 ebx, ecx
  00128	03 c0		 add	 eax, eax
  0012a	03 c9		 add	 ecx, ecx
  0012c	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  0012f	8b f8		 mov	 edi, eax
  00131	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00134	0b cf		 or	 ecx, edi
  00136	03 d2		 add	 edx, edx
  00138	0b d3		 or	 edx, ebx
  0013a	03 c0		 add	 eax, eax
  0013c	8b d9		 mov	 ebx, ecx
  0013e	03 c9		 add	 ecx, ecx
  00140	8b f8		 mov	 edi, eax
  00142	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00145	0b cf		 or	 ecx, edi
  00147	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  0014a	03 d2		 add	 edx, edx
  0014c	0b d3		 or	 edx, ebx
  0014e	03 c0		 add	 eax, eax
  00150	8b d9		 mov	 ebx, ecx
  00152	8b f8		 mov	 edi, eax
  00154	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00157	03 c9		 add	 ecx, ecx
  00159	0b cf		 or	 ecx, edi
  0015b	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  0015e	03 d2		 add	 edx, edx
  00160	0b d3		 or	 edx, ebx
  00162	03 c0		 add	 eax, eax
  00164	8b d9		 mov	 ebx, ecx
  00166	8b f8		 mov	 edi, eax
  00168	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  0016b	03 c9		 add	 ecx, ecx
  0016d	0b cf		 or	 ecx, edi
  0016f	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  00172	03 c0		 add	 eax, eax
  00174	03 d2		 add	 edx, edx
  00176	0b d3		 or	 edx, ebx
  00178	8b f8		 mov	 edi, eax
  0017a	8b d9		 mov	 ebx, ecx
  0017c	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  0017f	03 c9		 add	 ecx, ecx
  00181	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  00184	03 d2		 add	 edx, edx
  00186	81 ee fe 3f 00
	00		 sub	 esi, 16382		; 00003ffeH
  0018c	03 c0		 add	 eax, eax
  0018e	0b cf		 or	 ecx, edi
  00190	0b d3		 or	 edx, ebx

; 766  :             // make space for an extra byte, in case we shift right later.
; 767  :         }
; 768  :         if (ub_exp < 0) {

  00192	85 f6		 test	 esi, esi
  00194	7d 25		 jge	 SHORT $LN88@g_ecvt

; 769  :             int shift_count = (-ub_exp) & 0xff;

  00196	f7 de		 neg	 esi
  00198	81 e6 ff 00 00
	00		 and	 esi, 255		; 000000ffH

; 770  :             for (; shift_count > 0; shift_count--) {

  0019e	7e 1b		 jle	 SHORT $LN88@g_ecvt
$LL16@g_ecvt:

; 771  :                 shr_12(&ld12);

  001a0	8b d9		 mov	 ebx, ecx
  001a2	8b fa		 mov	 edi, edx
  001a4	c1 e7 1f	 shl	 edi, 31			; 0000001fH
  001a7	c1 e3 1f	 shl	 ebx, 31			; 0000001fH
  001aa	d1 e9		 shr	 ecx, 1
  001ac	d1 e8		 shr	 eax, 1
  001ae	83 ee 01	 sub	 esi, 1
  001b1	d1 ea		 shr	 edx, 1
  001b3	0b cf		 or	 ecx, edi
  001b5	0b c3		 or	 eax, ebx
  001b7	85 f6		 test	 esi, esi
  001b9	7f e5		 jg	 SHORT $LL16@g_ecvt
$LN88@g_ecvt:

; 772  :             }
; 773  :         }
; 774  : 
; 775  :         bartok_char *p = man;
; 776  :         for (int digcount = digits + 1; digcount > 0; digcount--) {

  001bb	8b 7d f8	 mov	 edi, DWORD PTR _digits$[ebp]
  001be	8b 75 fc	 mov	 esi, DWORD PTR _man$[ebp]
  001c1	83 c7 01	 add	 edi, 1
  001c4	85 ff		 test	 edi, edi
  001c6	8b de		 mov	 ebx, esi
  001c8	89 7d 0c	 mov	 DWORD PTR _digcount$11273[ebp], edi
  001cb	0f 8e f0 00 00
	00		 jle	 $LN92@g_ecvt
  001d1	eb 40		 jmp	 SHORT $LN13@g_ecvt
$LN25@g_ecvt:

; 625  :         return true;
; 626  :     }
; 627  : 
; 628  :     if (expn == 0x7fff) {

  001d3	66 3d ff 7f	 cmp	 ax, 32767		; 00007fffH
  001d7	0f 85 af fe ff
	ff		 jne	 $LN24@g_ecvt

; 629  :         man[0] = '\0';
; 630  :         *decpt = SCALE_NAN;
; 631  :         if (_IS_MAN_INF(sign, manhi, manlo)) {

  001dd	81 7d de 00 00
	00 80		 cmp	 DWORD PTR _ld12$[ebp+6], -2147483648 ; 80000000H
  001e4	8b 45 10	 mov	 eax, DWORD PTR _decpt$[ebp]
  001e7	66 c7 06 00 00	 mov	 WORD PTR [esi], 0
  001ec	c7 00 00 00 00
	80		 mov	 DWORD PTR [eax], -2147483648 ; 80000000H
  001f2	75 0c		 jne	 SHORT $LN23@g_ecvt
  001f4	83 7d da 00	 cmp	 DWORD PTR _ld12$[ebp+2], 0
  001f8	75 06		 jne	 SHORT $LN23@g_ecvt

; 632  :             *decpt = SCALE_INF; // infinity

  001fa	c7 00 ff ff ff
	7f		 mov	 DWORD PTR [eax], 2147483647 ; 7fffffffH
$LN23@g_ecvt:
  00200	5e		 pop	 esi

; 633  :         }
; 634  :         return false;

  00201	32 c0		 xor	 al, al
  00203	5b		 pop	 ebx

; 813  :     }
; 814  : }

  00204	8b e5		 mov	 esp, ebp
  00206	5d		 pop	 ebp
  00207	c2 10 00	 ret	 16			; 00000010H
  0020a	8d 9b 00 00 00
	00		 npad	 6
$LL82@g_ecvt:

; 772  :             }
; 773  :         }
; 774  : 
; 775  :         bartok_char *p = man;
; 776  :         for (int digcount = digits + 1; digcount > 0; digcount--) {

  00210	8b 55 e0	 mov	 edx, DWORD PTR _ld12$[ebp+8]
$LN13@g_ecvt:

; 777  :             _LDBL12 tmp12 = ld12;
; 778  :             shl_12(&ld12);

  00213	8b f9		 mov	 edi, ecx
  00215	89 4d ec	 mov	 DWORD PTR _tmp12$11277[ebp+4], ecx
  00218	8b f0		 mov	 esi, eax
  0021a	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0021d	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00220	03 c9		 add	 ecx, ecx
  00222	0b ce		 or	 ecx, esi
  00224	89 45 e8	 mov	 DWORD PTR _tmp12$11277[ebp], eax
  00227	89 55 f0	 mov	 DWORD PTR _tmp12$11277[ebp+8], edx
  0022a	03 c0		 add	 eax, eax
  0022c	03 d2		 add	 edx, edx
  0022e	0b d7		 or	 edx, edi

; 779  :             shl_12(&ld12);

  00230	8b f0		 mov	 esi, eax
  00232	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00235	8b f9		 mov	 edi, ecx
  00237	03 c9		 add	 ecx, ecx
  00239	0b ce		 or	 ecx, esi
  0023b	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  0023e	8d 34 12	 lea	 esi, DWORD PTR [edx+edx]
  00241	0b f7		 or	 esi, edi

; 780  :             add_12(&ld12,&tmp12);

  00243	8b 7d e8	 mov	 edi, DWORD PTR _tmp12$11277[ebp]
  00246	03 c0		 add	 eax, eax
  00248	8d 14 07	 lea	 edx, DWORD PTR [edi+eax]
  0024b	3b d0		 cmp	 edx, eax
  0024d	89 55 f8	 mov	 DWORD PTR _r$11493[ebp], edx
  00250	72 04		 jb	 SHORT $LN44@g_ecvt
  00252	3b d7		 cmp	 edx, edi
  00254	73 11		 jae	 SHORT $LN90@g_ecvt
$LN44@g_ecvt:
  00256	8b c1		 mov	 eax, ecx
  00258	83 c1 01	 add	 ecx, 1
  0025b	3b c8		 cmp	 ecx, eax
  0025d	72 05		 jb	 SHORT $LN89@g_ecvt
  0025f	83 f9 01	 cmp	 ecx, 1
  00262	73 03		 jae	 SHORT $LN90@g_ecvt
$LN89@g_ecvt:
  00264	83 c6 01	 add	 esi, 1
$LN90@g_ecvt:
  00267	8b 45 ec	 mov	 eax, DWORD PTR _tmp12$11277[ebp+4]
  0026a	8d 3c 08	 lea	 edi, DWORD PTR [eax+ecx]
  0026d	3b f9		 cmp	 edi, ecx
  0026f	89 7d f4	 mov	 DWORD PTR _r$11503[ebp], edi
  00272	72 04		 jb	 SHORT $LN52@g_ecvt
  00274	3b f8		 cmp	 edi, eax
  00276	73 03		 jae	 SHORT $LN37@g_ecvt
$LN52@g_ecvt:
  00278	83 c6 01	 add	 esi, 1
$LN37@g_ecvt:
  0027b	03 75 f0	 add	 esi, DWORD PTR _tmp12$11277[ebp+8]

; 781  :             shl_12(&ld12);    // ld12 *= 10

  0027e	8b 4d f4	 mov	 ecx, DWORD PTR _r$11503[ebp]
  00281	8b 45 f8	 mov	 eax, DWORD PTR _r$11493[ebp]
  00284	c1 ea 1f	 shr	 edx, 31			; 0000001fH
  00287	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  0028a	03 f6		 add	 esi, esi
  0028c	03 c9		 add	 ecx, ecx
  0028e	0b ca		 or	 ecx, edx
  00290	0b f7		 or	 esi, edi

; 782  : 
; 783  :             // Now we have the first decimal digit in the most significant byte of exponent
; 784  :             *p++ = (char) (*UCHAR_12(&ld12,11) + '0');

  00292	8b d6		 mov	 edx, esi
  00294	c1 ea 18	 shr	 edx, 24			; 00000018H
  00297	80 c2 30	 add	 dl, 48			; 00000030H
  0029a	66 0f be d2	 movsx	 dx, dl
  0029e	66 89 13	 mov	 WORD PTR [ebx], dx
  002a1	8b 55 0c	 mov	 edx, DWORD PTR _digcount$11273[ebp]
  002a4	83 ea 01	 sub	 edx, 1
  002a7	03 c0		 add	 eax, eax
  002a9	83 c3 02	 add	 ebx, 2
  002ac	85 d2		 test	 edx, edx
  002ae	89 75 e0	 mov	 DWORD PTR _ld12$[ebp+8], esi

; 785  :             *UCHAR_12(&ld12,11) = 0;

  002b1	c6 45 e3 00	 mov	 BYTE PTR _ld12$[ebp+11], 0
  002b5	89 55 0c	 mov	 DWORD PTR _digcount$11273[ebp], edx
  002b8	0f 8f 52 ff ff
	ff		 jg	 $LL82@g_ecvt

; 772  :             }
; 773  :         }
; 774  : 
; 775  :         bartok_char *p = man;
; 776  :         for (int digcount = digits + 1; digcount > 0; digcount--) {

  002be	8b 75 fc	 mov	 esi, DWORD PTR _man$[ebp]
$LN92@g_ecvt:

; 786  :         }
; 787  : 
; 788  :         bartok_char round = *(--p);

  002c1	0f b7 43 fe	 movzx	 eax, WORD PTR [ebx-2]
  002c5	83 eb 02	 sub	 ebx, 2

; 789  :         p--;

  002c8	83 eb 02	 sub	 ebx, 2

; 790  :         // p points now to the last character of the string excluding the rounding digit.
; 791  :         if (round >= '5') {

  002cb	66 3d 35 00	 cmp	 ax, 53			; 00000035H
  002cf	5f		 pop	 edi
  002d0	72 3e		 jb	 SHORT $LN10@g_ecvt

; 792  :             // look for a non-9 digit starting from the end of string
; 793  :             for (; p >= man && *p == '9'; p--) {

  002d2	3b de		 cmp	 ebx, esi
  002d4	72 18		 jb	 SHORT $LN78@g_ecvt
$LL9@g_ecvt:
  002d6	66 83 3b 39	 cmp	 WORD PTR [ebx], 57	; 00000039H
  002da	75 0e		 jne	 SHORT $LN7@g_ecvt

; 794  :                 *p = '0';

  002dc	66 c7 03 30 00	 mov	 WORD PTR [ebx], 48	; 00000030H
  002e1	83 eb 02	 sub	 ebx, 2
  002e4	3b de		 cmp	 ebx, esi
  002e6	73 ee		 jae	 SHORT $LL9@g_ecvt

; 795  :             }
; 796  :             if (p < man) {

  002e8	eb 04		 jmp	 SHORT $LN78@g_ecvt
$LN7@g_ecvt:
  002ea	3b de		 cmp	 ebx, esi
  002ec	73 09		 jae	 SHORT $LN91@g_ecvt
$LN78@g_ecvt:

; 797  :                 p++;
; 798  :                 (*decpt)++;

  002ee	8b 45 10	 mov	 eax, DWORD PTR _decpt$[ebp]
  002f1	83 c3 02	 add	 ebx, 2
  002f4	83 00 01	 add	 DWORD PTR [eax], 1
$LN91@g_ecvt:

; 799  :             }
; 800  :             (*p)++;

  002f7	66 83 03 01	 add	 WORD PTR [ebx], 1
$LN87@g_ecvt:

; 808  :                 goto zero_fos;
; 809  :             }
; 810  :         }
; 811  :         man[(p - man + 1)] = '\0';

  002fb	2b de		 sub	 ebx, esi
  002fd	d1 fb		 sar	 ebx, 1
  002ff	66 c7 44 5e 02
	00 00		 mov	 WORD PTR [esi+ebx*2+2], 0
  00306	5e		 pop	 esi

; 812  :         return true;

  00307	b0 01		 mov	 al, 1
  00309	5b		 pop	 ebx

; 813  :     }
; 814  : }

  0030a	8b e5		 mov	 esp, ebp
  0030c	5d		 pop	 ebp
  0030d	c2 10 00	 ret	 16			; 00000010H
$LN10@g_ecvt:

; 801  :         }
; 802  :         else {
; 803  :             // We probably don't want to truncate all of the zeros!
; 804  :             for (; p >= man && *p == '0'; p--) {

  00310	3b de		 cmp	 ebx, esi
  00312	72 13		 jb	 SHORT $zero_fos$11240
$LL4@g_ecvt:
  00314	66 83 3b 30	 cmp	 WORD PTR [ebx], 48	; 00000030H
  00318	75 09		 jne	 SHORT $LN2@g_ecvt
  0031a	83 eb 02	 sub	 ebx, 2
  0031d	3b de		 cmp	 ebx, esi
  0031f	73 f3		 jae	 SHORT $LL4@g_ecvt

; 805  :                 // remove extra zeros;
; 806  :             }
; 807  :             if (p < man) {

  00321	eb 04		 jmp	 SHORT $zero_fos$11240
$LN2@g_ecvt:
  00323	3b de		 cmp	 ebx, esi
  00325	73 d4		 jae	 SHORT $LN87@g_ecvt
$zero_fos$11240:

; 620  :       zero_fos:
; 621  :         *decpt = 0;

  00327	8b 45 10	 mov	 eax, DWORD PTR _decpt$[ebp]

; 622  :         *negative = false;

  0032a	8b 4d 14	 mov	 ecx, DWORD PTR _negative$[ebp]
  0032d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 623  :         man[0] = '0';

  00333	8b 45 fc	 mov	 eax, DWORD PTR _man$[ebp]
  00336	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00339	5e		 pop	 esi
  0033a	66 c7 00 30 00	 mov	 WORD PTR [eax], 48	; 00000030H

; 624  :         man[1] = '\0';

  0033f	66 c7 40 02 00
	00		 mov	 WORD PTR [eax+2], 0

; 812  :         return true;

  00345	b0 01		 mov	 al, 1
  00347	5b		 pop	 ebx

; 813  :     }
; 814  : }

  00348	8b e5		 mov	 esp, ebp
  0034a	5d		 pop	 ebp
  0034b	c2 10 00	 ret	 16			; 00000010H
?g_ecvt@Class_System_Number@@SI_NNHPAUClassVector_bartok_char@@PAHPA_N@Z ENDP ; Class_System_Number::g_ecvt
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	??_C@_0DF@JFPONKBO@assert?$CI?$CB?$CCatof?$CC?$CJ?5failed?5at?5Native@ ; `string'
PUBLIC	?g_atof@Class_System_Number@@SINPAUClassVector_uint8@@@Z ; Class_System_Number::g_atof
EXTRN	?fail_assert@@YIXPBD@Z:PROC			; fail_assert
EXTRN	__fltused:DWORD
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_C@_0DF@JFPONKBO@assert?$CI?$CB?$CCatof?$CC?$CJ?5failed?5at?5Native@
CONST	SEGMENT
??_C@_0DF@JFPONKBO@assert?$CI?$CB?$CCatof?$CC?$CJ?5failed?5at?5Native@ DB 'a'
	DB	'ssert(!"atof") failed at Native\Number.cpp:__LINE__', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?g_atof@Class_System_Number@@SINPAUClassVector_uint8@@@Z
_TEXT	SEGMENT
?g_atof@Class_System_Number@@SINPAUClassVector_uint8@@@Z PROC ; Class_System_Number::g_atof, COMDAT
; _a$ = ecx

; 818  :     Assert(!"atof");

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0DF@JFPONKBO@assert?$CI?$CB?$CCatof?$CC?$CJ?5failed?5at?5Native@
  00005	e8 00 00 00 00	 call	 ?fail_assert@@YIXPBD@Z	; fail_assert

; 819  :     return 0;

  0000a	d9 ee		 fldz

; 820  : }

  0000c	c3		 ret	 0
?g_atof@Class_System_Number@@SINPAUClassVector_uint8@@@Z ENDP ; Class_System_Number::g_atof
_TEXT	ENDS
END
