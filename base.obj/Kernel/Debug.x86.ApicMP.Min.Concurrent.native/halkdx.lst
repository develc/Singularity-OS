; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	C:\Users\cc\source\repos\Singularity-OS\base\Kernel\Native\ix86\halkdx.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_KdpSpinBase DW	02f00H
_DATA	ENDS
PUBLIC	??_C@_04OPBEDMAI@?$CL?9?$HM?$CK?$AA@		; `string'
PUBLIC	?KdpSpin@@YIXXZ					; KdpSpin
;	COMDAT ?state@?4??KdpSpin@@YIXXZ@4EA
; File c:\users\cc\source\repos\singularity-os\base\kernel\native\ix86\halkdx.cpp
_BSS	SEGMENT
?state@?4??KdpSpin@@YIXXZ@4EA DB 01H DUP (?)		; `KdpSpin'::`5'::state
_BSS	ENDS
;	COMDAT ??_C@_04OPBEDMAI@?$CL?9?$HM?$CK?$AA@
CONST	SEGMENT
??_C@_04OPBEDMAI@?$CL?9?$HM?$CK?$AA@ DB '+-|*', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?KdpSpin@@YIXXZ
_TEXT	SEGMENT
?KdpSpin@@YIXXZ PROC					; KdpSpin, COMDAT

; 21   :     if (KdpSpinBase != 0) {

  00000	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR _KdpSpinBase
  00007	66 85 c9	 test	 cx, cx
  0000a	74 24		 je	 SHORT $LN1@KdpSpin

; 22   :         static UINT8 state = 0;
; 23   : 
; 24   :         // Write the spinner to the screen.
; 25   :         *((UINT16 *)0xb809e) = KdpSpinBase + ("+-|*" [state++ & 0x3]);

  0000c	a0 00 00 00 00	 mov	 al, BYTE PTR ?state@?4??KdpSpin@@YIXXZ@4EA
  00011	0f b6 d0	 movzx	 edx, al
  00014	83 e2 03	 and	 edx, 3
  00017	66 0f be 92 00
	00 00 00	 movsx	 dx, BYTE PTR ??_C@_04OPBEDMAI@?$CL?9?$HM?$CK?$AA@[edx]
  0001f	66 03 d1	 add	 dx, cx
  00022	04 01		 add	 al, 1
  00024	66 89 15 9e 80
	0b 00		 mov	 WORD PTR ds:753822, dx
  0002b	a2 00 00 00 00	 mov	 BYTE PTR ?state@?4??KdpSpin@@YIXXZ@4EA, al
$LN1@KdpSpin:

; 26   :     }
; 27   : }

  00030	c3		 ret	 0
?KdpSpin@@YIXXZ ENDP					; KdpSpin
_TEXT	ENDS
PUBLIC	?KdpDisableInterruptsInline@@YI_NXZ		; KdpDisableInterruptsInline
; Function compile flags: /Ogtp
;	COMDAT ?KdpDisableInterruptsInline@@YI_NXZ
_TEXT	SEGMENT
?KdpDisableInterruptsInline@@YI_NXZ PROC		; KdpDisableInterruptsInline, COMDAT

; 37   :     __asm {
; 38   :         pushfd;

  00000	9c		 pushfd

; 39   :         pop eax;

  00001	58		 pop	 eax

; 40   :         test eax, Struct_Microsoft_Singularity_Isal_IX_EFlags_IF;

  00002	a9 00 02 00 00	 test	 eax, 512		; 00000200H

; 41   :         setnz al;

  00007	0f 95 c0	 setne	 al

; 42   :         nop;    // required so that the linker doesn't combine with g_Disable

  0000a	90		 npad	 1

; 43   :         cli;

  0000b	fa		 cli

; 44   :         ret;

  0000c	c3		 ret	 0
?KdpDisableInterruptsInline@@YI_NXZ ENDP		; KdpDisableInterruptsInline
_TEXT	ENDS
PUBLIC	?KdpRestoreInterruptsInline@@YIX_N@Z		; KdpRestoreInterruptsInline
; Function compile flags: /Ogtp
;	COMDAT ?KdpRestoreInterruptsInline@@YIX_N@Z
_TEXT	SEGMENT
?KdpRestoreInterruptsInline@@YIX_N@Z PROC		; KdpRestoreInterruptsInline, COMDAT
; _enabled$ = cl

; 50   :     __asm {
; 51   :         nop;

  00000	90		 npad	 1

; 52   :         test cl, cl;

  00001	84 c9		 test	 cl, cl

; 53   :         je done;

  00003	74 02		 je	 SHORT $done$11530

; 54   :         nop;    // required so that the linker doesn't combine with g_Restore

  00005	90		 npad	 1

; 55   :         sti;

  00006	fb		 sti
$done$11530:

; 56   :       done:
; 57   :         ret;

  00007	c3		 ret	 0
?KdpRestoreInterruptsInline@@YIX_N@Z ENDP		; KdpRestoreInterruptsInline
_TEXT	ENDS
PUBLIC	?KdpPause@@YIXXZ				; KdpPause
; Function compile flags: /Ogtp
;	COMDAT ?KdpPause@@YIXXZ
_TEXT	SEGMENT
?KdpPause@@YIXXZ PROC					; KdpPause, COMDAT

; 64   :     __asm {
; 65   :         pause;

  00000	f3 90		 pause

; 66   :         ret;

  00002	c3		 ret	 0
?KdpPause@@YIXXZ ENDP					; KdpPause
_TEXT	ENDS
PUBLIC	?KdpFlushInstCache@@YIXXZ			; KdpFlushInstCache
; Function compile flags: /Ogtp
;	COMDAT ?KdpFlushInstCache@@YIXXZ
_TEXT	SEGMENT
?KdpFlushInstCache@@YIXXZ PROC				; KdpFlushInstCache, COMDAT

; 73   :     __asm {
; 74   :         wbinvd;   // privileged instruction

  00000	0f 09		 wbinvd

; 75   :         ret;

  00002	c3		 ret	 0
?KdpFlushInstCache@@YIXXZ ENDP				; KdpFlushInstCache
_TEXT	ENDS
PUBLIC	?g_Break@Class_Microsoft_Singularity_DebugStub@@SIXXZ ; Class_Microsoft_Singularity_DebugStub::g_Break
; Function compile flags: /Ogtp
;	COMDAT ?g_Break@Class_Microsoft_Singularity_DebugStub@@SIXXZ
_TEXT	SEGMENT
?g_Break@Class_Microsoft_Singularity_DebugStub@@SIXXZ PROC ; Class_Microsoft_Singularity_DebugStub::g_Break, COMDAT

; 82   :     __asm {
; 83   :         int 3;

  00000	cc		 int	 3

; 84   :         ret;

  00001	c3		 ret	 0
?g_Break@Class_Microsoft_Singularity_DebugStub@@SIXXZ ENDP ; Class_Microsoft_Singularity_DebugStub::g_Break
_TEXT	ENDS
PUBLIC	?KdpReadMsr@@YI_NKPAK0@Z			; KdpReadMsr
; Function compile flags: /Ogtp
;	COMDAT ?KdpReadMsr@@YI_NKPAK0@Z
_TEXT	SEGMENT
_msr$ = -12						; size = 4
_lo$ = -8						; size = 4
_hi$ = -4						; size = 4
_phi$ = 8						; size = 4
?KdpReadMsr@@YI_NKPAK0@Z PROC				; KdpReadMsr, COMDAT
; _msr$ = ecx
; _plo$ = edx

; 90   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	8b f2		 mov	 esi, edx
  00009	89 4d f4	 mov	 DWORD PTR _msr$[ebp], ecx

; 91   :     UINT32 lo;
; 92   :     UINT32 hi;
; 93   : 
; 94   :     __asm {
; 95   :         mov ecx, msr;

  0000c	8b 4d f4	 mov	 ecx, DWORD PTR _msr$[ebp]

; 96   :         rdmsr;

  0000f	0f 32		 rdmsr

; 97   :         mov hi, edx;

  00011	89 55 fc	 mov	 DWORD PTR _hi$[ebp], edx

; 98   :         mov lo, eax;

  00014	89 45 f8	 mov	 DWORD PTR _lo$[ebp], eax

; 99   :     }
; 100  : 
; 101  :     *phi = hi;

  00017	8b 45 08	 mov	 eax, DWORD PTR _phi$[ebp]
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _hi$[ebp]

; 102  :     *plo = lo;

  0001d	8b 55 f8	 mov	 edx, DWORD PTR _lo$[ebp]
  00020	89 08		 mov	 DWORD PTR [eax], ecx
  00022	89 16		 mov	 DWORD PTR [esi], edx

; 103  : 
; 104  :     return true;

  00024	b0 01		 mov	 al, 1
  00026	5e		 pop	 esi

; 105  : }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?KdpReadMsr@@YI_NKPAK0@Z ENDP				; KdpReadMsr
_TEXT	ENDS
PUBLIC	?KdpWriteMsr@@YI_NKKK@Z				; KdpWriteMsr
; Function compile flags: /Ogtp
;	COMDAT ?KdpWriteMsr@@YI_NKKK@Z
_TEXT	SEGMENT
_msr$ = -8						; size = 4
_lo$ = -4						; size = 4
_hi$ = 8						; size = 4
?KdpWriteMsr@@YI_NKKK@Z PROC				; KdpWriteMsr, COMDAT
; _msr$ = ecx
; _lo$ = edx

; 109  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 55 fc	 mov	 DWORD PTR _lo$[ebp], edx
  00009	89 4d f8	 mov	 DWORD PTR _msr$[ebp], ecx

; 110  :     __asm {
; 111  :         mov ecx, msr;

  0000c	8b 4d f8	 mov	 ecx, DWORD PTR _msr$[ebp]

; 112  :         mov edx, hi;

  0000f	8b 55 08	 mov	 edx, DWORD PTR _hi$[ebp]

; 113  :         mov eax, lo;

  00012	8b 45 fc	 mov	 eax, DWORD PTR _lo$[ebp]

; 114  :         wrmsr;

  00015	0f 30		 wrmsr

; 115  :     }
; 116  :     return true;

  00017	b0 01		 mov	 al, 1

; 117  : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?KdpWriteMsr@@YI_NKKK@Z ENDP				; KdpWriteMsr
_TEXT	ENDS
PUBLIC	?KdpToKdContext@@YIXPBUStruct_Microsoft_Singularity_Isal_SpillContext@@PAUStruct_Microsoft_Singularity_Kd_X86Context@@@Z ; KdpToKdContext
; Function compile flags: /Ogtp
;	COMDAT ?KdpToKdContext@@YIXPBUStruct_Microsoft_Singularity_Isal_SpillContext@@PAUStruct_Microsoft_Singularity_Kd_X86Context@@@Z
_TEXT	SEGMENT
_windbg$ = -4						; size = 4
?KdpToKdContext@@YIXPBUStruct_Microsoft_Singularity_Isal_SpillContext@@PAUStruct_Microsoft_Singularity_Kd_X86Context@@@Z PROC ; KdpToKdContext, COMDAT
; _singularity$ = ecx
; _windbg$ = edx

; 123  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b c1		 mov	 eax, ecx

; 124  :     windbg->ContextFlags = (CONTEXT_CONTROL |
; 125  :                             CONTEXT_INTEGER |
; 126  :                             CONTEXT_SEGMENTS |
; 127  :                             CONTEXT_FLOATING_POINT |
; 128  :                             CONTEXT_EXTENDED_REGISTERS);

  00006	c7 02 2f 00 01
	00		 mov	 DWORD PTR [edx], 65583	; 0001002fH

; 129  : 
; 130  :     // CONTEXT_FULL;
; 131  :     windbg->Eax = singularity->ax;

  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 8a b0 00 00
	00		 mov	 DWORD PTR [edx+176], ecx

; 132  :     windbg->Ebx = singularity->bx;

  00014	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00017	89 8a a4 00 00
	00		 mov	 DWORD PTR [edx+164], ecx

; 133  :     windbg->Ecx = singularity->cx;

  0001d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00020	89 8a ac 00 00
	00		 mov	 DWORD PTR [edx+172], ecx

; 134  :     windbg->Edx = singularity->dx;

  00026	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00029	89 8a a8 00 00
	00		 mov	 DWORD PTR [edx+168], ecx

; 135  :     windbg->Esp = singularity->sp;

  0002f	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00032	89 8a c4 00 00
	00		 mov	 DWORD PTR [edx+196], ecx

; 136  :     windbg->Ebp = singularity->bp;

  00038	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0003b	89 8a b4 00 00
	00		 mov	 DWORD PTR [edx+180], ecx

; 137  :     windbg->Esi = singularity->si;

  00041	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00044	89 8a a0 00 00
	00		 mov	 DWORD PTR [edx+160], ecx

; 138  :     windbg->Edi = singularity->di;

  0004a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0004d	89 8a 9c 00 00
	00		 mov	 DWORD PTR [edx+156], ecx

; 139  :     windbg->Eip = singularity->ip;

  00053	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00056	89 8a b8 00 00
	00		 mov	 DWORD PTR [edx+184], ecx

; 140  :     windbg->EFlags = singularity->fl;

  0005c	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0005f	89 8a c0 00 00
	00		 mov	 DWORD PTR [edx+192], ecx

; 141  : 
; 142  :     windbg->FloatSave.ControlWord = singularity->mmx.fcw;

  00065	0f b7 48 30	 movzx	 ecx, WORD PTR [eax+48]
  00069	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 143  :     windbg->FloatSave.StatusWord = singularity->mmx.fsw;

  0006c	0f b7 48 32	 movzx	 ecx, WORD PTR [eax+50]
  00070	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 144  :     windbg->FloatSave.TagWord = singularity->mmx.ftw;

  00073	0f b7 48 34	 movzx	 ecx, WORD PTR [eax+52]
  00077	89 4a 24	 mov	 DWORD PTR [edx+36], ecx

; 145  :     windbg->FloatSave.ErrorOffset = singularity->mmx.ip;

  0007a	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0007d	53		 push	 ebx
  0007e	89 4a 28	 mov	 DWORD PTR [edx+40], ecx

; 146  :     windbg->FloatSave.ErrorSelector = singularity->mmx.cs;

  00081	0f b7 48 3c	 movzx	 ecx, WORD PTR [eax+60]
  00085	56		 push	 esi
  00086	8d 70 30	 lea	 esi, DWORD PTR [eax+48]
  00089	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx

; 147  :     windbg->FloatSave.DataOffset = singularity->mmx.dp;

  0008c	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0008f	89 4a 30	 mov	 DWORD PTR [edx+48], ecx

; 148  :     windbg->FloatSave.DataSelector = singularity->mmx.ds;

  00092	0f b7 48 44	 movzx	 ecx, WORD PTR [eax+68]
  00096	89 4a 34	 mov	 DWORD PTR [edx+52], ecx

; 149  : 
; 150  :     memcpy(&windbg->FloatSave.St0, &singularity->mmx.st0, 10);

  00099	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  0009c	89 4a 38	 mov	 DWORD PTR [edx+56], ecx
  0009f	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  000a2	89 4a 3c	 mov	 DWORD PTR [edx+60], ecx
  000a5	0f b7 48 58	 movzx	 ecx, WORD PTR [eax+88]
  000a9	66 89 4a 40	 mov	 WORD PTR [edx+64], cx

; 151  :     memcpy(&windbg->FloatSave.St1, &singularity->mmx.st1, 10);

  000ad	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  000b0	89 4a 42	 mov	 DWORD PTR [edx+66], ecx
  000b3	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  000b6	89 4a 46	 mov	 DWORD PTR [edx+70], ecx
  000b9	0f b7 48 68	 movzx	 ecx, WORD PTR [eax+104]
  000bd	66 89 4a 4a	 mov	 WORD PTR [edx+74], cx

; 152  :     memcpy(&windbg->FloatSave.St2, &singularity->mmx.st2, 10);

  000c1	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  000c4	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx
  000c7	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  000ca	89 4a 50	 mov	 DWORD PTR [edx+80], ecx
  000cd	0f b7 48 78	 movzx	 ecx, WORD PTR [eax+120]
  000d1	66 89 4a 54	 mov	 WORD PTR [edx+84], cx

; 153  :     memcpy(&windbg->FloatSave.St3, &singularity->mmx.st3, 10);

  000d5	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  000db	89 4a 56	 mov	 DWORD PTR [edx+86], ecx
  000de	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  000e4	89 4a 5a	 mov	 DWORD PTR [edx+90], ecx
  000e7	0f b7 88 88 00
	00 00		 movzx	 ecx, WORD PTR [eax+136]
  000ee	66 89 4a 5e	 mov	 WORD PTR [edx+94], cx

; 154  :     memcpy(&windbg->FloatSave.St4, &singularity->mmx.st4, 10);

  000f2	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  000f8	89 4a 60	 mov	 DWORD PTR [edx+96], ecx
  000fb	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [eax+148]
  00101	89 4a 64	 mov	 DWORD PTR [edx+100], ecx
  00104	0f b7 88 98 00
	00 00		 movzx	 ecx, WORD PTR [eax+152]
  0010b	66 89 4a 68	 mov	 WORD PTR [edx+104], cx

; 155  :     memcpy(&windbg->FloatSave.St5, &singularity->mmx.st5, 10);

  0010f	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  00115	89 4a 6a	 mov	 DWORD PTR [edx+106], ecx
  00118	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0011e	89 4a 6e	 mov	 DWORD PTR [edx+110], ecx
  00121	0f b7 88 a8 00
	00 00		 movzx	 ecx, WORD PTR [eax+168]
  00128	66 89 4a 72	 mov	 WORD PTR [edx+114], cx

; 156  :     memcpy(&windbg->FloatSave.St6, &singularity->mmx.st6, 10);

  0012c	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00132	89 4a 74	 mov	 DWORD PTR [edx+116], ecx
  00135	8b 88 b4 00 00
	00		 mov	 ecx, DWORD PTR [eax+180]
  0013b	57		 push	 edi
  0013c	89 55 fc	 mov	 DWORD PTR _windbg$[ebp], edx
  0013f	89 4a 78	 mov	 DWORD PTR [edx+120], ecx
  00142	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  00149	66 89 4a 7c	 mov	 WORD PTR [edx+124], cx

; 157  :     memcpy(&windbg->FloatSave.St7, &singularity->mmx.st7, 10);

  0014d	8b 88 c0 00 00
	00		 mov	 ecx, DWORD PTR [eax+192]
  00153	89 4a 7e	 mov	 DWORD PTR [edx+126], ecx
  00156	8b 88 c4 00 00
	00		 mov	 ecx, DWORD PTR [eax+196]
  0015c	89 8a 82 00 00
	00		 mov	 DWORD PTR [edx+130], ecx
  00162	0f b7 88 c8 00
	00 00		 movzx	 ecx, WORD PTR [eax+200]
  00169	66 89 8a 86 00
	00 00		 mov	 WORD PTR [edx+134], cx

; 158  : 
; 159  :     memcpy(&windbg->ExtendedRegisters, &singularity->mmx, 512);

  00170	8d ba cc 00 00
	00		 lea	 edi, DWORD PTR [edx+204]
  00176	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0017b	f3 a5		 rep movsd

; 160  : 
; 161  :     // Segment registers other than cs don't change so they are live
; 162  :     windbg->SegCs = singularity->cs;

  0017d	8b 80 30 02 00
	00		 mov	 eax, DWORD PTR [eax+560]
  00183	89 82 bc 00 00
	00		 mov	 DWORD PTR [edx+188], eax

; 164  :         mov ebx, windbg;

  00189	8b 5d fc	 mov	 ebx, DWORD PTR _windbg$[ebp]

; 165  : 
; 166  :         xor eax, eax;

  0018c	33 c0		 xor	 eax, eax

; 167  :         mov ax, gs;

  0018e	66 8c e8	 mov	 ax, gs

; 168  :         mov [ebx]CONTEXT.SegGs, eax;

  00191	89 83 8c 00 00
	00		 mov	 DWORD PTR [ebx+140], eax

; 169  :         mov ax, fs;

  00197	66 8c e0	 mov	 ax, fs

; 170  :         mov [ebx]CONTEXT.SegFs, eax;

  0019a	89 83 90 00 00
	00		 mov	 DWORD PTR [ebx+144], eax

; 171  :         mov ax, es;

  001a0	66 8c c0	 mov	 ax, es

; 172  :         mov [ebx]CONTEXT.SegEs, eax;

  001a3	89 83 94 00 00
	00		 mov	 DWORD PTR [ebx+148], eax

; 173  :         mov ax, ds;

  001a9	66 8c d8	 mov	 ax, ds

; 174  :         mov [ebx]CONTEXT.SegDs, eax;

  001ac	89 83 98 00 00
	00		 mov	 DWORD PTR [ebx+152], eax

; 175  :         mov ax, ss;

  001b2	66 8c d0	 mov	 ax, ss

; 176  :         mov [ebx]CONTEXT.SegSs, eax;

  001b5	89 83 c8 00 00
	00		 mov	 DWORD PTR [ebx+200], eax

; 163  :     __asm {

  001bb	5f		 pop	 edi
  001bc	5e		 pop	 esi
  001bd	5b		 pop	 ebx

; 177  :     }
; 178  : }

  001be	8b e5		 mov	 esp, ebp
  001c0	5d		 pop	 ebp
  001c1	c3		 ret	 0
?KdpToKdContext@@YIXPBUStruct_Microsoft_Singularity_Isal_SpillContext@@PAUStruct_Microsoft_Singularity_Kd_X86Context@@@Z ENDP ; KdpToKdContext
_TEXT	ENDS
PUBLIC	?KdpFromKdContext@@YIXPBUStruct_Microsoft_Singularity_Kd_X86Context@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ; KdpFromKdContext
; Function compile flags: /Ogtp
;	COMDAT ?KdpFromKdContext@@YIXPBUStruct_Microsoft_Singularity_Kd_X86Context@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z
_TEXT	SEGMENT
?KdpFromKdContext@@YIXPBUStruct_Microsoft_Singularity_Kd_X86Context@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z PROC ; KdpFromKdContext, COMDAT
; _windbg$ = ecx
; _singularity$ = edx

; 183  :     singularity->ax = windbg->Eax;

  00000	8b 81 b0 00 00
	00		 mov	 eax, DWORD PTR [ecx+176]
  00006	89 02		 mov	 DWORD PTR [edx], eax

; 184  :     singularity->bx = windbg->Ebx;

  00008	8b 81 a4 00 00
	00		 mov	 eax, DWORD PTR [ecx+164]
  0000e	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 185  :     singularity->cx = windbg->Ecx;

  00011	8b 81 ac 00 00
	00		 mov	 eax, DWORD PTR [ecx+172]
  00017	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 186  :     singularity->dx = windbg->Edx;

  0001a	8b 81 a8 00 00
	00		 mov	 eax, DWORD PTR [ecx+168]
  00020	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 187  :     singularity->sp = windbg->Esp;

  00023	8b 81 c4 00 00
	00		 mov	 eax, DWORD PTR [ecx+196]
  00029	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 188  :     singularity->bp = windbg->Ebp;

  0002c	8b 81 b4 00 00
	00		 mov	 eax, DWORD PTR [ecx+180]
  00032	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 189  :     singularity->si = windbg->Esi;

  00035	8b 81 a0 00 00
	00		 mov	 eax, DWORD PTR [ecx+160]
  0003b	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 190  :     singularity->di = windbg->Edi;

  0003e	8b 81 9c 00 00
	00		 mov	 eax, DWORD PTR [ecx+156]
  00044	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 191  :     singularity->ip = windbg->Eip;

  00047	8b 81 b8 00 00
	00		 mov	 eax, DWORD PTR [ecx+184]
  0004d	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 192  :     singularity->fl = windbg->EFlags;

  00050	8b 81 c0 00 00
	00		 mov	 eax, DWORD PTR [ecx+192]
  00056	89 42 24	 mov	 DWORD PTR [edx+36], eax

; 193  : 
; 194  :     // CONTEXT_FLOATING_POINT
; 195  :     if (windbg->ContextFlags & CONTEXT_FLOATING_POINT) {

  00059	f7 01 08 00 01
	00		 test	 DWORD PTR [ecx], 65544	; 00010008H
  0005f	0f 84 07 01 00
	00		 je	 $LN2@KdpFromKdC

; 196  :         singularity->mmx.fcw = windbg->FloatSave.ControlWord;

  00065	0f b7 41 1c	 movzx	 eax, WORD PTR [ecx+28]
  00069	66 89 42 30	 mov	 WORD PTR [edx+48], ax

; 197  :         singularity->mmx.fsw = windbg->FloatSave.StatusWord;

  0006d	0f b7 41 20	 movzx	 eax, WORD PTR [ecx+32]
  00071	66 89 42 32	 mov	 WORD PTR [edx+50], ax

; 198  :         singularity->mmx.ftw = windbg->FloatSave.TagWord;

  00075	0f b7 41 24	 movzx	 eax, WORD PTR [ecx+36]
  00079	66 89 42 34	 mov	 WORD PTR [edx+52], ax

; 199  :         singularity->mmx.cs = windbg->FloatSave.ErrorSelector;

  0007d	0f b7 41 2c	 movzx	 eax, WORD PTR [ecx+44]
  00081	66 89 42 3c	 mov	 WORD PTR [edx+60], ax

; 200  :         singularity->mmx.ip = windbg->FloatSave.ErrorOffset;

  00085	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00088	89 42 38	 mov	 DWORD PTR [edx+56], eax

; 201  :         singularity->mmx.ds = windbg->FloatSave.DataSelector;

  0008b	0f b7 41 34	 movzx	 eax, WORD PTR [ecx+52]
  0008f	66 89 42 44	 mov	 WORD PTR [edx+68], ax

; 202  :         singularity->mmx.dp = windbg->FloatSave.DataOffset;

  00093	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00096	89 42 40	 mov	 DWORD PTR [edx+64], eax

; 203  :         memcpy(&singularity->mmx.st0, &windbg->FloatSave.St0, 10);

  00099	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  0009c	89 42 50	 mov	 DWORD PTR [edx+80], eax
  0009f	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]
  000a2	89 42 54	 mov	 DWORD PTR [edx+84], eax
  000a5	0f b7 41 40	 movzx	 eax, WORD PTR [ecx+64]
  000a9	66 89 42 58	 mov	 WORD PTR [edx+88], ax

; 204  :         memcpy(&singularity->mmx.st1, &windbg->FloatSave.St1, 10);

  000ad	8b 41 42	 mov	 eax, DWORD PTR [ecx+66]
  000b0	89 42 60	 mov	 DWORD PTR [edx+96], eax
  000b3	8b 41 46	 mov	 eax, DWORD PTR [ecx+70]
  000b6	89 42 64	 mov	 DWORD PTR [edx+100], eax
  000b9	0f b7 41 4a	 movzx	 eax, WORD PTR [ecx+74]
  000bd	66 89 42 68	 mov	 WORD PTR [edx+104], ax

; 205  :         memcpy(&singularity->mmx.st2, &windbg->FloatSave.St2, 10);

  000c1	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  000c4	89 42 70	 mov	 DWORD PTR [edx+112], eax
  000c7	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  000ca	89 42 74	 mov	 DWORD PTR [edx+116], eax
  000cd	0f b7 41 54	 movzx	 eax, WORD PTR [ecx+84]
  000d1	66 89 42 78	 mov	 WORD PTR [edx+120], ax

; 206  :         memcpy(&singularity->mmx.st3, &windbg->FloatSave.St3, 10);

  000d5	8b 41 56	 mov	 eax, DWORD PTR [ecx+86]
  000d8	89 82 80 00 00
	00		 mov	 DWORD PTR [edx+128], eax
  000de	8b 41 5a	 mov	 eax, DWORD PTR [ecx+90]
  000e1	89 82 84 00 00
	00		 mov	 DWORD PTR [edx+132], eax
  000e7	0f b7 41 5e	 movzx	 eax, WORD PTR [ecx+94]
  000eb	66 89 82 88 00
	00 00		 mov	 WORD PTR [edx+136], ax

; 207  :         memcpy(&singularity->mmx.st4, &windbg->FloatSave.St4, 10);

  000f2	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]
  000f5	89 82 90 00 00
	00		 mov	 DWORD PTR [edx+144], eax
  000fb	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  000fe	89 82 94 00 00
	00		 mov	 DWORD PTR [edx+148], eax
  00104	0f b7 41 68	 movzx	 eax, WORD PTR [ecx+104]
  00108	66 89 82 98 00
	00 00		 mov	 WORD PTR [edx+152], ax

; 208  :         memcpy(&singularity->mmx.st5, &windbg->FloatSave.St5, 10);

  0010f	8b 41 6a	 mov	 eax, DWORD PTR [ecx+106]
  00112	89 82 a0 00 00
	00		 mov	 DWORD PTR [edx+160], eax
  00118	8b 41 6e	 mov	 eax, DWORD PTR [ecx+110]
  0011b	89 82 a4 00 00
	00		 mov	 DWORD PTR [edx+164], eax
  00121	0f b7 41 72	 movzx	 eax, WORD PTR [ecx+114]
  00125	66 89 82 a8 00
	00 00		 mov	 WORD PTR [edx+168], ax

; 209  :         memcpy(&singularity->mmx.st6, &windbg->FloatSave.St6, 10);

  0012c	8b 41 74	 mov	 eax, DWORD PTR [ecx+116]
  0012f	89 82 b0 00 00
	00		 mov	 DWORD PTR [edx+176], eax
  00135	8b 41 78	 mov	 eax, DWORD PTR [ecx+120]
  00138	89 82 b4 00 00
	00		 mov	 DWORD PTR [edx+180], eax
  0013e	0f b7 41 7c	 movzx	 eax, WORD PTR [ecx+124]
  00142	66 89 82 b8 00
	00 00		 mov	 WORD PTR [edx+184], ax

; 210  :         memcpy(&singularity->mmx.st7, &windbg->FloatSave.St7, 10);

  00149	8b 41 7e	 mov	 eax, DWORD PTR [ecx+126]
  0014c	89 82 c0 00 00
	00		 mov	 DWORD PTR [edx+192], eax
  00152	8b 81 82 00 00
	00		 mov	 eax, DWORD PTR [ecx+130]
  00158	89 82 c4 00 00
	00		 mov	 DWORD PTR [edx+196], eax
  0015e	0f b7 81 86 00
	00 00		 movzx	 eax, WORD PTR [ecx+134]
  00165	66 89 82 c8 00
	00 00		 mov	 WORD PTR [edx+200], ax
$LN2@KdpFromKdC:

; 211  :     }
; 212  : 
; 213  :     // CONTEXT_EXTENDED_REGISTERS
; 214  :     if (windbg->ContextFlags & CONTEXT_EXTENDED_REGISTERS) {

  0016c	f7 01 20 00 01
	00		 test	 DWORD PTR [ecx], 65568	; 00010020H
  00172	74 14		 je	 SHORT $LN1@KdpFromKdC
  00174	56		 push	 esi
  00175	57		 push	 edi

; 215  :         memcpy(&singularity->mmx, &windbg->ExtendedRegisters, 512);

  00176	8d b1 cc 00 00
	00		 lea	 esi, DWORD PTR [ecx+204]
  0017c	8d 7a 30	 lea	 edi, DWORD PTR [edx+48]
  0017f	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00184	f3 a5		 rep movsd
  00186	5f		 pop	 edi
  00187	5e		 pop	 esi
$LN1@KdpFromKdC:

; 216  :     }
; 217  : }

  00188	c3		 ret	 0
?KdpFromKdContext@@YIXPBUStruct_Microsoft_Singularity_Kd_X86Context@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ENDP ; KdpFromKdContext
_TEXT	ENDS
PUBLIC	?KdpSetControlReport@@YIXPAUStruct_Microsoft_Singularity_Kd_X86KdControlReport@@PBUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ; KdpSetControlReport
; Function compile flags: /Ogtp
;	COMDAT ?KdpSetControlReport@@YIXPAUStruct_Microsoft_Singularity_Kd_X86KdControlReport@@PBUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z
_TEXT	SEGMENT
__dr7$ = -24						; size = 4
__dr6$ = -20						; size = 4
__fs$ = -16						; size = 2
__es$ = -12						; size = 2
__ds$ = -8						; size = 2
__cs$ = -4						; size = 2
?KdpSetControlReport@@YIXPAUStruct_Microsoft_Singularity_Kd_X86KdControlReport@@PBUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z PROC ; KdpSetControlReport, COMDAT
; _report$ = ecx
; _x86Context$ = edx

; 227  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 228  :     UINT32 _dr6;
; 229  :     UINT32 _dr7;
; 230  :     UINT16 _cs;
; 231  :     UINT16 _ds;
; 232  :     UINT16 _es;
; 233  :     UINT16 _fs;
; 234  : 
; 235  :     __asm {
; 236  :         mov eax, dr6;

  00006	0f 21 f0	 mov	 eax, dr6

; 237  :         mov _dr6, eax;

  00009	89 45 ec	 mov	 DWORD PTR __dr6$[ebp], eax

; 238  :         mov eax, dr7;

  0000c	0f 21 f8	 mov	 eax, dr7

; 239  :         mov _dr7, eax;

  0000f	89 45 e8	 mov	 DWORD PTR __dr7$[ebp], eax

; 240  : 
; 241  :         mov ax, cs;

  00012	66 8c c8	 mov	 ax, cs

; 242  :         mov _cs, ax;

  00015	66 89 45 fc	 mov	 WORD PTR __cs$[ebp], ax

; 243  :         mov ax, ds;

  00019	66 8c d8	 mov	 ax, ds

; 244  :         mov _ds, ax;

  0001c	66 89 45 f8	 mov	 WORD PTR __ds$[ebp], ax

; 245  :         mov ax, es;

  00020	66 8c c0	 mov	 ax, es

; 246  :         mov _es, ax;

  00023	66 89 45 f4	 mov	 WORD PTR __es$[ebp], ax

; 247  :         mov ax, fs;

  00027	66 8c e0	 mov	 ax, fs

; 248  :         mov _fs, ax;

  0002a	66 89 45 f0	 mov	 WORD PTR __fs$[ebp], ax

; 249  :     }
; 250  : 
; 251  :     report->Dr6 = _dr6;

  0002e	8b 45 ec	 mov	 eax, DWORD PTR __dr6$[ebp]
  00031	89 01		 mov	 DWORD PTR [ecx], eax

; 252  :     report->Dr7 = _dr7;

  00033	8b 45 e8	 mov	 eax, DWORD PTR __dr7$[ebp]
  00036	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 253  :     report->SegCs  = _cs;

  00039	0f b7 45 fc	 movzx	 eax, WORD PTR __cs$[ebp]
  0003d	66 89 41 1c	 mov	 WORD PTR [ecx+28], ax

; 254  :     report->SegDs  = _ds;

  00041	0f b7 45 f8	 movzx	 eax, WORD PTR __ds$[ebp]
  00045	66 89 41 1e	 mov	 WORD PTR [ecx+30], ax

; 255  :     report->SegEs  = _es;

  00049	0f b7 45 f4	 movzx	 eax, WORD PTR __es$[ebp]
  0004d	66 89 41 20	 mov	 WORD PTR [ecx+32], ax

; 256  :     report->SegFs  = _fs;

  00051	0f b7 45 f0	 movzx	 eax, WORD PTR __fs$[ebp]
  00055	66 89 41 22	 mov	 WORD PTR [ecx+34], ax

; 257  :     report->EFlags = x86Context->fl;

  00059	8b 52 24	 mov	 edx, DWORD PTR [edx+36]
  0005c	89 51 24	 mov	 DWORD PTR [ecx+36], edx

; 258  :     report->ReportFlags = X86_REPORT_INCLUDES_SEGS;
; 259  : 
; 260  : #if !PAGING
; 261  :     // Let the debugger know so that it doesn't have to retrieve the CS descriptor.
; 262  :     report->ReportFlags |= X86_REPORT_STANDARD_CS;

  0005f	66 c7 41 0a 03
	00		 mov	 WORD PTR [ecx+10], 3

; 263  : #endif
; 264  : }

  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
?KdpSetControlReport@@YIXPAUStruct_Microsoft_Singularity_Kd_X86KdControlReport@@PBUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ENDP ; KdpSetControlReport
_TEXT	ENDS
PUBLIC	?KdpSetControlSet@@YIXPBUStruct_Microsoft_Singularity_Kd_X86KdControlSet@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ; KdpSetControlSet
; Function compile flags: /Ogtp
;	COMDAT ?KdpSetControlSet@@YIXPBUStruct_Microsoft_Singularity_Kd_X86KdControlSet@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z
_TEXT	SEGMENT
__dr7$ = -4						; size = 4
?KdpSetControlSet@@YIXPBUStruct_Microsoft_Singularity_Kd_X86KdControlSet@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z PROC ; KdpSetControlSet, COMDAT
; _control$ = ecx
; _x86Context$ = edx

; 268  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 269  :     if (control->TraceFlag) {

  00004	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00008	74 09		 je	 SHORT $LN2@KdpSetCont

; 270  :         //KDDBG("KD: Warning - trace flag set prev efl=%x\n",x86Context->efl);
; 271  :         x86Context->fl |= Struct_Microsoft_Singularity_Isal_IX_EFlags_TF;

  0000a	81 4a 24 00 01
	00 00		 or	 DWORD PTR [edx+36], 256	; 00000100H

; 272  :     }
; 273  :     else {

  00011	eb 07		 jmp	 SHORT $LN1@KdpSetCont
$LN2@KdpSetCont:

; 274  :         //KDDBG("KD: turning off tracing in efl\n");
; 275  :         x86Context->fl &= ~Struct_Microsoft_Singularity_Isal_IX_EFlags_TF;

  00013	81 62 24 ff fe
	ff ff		 and	 DWORD PTR [edx+36], -257 ; fffffeffH
$LN1@KdpSetCont:

; 276  :     }
; 277  : 
; 278  :     UINT32 _dr7 = control->Dr7;

  0001a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0001d	89 45 fc	 mov	 DWORD PTR __dr7$[ebp], eax

; 279  : 
; 280  :     __asm {
; 281  :         mov eax, _dr7;

  00020	8b 45 fc	 mov	 eax, DWORD PTR __dr7$[ebp]

; 282  :         mov dr7, eax

  00023	0f 23 f8	 mov	 dr7, eax

; 283  :     }
; 284  : }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?KdpSetControlSet@@YIXPBUStruct_Microsoft_Singularity_Kd_X86KdControlSet@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ENDP ; KdpSetControlSet
_TEXT	ENDS
PUBLIC	?KdpReadSpecialRegisters@@YIXPAUStruct_Microsoft_Singularity_Kd_X86KSpecialRegisters@@PBUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ; KdpReadSpecialRegisters
; Function compile flags: /Ogtp
;	COMDAT ?KdpReadSpecialRegisters@@YIXPAUStruct_Microsoft_Singularity_Kd_X86KSpecialRegisters@@PBUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z
_TEXT	SEGMENT
_gdtp$ = -20						; size = 8
_idtp$ = -12						; size = 8
_pksp$ = -4						; size = 4
?KdpReadSpecialRegisters@@YIXPAUStruct_Microsoft_Singularity_Kd_X86KSpecialRegisters@@PBUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z PROC ; KdpReadSpecialRegisters, COMDAT
; _pksp$ = ecx
; _x86Context$ = edx

; 290  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx
  00007	89 4d fc	 mov	 DWORD PTR _pksp$[ebp], ecx

; 291  :     Struct_Microsoft_Singularity_Kd_X86Descriptor idtp;
; 292  :     Struct_Microsoft_Singularity_Kd_X86Descriptor gdtp;
; 293  : 
; 294  :     __asm {
; 295  :         mov ebx, pksp;

  0000a	8b 5d fc	 mov	 ebx, DWORD PTR _pksp$[ebp]

; 296  : 
; 297  :         sidt idtp.Limit;

  0000d	0f 01 4d f6	 sidt	 FWORD PTR _idtp$[ebp+2]

; 298  :         sgdt gdtp.Limit;

  00011	0f 01 45 ee	 sgdt	 FWORD PTR _gdtp$[ebp+2]

; 299  : 
; 300  :         mov eax, cr0;

  00015	0f 20 c0	 mov	 eax, cr0

; 301  :         mov [ebx]KSPECIAL_REGISTERS.Cr0, eax;

  00018	89 03		 mov	 DWORD PTR [ebx], eax

; 302  :         mov eax, cr2;

  0001a	0f 20 d0	 mov	 eax, cr2

; 303  :         mov [ebx]KSPECIAL_REGISTERS.Cr2, eax;

  0001d	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 304  :         mov eax, cr3;

  00020	0f 20 d8	 mov	 eax, cr3

; 305  :         mov [ebx]KSPECIAL_REGISTERS.Cr3, eax;

  00023	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 306  :         _emit 0x0f;  // mov eax,cr4

  00026	0f		 DB	 15			; 0000000fH

; 307  :         _emit 0x20;

  00027	20		 DB	 32			; 00000020H

; 308  :         _emit 0xe0;

  00028	e0		 DB	 -32			; ffffffe0H

; 309  :         mov [ebx]KSPECIAL_REGISTERS.Cr4, eax;

  00029	89 43 0c	 mov	 DWORD PTR [ebx+12], eax

; 310  : 
; 311  :         // Should we save segment regs as well?
; 312  :         str ax;

  0002c	0f 00 c8	 str	 ax

; 313  :         mov [ebx]KSPECIAL_REGISTERS.Tr, ax;

  0002f	66 89 43 38	 mov	 WORD PTR [ebx+56], ax

; 314  :     }
; 315  : 
; 316  :     pksp->Idtr = idtp;

  00033	8b 45 f4	 mov	 eax, DWORD PTR _idtp$[ebp]
  00036	8b 55 f8	 mov	 edx, DWORD PTR _idtp$[ebp+4]
  00039	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 317  :     pksp->Gdtr = gdtp;

  0003c	8b 45 ec	 mov	 eax, DWORD PTR _gdtp$[ebp]
  0003f	89 51 34	 mov	 DWORD PTR [ecx+52], edx
  00042	8b 55 f0	 mov	 edx, DWORD PTR _gdtp$[ebp+4]
  00045	89 41 28	 mov	 DWORD PTR [ecx+40], eax
  00048	89 51 2c	 mov	 DWORD PTR [ecx+44], edx
  0004b	5b		 pop	 ebx

; 318  : }

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?KdpReadSpecialRegisters@@YIXPAUStruct_Microsoft_Singularity_Kd_X86KSpecialRegisters@@PBUStruct_Microsoft_Singularity_Isal_SpillContext@@@Z ENDP ; KdpReadSpecialRegisters
_TEXT	ENDS
PUBLIC	?KdpWriteSpecialRegisters@@YIXPBUStruct_Microsoft_Singularity_Kd_X86KSpecialRegisters@@@Z ; KdpWriteSpecialRegisters
; Function compile flags: /Ogtp
;	COMDAT ?KdpWriteSpecialRegisters@@YIXPBUStruct_Microsoft_Singularity_Kd_X86KSpecialRegisters@@@Z
_TEXT	SEGMENT
_pksp$ = -4						; size = 4
?KdpWriteSpecialRegisters@@YIXPBUStruct_Microsoft_Singularity_Kd_X86KSpecialRegisters@@@Z PROC ; KdpWriteSpecialRegisters, COMDAT
; _pksp$ = ecx

; 321  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	89 4d fc	 mov	 DWORD PTR _pksp$[ebp], ecx

; 323  :         mov ebx, pksp;

  00008	8b 5d fc	 mov	 ebx, DWORD PTR _pksp$[ebp]

; 324  : 
; 325  :         mov eax, [ebx]KSPECIAL_REGISTERS.KernelDr0;

  0000b	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]

; 326  :         mov dr0, eax;

  0000e	0f 23 c0	 mov	 dr0, eax

; 327  :         mov eax, [ebx]KSPECIAL_REGISTERS.KernelDr1;

  00011	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]

; 328  :         mov dr1, eax;

  00014	0f 23 c8	 mov	 dr1, eax

; 329  :         mov eax, [ebx]KSPECIAL_REGISTERS.KernelDr2;

  00017	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]

; 330  :         mov dr2, eax;

  0001a	0f 23 d0	 mov	 dr2, eax

; 331  :         mov eax, [ebx]KSPECIAL_REGISTERS.KernelDr3;

  0001d	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]

; 332  :         mov dr3, eax;

  00020	0f 23 d8	 mov	 dr3, eax

; 333  :         mov eax, [ebx]KSPECIAL_REGISTERS.KernelDr6;

  00023	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]

; 334  :         mov dr6, eax;

  00026	0f 23 f0	 mov	 dr6, eax

; 335  :         mov eax, [ebx]KSPECIAL_REGISTERS.KernelDr7;

  00029	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]

; 336  :         mov dr7, eax;

  0002c	0f 23 f8	 mov	 dr7, eax

; 322  :     __asm {

  0002f	5b		 pop	 ebx

; 337  :     }
; 338  : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?KdpWriteSpecialRegisters@@YIXPBUStruct_Microsoft_Singularity_Kd_X86KSpecialRegisters@@@Z ENDP ; KdpWriteSpecialRegisters
_TEXT	ENDS
PUBLIC	?KdpIsDebugTrap@@YIPAUKdDebugTrapData@@PBUStruct_Microsoft_Singularity_Isal_SpillContext@@H@Z ; KdpIsDebugTrap
; Function compile flags: /Ogtp
;	COMDAT ?KdpIsDebugTrap@@YIPAUKdDebugTrapData@@PBUStruct_Microsoft_Singularity_Isal_SpillContext@@H@Z
_TEXT	SEGMENT
?KdpIsDebugTrap@@YIPAUKdDebugTrapData@@PBUStruct_Microsoft_Singularity_Isal_SpillContext@@H@Z PROC ; KdpIsDebugTrap, COMDAT
; _context$ = ecx
; _id$ = edx

; 345  :     if (id == Struct_Microsoft_Singularity_Isal_IX_EVectors_FirstChanceException) {

  00000	83 fa 1d	 cmp	 edx, 29			; 0000001dH
  00003	75 03		 jne	 SHORT $LN1@KdpIsDebug

; 346  :         return (KdDebugTrapData *)(context->ax);

  00005	8b 01		 mov	 eax, DWORD PTR [ecx]

; 349  : }

  00007	c3		 ret	 0
$LN1@KdpIsDebug:

; 347  :     }
; 348  :     return NULL;

  00008	33 c0		 xor	 eax, eax

; 349  : }

  0000a	c3		 ret	 0
?KdpIsDebugTrap@@YIPAUKdDebugTrapData@@PBUStruct_Microsoft_Singularity_Isal_SpillContext@@H@Z ENDP ; KdpIsDebugTrap
_TEXT	ENDS
PUBLIC	?KdpConvertTrapToException@@YIXPAUStruct_Microsoft_Singularity_Kd_ExceptionRecord64@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@H@Z ; KdpConvertTrapToException
; Function compile flags: /Ogtp
;	COMDAT ?KdpConvertTrapToException@@YIXPAUStruct_Microsoft_Singularity_Kd_ExceptionRecord64@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@H@Z
_TEXT	SEGMENT
__cr2$11625 = 8						; size = 4
_id$ = 8						; size = 4
?KdpConvertTrapToException@@YIXPAUStruct_Microsoft_Singularity_Kd_ExceptionRecord64@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@H@Z PROC ; KdpConvertTrapToException, COMDAT
; _per$ = ecx
; _context$ = edx

; 355  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 356  :     // Breakpoints:
; 357  :     switch (id) {

  00005	8b 7d 08	 mov	 edi, DWORD PTR _id$[ebp]
  00008	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  0000b	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  0000e	0f 87 08 01 00
	00		 ja	 $LN7@KdpConvert
  00014	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN33@KdpConvert[eax]
  0001b	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN36@KdpConvert[eax*4]
$LN28@KdpConvert:

; 358  : 
; 359  :         case Struct_Microsoft_Singularity_Isal_IX_EVectors_SingleStep:
; 360  :             KDDBG("SingleStep\n");
; 361  :             per->ExceptionCode = STATUS_SINGLE_STEP;

  00022	c7 01 04 00 00
	80		 mov	 DWORD PTR [ecx], -2147483644 ; 80000004H

; 439  :             per->ExceptionAddress = SIGN_EXTEND(context->ip);

  00028	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0002b	99		 cdq
  0002c	5f		 pop	 edi
  0002d	89 51 14	 mov	 DWORD PTR [ecx+20], edx
  00030	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00033	5e		 pop	 esi

; 440  :             break;
; 441  : 
; 442  :     }
; 443  : 
; 444  :     KDDBG("Trap: Context at %p\n", context);
; 445  :     KDDBG("  CXT=%08x  THR=%08x\n",
; 446  :           context,
; 447  :           Class_Microsoft_Singularity_Processor::g_GetCurrentThreadContext()->_thread);
; 448  :     KDDBG("  EIP=%08x  EFL=%08x\n",
; 449  :           context->ip, context->fl);
; 450  :     KDDBG("  EAX=%08x  EBX=%08x  ECX=%08x  EDX=%08x\n",
; 451  :           context->ax, context->bx, context->cx, context->dx);
; 452  :     KDDBG("  ESP=%08x  EBP=%08x  ESI=%08x  EDI=%08x\n",
; 453  :           context->sp, context->bp, context->si, context->di);
; 454  : }

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN26@KdpConvert:

; 362  :             per->ExceptionAddress = SIGN_EXTEND(context->ip);
; 363  :             // context->efl &= ~Struct_Microsoft_Singularity_Isal_IX_EFlags_TF;
; 364  :             break;
; 365  : 
; 366  :         case Struct_Microsoft_Singularity_Isal_IX_EVectors_Breakpoint:
; 367  :             KDDBG("Breakpoint\n");
; 368  :             context->ip -= 1;

  00038	83 42 1c ff	 add	 DWORD PTR [edx+28], -1

; 369  :             per->ExceptionCode = STATUS_BREAKPOINT;
; 370  :             per->NumberParameters = 1;
; 371  :             per->ExceptionInformation0 = BREAKPOINT_BREAK;

  0003c	33 f6		 xor	 esi, esi
  0003e	89 71 20	 mov	 DWORD PTR [ecx+32], esi
  00041	89 71 24	 mov	 DWORD PTR [ecx+36], esi
  00044	c7 01 03 00 00
	80		 mov	 DWORD PTR [ecx], -2147483645 ; 80000003H
  0004a	c7 41 18 01 00
	00 00		 mov	 DWORD PTR [ecx+24], 1

; 439  :             per->ExceptionAddress = SIGN_EXTEND(context->ip);

  00051	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00054	99		 cdq
  00055	5f		 pop	 edi
  00056	89 51 14	 mov	 DWORD PTR [ecx+20], edx
  00059	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0005c	5e		 pop	 esi

; 440  :             break;
; 441  : 
; 442  :     }
; 443  : 
; 444  :     KDDBG("Trap: Context at %p\n", context);
; 445  :     KDDBG("  CXT=%08x  THR=%08x\n",
; 446  :           context,
; 447  :           Class_Microsoft_Singularity_Processor::g_GetCurrentThreadContext()->_thread);
; 448  :     KDDBG("  EIP=%08x  EFL=%08x\n",
; 449  :           context->ip, context->fl);
; 450  :     KDDBG("  EAX=%08x  EBX=%08x  ECX=%08x  EDX=%08x\n",
; 451  :           context->ax, context->bx, context->cx, context->dx);
; 452  :     KDDBG("  ESP=%08x  EBP=%08x  ESI=%08x  EDI=%08x\n",
; 453  :           context->sp, context->bp, context->si, context->di);
; 454  : }

  0005d	5d		 pop	 ebp
  0005e	c2 04 00	 ret	 4
$LN24@KdpConvert:
  00061	5f		 pop	 edi

; 372  :             per->ExceptionAddress = SIGN_EXTEND(context->ip);
; 373  :             break;
; 374  : 
; 375  :         case Struct_Microsoft_Singularity_Isal_IX_EVectors_IllegalInstruction:
; 376  :             KDDBG("Illegal Instruction\n");
; 377  :             per->ExceptionCode = STATUS_ILLEGAL_INSTRUCTION;

  00062	c7 01 1d 00 00
	c0		 mov	 DWORD PTR [ecx], -1073741795 ; c000001dH
  00068	5e		 pop	 esi

; 440  :             break;
; 441  : 
; 442  :     }
; 443  : 
; 444  :     KDDBG("Trap: Context at %p\n", context);
; 445  :     KDDBG("  CXT=%08x  THR=%08x\n",
; 446  :           context,
; 447  :           Class_Microsoft_Singularity_Processor::g_GetCurrentThreadContext()->_thread);
; 448  :     KDDBG("  EIP=%08x  EFL=%08x\n",
; 449  :           context->ip, context->fl);
; 450  :     KDDBG("  EAX=%08x  EBX=%08x  ECX=%08x  EDX=%08x\n",
; 451  :           context->ax, context->bx, context->cx, context->dx);
; 452  :     KDDBG("  ESP=%08x  EBP=%08x  ESI=%08x  EDI=%08x\n",
; 453  :           context->sp, context->bp, context->si, context->di);
; 454  : }

  00069	5d		 pop	 ebp
  0006a	c2 04 00	 ret	 4
$LN22@KdpConvert:

; 378  :             break;
; 379  : 
; 380  :         case Struct_Microsoft_Singularity_Isal_IX_EVectors_PageFault:
; 381  :             KDDBG("KD: 0x0E %d\n", id);
; 382  :             per->ExceptionCode = STATUS_ACCESS_VIOLATION;

  0006d	c7 01 05 00 00
	c0		 mov	 DWORD PTR [ecx], -1073741819 ; c0000005H

; 383  :             per->ExceptionAddress = SIGN_EXTEND(context->ip);

  00073	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00076	99		 cdq
  00077	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0007a	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 384  :             per->NumberParameters = 1;

  0007d	c7 41 18 01 00
	00 00		 mov	 DWORD PTR [ecx+24], 1

; 385  :             {
; 386  :                 UINT32 _cr2;
; 387  :                 __asm {
; 388  :                     mov eax, cr2;

  00084	0f 20 d0	 mov	 eax, cr2

; 389  :                     mov _cr2, eax;

  00087	89 45 08	 mov	 DWORD PTR __cr2$11625[ebp], eax

; 390  :                 }
; 391  :                 per->ExceptionInformation0 = SIGN_EXTEND(_cr2);

  0008a	8b 45 08	 mov	 eax, DWORD PTR __cr2$11625[ebp]
  0008d	99		 cdq
  0008e	5f		 pop	 edi
  0008f	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  00092	89 51 24	 mov	 DWORD PTR [ecx+36], edx
  00095	5e		 pop	 esi

; 440  :             break;
; 441  : 
; 442  :     }
; 443  : 
; 444  :     KDDBG("Trap: Context at %p\n", context);
; 445  :     KDDBG("  CXT=%08x  THR=%08x\n",
; 446  :           context,
; 447  :           Class_Microsoft_Singularity_Processor::g_GetCurrentThreadContext()->_thread);
; 448  :     KDDBG("  EIP=%08x  EFL=%08x\n",
; 449  :           context->ip, context->fl);
; 450  :     KDDBG("  EAX=%08x  EBX=%08x  ECX=%08x  EDX=%08x\n",
; 451  :           context->ax, context->bx, context->cx, context->dx);
; 452  :     KDDBG("  ESP=%08x  EBP=%08x  ESI=%08x  EDI=%08x\n",
; 453  :           context->sp, context->bp, context->si, context->di);
; 454  : }

  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
$LN20@KdpConvert:

; 392  :             }
; 393  :             break;
; 394  : 
; 395  :         case Struct_Microsoft_Singularity_Isal_IX_EVectors_FirstChanceException: {
; 396  :             KdDebugTrapData *trapData = (KdDebugTrapData *) (context->ax);

  0009a	8b 02		 mov	 eax, DWORD PTR [edx]

; 397  :             switch (trapData->tag) {

  0009c	33 f6		 xor	 esi, esi
  0009e	39 30		 cmp	 DWORD PTR [eax], esi

; 398  :                 case KdDebugTrapData::FIRST_CHANCE_EXCEPTION:
; 399  :                     context->ax = trapData->firstChanceException.throwAddr;
; 400  :                     KDDBG("KD: First chance C# exception\n");
; 401  :                     // per->ExceptionCode = STATUS_CPP_EH_EXCEPTION; //0xe06d7363;
; 402  :                     per->ExceptionCode = STATUS_VCPP_EXCEPTION; //0x8000ff1f;
; 403  :                     per->ExceptionAddress = SIGN_EXTEND(context->ip);
; 404  :                     per->NumberParameters = 1;
; 405  :                     per->ExceptionInformation0 = BREAKPOINT_BREAK;
; 406  :                     break;
; 407  :                 default:
; 408  :                     KDDBG("KD: Unexpected interrupt %d\n", id);
; 409  :                     per->ExceptionCode = 0x80000000 + id;
; 410  :                     per->ExceptionAddress = SIGN_EXTEND(context->ip);
; 411  :                     break;

  000a0	75 7a		 jne	 SHORT $LN7@KdpConvert
  000a2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a5	89 02		 mov	 DWORD PTR [edx], eax
  000a7	c7 01 88 13 6d
	40		 mov	 DWORD PTR [ecx], 1080890248 ; 406d1388H
  000ad	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]

; 439  :             per->ExceptionAddress = SIGN_EXTEND(context->ip);

  000b0	99		 cdq
  000b1	5f		 pop	 edi
  000b2	89 71 20	 mov	 DWORD PTR [ecx+32], esi
  000b5	89 71 24	 mov	 DWORD PTR [ecx+36], esi
  000b8	c7 41 18 01 00
	00 00		 mov	 DWORD PTR [ecx+24], 1
  000bf	89 51 14	 mov	 DWORD PTR [ecx+20], edx
  000c2	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  000c5	5e		 pop	 esi

; 440  :             break;
; 441  : 
; 442  :     }
; 443  : 
; 444  :     KDDBG("Trap: Context at %p\n", context);
; 445  :     KDDBG("  CXT=%08x  THR=%08x\n",
; 446  :           context,
; 447  :           Class_Microsoft_Singularity_Processor::g_GetCurrentThreadContext()->_thread);
; 448  :     KDDBG("  EIP=%08x  EFL=%08x\n",
; 449  :           context->ip, context->fl);
; 450  :     KDDBG("  EAX=%08x  EBX=%08x  ECX=%08x  EDX=%08x\n",
; 451  :           context->ax, context->bx, context->cx, context->dx);
; 452  :     KDDBG("  ESP=%08x  EBP=%08x  ESI=%08x  EDI=%08x\n",
; 453  :           context->sp, context->bp, context->si, context->di);
; 454  : }

  000c6	5d		 pop	 ebp
  000c7	c2 04 00	 ret	 4
$LN13@KdpConvert:

; 412  :             }
; 413  :             break;
; 414  :         }
; 415  : 
; 416  :         case Struct_Microsoft_Singularity_Isal_IX_EVectors_SecondChanceException:
; 417  :             KDDBG("KD: Second chance C# exception\n");
; 418  :             per->ExceptionCode = STATUS_VCPP_EXCEPTION;

  000ca	c7 01 88 13 6d
	40		 mov	 DWORD PTR [ecx], 1080890248 ; 406d1388H

; 439  :             per->ExceptionAddress = SIGN_EXTEND(context->ip);

  000d0	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000d3	99		 cdq
  000d4	5f		 pop	 edi
  000d5	89 51 14	 mov	 DWORD PTR [ecx+20], edx
  000d8	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  000db	5e		 pop	 esi

; 440  :             break;
; 441  : 
; 442  :     }
; 443  : 
; 444  :     KDDBG("Trap: Context at %p\n", context);
; 445  :     KDDBG("  CXT=%08x  THR=%08x\n",
; 446  :           context,
; 447  :           Class_Microsoft_Singularity_Processor::g_GetCurrentThreadContext()->_thread);
; 448  :     KDDBG("  EIP=%08x  EFL=%08x\n",
; 449  :           context->ip, context->fl);
; 450  :     KDDBG("  EAX=%08x  EBX=%08x  ECX=%08x  EDX=%08x\n",
; 451  :           context->ax, context->bx, context->cx, context->dx);
; 452  :     KDDBG("  ESP=%08x  EBP=%08x  ESI=%08x  EDI=%08x\n",
; 453  :           context->sp, context->bp, context->si, context->di);
; 454  : }

  000dc	5d		 pop	 ebp
  000dd	c2 04 00	 ret	 4
$LN11@KdpConvert:

; 419  :             per->ExceptionAddress = SIGN_EXTEND(context->ip);
; 420  :             break;
; 421  : 
; 422  :         case Struct_Microsoft_Singularity_Isal_IX_EVectors_DebuggerBreakRequest:
; 423  :             KDDBG("KD: Debugger ctrl-break\n");
; 424  :             per->ExceptionCode = STATUS_BREAKPOINT;
; 425  :             per->ExceptionInformation0 = BREAKPOINT_BREAK;

  000e0	33 f6		 xor	 esi, esi
  000e2	89 71 20	 mov	 DWORD PTR [ecx+32], esi
  000e5	89 71 24	 mov	 DWORD PTR [ecx+36], esi
  000e8	c7 01 03 00 00
	80		 mov	 DWORD PTR [ecx], -2147483645 ; 80000003H

; 439  :             per->ExceptionAddress = SIGN_EXTEND(context->ip);

  000ee	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000f1	99		 cdq
  000f2	5f		 pop	 edi
  000f3	89 51 14	 mov	 DWORD PTR [ecx+20], edx
  000f6	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  000f9	5e		 pop	 esi

; 440  :             break;
; 441  : 
; 442  :     }
; 443  : 
; 444  :     KDDBG("Trap: Context at %p\n", context);
; 445  :     KDDBG("  CXT=%08x  THR=%08x\n",
; 446  :           context,
; 447  :           Class_Microsoft_Singularity_Processor::g_GetCurrentThreadContext()->_thread);
; 448  :     KDDBG("  EIP=%08x  EFL=%08x\n",
; 449  :           context->ip, context->fl);
; 450  :     KDDBG("  EAX=%08x  EBX=%08x  ECX=%08x  EDX=%08x\n",
; 451  :           context->ax, context->bx, context->cx, context->dx);
; 452  :     KDDBG("  ESP=%08x  EBP=%08x  ESI=%08x  EDI=%08x\n",
; 453  :           context->sp, context->bp, context->si, context->di);
; 454  : }

  000fa	5d		 pop	 ebp
  000fb	c2 04 00	 ret	 4
$LN9@KdpConvert:

; 426  :             per->ExceptionAddress = SIGN_EXTEND(context->ip);
; 427  :             break;
; 428  : 
; 429  :         case Struct_Microsoft_Singularity_Isal_IX_EVectors_Nmi:
; 430  :             KDDBG("KD: NMI exception\n");
; 431  :             per->ExceptionCode = STATUS_UNHANDLED_EXCEPTION;
; 432  :             per->ExceptionInformation0 = BREAKPOINT_BREAK;

  000fe	33 f6		 xor	 esi, esi
  00100	89 71 20	 mov	 DWORD PTR [ecx+32], esi
  00103	89 71 24	 mov	 DWORD PTR [ecx+36], esi
  00106	c7 01 44 01 00
	c0		 mov	 DWORD PTR [ecx], -1073741500 ; c0000144H

; 439  :             per->ExceptionAddress = SIGN_EXTEND(context->ip);

  0010c	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0010f	99		 cdq
  00110	5f		 pop	 edi
  00111	89 51 14	 mov	 DWORD PTR [ecx+20], edx
  00114	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00117	5e		 pop	 esi

; 440  :             break;
; 441  : 
; 442  :     }
; 443  : 
; 444  :     KDDBG("Trap: Context at %p\n", context);
; 445  :     KDDBG("  CXT=%08x  THR=%08x\n",
; 446  :           context,
; 447  :           Class_Microsoft_Singularity_Processor::g_GetCurrentThreadContext()->_thread);
; 448  :     KDDBG("  EIP=%08x  EFL=%08x\n",
; 449  :           context->ip, context->fl);
; 450  :     KDDBG("  EAX=%08x  EBX=%08x  ECX=%08x  EDX=%08x\n",
; 451  :           context->ax, context->bx, context->cx, context->dx);
; 452  :     KDDBG("  ESP=%08x  EBP=%08x  ESI=%08x  EDI=%08x\n",
; 453  :           context->sp, context->bp, context->si, context->di);
; 454  : }

  00118	5d		 pop	 ebp
  00119	c2 04 00	 ret	 4
$LN7@KdpConvert:

; 433  :             per->ExceptionAddress = SIGN_EXTEND(context->ip);
; 434  :             break;
; 435  : 
; 436  :         default:
; 437  :             KDDBG("KD: Unexpected interrupt %d\n", id);
; 438  :             per->ExceptionCode = 0x80000000 + id;

  0011c	81 c7 00 00 00
	80		 add	 edi, -2147483648	; 80000000H
  00122	89 39		 mov	 DWORD PTR [ecx], edi

; 439  :             per->ExceptionAddress = SIGN_EXTEND(context->ip);

  00124	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00127	99		 cdq
  00128	5f		 pop	 edi
  00129	89 51 14	 mov	 DWORD PTR [ecx+20], edx
  0012c	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0012f	5e		 pop	 esi

; 440  :             break;
; 441  : 
; 442  :     }
; 443  : 
; 444  :     KDDBG("Trap: Context at %p\n", context);
; 445  :     KDDBG("  CXT=%08x  THR=%08x\n",
; 446  :           context,
; 447  :           Class_Microsoft_Singularity_Processor::g_GetCurrentThreadContext()->_thread);
; 448  :     KDDBG("  EIP=%08x  EFL=%08x\n",
; 449  :           context->ip, context->fl);
; 450  :     KDDBG("  EAX=%08x  EBX=%08x  ECX=%08x  EDX=%08x\n",
; 451  :           context->ax, context->bx, context->cx, context->dx);
; 452  :     KDDBG("  ESP=%08x  EBP=%08x  ESI=%08x  EDI=%08x\n",
; 453  :           context->sp, context->bp, context->si, context->di);
; 454  : }

  00130	5d		 pop	 ebp
  00131	c2 04 00	 ret	 4
$LN36@KdpConvert:
  00134	00 00 00 00	 DD	 $LN28@KdpConvert
  00138	00 00 00 00	 DD	 $LN9@KdpConvert
  0013c	00 00 00 00	 DD	 $LN26@KdpConvert
  00140	00 00 00 00	 DD	 $LN24@KdpConvert
  00144	00 00 00 00	 DD	 $LN22@KdpConvert
  00148	00 00 00 00	 DD	 $LN20@KdpConvert
  0014c	00 00 00 00	 DD	 $LN13@KdpConvert
  00150	00 00 00 00	 DD	 $LN11@KdpConvert
  00154	00 00 00 00	 DD	 $LN7@KdpConvert
$LN33@KdpConvert:
  00158	00		 DB	 0
  00159	01		 DB	 1
  0015a	02		 DB	 2
  0015b	08		 DB	 8
  0015c	08		 DB	 8
  0015d	03		 DB	 3
  0015e	08		 DB	 8
  0015f	08		 DB	 8
  00160	08		 DB	 8
  00161	08		 DB	 8
  00162	08		 DB	 8
  00163	08		 DB	 8
  00164	08		 DB	 8
  00165	04		 DB	 4
  00166	08		 DB	 8
  00167	08		 DB	 8
  00168	08		 DB	 8
  00169	08		 DB	 8
  0016a	08		 DB	 8
  0016b	08		 DB	 8
  0016c	08		 DB	 8
  0016d	08		 DB	 8
  0016e	08		 DB	 8
  0016f	08		 DB	 8
  00170	08		 DB	 8
  00171	08		 DB	 8
  00172	08		 DB	 8
  00173	08		 DB	 8
  00174	05		 DB	 5
  00175	06		 DB	 6
  00176	07		 DB	 7
?KdpConvertTrapToException@@YIXPAUStruct_Microsoft_Singularity_Kd_ExceptionRecord64@@PAUStruct_Microsoft_Singularity_Isal_SpillContext@@H@Z ENDP ; KdpConvertTrapToException
_TEXT	ENDS
PUBLIC	?KdpReadWriteIoSpace@@YIHHHGI@Z			; KdpReadWriteIoSpace
; Function compile flags: /Ogtp
;	COMDAT ?KdpReadWriteIoSpace@@YIHHHGI@Z
_TEXT	SEGMENT
_addr$ = 8						; size = 2
_value$ = 12						; size = 4
?KdpReadWriteIoSpace@@YIHHHGI@Z PROC			; KdpReadWriteIoSpace, COMDAT
; _size$ = ecx
; _iowrite$ = edx

; 471  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 472  :     unsigned int retValue = 0;

  00004	33 f6		 xor	 esi, esi

; 473  : 
; 474  :     if (iowrite != 0) {

  00006	85 d2		 test	 edx, edx
  00008	74 3e		 je	 SHORT $LN12@KdpReadWri

; 475  :         // I/O Write's
; 476  : 
; 477  :         if (size == 1) {

  0000a	83 f9 01	 cmp	 ecx, 1
  0000d	75 0f		 jne	 SHORT $LN11@KdpReadWri

; 478  :             unsigned char byteValue = (unsigned char)value;
; 479  :             __outbyte(addr, value);

  0000f	66 8b 55 08	 mov	 dx, WORD PTR _addr$[ebp]
  00013	8a 45 0c	 mov	 al, BYTE PTR _value$[ebp]
  00016	ee		 out	 dx, al
$LN16@KdpReadWri:

; 500  :         }
; 501  :     }
; 502  : 
; 503  :     return retValue;

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi

; 504  : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
$LN11@KdpReadWri:

; 480  :         }
; 481  :         else if (size == 2) {

  0001e	83 f9 02	 cmp	 ecx, 2
  00021	75 11		 jne	 SHORT $LN9@KdpReadWri

; 482  :             unsigned short wordValue = (unsigned short)value;
; 483  :             __outword(addr, value);

  00023	66 8b 45 0c	 mov	 ax, WORD PTR _value$[ebp]
  00027	66 8b 55 08	 mov	 dx, WORD PTR _addr$[ebp]
  0002b	66 ef		 out	 dx, ax

; 500  :         }
; 501  :     }
; 502  : 
; 503  :     return retValue;

  0002d	8b c6		 mov	 eax, esi
  0002f	5e		 pop	 esi

; 504  : }

  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
$LN9@KdpReadWri:

; 484  :         }
; 485  :         else if (size == 4) {

  00034	83 f9 04	 cmp	 ecx, 4
  00037	75 de		 jne	 SHORT $LN16@KdpReadWri

; 486  :             __outdword(addr, value);

  00039	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  0003c	66 8b 55 08	 mov	 dx, WORD PTR _addr$[ebp]
  00040	ef		 out	 dx, eax

; 500  :         }
; 501  :     }
; 502  : 
; 503  :     return retValue;

  00041	8b c6		 mov	 eax, esi
  00043	5e		 pop	 esi

; 504  : }

  00044	5d		 pop	 ebp
  00045	c2 08 00	 ret	 8
$LN12@KdpReadWri:

; 487  :         }
; 488  :     }
; 489  :     else {
; 490  :         // I/O Read's
; 491  : 
; 492  :         if (size == 1) {

  00048	83 f9 01	 cmp	 ecx, 1
  0004b	75 0d		 jne	 SHORT $LN5@KdpReadWri

; 493  :             retValue = __inbyte(addr);

  0004d	66 8b 55 08	 mov	 dx, WORD PTR _addr$[ebp]
  00051	ec		 in	 al, dx
  00052	0f b6 c0	 movzx	 eax, al
  00055	5e		 pop	 esi

; 504  : }

  00056	5d		 pop	 ebp
  00057	c2 08 00	 ret	 8
$LN5@KdpReadWri:

; 494  :         }
; 495  :         else if (size == 2) {

  0005a	83 f9 02	 cmp	 ecx, 2
  0005d	75 0e		 jne	 SHORT $LN3@KdpReadWri

; 496  :             retValue = __inword(addr);

  0005f	66 8b 55 08	 mov	 dx, WORD PTR _addr$[ebp]
  00063	66 ed		 in	 ax, dx
  00065	0f b7 c0	 movzx	 eax, ax
  00068	5e		 pop	 esi

; 504  : }

  00069	5d		 pop	 ebp
  0006a	c2 08 00	 ret	 8
$LN3@KdpReadWri:

; 497  :         }
; 498  :         else if (size == 4) {

  0006d	83 f9 04	 cmp	 ecx, 4
  00070	75 a5		 jne	 SHORT $LN16@KdpReadWri

; 499  :             retValue = __indword(addr);

  00072	66 8b 55 08	 mov	 dx, WORD PTR _addr$[ebp]
  00076	ed		 in	 eax, dx
  00077	5e		 pop	 esi

; 504  : }

  00078	5d		 pop	 ebp
  00079	c2 08 00	 ret	 8
?KdpReadWriteIoSpace@@YIHHHGI@Z ENDP			; KdpReadWriteIoSpace
_TEXT	ENDS
END
