; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	C:\Users\cc\source\repos\Singularity-OS\base\Kernel\Native\MemoryStorage.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?GetRecordHeaderSize@@YIIGG@Z			; GetRecordHeaderSize
; Function compile flags: /Ogtp
; File c:\users\cc\source\repos\singularity-os\base\kernel\native\eventing.h
;	COMDAT ?GetRecordHeaderSize@@YIIGG@Z
_TEXT	SEGMENT
?GetRecordHeaderSize@@YIIGG@Z PROC			; GetRecordHeaderSize, COMDAT
; _Flags$ = cx
; _StackSize$ = edx

; 168  :     uint16 HeaderSize = sizeof(MEMORY_HEADER);
; 169  : 
; 170  :     if (Flags & RECORD_STACK_TRACES) {

  00000	f6 c1 01	 test	 cl, 1
  00003	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00008	74 05		 je	 SHORT $LN4@GetRecordH

; 171  :         
; 172  :         HeaderSize += StackSize;

  0000a	03 d0		 add	 edx, eax
  0000c	0f b7 c2	 movzx	 eax, dx
$LN4@GetRecordH:

; 173  :     }
; 174  : 
; 175  :     return HeaderSize;

  0000f	0f b7 c0	 movzx	 eax, ax

; 176  : }

  00012	c3		 ret	 0
?GetRecordHeaderSize@@YIIGG@Z ENDP			; GetRecordHeaderSize
_TEXT	ENDS
PUBLIC	?GetRecordInternalStructure@@YIPAXPAU_MEMORY_HEADER@@G@Z ; GetRecordInternalStructure
; Function compile flags: /Ogtp
;	COMDAT ?GetRecordInternalStructure@@YIPAXPAU_MEMORY_HEADER@@G@Z
_TEXT	SEGMENT
?GetRecordInternalStructure@@YIPAXPAU_MEMORY_HEADER@@G@Z PROC ; GetRecordInternalStructure, COMDAT
; _Record$ = ecx
; _RecordFlag$ = dx

; 186  :     if (Record->Flags & RecordFlag) {

  00000	66 85 51 06	 test	 WORD PTR [ecx+6], dx
  00004	74 0e		 je	 SHORT $LN2@GetRecordI

; 187  : 
; 188  :         uint16 HeaderSize;
; 189  : 
; 190  :         if (RecordFlag & (RecordFlag - 1)) {

  00006	0f b7 c2	 movzx	 eax, dx
  00009	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
  0000c	85 d0		 test	 edx, eax

; 191  : 
; 192  :             //  A single bit at the time can be set to query the internal layout info.
; 193  :             //  Return failure otherwise.
; 194  : 
; 195  :             return NULL;

  0000e	75 04		 jne	 SHORT $LN2@GetRecordI

; 196  :         }
; 197  : 
; 198  :         //  The structures are allocated in order, as the flags bits decrease
; 199  :         //  We can clear the flags 
; 200  : 
; 201  :         HeaderSize = GetRecordHeaderSize(Record->Flags & (~((RecordFlag << 1) - 1)), 0);
; 202  : 
; 203  :         return (PVOID)((ULONG_PTR)Record + HeaderSize);

  00010	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]

; 207  : }

  00013	c3		 ret	 0
$LN2@GetRecordI:

; 204  :     }
; 205  : 
; 206  :     return NULL;

  00014	33 c0		 xor	 eax, eax

; 207  : }

  00016	c3		 ret	 0
?GetRecordInternalStructure@@YIPAXPAU_MEMORY_HEADER@@G@Z ENDP ; GetRecordInternalStructure
_TEXT	ENDS
PUBLIC	?GetUserRecordStructure@@YIPAXPAU_MEMORY_HEADER@@@Z ; GetUserRecordStructure
; Function compile flags: /Ogtp
;	COMDAT ?GetUserRecordStructure@@YIPAXPAU_MEMORY_HEADER@@@Z
_TEXT	SEGMENT
?GetUserRecordStructure@@YIPAXPAU_MEMORY_HEADER@@@Z PROC ; GetUserRecordStructure, COMDAT
; _Record$ = ecx

; 216  :     if (Record->Flags & RECORD_STACK_TRACES) {

  00000	f6 41 06 01	 test	 BYTE PTR [ecx+6], 1
  00004	74 17		 je	 SHORT $LN2@GetUserRec

; 217  : 
; 218  :         ULONG_PTR * StackSize = (ULONG_PTR *)GetRecordInternalStructure(Record, RECORD_STACK_TRACES);
; 219  :         return (PVOID)((ULONG_PTR)Record + GetRecordHeaderSize(Record->Flags, (uint16)(*StackSize + 1) * sizeof(UIntPtr)));

  00006	66 8b 41 18	 mov	 ax, WORD PTR [ecx+24]
  0000a	66 05 07 00	 add	 ax, 7
  0000e	66 03 c0	 add	 ax, ax
  00011	66 03 c0	 add	 ax, ax
  00014	0f b7 c0	 movzx	 eax, ax
  00017	0f b7 c0	 movzx	 eax, ax
  0001a	03 c1		 add	 eax, ecx

; 224  :     }
; 225  : 
; 226  :     return NULL;
; 227  : }

  0001c	c3		 ret	 0
$LN2@GetUserRec:

; 220  : 
; 221  :     } else {
; 222  : 
; 223  :         return (PVOID)((ULONG_PTR)Record + GetRecordHeaderSize(Record->Flags, 0));

  0001d	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]

; 224  :     }
; 225  : 
; 226  :     return NULL;
; 227  : }

  00020	c3		 ret	 0
?GetUserRecordStructure@@YIPAXPAU_MEMORY_HEADER@@@Z ENDP ; GetUserRecordStructure
_TEXT	ENDS
PUBLIC	?MemoryStorageGetNextGeneration@@YIIPAU_MEMORY_STORAGE@@@Z ; MemoryStorageGetNextGeneration
; Function compile flags: /Ogtp
; File c:\users\cc\source\repos\singularity-os\base\kernel\native\memorystorage.cpp
;	COMDAT ?MemoryStorageGetNextGeneration@@YIIPAU_MEMORY_STORAGE@@@Z
_TEXT	SEGMENT
?MemoryStorageGetNextGeneration@@YIIPAU_MEMORY_STORAGE@@@Z PROC ; MemoryStorageGetNextGeneration, COMDAT
; _Storage$ = ecx

; 25   :     return (uint32)InterlockedIncrement((volatile INT32* )&Storage->Generation);

  00000	83 c1 20	 add	 ecx, 32			; 00000020H
  00003	b8 01 00 00 00	 mov	 eax, 1
  00008	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  0000c	40		 inc	 eax

; 26   : }

  0000d	c3		 ret	 0
?MemoryStorageGetNextGeneration@@YIIPAU_MEMORY_STORAGE@@@Z ENDP ; MemoryStorageGetNextGeneration
_TEXT	ENDS
PUBLIC	?MemoryStorageAdvanceCursor@@YIPAU_MEMORY_HEADER@@PAU_MEMORY_STORAGE@@PAU_MEMORY_ZONE@@G@Z ; MemoryStorageAdvanceCursor
EXTRN	?AllocateEventEntry@@YIPAU_MEMORY_HEADER@@PAU_MEMORY_ZONE@@G@Z:PROC ; AllocateEventEntry
EXTRN	?RecycleZone@@YI_NPAU_MEMORY_ZONE@@@Z:PROC	; RecycleZone
EXTRN	?IsZoneCompleted@@YI_NPAU_MEMORY_ZONE@@@Z:PROC	; IsZoneCompleted
; Function compile flags: /Ogtp
;	COMDAT ?MemoryStorageAdvanceCursor@@YIPAU_MEMORY_HEADER@@PAU_MEMORY_STORAGE@@PAU_MEMORY_ZONE@@G@Z
_TEXT	SEGMENT
_CapturedCursor$ = -12					; size = 4
tv160 = -8						; size = 4
_Reycled$ = -4						; size = 4
_size$ = 8						; size = 2
?MemoryStorageAdvanceCursor@@YIPAU_MEMORY_HEADER@@PAU_MEMORY_STORAGE@@PAU_MEMORY_ZONE@@G@Z PROC ; MemoryStorageAdvanceCursor, COMDAT
; _Storage$ = ecx
; _CurrentCursor$ = edx

; 32   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx

; 33   :     PMEMORY_ZONE NewCursor;
; 34   :     PMEMORY_ZONE CapturedCursor = Storage->ZoneCursor;

  0000b	8d 47 1c	 lea	 eax, DWORD PTR [edi+28]
  0000e	89 45 f8	 mov	 DWORD PTR tv160[ebp], eax
  00011	8b 00		 mov	 eax, DWORD PTR [eax]
  00013	8b da		 mov	 ebx, edx

; 35   :     BOOL Reycled = false;
; 36   : 
; 37   :     NewCursor = CurrentCursor;
; 38   : 
; 39   :     if (NewCursor == NULL) {

  00015	85 db		 test	 ebx, ebx
  00017	89 45 f4	 mov	 DWORD PTR _CapturedCursor$[ebp], eax
  0001a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Reycled$[ebp], 0
  00021	8b c3		 mov	 eax, ebx
  00023	75 03		 jne	 SHORT $LN11@MemoryStor

; 40   : 
; 41   :         NewCursor = Storage->MemoryZoneLink;

  00025	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
$LN11@MemoryStor:

; 42   :     }
; 43   : 
; 44   :     for (NewCursor = NewCursor->Link; NewCursor != CurrentCursor; NewCursor = NewCursor->Link) {

  00028	8b 30		 mov	 esi, DWORD PTR [eax]
  0002a	3b f3		 cmp	 esi, ebx
  0002c	74 49		 je	 SHORT $LN8@MemoryStor
  0002e	8b ff		 npad	 2
$LL18@MemoryStor:

; 45   : 
; 46   :         if (NewCursor == NULL) {

  00030	85 f6		 test	 esi, esi
  00032	75 1b		 jne	 SHORT $LN3@MemoryStor

; 47   : 
; 48   :             //  Restart from the begining of the storage
; 49   :             //  Make sure the policy allows this
; 50   : 
; 51   :             if (Storage->Flags & MEMORY_STORAGE_FLAGS_RECYCLE_MEMORY) {

  00034	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00037	a8 02		 test	 al, 2
  00039	74 3c		 je	 SHORT $LN8@MemoryStor

; 52   : 
; 53   :                 if (Reycled) {

  0003b	39 75 fc	 cmp	 DWORD PTR _Reycled$[ebp], esi
  0003e	75 37		 jne	 SHORT $LN8@MemoryStor

; 54   : 
; 55   :                     // Every zone has been tried for this allocation
; 56   :                     // return back the failure.
; 57   : 
; 58   :                     return NULL;
; 59   :                 }
; 60   : 
; 61   :                 if (Storage->Flags & MEMORY_STORAGE_FLAGS_BREAK_ON_RECYCLE) {

  00040	a8 40		 test	 al, 64			; 00000040H
  00042	74 01		 je	 SHORT $LN4@MemoryStor

; 62   : 
; 63   :                     // If we trap here, there is a request to stop before over-writing
; 64   :                     // any buffer contents.  That is about to happen, so this is the
; 65   :                     // last chance to retrieve those contents before they are lost.
; 66   :                     //
; 67   :                     // Then proceed from this breakpoint.
; 68   : 
; 69   :                     __debugbreak();

  00044	cc		 int	 3
$LN4@MemoryStor:

; 70   :                 }
; 71   : 
; 72   :                 Reycled = true;
; 73   : 
; 74   :                 NewCursor = Storage->MemoryZoneLink;

  00045	8b 77 14	 mov	 esi, DWORD PTR [edi+20]
  00048	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _Reycled$[ebp], 1
$LN3@MemoryStor:

; 75   : 
; 76   :             } else {
; 77   : 
; 78   :                 // We must return here failure, as recycling the memory for older events
; 79   :                 // is not permited
; 80   : 
; 81   :                 return NULL;
; 82   :             }
; 83   : 
; 84   :         }
; 85   : 
; 86   :         if (IsZoneCompleted(NewCursor)) {

  0004f	8b ce		 mov	 ecx, esi
  00051	e8 00 00 00 00	 call	 ?IsZoneCompleted@@YI_NPAU_MEMORY_ZONE@@@Z ; IsZoneCompleted
  00056	84 c0		 test	 al, al
  00058	74 07		 je	 SHORT $LN2@MemoryStor

; 87   : 
; 88   :             RecycleZone(NewCursor);

  0005a	8b ce		 mov	 ecx, esi
  0005c	e8 00 00 00 00	 call	 ?RecycleZone@@YI_NPAU_MEMORY_ZONE@@@Z ; RecycleZone
$LN2@MemoryStor:

; 89   :         }
; 90   : 
; 91   :         PMEMORY_HEADER Event = AllocateEventEntry(NewCursor, size);

  00061	8b 55 08	 mov	 edx, DWORD PTR _size$[ebp]
  00064	8b ce		 mov	 ecx, esi
  00066	e8 00 00 00 00	 call	 ?AllocateEventEntry@@YIPAU_MEMORY_HEADER@@PAU_MEMORY_ZONE@@G@Z ; AllocateEventEntry
  0006b	8b c8		 mov	 ecx, eax

; 92   :         if (Event != NULL) {

  0006d	85 c9		 test	 ecx, ecx
  0006f	75 11		 jne	 SHORT $LN16@MemoryStor
  00071	8b 36		 mov	 esi, DWORD PTR [esi]
  00073	3b f3		 cmp	 esi, ebx
  00075	75 b9		 jne	 SHORT $LL18@MemoryStor
$LN8@MemoryStor:
  00077	5f		 pop	 edi
  00078	5e		 pop	 esi

; 103  :         }
; 104  :     }
; 105  : 
; 106  :     return NULL;

  00079	33 c0		 xor	 eax, eax
  0007b	5b		 pop	 ebx

; 107  : }

  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c2 04 00	 ret	 4
$LN16@MemoryStor:

; 93   : 
; 94   :             // we were successfuly in using this zone, set it as current cursor
; 95   :             // It is possible some other thread already did it, or even moved far ahead
; 96   :             // But this should not be a problem as there are no guarantees wrt. ordering
; 97   :             // in the storage
; 98   : 
; 99   :             InterlockedCompareExchangePointer((PVOID *)&Storage->ZoneCursor,
; 100  :                     (PVOID)NewCursor,
; 101  :                     (PVOID)CapturedCursor);

  00082	8b 55 f8	 mov	 edx, DWORD PTR tv160[ebp]
  00085	8b 45 f4	 mov	 eax, DWORD PTR _CapturedCursor$[ebp]
  00088	f0 0f b1 32	 lock	  cmpxchg DWORD PTR [edx], esi
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi

; 102  :             return Event;

  0008e	8b c1		 mov	 eax, ecx
  00090	5b		 pop	 ebx

; 107  : }

  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 04 00	 ret	 4
?MemoryStorageAdvanceCursor@@YIPAU_MEMORY_HEADER@@PAU_MEMORY_STORAGE@@PAU_MEMORY_ZONE@@G@Z ENDP ; MemoryStorageAdvanceCursor
_TEXT	ENDS
PUBLIC	?CaptureStackTrace@@YIIPAPAUuintPtr@@I@Z	; CaptureStackTrace
EXTRN	?g_GetFrameReturnAddress@Class_Microsoft_Singularity_Isal_Isa@@SIPAUuintPtr@@PAU2@@Z:PROC ; Class_Microsoft_Singularity_Isal_Isa::g_GetFrameReturnAddress
EXTRN	?g_GetCurrentProcessorContext@Class_Microsoft_Singularity_Processor@@SIPAUStruct_Microsoft_Singularity_ProcessorContext@@XZ:PROC ; Class_Microsoft_Singularity_Processor::g_GetCurrentProcessorContext
EXTRN	?g_GetFrameCallerFrame@Class_Microsoft_Singularity_Isal_Isa@@SIPAUuintPtr@@PAU2@@Z:PROC ; Class_Microsoft_Singularity_Isal_Isa::g_GetFrameCallerFrame
EXTRN	?g_GetFramePointer@Class_Microsoft_Singularity_Isal_Isa@@SIPAUuintPtr@@XZ:PROC ; Class_Microsoft_Singularity_Isal_Isa::g_GetFramePointer
; Function compile flags: /Ogtp
;	COMDAT ?CaptureStackTrace@@YIIPAPAUuintPtr@@I@Z
_TEXT	SEGMENT
_processorContext$ = -8					; size = 4
_MaxStackSize$ = -4					; size = 4
?CaptureStackTrace@@YIIPAPAUuintPtr@@I@Z PROC		; CaptureStackTrace, COMDAT
; _StackArray$ = ecx
; _MaxStackSize$ = edx

; 112  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 55 fc	 mov	 DWORD PTR _MaxStackSize$[ebp], edx
  0000c	8b d9		 mov	 ebx, ecx

; 113  : 
; 114  :     uint32 Index;
; 115  :     UIntPtr CurrentFrame = Class_Microsoft_Singularity_Isal_Isa::g_GetFramePointer();

  0000e	e8 00 00 00 00	 call	 ?g_GetFramePointer@Class_Microsoft_Singularity_Isal_Isa@@SIPAUuintPtr@@XZ ; Class_Microsoft_Singularity_Isal_Isa::g_GetFramePointer
  00013	8b f8		 mov	 edi, eax

; 116  :     UIntPtr CallerFrame = Class_Microsoft_Singularity_Isal_Isa::g_GetFrameCallerFrame(CurrentFrame);

  00015	8b cf		 mov	 ecx, edi
  00017	e8 00 00 00 00	 call	 ?g_GetFrameCallerFrame@Class_Microsoft_Singularity_Isal_Isa@@SIPAUuintPtr@@PAU2@@Z ; Class_Microsoft_Singularity_Isal_Isa::g_GetFrameCallerFrame
  0001c	8b f0		 mov	 esi, eax

; 117  : 
; 118  :     Struct_Microsoft_Singularity_ProcessorContext *processorContext =
; 119  :         Class_Microsoft_Singularity_Processor::g_GetCurrentProcessorContext();

  0001e	e8 00 00 00 00	 call	 ?g_GetCurrentProcessorContext@Class_Microsoft_Singularity_Processor@@SIPAUStruct_Microsoft_Singularity_ProcessorContext@@XZ ; Class_Microsoft_Singularity_Processor::g_GetCurrentProcessorContext

; 120  : 
; 121  :     if ((CurrentFrame <= (UIntPtr)processorContext->cpuRecord.interruptStackBegin) &&
; 122  :         (CurrentFrame > (UIntPtr)processorContext->cpuRecord.interruptStackLimit)) {

  00023	3b b8 44 02 00
	00		 cmp	 edi, DWORD PTR [eax+580]
  00029	89 45 f8	 mov	 DWORD PTR _processorContext$[ebp], eax
  0002c	77 4d		 ja	 SHORT $LN9@CaptureSta
  0002e	3b b8 48 02 00
	00		 cmp	 edi, DWORD PTR [eax+584]
  00034	76 45		 jbe	 SHORT $LN9@CaptureSta

; 123  : 
; 124  :         //  Capture the interrupte stack. Always check against the limits
; 125  :         //  before fetching the next frame
; 126  : 
; 127  :         for (Index = 0; (CallerFrame != 0) && Index < MaxStackSize; Index += 1) {

  00036	33 ff		 xor	 edi, edi
  00038	85 f6		 test	 esi, esi
  0003a	74 64		 je	 SHORT $LN1@CaptureSta
  0003c	eb 05		 jmp	 SHORT $LN8@CaptureSta
  0003e	8b ff		 npad	 2
$LL17@CaptureSta:
  00040	8b 45 f8	 mov	 eax, DWORD PTR _processorContext$[ebp]
$LN8@CaptureSta:
  00043	3b 7d fc	 cmp	 edi, DWORD PTR _MaxStackSize$[ebp]
  00046	73 58		 jae	 SHORT $LN1@CaptureSta

; 128  : 
; 129  :             if ((CallerFrame > (UIntPtr)processorContext->cpuRecord.interruptStackBegin) ||
; 130  :                 (CallerFrame < (UIntPtr)processorContext->cpuRecord.interruptStackLimit)) {

  00048	3b b0 44 02 00
	00		 cmp	 esi, DWORD PTR [eax+580]
  0004e	77 50		 ja	 SHORT $LN1@CaptureSta
  00050	3b b0 48 02 00
	00		 cmp	 esi, DWORD PTR [eax+584]
  00056	72 48		 jb	 SHORT $LN1@CaptureSta

; 131  : 
; 132  :                 return Index;
; 133  :             }
; 134  :             StackArray[Index] = Class_Microsoft_Singularity_Isal_Isa::g_GetFrameReturnAddress(CallerFrame);

  00058	8b ce		 mov	 ecx, esi
  0005a	e8 00 00 00 00	 call	 ?g_GetFrameReturnAddress@Class_Microsoft_Singularity_Isal_Isa@@SIPAUuintPtr@@PAU2@@Z ; Class_Microsoft_Singularity_Isal_Isa::g_GetFrameReturnAddress

; 135  :             CallerFrame = Class_Microsoft_Singularity_Isal_Isa::g_GetFrameCallerFrame(CallerFrame);

  0005f	8b ce		 mov	 ecx, esi
  00061	89 04 bb	 mov	 DWORD PTR [ebx+edi*4], eax
  00064	e8 00 00 00 00	 call	 ?g_GetFrameCallerFrame@Class_Microsoft_Singularity_Isal_Isa@@SIPAUuintPtr@@PAU2@@Z ; Class_Microsoft_Singularity_Isal_Isa::g_GetFrameCallerFrame
  00069	8b f0		 mov	 esi, eax
  0006b	83 c7 01	 add	 edi, 1
  0006e	85 f6		 test	 esi, esi
  00070	75 ce		 jne	 SHORT $LL17@CaptureSta

; 145  :     }
; 146  :     return Index;

  00072	8b c7		 mov	 eax, edi
  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx

; 147  : }

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
$LN9@CaptureSta:

; 136  :         }
; 137  :         return Index;
; 138  :     }
; 139  : 
; 140  : 
; 141  :     for (Index = 0; (CallerFrame != 0) && Index < MaxStackSize; Index += 1) {

  0007b	33 ff		 xor	 edi, edi
  0007d	85 f6		 test	 esi, esi
  0007f	74 1f		 je	 SHORT $LN1@CaptureSta
$LL3@CaptureSta:
  00081	3b 7d fc	 cmp	 edi, DWORD PTR _MaxStackSize$[ebp]
  00084	73 1a		 jae	 SHORT $LN1@CaptureSta

; 142  : 
; 143  :         StackArray[Index] = Class_Microsoft_Singularity_Isal_Isa::g_GetFrameReturnAddress(CallerFrame);

  00086	8b ce		 mov	 ecx, esi
  00088	e8 00 00 00 00	 call	 ?g_GetFrameReturnAddress@Class_Microsoft_Singularity_Isal_Isa@@SIPAUuintPtr@@PAU2@@Z ; Class_Microsoft_Singularity_Isal_Isa::g_GetFrameReturnAddress

; 144  :         CallerFrame = Class_Microsoft_Singularity_Isal_Isa::g_GetFrameCallerFrame(CallerFrame);

  0008d	8b ce		 mov	 ecx, esi
  0008f	89 04 bb	 mov	 DWORD PTR [ebx+edi*4], eax
  00092	e8 00 00 00 00	 call	 ?g_GetFrameCallerFrame@Class_Microsoft_Singularity_Isal_Isa@@SIPAUuintPtr@@PAU2@@Z ; Class_Microsoft_Singularity_Isal_Isa::g_GetFrameCallerFrame
  00097	8b f0		 mov	 esi, eax
  00099	83 c7 01	 add	 edi, 1
  0009c	85 f6		 test	 esi, esi
  0009e	75 e1		 jne	 SHORT $LL3@CaptureSta
$LN1@CaptureSta:

; 145  :     }
; 146  :     return Index;

  000a0	8b c7		 mov	 eax, edi
  000a2	5f		 pop	 edi
  000a3	5e		 pop	 esi
  000a4	5b		 pop	 ebx

; 147  : }

  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c3		 ret	 0
?CaptureStackTrace@@YIIPAPAUuintPtr@@I@Z ENDP		; CaptureStackTrace
_TEXT	ENDS
PUBLIC	?InternalLogRecord@@YIPAU_MEMORY_HEADER@@PAUuintPtr@@I0PAXIPAPAXI@Z ; InternalLogRecord
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
;	COMDAT ?InternalLogRecord@@YIPAU_MEMORY_HEADER@@PAUuintPtr@@I0PAXIPAPAXI@Z
_TEXT	SEGMENT
_Stacks$ = -152						; size = 128
tv309 = -24						; size = 4
_allocSize$ = -20					; size = 4
_StorageHandle$ = -16					; size = 4
_EntrySize$ = -12					; size = 4
_Flags$ = -8						; size = 4
_StackSize$ = -4					; size = 4
_eventType$ = 8						; size = 4
_Buffer$ = 12						; size = 4
_size$ = 16						; size = 4
_ExtendedBuffer$ = 20					; size = 4
_ExtendedSize$ = 24					; size = 4
?InternalLogRecord@@YIPAU_MEMORY_HEADER@@PAUuintPtr@@I0PAXIPAPAXI@Z PROC ; InternalLogRecord, COMDAT
; _StorageHandle$ = ecx
; _Flags$ = edx

; 159  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx

; 160  :     if (StorageHandle == 0) return NULL;

  0000d	85 ff		 test	 edi, edi
  0000f	8b da		 mov	 ebx, edx
  00011	89 5d f8	 mov	 DWORD PTR _Flags$[ebp], ebx
  00014	89 7d f0	 mov	 DWORD PTR _StorageHandle$[ebp], edi
  00017	75 0a		 jne	 SHORT $LN10@InternalLo
  00019	5f		 pop	 edi
  0001a	33 c0		 xor	 eax, eax
  0001c	5b		 pop	 ebx

; 239  : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 14 00	 ret	 20			; 00000014H
$LN10@InternalLo:
  00023	56		 push	 esi

; 161  : 
; 162  :     PMEMORY_STORAGE Storage = (PMEMORY_STORAGE)StorageHandle;
; 163  : 
; 164  :     UIntPtr Stacks[RECORD_MAXSTACKSIZE];
; 165  :     uint32 StackSize = 0;
; 166  :     uint32 allocSize = (uint32)ROUND_UP_TO_POWER2(size, sizeof(UIntPtr));

  00024	8b 75 10	 mov	 esi, DWORD PTR _size$[ebp]
  00027	83 c6 03	 add	 esi, 3
  0002a	83 e6 fc	 and	 esi, -4			; fffffffcH

; 167  : 
; 168  :     if (Flags & RECORD_STACK_TRACES) {

  0002d	f6 c3 01	 test	 bl, 1
  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _StackSize$[ebp], 0
  00037	89 75 ec	 mov	 DWORD PTR _allocSize$[ebp], esi
  0003a	74 32		 je	 SHORT $LN7@InternalLo

; 169  : 
; 170  :         StackSize = CaptureStackTrace(Stacks, RECORD_MAXSTACKSIZE);

  0003c	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00041	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _Stacks$[ebp]
  00047	e8 00 00 00 00	 call	 ?CaptureStackTrace@@YIIPAPAUuintPtr@@I@Z ; CaptureStackTrace

; 171  : 
; 172  :         if (StackSize) {

  0004c	85 c0		 test	 eax, eax
  0004e	89 45 fc	 mov	 DWORD PTR _StackSize$[ebp], eax
  00051	74 15		 je	 SHORT $LN8@InternalLo

; 173  : 
; 174  :             // There is no point to save the eip of the current function in the database
; 175  :             // since is redundant information. Reuse instead that slot to keep the stack size
; 176  : 
; 177  :             Stacks[0] = (UIntPtr)(StackSize - 1);

  00053	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]

; 178  : 
; 179  :             // Convert to memory usage
; 180  : 
; 181  :             StackSize *= sizeof(UIntPtr);

  00056	8d 14 85 00 00
	00 00		 lea	 edx, DWORD PTR [eax*4]
  0005d	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _Stacks$[ebp], ecx
  00063	89 55 fc	 mov	 DWORD PTR _StackSize$[ebp], edx

; 182  :         } else {

  00066	eb 06		 jmp	 SHORT $LN7@InternalLo
$LN8@InternalLo:

; 183  : 
; 184  :             // clear the flag as there is no stack available
; 185  :             Flags &= ~RECORD_STACK_TRACES;

  00068	83 e3 fe	 and	 ebx, -2			; fffffffeH
  0006b	89 5d f8	 mov	 DWORD PTR _Flags$[ebp], ebx
$LN7@InternalLo:

; 186  :         }
; 187  :     }
; 188  : 
; 189  :     PMEMORY_ZONE Zone = Storage->ZoneCursor;

  0006e	8b 5f 1c	 mov	 ebx, DWORD PTR [edi+28]

; 190  : 
; 191  :     if (Zone == NULL) {

  00071	85 db		 test	 ebx, ebx
  00073	75 03		 jne	 SHORT $LN6@InternalLo

; 192  : 
; 193  :         Zone = Storage->MemoryZoneLink;

  00075	8b 5f 14	 mov	 ebx, DWORD PTR [edi+20]
$LN6@InternalLo:

; 194  :     }
; 195  : 
; 196  :     UINT32 EntrySize = GetRecordHeaderSize (Flags, StackSize);

  00078	8b 4d f8	 mov	 ecx, DWORD PTR _Flags$[ebp]
  0007b	83 e1 01	 and	 ecx, 1
  0007e	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00083	89 4d e8	 mov	 DWORD PTR tv309[ebp], ecx
  00086	74 09		 je	 SHORT $LN13@InternalLo
  00088	8b 45 fc	 mov	 eax, DWORD PTR _StackSize$[ebp]
  0008b	83 c0 18	 add	 eax, 24			; 00000018H
  0008e	0f b7 c0	 movzx	 eax, ax
$LN13@InternalLo:

; 197  : 
; 198  :     PMEMORY_HEADER Event = AllocateEventEntry(Zone,
; 199  :             (uint16)(EntrySize + allocSize + ExtendedSize - sizeof(MEMORY_HEADER)));

  00091	8b 4d 18	 mov	 ecx, DWORD PTR _ExtendedSize$[ebp]
  00094	0f b7 c0	 movzx	 eax, ax
  00097	03 ce		 add	 ecx, esi
  00099	8d 7c 01 e8	 lea	 edi, DWORD PTR [ecx+eax-24]
  0009d	8b d7		 mov	 edx, edi
  0009f	8b cb		 mov	 ecx, ebx
  000a1	89 45 f4	 mov	 DWORD PTR _EntrySize$[ebp], eax
  000a4	e8 00 00 00 00	 call	 ?AllocateEventEntry@@YIPAU_MEMORY_HEADER@@PAU_MEMORY_ZONE@@G@Z ; AllocateEventEntry
  000a9	8b f0		 mov	 esi, eax

; 200  : 
; 201  :     if (Event == NULL) {

  000ab	85 f6		 test	 esi, esi
  000ad	75 11		 jne	 SHORT $LN23@InternalLo

; 202  : 
; 203  :         //  The zone is filled up, advance the cursor to the next zone
; 204  : 
; 205  :         Event = MemoryStorageAdvanceCursor(Storage, Zone,
; 206  :             (uint16)(EntrySize + allocSize + ExtendedSize - sizeof(MEMORY_HEADER)));

  000af	8b 4d f0	 mov	 ecx, DWORD PTR _StorageHandle$[ebp]
  000b2	57		 push	 edi
  000b3	8b d3		 mov	 edx, ebx
  000b5	e8 00 00 00 00	 call	 ?MemoryStorageAdvanceCursor@@YIPAU_MEMORY_HEADER@@PAU_MEMORY_STORAGE@@PAU_MEMORY_ZONE@@G@Z ; MemoryStorageAdvanceCursor
  000ba	8b f0		 mov	 esi, eax

; 207  :     }
; 208  : 
; 209  :     if (Event != NULL) {

  000bc	85 f6		 test	 esi, esi
  000be	74 5f		 je	 SHORT $LN1@InternalLo
$LN23@InternalLo:

; 210  : 
; 211  :         // Copy the entry flags, which also include the layout description
; 212  : 
; 213  :         Event->Flags = (uint16)Flags;
; 214  :         Event->Type = eventType;
; 215  :         // Handle the stack traces, if present
; 216  : 
; 217  :         UCHAR * Dest = (UCHAR *)GetRecordInternalStructure(Event, RECORD_STACK_TRACES);

  000c0	66 83 7d e8 00	 cmp	 WORD PTR tv309[ebp], 0
  000c5	66 8b 55 f8	 mov	 dx, WORD PTR _Flags$[ebp]
  000c9	8b 45 08	 mov	 eax, DWORD PTR _eventType$[ebp]
  000cc	66 89 56 06	 mov	 WORD PTR [esi+6], dx
  000d0	89 46 10	 mov	 DWORD PTR [esi+16], eax
  000d3	74 1b		 je	 SHORT $LN3@InternalLo
  000d5	8d 46 18	 lea	 eax, DWORD PTR [esi+24]

; 218  : 
; 219  :         if (Dest != NULL) {

  000d8	85 c0		 test	 eax, eax
  000da	74 14		 je	 SHORT $LN3@InternalLo

; 220  : 
; 221  :             memcpy(Dest, Stacks, StackSize);

  000dc	8b 4d fc	 mov	 ecx, DWORD PTR _StackSize$[ebp]
  000df	51		 push	 ecx
  000e0	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR _Stacks$[ebp]
  000e6	52		 push	 edx
  000e7	50		 push	 eax
  000e8	e8 00 00 00 00	 call	 _memcpy
  000ed	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@InternalLo:

; 222  :         }
; 223  : 
; 224  :         //  Copy the remaining portion provided by the user to the buffer
; 225  : 
; 226  :         if (Buffer) {

  000f0	8b 45 0c	 mov	 eax, DWORD PTR _Buffer$[ebp]
  000f3	85 c0		 test	 eax, eax
  000f5	74 14		 je	 SHORT $LN24@InternalLo

; 227  : 
; 228  :             memcpy((char *)Event + EntrySize, Buffer, size);

  000f7	8b 4d 10	 mov	 ecx, DWORD PTR _size$[ebp]
  000fa	8b 55 f4	 mov	 edx, DWORD PTR _EntrySize$[ebp]
  000fd	51		 push	 ecx
  000fe	50		 push	 eax
  000ff	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  00102	50		 push	 eax
  00103	e8 00 00 00 00	 call	 _memcpy
  00108	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN24@InternalLo:

; 229  :         }
; 230  : 
; 231  :         if (ExtendedSize != 0) {

  0010b	83 7d 18 00	 cmp	 DWORD PTR _ExtendedSize$[ebp], 0
  0010f	74 0e		 je	 SHORT $LN1@InternalLo

; 232  : 
; 233  :             *ExtendedBuffer = (char *)Event + EntrySize + allocSize;

  00111	8b 4d f4	 mov	 ecx, DWORD PTR _EntrySize$[ebp]
  00114	8b 45 14	 mov	 eax, DWORD PTR _ExtendedBuffer$[ebp]
  00117	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  0011a	03 55 ec	 add	 edx, DWORD PTR _allocSize$[ebp]
  0011d	89 10		 mov	 DWORD PTR [eax], edx
$LN1@InternalLo:

; 234  :         }
; 235  : 
; 236  :     }
; 237  : 
; 238  :     return Event;

  0011f	8b c6		 mov	 eax, esi
  00121	5e		 pop	 esi
  00122	5f		 pop	 edi
  00123	5b		 pop	 ebx

; 239  : }

  00124	8b e5		 mov	 esp, ebp
  00126	5d		 pop	 ebp
  00127	c2 14 00	 ret	 20			; 00000014H
?InternalLogRecord@@YIPAU_MEMORY_HEADER@@PAUuintPtr@@I0PAXIPAPAXI@Z ENDP ; InternalLogRecord
_TEXT	ENDS
PUBLIC	?InternalLogFixedRecord@@YIPAU_MEMORY_HEADER@@PAUuintPtr@@I0PAXI@Z ; InternalLogFixedRecord
EXTRN	?CommitEventEntry@@YIXPAU_MEMORY_HEADER@@@Z:PROC ; CommitEventEntry
EXTRN	?DebugPrintEvent@@YIXPAUuintPtr@@@Z:PROC	; DebugPrintEvent
; Function compile flags: /Ogtp
;	COMDAT ?InternalLogFixedRecord@@YIPAU_MEMORY_HEADER@@PAUuintPtr@@I0PAXI@Z
_TEXT	SEGMENT
_eventType$ = 8						; size = 4
_Buffer$ = 12						; size = 4
_size$ = 16						; size = 4
?InternalLogFixedRecord@@YIPAU_MEMORY_HEADER@@PAUuintPtr@@I0PAXI@Z PROC ; InternalLogFixedRecord, COMDAT
; _StorageHandle$ = ecx
; _Flags$ = edx

; 247  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 248  :     PMEMORY_HEADER entry = InternalLogRecord(StorageHandle, Flags, eventType, Buffer, size, NULL, 0);

  00003	8b 45 10	 mov	 eax, DWORD PTR _size$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	6a 00		 push	 0
  0000a	6a 00		 push	 0
  0000c	8b da		 mov	 ebx, edx
  0000e	8b 55 0c	 mov	 edx, DWORD PTR _Buffer$[ebp]
  00011	50		 push	 eax
  00012	8b 45 08	 mov	 eax, DWORD PTR _eventType$[ebp]
  00015	52		 push	 edx
  00016	50		 push	 eax
  00017	8b d3		 mov	 edx, ebx
  00019	e8 00 00 00 00	 call	 ?InternalLogRecord@@YIPAU_MEMORY_HEADER@@PAUuintPtr@@I0PAXIPAPAXI@Z ; InternalLogRecord
  0001e	8b f0		 mov	 esi, eax

; 249  : 
; 250  :     if (entry != NULL) {

  00020	85 f6		 test	 esi, esi
  00022	74 15		 je	 SHORT $LN2@InternalLo@2

; 251  : 
; 252  :         if (Flags & Class_Microsoft_Singularity_Eventing_EventSource_CAPTURE_DEBUG_PRINT){

  00024	f6 c3 02	 test	 bl, 2
  00027	74 07		 je	 SHORT $LN1@InternalLo@2

; 253  : 
; 254  :             DebugPrintEvent((UIntPtr)entry);

  00029	8b ce		 mov	 ecx, esi
  0002b	e8 00 00 00 00	 call	 ?DebugPrintEvent@@YIXPAUuintPtr@@@Z ; DebugPrintEvent
$LN1@InternalLo@2:

; 255  :         }
; 256  : 
; 257  :         CommitEventEntry(entry);

  00030	8b ce		 mov	 ecx, esi
  00032	e8 00 00 00 00	 call	 ?CommitEventEntry@@YIXPAU_MEMORY_HEADER@@@Z ; CommitEventEntry

; 258  :     }
; 259  : 
; 260  :     return entry;

  00037	8b c6		 mov	 eax, esi
$LN2@InternalLo@2:
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx

; 261  : }

  0003b	5d		 pop	 ebp
  0003c	c2 0c 00	 ret	 12			; 0000000cH
?InternalLogFixedRecord@@YIPAU_MEMORY_HEADER@@PAUuintPtr@@I0PAXI@Z ENDP ; InternalLogFixedRecord
_TEXT	ENDS
PUBLIC	?InternalLogVariableRecord@@YIPAU_MEMORY_HEADER@@_NPAUuintPtr@@I1PAXIHPAUStruct_Microsoft_Singularity_Eventing_ArrayType@@@Z ; InternalLogVariableRecord
EXTRN	?ConvertToChars@@YIPADPADPA_WH@Z:PROC		; ConvertToChars
; Function compile flags: /Ogtp
;	COMDAT ?InternalLogVariableRecord@@YIPAU_MEMORY_HEADER@@_NPAUuintPtr@@I1PAXIHPAUStruct_Microsoft_Singularity_Eventing_ArrayType@@@Z
_TEXT	SEGMENT
_doCommit$ = -4						; size = 1
_Flags$ = 8						; size = 4
_eventType$ = 12					; size = 4
_Buffer$ = 16						; size = 4
_ExtendedBuffer$ = 20					; size = 4
_size$ = 20						; size = 4
_variableItemsCount$ = 24				; size = 4
tv134 = 28						; size = 4
_variableItems$ = 28					; size = 4
?InternalLogVariableRecord@@YIPAU_MEMORY_HEADER@@_NPAUuintPtr@@I1PAXIHPAUStruct_Microsoft_Singularity_Eventing_ArrayType@@@Z PROC ; InternalLogVariableRecord, COMDAT
; _doCommit$ = cl
; _StorageHandle$ = edx

; 273  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b da		 mov	 ebx, edx

; 274  :     if (StorageHandle == 0) return NULL;

  00007	85 db		 test	 ebx, ebx
  00009	88 4d fc	 mov	 BYTE PTR _doCommit$[ebp], cl
  0000c	75 09		 jne	 SHORT $LN19@InternalLo@3
  0000e	33 c0		 xor	 eax, eax
  00010	5b		 pop	 ebx

; 402  : }

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 18 00	 ret	 24			; 00000018H
$LN19@InternalLo@3:
  00017	56		 push	 esi
  00018	57		 push	 edi

; 275  : 
; 276  :     PVOID ExtendedBuffer;
; 277  :     int i;
; 278  :     int arrayDescriptorSize = variableItemsCount * sizeof(uint16);

  00019	8b 7d 18	 mov	 edi, DWORD PTR _variableItemsCount$[ebp]

; 279  : 
; 280  :     int32 extendedSize =  arrayDescriptorSize;
; 281  : 
; 282  :     for (i = 0; i < variableItemsCount; i++) {

  0001c	85 ff		 test	 edi, edi
  0001e	8d 34 3f	 lea	 esi, DWORD PTR [edi+edi]
  00021	7e 30		 jle	 SHORT $LN16@InternalLo@3
  00023	8b 45 1c	 mov	 eax, DWORD PTR _variableItems$[ebp]
  00026	83 c0 04	 add	 eax, 4
  00029	8b d7		 mov	 edx, edi
  0002b	eb 03 8d 49 00	 npad	 5
$LL18@InternalLo@3:

; 283  : 
; 284  :         extendedSize += (int32)variableItems[i].Length;

  00030	0f b7 48 fc	 movzx	 ecx, WORD PTR [eax-4]
  00034	03 f1		 add	 esi, ecx

; 285  : 
; 286  :         if ((variableItems[i].Type == EVENT_FIELD_TYPE_string)
; 287  :                 ||
; 288  :             (variableItems[i].Type == EVENT_FIELD_TYPE_szChar)) {

  00036	8b 08		 mov	 ecx, DWORD PTR [eax]
  00038	81 f9 00 40 00
	00		 cmp	 ecx, 16384		; 00004000H
  0003e	74 08		 je	 SHORT $LN14@InternalLo@3
  00040	81 f9 00 20 00
	00		 cmp	 ecx, 8192		; 00002000H
  00046	75 03		 jne	 SHORT $LN17@InternalLo@3
$LN14@InternalLo@3:

; 289  : 
; 290  :             // Account for the null terminator that ConvertToChars automatically
; 291  :             // inserts to the string. For szChar data, the string will also have one
; 292  :             // null character at the end, that has not been encounted for
; 293  : 
; 294  :             extendedSize += 1;

  00048	83 c6 01	 add	 esi, 1
$LN17@InternalLo@3:

; 279  : 
; 280  :     int32 extendedSize =  arrayDescriptorSize;
; 281  : 
; 282  :     for (i = 0; i < variableItemsCount; i++) {

  0004b	83 c0 0c	 add	 eax, 12			; 0000000cH
  0004e	83 ea 01	 sub	 edx, 1
  00051	75 dd		 jne	 SHORT $LL18@InternalLo@3
$LN16@InternalLo@3:

; 295  :         }
; 296  :     }
; 297  : 
; 298  :     PMEMORY_HEADER Entry = InternalLogRecord(StorageHandle,
; 299  :                                              Flags,
; 300  :                                              eventType,
; 301  :                                              Buffer,
; 302  :                                              size,
; 303  :                                              &ExtendedBuffer,
; 304  :                                              extendedSize);

  00053	8b 45 14	 mov	 eax, DWORD PTR _size$[ebp]
  00056	8b 4d 10	 mov	 ecx, DWORD PTR _Buffer$[ebp]
  00059	56		 push	 esi
  0005a	8d 55 14	 lea	 edx, DWORD PTR _ExtendedBuffer$[ebp]
  0005d	52		 push	 edx
  0005e	8b 55 0c	 mov	 edx, DWORD PTR _eventType$[ebp]
  00061	50		 push	 eax
  00062	51		 push	 ecx
  00063	52		 push	 edx
  00064	8b 55 08	 mov	 edx, DWORD PTR _Flags$[ebp]
  00067	8b cb		 mov	 ecx, ebx
  00069	e8 00 00 00 00	 call	 ?InternalLogRecord@@YIPAU_MEMORY_HEADER@@PAUuintPtr@@I0PAXIPAPAXI@Z ; InternalLogRecord
  0006e	8b d8		 mov	 ebx, eax

; 305  : 
; 306  :     if (Entry == NULL) {

  00070	85 db		 test	 ebx, ebx
  00072	75 09		 jne	 SHORT $LN13@InternalLo@3
  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx

; 402  : }

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 18 00	 ret	 24			; 00000018H
$LN13@InternalLo@3:

; 307  :         return Entry;
; 308  :     }
; 309  : 
; 310  :     if (extendedSize > 0) {

  0007d	85 f6		 test	 esi, esi
  0007f	0f 8e b4 00 00
	00		 jle	 $LN9@InternalLo@3

; 311  : 
; 312  :         //  Note the test for extendedSize. This is the only case where we are
; 313  :         //  allowed to add something after calling InternalLogRecord. We are also required
; 314  :         //  explicitely commit the entry when we're done
; 315  : 
; 316  :         for (i = 0; i < variableItemsCount; i++) {

  00085	85 ff		 test	 edi, edi
  00087	0f 8e ac 00 00
	00		 jle	 $LN9@InternalLo@3
  0008d	8b 45 18	 mov	 eax, DWORD PTR _variableItemsCount$[ebp]
  00090	8b 7d 1c	 mov	 edi, DWORD PTR _variableItems$[ebp]
  00093	8b 75 14	 mov	 esi, DWORD PTR _ExtendedBuffer$[ebp]
  00096	89 45 1c	 mov	 DWORD PTR tv134[ebp], eax
  00099	8d a4 24 00 00
	00 00		 npad	 7
$LL11@InternalLo@3:

; 317  : 
; 318  :             //
; 319  :             //  For strings, the mechanism wil automatically extend the buffer with one
; 320  :             //  extra character to include the null terminator. The length in the field
; 321  :             //  should be however consistent and report the correct length of the buffer
; 322  :             //
; 323  : 
; 324  :             if (variableItems[i].Type == EVENT_FIELD_TYPE_string) {

  000a0	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000a3	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  000a8	75 27		 jne	 SHORT $LN8@InternalLo@3

; 325  : 
; 326  :                 // Account for the null terminator that ConvertToChars automatically
; 327  :                 // inserts to the string.
; 328  : 
; 329  :                 unsigned short adjustedLength = variableItems[i].Length + 1;

  000aa	66 8b 0f	 mov	 cx, WORD PTR [edi]
  000ad	66 83 c1 01	 add	 cx, 1

; 330  : 
; 331  :                 C_ASSERT(sizeof(adjustedLength) == sizeof(variableItems[i].Length));
; 332  :                 memcpy(ExtendedBuffer, &adjustedLength, sizeof(adjustedLength));

  000b1	66 89 0e	 mov	 WORD PTR [esi], cx

; 333  :                 ExtendedBuffer = (char *)ExtendedBuffer + sizeof(variableItems[i].Length);
; 334  : 
; 335  : 
; 336  :                 //  If this was a bartok string, convert it to ascii
; 337  : 
; 338  :                 ExtendedBuffer = ConvertToChars((char *)ExtendedBuffer,
; 339  :                                                 (bartok_char *)variableItems[i].Buffer,
; 340  :                                                 (int32)variableItems[i].Length);

  000b4	0f b7 17	 movzx	 edx, WORD PTR [edi]
  000b7	52		 push	 edx
  000b8	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  000bb	8d 4e 02	 lea	 ecx, DWORD PTR [esi+2]
  000be	e8 00 00 00 00	 call	 ?ConvertToChars@@YIPADPADPA_WH@Z ; ConvertToChars
  000c3	8b f0		 mov	 esi, eax

; 341  : 
; 342  : 
; 343  :                 EV_ASSERT(ExtendedBuffer <= (PVOID)((char*)Entry + Entry->Size ));

  000c5	0f b7 03	 movzx	 eax, WORD PTR [ebx]
  000c8	03 c3		 add	 eax, ebx
  000ca	3b f0		 cmp	 esi, eax
  000cc	76 54		 jbe	 SHORT $LN27@InternalLo@3
  000ce	cc		 int	 3
  000cf	eb 51		 jmp	 SHORT $LN27@InternalLo@3
$LN8@InternalLo@3:

; 344  : 
; 345  :             } else  if (variableItems[i].Type == EVENT_FIELD_TYPE_szChar) {

  000d1	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  000d6	75 2b		 jne	 SHORT $LN5@InternalLo@3

; 346  : 
; 347  :                 // Account for the null terminator that is automatically
; 348  :                 // inserted to the string.
; 349  : 
; 350  :                 unsigned short adjustedLength = variableItems[i].Length + 1;

  000d8	66 8b 0f	 mov	 cx, WORD PTR [edi]
  000db	66 83 c1 01	 add	 cx, 1

; 351  : 
; 352  :                 //
; 353  :                 //  Save the total size in bytes and save it to the entry. Move the pointer forward
; 354  :                 //
; 355  : 
; 356  :                 C_ASSERT(sizeof(adjustedLength) == sizeof(variableItems[i].Length));
; 357  :                 memcpy(ExtendedBuffer, &adjustedLength, sizeof(adjustedLength));

  000df	66 89 0e	 mov	 WORD PTR [esi], cx

; 358  :                 ExtendedBuffer = (char *)ExtendedBuffer + sizeof(adjustedLength);
; 359  : 
; 360  :                 //
; 361  :                 //  Copy now the actual content of the buffer
; 362  :                 //
; 363  : 
; 364  :                 memcpy(ExtendedBuffer, variableItems[i].Buffer, (int32)variableItems[i].Length);

  000e2	0f b7 17	 movzx	 edx, WORD PTR [edi]
  000e5	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000e8	52		 push	 edx
  000e9	50		 push	 eax
  000ea	83 c6 02	 add	 esi, 2
  000ed	56		 push	 esi
  000ee	e8 00 00 00 00	 call	 _memcpy

; 365  :                 ExtendedBuffer = (char *)ExtendedBuffer + variableItems[i].Length;

  000f3	0f b7 0f	 movzx	 ecx, WORD PTR [edi]
  000f6	03 f1		 add	 esi, ecx
  000f8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 366  :                 *(char *)ExtendedBuffer = (char)0;

  000fb	c6 06 00	 mov	 BYTE PTR [esi], 0

; 367  :                 ExtendedBuffer = (char *)ExtendedBuffer + 1;

  000fe	83 c6 01	 add	 esi, 1

; 368  : 
; 369  :             } else {

  00101	eb 1f		 jmp	 SHORT $LN27@InternalLo@3
$LN5@InternalLo@3:

; 370  : 
; 371  :                 //
; 372  :                 //  Save the length of the data and advance the pointer
; 373  :                 //
; 374  : 
; 375  :                 memcpy(ExtendedBuffer, &variableItems[i].Length, sizeof(variableItems[i].Length));

  00103	66 8b 17	 mov	 dx, WORD PTR [edi]
  00106	66 89 16	 mov	 WORD PTR [esi], dx

; 376  :                 ExtendedBuffer = (char *)ExtendedBuffer + sizeof(variableItems[i].Length);
; 377  : 
; 378  :                 // nothing else to do here, just copy the content and advance the pointer
; 379  : 
; 380  :                 memcpy(ExtendedBuffer, variableItems[i].Buffer, (int32)variableItems[i].Length);

  00109	0f b7 07	 movzx	 eax, WORD PTR [edi]
  0010c	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0010f	50		 push	 eax
  00110	51		 push	 ecx
  00111	83 c6 02	 add	 esi, 2
  00114	56		 push	 esi
  00115	e8 00 00 00 00	 call	 _memcpy

; 381  :                 ExtendedBuffer = (char *)ExtendedBuffer + variableItems[i].Length;

  0011a	0f b7 17	 movzx	 edx, WORD PTR [edi]
  0011d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00120	03 f2		 add	 esi, edx
$LN27@InternalLo@3:

; 382  :             }
; 383  : 
; 384  :             EV_ASSERT(ExtendedBuffer <= (PVOID)((char*)Entry + Entry->Size ));

  00122	0f b7 03	 movzx	 eax, WORD PTR [ebx]
  00125	03 c3		 add	 eax, ebx
  00127	3b f0		 cmp	 esi, eax
  00129	76 01		 jbe	 SHORT $LN10@InternalLo@3
  0012b	cc		 int	 3
$LN10@InternalLo@3:

; 311  : 
; 312  :         //  Note the test for extendedSize. This is the only case where we are
; 313  :         //  allowed to add something after calling InternalLogRecord. We are also required
; 314  :         //  explicitely commit the entry when we're done
; 315  : 
; 316  :         for (i = 0; i < variableItemsCount; i++) {

  0012c	83 c7 0c	 add	 edi, 12			; 0000000cH
  0012f	83 6d 1c 01	 sub	 DWORD PTR tv134[ebp], 1
  00133	0f 85 67 ff ff
	ff		 jne	 $LL11@InternalLo@3
$LN9@InternalLo@3:

; 385  : 
; 386  :         }
; 387  : 
; 388  :     }
; 389  : 
; 390  :     if (Flags & Class_Microsoft_Singularity_Eventing_EventSource_CAPTURE_DEBUG_PRINT){

  00139	f6 45 08 02	 test	 BYTE PTR _Flags$[ebp], 2
  0013d	74 07		 je	 SHORT $LN2@InternalLo@3

; 391  : 
; 392  :         DebugPrintEvent((UIntPtr)Entry);

  0013f	8b cb		 mov	 ecx, ebx
  00141	e8 00 00 00 00	 call	 ?DebugPrintEvent@@YIXPAUuintPtr@@@Z ; DebugPrintEvent
$LN2@InternalLo@3:

; 393  :     }
; 394  : 
; 395  :     if (doCommit) {

  00146	80 7d fc 00	 cmp	 BYTE PTR _doCommit$[ebp], 0
  0014a	74 07		 je	 SHORT $LN1@InternalLo@3

; 396  : 
; 397  :         CommitEventEntry(Entry);

  0014c	8b cb		 mov	 ecx, ebx
  0014e	e8 00 00 00 00	 call	 ?CommitEventEntry@@YIXPAU_MEMORY_HEADER@@@Z ; CommitEventEntry
$LN1@InternalLo@3:
  00153	5f		 pop	 edi
  00154	5e		 pop	 esi

; 398  :     }
; 399  : 
; 400  : 
; 401  :     return Entry;

  00155	8b c3		 mov	 eax, ebx
  00157	5b		 pop	 ebx

; 402  : }

  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c2 18 00	 ret	 24			; 00000018H
?InternalLogVariableRecord@@YIPAU_MEMORY_HEADER@@_NPAUuintPtr@@I1PAXIHPAUStruct_Microsoft_Singularity_Eventing_ArrayType@@@Z ENDP ; InternalLogVariableRecord
_TEXT	ENDS
PUBLIC	?OpenLoggingStorage@@YIPAUuintPtr@@PAU1@PAI@Z	; OpenLoggingStorage
; Function compile flags: /Ogtp
;	COMDAT ?OpenLoggingStorage@@YIPAUuintPtr@@PAU1@PAI@Z
_TEXT	SEGMENT
?OpenLoggingStorage@@YIPAUuintPtr@@PAU1@PAI@Z PROC	; OpenLoggingStorage, COMDAT
; _sourceHandle$ = ecx
; _flags$ = edx

; 408  :     if (sourceHandle == 0) return 0;

  00000	85 c9		 test	 ecx, ecx
  00002	75 03		 jne	 SHORT $LN2@OpenLoggin
  00004	33 c0		 xor	 eax, eax

; 415  : }

  00006	c3		 ret	 0
$LN2@OpenLoggin:

; 409  : 
; 410  :     PSOURCE_DESCRIPTOR source = HANDLE_TO_SOURCE(sourceHandle);
; 411  :     if (((source->ControlFlags & (*flags)) >> 16) == 0) return 0;

  00007	8b 02		 mov	 eax, DWORD PTR [edx]
  00009	56		 push	 esi
  0000a	8b 71 2c	 mov	 esi, DWORD PTR [ecx+44]
  0000d	57		 push	 edi
  0000e	8b f8		 mov	 edi, eax
  00010	23 fe		 and	 edi, esi
  00012	f7 c7 00 00 ff
	ff		 test	 edi, -65536		; ffff0000H
  00018	75 05		 jne	 SHORT $LN1@OpenLoggin
  0001a	5f		 pop	 edi
  0001b	33 c0		 xor	 eax, eax
  0001d	5e		 pop	 esi

; 415  : }

  0001e	c3		 ret	 0
$LN1@OpenLoggin:

; 412  : 
; 413  :     *flags |= source->ControlFlags;

  0001f	0b c6		 or	 eax, esi
  00021	5f		 pop	 edi
  00022	89 02		 mov	 DWORD PTR [edx], eax

; 414  :     return source->StorageHandle;

  00024	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00027	5e		 pop	 esi

; 415  : }

  00028	c3		 ret	 0
?OpenLoggingStorage@@YIPAUuintPtr@@PAU1@PAI@Z ENDP	; OpenLoggingStorage
_TEXT	ENDS
PUBLIC	?GetNextZone@@YIPAU_MEMORY_ZONE@@PAU_QUERY_VIEW@@@Z ; GetNextZone
; Function compile flags: /Ogtp
;	COMDAT ?GetNextZone@@YIPAU_MEMORY_ZONE@@PAU_QUERY_VIEW@@@Z
_TEXT	SEGMENT
?GetNextZone@@YIPAU_MEMORY_ZONE@@PAU_QUERY_VIEW@@@Z PROC ; GetNextZone, COMDAT
; _view$ = ecx

; 421  :     if (view->StartZone == NULL) {

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	85 d2		 test	 edx, edx
  00005	75 03		 jne	 SHORT $LN13@GetNextZon

; 422  :         return NULL;

  00007	33 c0		 xor	 eax, eax

; 457  :         }
; 458  : 
; 459  :     }
; 460  : }

  00009	c3		 ret	 0
$LN13@GetNextZon:
  0000a	53		 push	 ebx
  0000b	8a 59 20	 mov	 bl, BYTE PTR [ecx+32]
  0000e	8b ff		 npad	 2
$LL8@GetNextZon:

; 423  :     }
; 424  : 
; 425  :     for (;;) {
; 426  : 
; 427  :         if (view->Forward) {

  00010	84 db		 test	 bl, bl

; 428  : 
; 429  :             view->CurrentZone = view->CurrentZone->Link;

  00012	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00015	74 11		 je	 SHORT $LN6@GetNextZon
  00017	8b 00		 mov	 eax, DWORD PTR [eax]

; 430  : 
; 431  :             if (view->CurrentZone == NULL) {

  00019	85 c0		 test	 eax, eax
  0001b	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  0001e	75 1b		 jne	 SHORT $LN3@GetNextZon

; 432  : 
; 433  :                 view->CurrentZone = view->Storage->MemoryZoneLink;

  00020	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00023	8b 40 14	 mov	 eax, DWORD PTR [eax+20]

; 434  :             }
; 435  :         } else {

  00026	eb 10		 jmp	 SHORT $LN17@GetNextZon
$LN6@GetNextZon:

; 436  : 
; 437  :             view->CurrentZone = view->CurrentZone->BkLink;

  00028	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 438  : 
; 439  :             if (view->CurrentZone == NULL) {

  0002b	85 c0		 test	 eax, eax
  0002d	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00030	75 09		 jne	 SHORT $LN3@GetNextZon

; 440  : 
; 441  :                 view->CurrentZone = view->Storage->BkLink;

  00032	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00035	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
$LN17@GetNextZon:
  00038	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$LN3@GetNextZon:

; 442  :             }
; 443  :         }
; 444  : 
; 445  :         if (view->CurrentZone == view->StartZone) {

  0003b	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0003e	3b c2		 cmp	 eax, edx
  00040	74 1c		 je	 SHORT $LN14@GetNextZon

; 448  :         }
; 449  : 
; 450  :         //  ??? handle the generation wrap
; 451  : 
; 452  :         if (view->CurrentZone->Generation <= view->QueryGeneration) {

  00042	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00045	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]
  00048	77 c6		 ja	 SHORT $LL8@GetNextZon

; 453  : 
; 454  :             view->CurrentEntryIndex = 0;
; 455  :             view->ZoneGeneration = view->CurrentZone->Generation;

  0004a	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0004d	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0
  00054	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00057	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 456  :             return view->CurrentZone;

  0005a	8b c2		 mov	 eax, edx
  0005c	5b		 pop	 ebx

; 457  :         }
; 458  : 
; 459  :     }
; 460  : }

  0005d	c3		 ret	 0
$LN14@GetNextZon:

; 446  : 
; 447  :             return NULL;

  0005e	33 c0		 xor	 eax, eax
  00060	5b		 pop	 ebx

; 457  :         }
; 458  : 
; 459  :     }
; 460  : }

  00061	c3		 ret	 0
?GetNextZone@@YIPAU_MEMORY_ZONE@@PAU_QUERY_VIEW@@@Z ENDP ; GetNextZone
_TEXT	ENDS
PUBLIC	?CreateQuery@@YIPAU_QUERY_VIEW@@PAUuintPtr@@_N@Z ; CreateQuery
EXTRN	?AllocateQueryView@@YIPAU_QUERY_VIEW@@XZ:PROC	; AllocateQueryView
; Function compile flags: /Ogtp
;	COMDAT ?CreateQuery@@YIPAU_QUERY_VIEW@@PAUuintPtr@@_N@Z
_TEXT	SEGMENT
?CreateQuery@@YIPAU_QUERY_VIEW@@PAUuintPtr@@_N@Z PROC	; CreateQuery, COMDAT
; _storageHandle$ = ecx
; _forward$ = dl

; 464  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8a da		 mov	 bl, dl
  00004	8b f1		 mov	 esi, ecx

; 465  :     PQUERY_VIEW queryView = AllocateQueryView( );

  00006	e8 00 00 00 00	 call	 ?AllocateQueryView@@YIPAU_QUERY_VIEW@@XZ ; AllocateQueryView

; 466  : 
; 467  :     if (queryView) {

  0000b	33 d2		 xor	 edx, edx
  0000d	3b c2		 cmp	 eax, edx
  0000f	74 57		 je	 SHORT $LN6@CreateQuer

; 468  : 
; 469  :         queryView->Storage = HANDLE_TO_STORAGE(storageHandle);
; 470  :         queryView->Forward = forward;
; 471  :         queryView->QueryGeneration = queryView->Storage->Generation;
; 472  : 
; 473  :         queryView->CurrentZone = NULL;
; 474  :         queryView->ZoneGeneration = 0;
; 475  :         queryView->CurrentEntry = NULL;
; 476  :         queryView->CurrentEntryIndex = 0;
; 477  :         queryView->EndOfBuffer = false;
; 478  : 
; 479  :         if (forward) {

  00011	3a da		 cmp	 bl, dl
  00013	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00016	88 58 20	 mov	 BYTE PTR [eax+32], bl
  00019	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  0001c	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  0001f	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00022	89 50 18	 mov	 DWORD PTR [eax+24], edx
  00025	89 50 10	 mov	 DWORD PTR [eax+16], edx
  00028	89 50 1c	 mov	 DWORD PTR [eax+28], edx
  0002b	88 50 22	 mov	 BYTE PTR [eax+34], dl

; 480  : 
; 481  :             queryView->StartZone = queryView->Storage->ZoneCursor;

  0002e	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00031	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00034	74 1e		 je	 SHORT $LN5@CreateQuer

; 482  : 
; 483  :             if (queryView->StartZone != NULL) {

  00036	3b ca		 cmp	 ecx, edx
  00038	74 05		 je	 SHORT $LN4@CreateQuer

; 484  : 
; 485  :                 queryView->StartZone = queryView->StartZone->Link;

  0003a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003c	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN4@CreateQuer:

; 486  :             }
; 487  : 
; 488  :             if (queryView->StartZone == NULL) {

  0003f	39 50 08	 cmp	 DWORD PTR [eax+8], edx
  00042	75 1a		 jne	 SHORT $LN1@CreateQuer

; 489  : 
; 490  :                 queryView->StartZone  = queryView->Storage->MemoryZoneLink;

  00044	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00047	5e		 pop	 esi
  00048	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 500  :             }
; 501  :         }
; 502  : 
; 503  :         queryView->CurrentZone = queryView->StartZone;

  0004b	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 504  :         queryView->QueryReset = true;

  0004e	c6 40 21 01	 mov	 BYTE PTR [eax+33], 1
  00052	5b		 pop	 ebx

; 505  : 
; 506  :    }
; 507  : 
; 508  :     return queryView;
; 509  : }

  00053	c3		 ret	 0
$LN5@CreateQuer:

; 491  :             }
; 492  : 
; 493  :         } else {
; 494  : 
; 495  :             queryView->StartZone = queryView->Storage->ZoneCursor;
; 496  : 
; 497  :             if (queryView->StartZone == NULL) {

  00054	3b ca		 cmp	 ecx, edx
  00056	75 06		 jne	 SHORT $LN1@CreateQuer

; 498  : 
; 499  :                 queryView->StartZone  = queryView->Storage->BkLink;

  00058	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  0005b	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN1@CreateQuer:

; 500  :             }
; 501  :         }
; 502  : 
; 503  :         queryView->CurrentZone = queryView->StartZone;

  0005e	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00061	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 504  :         queryView->QueryReset = true;

  00064	c6 40 21 01	 mov	 BYTE PTR [eax+33], 1
$LN6@CreateQuer:
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx

; 505  : 
; 506  :    }
; 507  : 
; 508  :     return queryView;
; 509  : }

  0006a	c3		 ret	 0
?CreateQuery@@YIPAU_QUERY_VIEW@@PAUuintPtr@@_N@Z ENDP	; CreateQuery
_TEXT	ENDS
PUBLIC	?GetNextStorageEntry@@YIPAU_MEMORY_HEADER@@PAU_QUERY_VIEW@@@Z ; GetNextStorageEntry
EXTRN	?GetFirstEntry@@YIPAU_MEMORY_HEADER@@PAU_MEMORY_ZONE@@_N@Z:PROC ; GetFirstEntry
EXTRN	?GetNextEntry@@YIPAU_MEMORY_HEADER@@PAU_QUERY_VIEW@@@Z:PROC ; GetNextEntry
; Function compile flags: /Ogtp
;	COMDAT ?GetNextStorageEntry@@YIPAU_MEMORY_HEADER@@PAU_QUERY_VIEW@@@Z
_TEXT	SEGMENT
?GetNextStorageEntry@@YIPAU_MEMORY_HEADER@@PAU_QUERY_VIEW@@@Z PROC ; GetNextStorageEntry, COMDAT
; _queryView$ = ecx

; 513  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 514  :     PMEMORY_HEADER Entry;
; 515  : 
; 516  :     if (queryView->EndOfBuffer) {

  00003	80 7e 22 00	 cmp	 BYTE PTR [esi+34], 0

; 517  : 
; 518  :         return NULL;

  00007	75 57		 jne	 SHORT $LN14@GetNextSto

; 519  :     }
; 520  : 
; 521  :     if (queryView->CurrentEntry) {

  00009	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  0000d	74 09		 je	 SHORT $LN6@GetNextSto

; 522  : 
; 523  :         Entry = GetNextEntry(queryView);

  0000f	e8 00 00 00 00	 call	 ?GetNextEntry@@YIPAU_MEMORY_HEADER@@PAU_QUERY_VIEW@@@Z ; GetNextEntry

; 524  : 
; 525  :         if (Entry) {

  00014	85 c0		 test	 eax, eax

; 526  : 
; 527  :             return Entry;

  00016	75 4a		 jne	 SHORT $LN9@GetNextSto
$LN6@GetNextSto:

; 528  :         }
; 529  :     }
; 530  : 
; 531  :     PMEMORY_ZONE zone;
; 532  :     if (queryView->QueryReset) {

  00018	80 7e 21 00	 cmp	 BYTE PTR [esi+33], 0
  0001c	74 16		 je	 SHORT $LN5@GetNextSto

; 533  : 
; 534  :         zone = queryView->StartZone;

  0001e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 535  :         queryView->QueryReset = false;

  00021	c6 46 21 00	 mov	 BYTE PTR [esi+33], 0

; 536  :         queryView->ZoneGeneration = zone->Generation;

  00025	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00028	89 4e 18	 mov	 DWORD PTR [esi+24], ecx

; 537  :         queryView->CurrentEntryIndex = 0;

  0002b	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 538  : 
; 539  :     } else {

  00032	eb 07		 jmp	 SHORT $LN11@GetNextSto
$LN5@GetNextSto:

; 540  : 
; 541  :         zone = GetNextZone(queryView);

  00034	8b ce		 mov	 ecx, esi
  00036	e8 00 00 00 00	 call	 ?GetNextZone@@YIPAU_MEMORY_ZONE@@PAU_QUERY_VIEW@@@Z ; GetNextZone
$LN11@GetNextSto:

; 542  :     }
; 543  : 
; 544  :     while (zone != NULL) {

  0003b	85 c0		 test	 eax, eax
  0003d	74 1d		 je	 SHORT $LN2@GetNextSto
  0003f	90		 npad	 1
$LL3@GetNextSto:

; 545  : 
; 546  :         queryView->CurrentEntry = GetFirstEntry(zone, queryView->Forward);

  00040	8a 56 20	 mov	 dl, BYTE PTR [esi+32]
  00043	8b c8		 mov	 ecx, eax
  00045	e8 00 00 00 00	 call	 ?GetFirstEntry@@YIPAU_MEMORY_HEADER@@PAU_MEMORY_ZONE@@_N@Z ; GetFirstEntry

; 547  : 
; 548  :         if (queryView->CurrentEntry) {

  0004a	85 c0		 test	 eax, eax
  0004c	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0004f	75 11		 jne	 SHORT $LN9@GetNextSto

; 549  :             return queryView->CurrentEntry;
; 550  :         }
; 551  : 
; 552  :         zone = GetNextZone(queryView);

  00051	8b ce		 mov	 ecx, esi
  00053	e8 00 00 00 00	 call	 ?GetNextZone@@YIPAU_MEMORY_ZONE@@PAU_QUERY_VIEW@@@Z ; GetNextZone
  00058	85 c0		 test	 eax, eax
  0005a	75 e4		 jne	 SHORT $LL3@GetNextSto
$LN2@GetNextSto:

; 553  :     }
; 554  : 
; 555  :     queryView->EndOfBuffer = true;

  0005c	c6 46 22 01	 mov	 BYTE PTR [esi+34], 1
$LN14@GetNextSto:

; 556  : 
; 557  :     return NULL;

  00060	33 c0		 xor	 eax, eax
$LN9@GetNextSto:
  00062	5e		 pop	 esi

; 558  : }

  00063	c3		 ret	 0
?GetNextStorageEntry@@YIPAU_MEMORY_HEADER@@PAU_QUERY_VIEW@@@Z ENDP ; GetNextStorageEntry
_TEXT	ENDS
PUBLIC	?g_MemoryStorageRegisterBufferImpl@Class_Microsoft_Singularity_Eventing_MemoryStorage@@SIXPAUuintPtr@@PAEI@Z ; Class_Microsoft_Singularity_Eventing_MemoryStorage::g_MemoryStorageRegisterBufferImpl
EXTRN	?InitializeMemoryZone@@YIPAU_MEMORY_ZONE@@PAXGPAUuintPtr@@@Z:PROC ; InitializeMemoryZone
; Function compile flags: /Ogtp
;	COMDAT ?g_MemoryStorageRegisterBufferImpl@Class_Microsoft_Singularity_Eventing_MemoryStorage@@SIXPAUuintPtr@@PAEI@Z
_TEXT	SEGMENT
_LastExistingZone$ = -16				; size = 4
_Buffer$ = -12						; size = 4
tv147 = -8						; size = 4
_ZoneChain$ = -4					; size = 4
_BufferSize$ = 8					; size = 4
?g_MemoryStorageRegisterBufferImpl@Class_Microsoft_Singularity_Eventing_MemoryStorage@@SIXPAUuintPtr@@PAEI@Z PROC ; Class_Microsoft_Singularity_Eventing_MemoryStorage::g_MemoryStorageRegisterBufferImpl, COMDAT
; _StorageHandle$ = ecx
; _Buffer$ = edx

; 620  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 621  : 
; 622  :     PMEMORY_STORAGE Storage = (PMEMORY_STORAGE)StorageHandle;
; 623  :     PMEMORY_ZONE LastZone = NULL;
; 624  :     PMEMORY_ZONE ZoneChain = NULL;
; 625  :     PMEMORY_ZONE TempZone;
; 626  :     PMEMORY_ZONE LastExistingZone = Storage->BkLink;

  0000a	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0000d	57		 push	 edi
  0000e	8b da		 mov	 ebx, edx
  00010	89 45 f0	 mov	 DWORD PTR _LastExistingZone$[ebp], eax

; 627  : 
; 628  :     InterlockedExchangeAdd((volatile INT32 *)&Storage->StorageSize, BufferSize);

  00013	8b 45 08	 mov	 eax, DWORD PTR _BufferSize$[ebp]
  00016	33 ff		 xor	 edi, edi
  00018	89 5d f4	 mov	 DWORD PTR _Buffer$[ebp], ebx
  0001b	89 7d fc	 mov	 DWORD PTR _ZoneChain$[ebp], edi
  0001e	8b c8		 mov	 ecx, eax
  00020	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
  00023	f0 0f c1 0a	 lock	  xadd	 DWORD PTR [edx], ecx

; 629  : 
; 630  :     if ((Storage->DefaultZoneSize != 0) && (BufferSize > Storage->DefaultZoneSize)) {

  00027	0f b7 4e 0c	 movzx	 ecx, WORD PTR [esi+12]
  0002b	66 85 c9	 test	 cx, cx
  0002e	74 5c		 je	 SHORT $LN10@g_MemorySt
  00030	0f b7 d1	 movzx	 edx, cx
  00033	3b c2		 cmp	 eax, edx
  00035	76 55		 jbe	 SHORT $LN10@g_MemorySt

; 631  : 
; 632  :         //  We have to split the larger chunk in multiple zones
; 633  : 
; 634  :         uint32 MaxZone = BufferSize / Storage->DefaultZoneSize;

  00037	0f b7 d9	 movzx	 ebx, cx
  0003a	33 d2		 xor	 edx, edx
  0003c	f7 f3		 div	 ebx
  0003e	8b 5d f4	 mov	 ebx, DWORD PTR _Buffer$[ebp]

; 635  : 
; 636  :         for (uint32 i = 0; i < MaxZone; i++) {

  00041	85 c0		 test	 eax, eax
  00043	76 44		 jbe	 SHORT $LN18@g_MemorySt

; 631  : 
; 632  :         //  We have to split the larger chunk in multiple zones
; 633  : 
; 634  :         uint32 MaxZone = BufferSize / Storage->DefaultZoneSize;

  00045	89 45 f8	 mov	 DWORD PTR tv147[ebp], eax
$LL12@g_MemorySt:

; 637  : 
; 638  :             TempZone = InitializeMemoryZone(Buffer, Storage->DefaultZoneSize, StorageHandle);

  00048	8b d1		 mov	 edx, ecx
  0004a	56		 push	 esi
  0004b	8b cb		 mov	 ecx, ebx
  0004d	e8 00 00 00 00	 call	 ?InitializeMemoryZone@@YIPAU_MEMORY_ZONE@@PAXGPAUuintPtr@@@Z ; InitializeMemoryZone

; 639  :             EV_ASSERT(TempZone != NULL);

  00052	85 c0		 test	 eax, eax
  00054	75 01		 jne	 SHORT $LN9@g_MemorySt
  00056	cc		 int	 3
$LN9@g_MemorySt:

; 640  : 
; 641  :             InterlockedIncrement((volatile INT32* )&Storage->ZoneCount);

  00057	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  0005a	ba 01 00 00 00	 mov	 edx, 1
  0005f	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx

; 642  : 
; 643  :             if (ZoneChain == NULL) {

  00063	83 7d fc 00	 cmp	 DWORD PTR _ZoneChain$[ebp], 0
  00067	75 03		 jne	 SHORT $LN8@g_MemorySt

; 644  : 
; 645  :                 ZoneChain = TempZone;

  00069	89 45 fc	 mov	 DWORD PTR _ZoneChain$[ebp], eax
$LN8@g_MemorySt:

; 646  :             }
; 647  : 
; 648  :             //  Link the zones togeather. Note the chain is not yet published outside
; 649  :             //  until is pushed to the memory storage list eventually
; 650  : 
; 651  :             if (LastZone) {

  0006c	85 ff		 test	 edi, edi
  0006e	74 02		 je	 SHORT $LN7@g_MemorySt

; 652  : 
; 653  :                 LastZone->Link = TempZone;

  00070	89 07		 mov	 DWORD PTR [edi], eax
$LN7@g_MemorySt:

; 654  :             }
; 655  : 
; 656  :             TempZone->BkLink = LastZone;

  00072	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 657  :             LastZone = TempZone;
; 658  : 
; 659  :             Buffer = (UCHAR *)Buffer + Storage->DefaultZoneSize;

  00075	0f b7 4e 0c	 movzx	 ecx, WORD PTR [esi+12]
  00079	8b f8		 mov	 edi, eax
  0007b	0f b7 c1	 movzx	 eax, cx

; 660  :             BufferSize -= Storage->DefaultZoneSize;

  0007e	29 45 08	 sub	 DWORD PTR _BufferSize$[ebp], eax
  00081	03 d8		 add	 ebx, eax
  00083	83 6d f8 01	 sub	 DWORD PTR tv147[ebp], 1
  00087	75 bf		 jne	 SHORT $LL12@g_MemorySt
$LN18@g_MemorySt:

; 635  : 
; 636  :         for (uint32 i = 0; i < MaxZone; i++) {

  00089	8b 45 08	 mov	 eax, DWORD PTR _BufferSize$[ebp]
$LN10@g_MemorySt:

; 661  : 
; 662  :         }
; 663  : 
; 664  :     }
; 665  : 
; 666  :     TempZone = InitializeMemoryZone(Buffer, BufferSize, StorageHandle);

  0008c	56		 push	 esi
  0008d	8b d0		 mov	 edx, eax
  0008f	8b cb		 mov	 ecx, ebx
  00091	e8 00 00 00 00	 call	 ?InitializeMemoryZone@@YIPAU_MEMORY_ZONE@@PAXGPAUuintPtr@@@Z ; InitializeMemoryZone

; 667  : 
; 668  :     if (TempZone != NULL) {

  00096	85 c0		 test	 eax, eax
  00098	74 25		 je	 SHORT $LN19@g_MemorySt

; 669  : 
; 670  :         InterlockedIncrement((volatile INT32 *)&Storage->ZoneCount);

  0009a	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  0009d	ba 01 00 00 00	 mov	 edx, 1
  000a2	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx

; 671  : 
; 672  :         // Here the remining portion might be too small for a whole zone.
; 673  : 
; 674  :         if (ZoneChain == NULL) {

  000a6	8b 4d fc	 mov	 ecx, DWORD PTR _ZoneChain$[ebp]
  000a9	85 c9		 test	 ecx, ecx
  000ab	75 05		 jne	 SHORT $LN5@g_MemorySt

; 675  : 
; 676  :             ZoneChain = TempZone;

  000ad	89 45 fc	 mov	 DWORD PTR _ZoneChain$[ebp], eax
  000b0	8b c8		 mov	 ecx, eax
$LN5@g_MemorySt:

; 677  :         }
; 678  : 
; 679  :         //  Link the zones togeather. Note the chain is not yet published outside
; 680  :         //  until is pushed to the memory storage list eventually
; 681  : 
; 682  :         if (LastZone) {

  000b2	85 ff		 test	 edi, edi
  000b4	74 02		 je	 SHORT $LN4@g_MemorySt

; 683  : 
; 684  :             LastZone->Link = TempZone;

  000b6	89 07		 mov	 DWORD PTR [edi], eax
$LN4@g_MemorySt:

; 685  :         }
; 686  : 
; 687  :         TempZone->BkLink = LastZone;

  000b8	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 688  :         LastZone = TempZone;

  000bb	8b f8		 mov	 edi, eax
  000bd	eb 03		 jmp	 SHORT $LN6@g_MemorySt
$LN19@g_MemorySt:
  000bf	8b 4d fc	 mov	 ecx, DWORD PTR _ZoneChain$[ebp]
$LN6@g_MemorySt:

; 689  :     }
; 690  : 
; 691  :     if (LastZone != NULL) {

  000c2	85 ff		 test	 edi, edi
  000c4	74 2a		 je	 SHORT $LN3@g_MemorySt

; 692  : 
; 693  :         LastZone->Link = NULL;
; 694  : 
; 695  :         if (LastExistingZone == NULL) {

  000c6	8b 45 f0	 mov	 eax, DWORD PTR _LastExistingZone$[ebp]
  000c9	85 c0		 test	 eax, eax
  000cb	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  000d1	75 15		 jne	 SHORT $LN2@g_MemorySt

; 696  : 
; 697  :             // The existing list is empty. Insert the new one to the head
; 698  : 
; 699  :             ZoneChain->BkLink = NULL;

  000d3	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 700  :             Storage->BkLink = LastZone;

  000d6	89 7e 18	 mov	 DWORD PTR [esi+24], edi

; 707  : 
; 708  :         }
; 709  : 
; 710  :         Storage->BkLink = LastZone;

  000d9	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  000dc	5f		 pop	 edi
  000dd	89 4e 14	 mov	 DWORD PTR [esi+20], ecx
  000e0	5e		 pop	 esi
  000e1	5b		 pop	 ebx

; 711  :     }
; 712  : 
; 713  : }

  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c2 04 00	 ret	 4
$LN2@g_MemorySt:

; 701  :             Storage->MemoryZoneLink = ZoneChain;
; 702  : 
; 703  :         } else {
; 704  : 
; 705  :             LastExistingZone->Link = ZoneChain;

  000e8	89 08		 mov	 DWORD PTR [eax], ecx

; 706  :             ZoneChain->BkLink = LastExistingZone;

  000ea	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 707  : 
; 708  :         }
; 709  : 
; 710  :         Storage->BkLink = LastZone;

  000ed	89 7e 18	 mov	 DWORD PTR [esi+24], edi
$LN3@g_MemorySt:
  000f0	5f		 pop	 edi
  000f1	5e		 pop	 esi
  000f2	5b		 pop	 ebx

; 711  :     }
; 712  : 
; 713  : }

  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c2 04 00	 ret	 4
?g_MemoryStorageRegisterBufferImpl@Class_Microsoft_Singularity_Eventing_MemoryStorage@@SIXPAUuintPtr@@PAEI@Z ENDP ; Class_Microsoft_Singularity_Eventing_MemoryStorage::g_MemoryStorageRegisterBufferImpl
_TEXT	ENDS
PUBLIC	?g_LogSourceEntryImpl@Class_Microsoft_Singularity_Eventing_EventSource@@SIPAUuintPtr@@PAU2@I0PAEH@Z ; Class_Microsoft_Singularity_Eventing_EventSource::g_LogSourceEntryImpl
; Function compile flags: /Ogtp
;	COMDAT ?g_LogSourceEntryImpl@Class_Microsoft_Singularity_Eventing_EventSource@@SIPAUuintPtr@@PAU2@I0PAEH@Z
_TEXT	SEGMENT
_eventType$ = 8						; size = 4
_Buffer$ = 12						; size = 4
_size$ = 16						; size = 4
?g_LogSourceEntryImpl@Class_Microsoft_Singularity_Eventing_EventSource@@SIPAUuintPtr@@PAU2@I0PAEH@Z PROC ; Class_Microsoft_Singularity_Eventing_EventSource::g_LogSourceEntryImpl, COMDAT
; _sourceHandle$ = ecx
; _flags$ = edx

; 722  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 723  :     UIntPtr storageHandle = OpenLoggingStorage(sourceHandle, &flags);

  00003	85 c9		 test	 ecx, ecx
  00005	53		 push	 ebx
  00006	56		 push	 esi
  00007	8b da		 mov	 ebx, edx
  00009	74 18		 je	 SHORT $LN5@g_LogSourc
$LN4@g_LogSourc:
  0000b	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0000e	8b d0		 mov	 edx, eax
  00010	23 d3		 and	 edx, ebx
  00012	f7 c2 00 00 ff
	ff		 test	 edx, -65536		; ffff0000H
  00018	75 04		 jne	 SHORT $LN3@g_LogSourc
  0001a	33 c9		 xor	 ecx, ecx
  0001c	eb 05		 jmp	 SHORT $LN5@g_LogSourc
$LN3@g_LogSourc:
  0001e	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00021	0b d8		 or	 ebx, eax
$LN5@g_LogSourc:

; 724  :     return (UIntPtr)InternalLogFixedRecord(storageHandle,
; 725  :                                            flags,
; 726  :                                            eventType,
; 727  :                                            Buffer,
; 728  :                                            size);

  00023	8b 45 10	 mov	 eax, DWORD PTR _size$[ebp]
  00026	8b 55 0c	 mov	 edx, DWORD PTR _Buffer$[ebp]
  00029	6a 00		 push	 0
  0002b	6a 00		 push	 0
  0002d	50		 push	 eax
  0002e	8b 45 08	 mov	 eax, DWORD PTR _eventType$[ebp]
  00031	52		 push	 edx
  00032	50		 push	 eax
  00033	8b d3		 mov	 edx, ebx
  00035	e8 00 00 00 00	 call	 ?InternalLogRecord@@YIPAU_MEMORY_HEADER@@PAUuintPtr@@I0PAXIPAPAXI@Z ; InternalLogRecord
  0003a	8b f0		 mov	 esi, eax
  0003c	85 f6		 test	 esi, esi
  0003e	74 13		 je	 SHORT $LN11@g_LogSourc
  00040	f6 c3 02	 test	 bl, 2
  00043	74 07		 je	 SHORT $LN7@g_LogSourc
  00045	8b ce		 mov	 ecx, esi
  00047	e8 00 00 00 00	 call	 ?DebugPrintEvent@@YIXPAUuintPtr@@@Z ; DebugPrintEvent
$LN7@g_LogSourc:
  0004c	8b ce		 mov	 ecx, esi
  0004e	e8 00 00 00 00	 call	 ?CommitEventEntry@@YIXPAU_MEMORY_HEADER@@@Z ; CommitEventEntry
$LN11@g_LogSourc:
  00053	8b c6		 mov	 eax, esi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx

; 729  : }

  00057	5d		 pop	 ebp
  00058	c2 0c 00	 ret	 12			; 0000000cH
?g_LogSourceEntryImpl@Class_Microsoft_Singularity_Eventing_EventSource@@SIPAUuintPtr@@PAU2@I0PAEH@Z ENDP ; Class_Microsoft_Singularity_Eventing_EventSource::g_LogSourceEntryImpl
_TEXT	ENDS
PUBLIC	?g_LogSourceEntryImpl@Class_Microsoft_Singularity_Eventing_EventSource@@SIPAUuintPtr@@PAU2@I0PAEHHPAUStruct_Microsoft_Singularity_Eventing_ArrayType@@@Z ; Class_Microsoft_Singularity_Eventing_EventSource::g_LogSourceEntryImpl
; Function compile flags: /Ogtp
;	COMDAT ?g_LogSourceEntryImpl@Class_Microsoft_Singularity_Eventing_EventSource@@SIPAUuintPtr@@PAU2@I0PAEHHPAUStruct_Microsoft_Singularity_Eventing_ArrayType@@@Z
_TEXT	SEGMENT
_eventType$ = 8						; size = 4
_Buffer$ = 12						; size = 4
_size$ = 16						; size = 4
_arraysCount$ = 20					; size = 4
_arrays$ = 24						; size = 4
?g_LogSourceEntryImpl@Class_Microsoft_Singularity_Eventing_EventSource@@SIPAUuintPtr@@PAU2@I0PAEHHPAUStruct_Microsoft_Singularity_Eventing_ArrayType@@@Z PROC ; Class_Microsoft_Singularity_Eventing_EventSource::g_LogSourceEntryImpl, COMDAT
; _sourceHandle$ = ecx
; _flags$ = edx

; 739  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 740  :     UIntPtr storageHandle = OpenLoggingStorage(sourceHandle, &flags);

  00003	85 c9		 test	 ecx, ecx
  00005	8b c2		 mov	 eax, edx
  00007	75 04		 jne	 SHORT $LN4@g_LogSourc@2
$LN7@g_LogSourc@2:
  00009	33 c9		 xor	 ecx, ecx
  0000b	eb 16		 jmp	 SHORT $LN5@g_LogSourc@2
$LN4@g_LogSourc@2:
  0000d	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00010	56		 push	 esi
  00011	8b f2		 mov	 esi, edx
  00013	23 f0		 and	 esi, eax
  00015	f7 c6 00 00 ff
	ff		 test	 esi, -65536		; ffff0000H
  0001b	5e		 pop	 esi
  0001c	74 eb		 je	 SHORT $LN7@g_LogSourc@2
  0001e	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00021	0b c2		 or	 eax, edx
$LN5@g_LogSourc@2:

; 741  :     return (UIntPtr)InternalLogVariableRecord(true,
; 742  :                                               storageHandle,
; 743  :                                               flags,
; 744  :                                               eventType,
; 745  :                                               Buffer,
; 746  :                                               size,
; 747  :                                               arraysCount,
; 748  :                                               arrays);

  00023	8b 55 18	 mov	 edx, DWORD PTR _arrays$[ebp]
  00026	52		 push	 edx
  00027	8b 55 14	 mov	 edx, DWORD PTR _arraysCount$[ebp]
  0002a	52		 push	 edx
  0002b	8b 55 10	 mov	 edx, DWORD PTR _size$[ebp]
  0002e	52		 push	 edx
  0002f	8b 55 0c	 mov	 edx, DWORD PTR _Buffer$[ebp]
  00032	52		 push	 edx
  00033	8b 55 08	 mov	 edx, DWORD PTR _eventType$[ebp]
  00036	52		 push	 edx
  00037	8b d1		 mov	 edx, ecx
  00039	50		 push	 eax
  0003a	b1 01		 mov	 cl, 1
  0003c	e8 00 00 00 00	 call	 ?InternalLogVariableRecord@@YIPAU_MEMORY_HEADER@@_NPAUuintPtr@@I1PAXIHPAUStruct_Microsoft_Singularity_Eventing_ArrayType@@@Z ; InternalLogVariableRecord

; 749  : }

  00041	5d		 pop	 ebp
  00042	c2 14 00	 ret	 20			; 00000014H
?g_LogSourceEntryImpl@Class_Microsoft_Singularity_Eventing_EventSource@@SIPAUuintPtr@@PAU2@I0PAEHHPAUStruct_Microsoft_Singularity_Eventing_ArrayType@@@Z ENDP ; Class_Microsoft_Singularity_Eventing_EventSource::g_LogSourceEntryImpl
_TEXT	ENDS
PUBLIC	?g_GetMemoryStorageOveheadImpl@Class_Microsoft_Singularity_Eventing_MemoryStorage@@SIIXZ ; Class_Microsoft_Singularity_Eventing_MemoryStorage::g_GetMemoryStorageOveheadImpl
; Function compile flags: /Ogtp
;	COMDAT ?g_GetMemoryStorageOveheadImpl@Class_Microsoft_Singularity_Eventing_MemoryStorage@@SIIXZ
_TEXT	SEGMENT
?g_GetMemoryStorageOveheadImpl@Class_Microsoft_Singularity_Eventing_MemoryStorage@@SIIXZ PROC ; Class_Microsoft_Singularity_Eventing_MemoryStorage::g_GetMemoryStorageOveheadImpl, COMDAT

; 755  :     // Determine the overhead in the pesimistic case
; 756  : 
; 757  :     return sizeof(MEMORY_STORAGE) +
; 758  :            (sizeof(MEMORY_ZONE) + EV_ZONE_ALIGNMENT) * EV_DEFAULT_ZONE_BUFFER_RATIO +
; 759  :            sizeof(MEMORY_HEADER) * EV_DEFAULT_ZONE_BUFFER_RATIO;

  00000	b8 f4 02 00 00	 mov	 eax, 756		; 000002f4H

; 760  : }

  00005	c3		 ret	 0
?g_GetMemoryStorageOveheadImpl@Class_Microsoft_Singularity_Eventing_MemoryStorage@@SIIXZ ENDP ; Class_Microsoft_Singularity_Eventing_MemoryStorage::g_GetMemoryStorageOveheadImpl
_TEXT	ENDS
PUBLIC	?g_CreateQueryViewImpl@Class_Microsoft_Singularity_Eventing_MemoryStorage@@SIPAUuintPtr@@PAU2@_N@Z ; Class_Microsoft_Singularity_Eventing_MemoryStorage::g_CreateQueryViewImpl
; Function compile flags: /Ogtp
;	COMDAT ?g_CreateQueryViewImpl@Class_Microsoft_Singularity_Eventing_MemoryStorage@@SIPAUuintPtr@@PAU2@_N@Z
_TEXT	SEGMENT
?g_CreateQueryViewImpl@Class_Microsoft_Singularity_Eventing_MemoryStorage@@SIPAUuintPtr@@PAU2@_N@Z PROC ; Class_Microsoft_Singularity_Eventing_MemoryStorage::g_CreateQueryViewImpl, COMDAT
; _storageHandle$ = ecx
; _forward$ = dl

; 765  :     return (UIntPtr)CreateQuery(storageHandle, forward);

  00000	e9 00 00 00 00	 jmp	 ?CreateQuery@@YIPAU_QUERY_VIEW@@PAUuintPtr@@_N@Z ; CreateQuery
?g_CreateQueryViewImpl@Class_Microsoft_Singularity_Eventing_MemoryStorage@@SIPAUuintPtr@@PAU2@_N@Z ENDP ; Class_Microsoft_Singularity_Eventing_MemoryStorage::g_CreateQueryViewImpl
_TEXT	ENDS
PUBLIC	?g_DeleteQueryViewImpl@Class_Microsoft_Singularity_Eventing_MemoryStorage@@SIXPAUuintPtr@@@Z ; Class_Microsoft_Singularity_Eventing_MemoryStorage::g_DeleteQueryViewImpl
EXTRN	?UnRegisterQueryView@@YIXPAU_QUERY_VIEW@@@Z:PROC ; UnRegisterQueryView
; Function compile flags: /Ogtp
;	COMDAT ?g_DeleteQueryViewImpl@Class_Microsoft_Singularity_Eventing_MemoryStorage@@SIXPAUuintPtr@@@Z
_TEXT	SEGMENT
?g_DeleteQueryViewImpl@Class_Microsoft_Singularity_Eventing_MemoryStorage@@SIXPAUuintPtr@@@Z PROC ; Class_Microsoft_Singularity_Eventing_MemoryStorage::g_DeleteQueryViewImpl, COMDAT
; _queryHandle$ = ecx

; 771  :     UnRegisterQueryView((PQUERY_VIEW)queryHandle);

  00000	e9 00 00 00 00	 jmp	 ?UnRegisterQueryView@@YIXPAU_QUERY_VIEW@@@Z ; UnRegisterQueryView
?g_DeleteQueryViewImpl@Class_Microsoft_Singularity_Eventing_MemoryStorage@@SIXPAUuintPtr@@@Z ENDP ; Class_Microsoft_Singularity_Eventing_MemoryStorage::g_DeleteQueryViewImpl
_TEXT	ENDS
PUBLIC	?g_GetNextEntryImpl@Class_Microsoft_Singularity_Eventing_MemoryStorage@@SIPAUuintPtr@@PAU2@PAPAU2@PAIPAEG@Z ; Class_Microsoft_Singularity_Eventing_MemoryStorage::g_GetNextEntryImpl
; Function compile flags: /Ogtp
;	COMDAT ?g_GetNextEntryImpl@Class_Microsoft_Singularity_Eventing_MemoryStorage@@SIPAUuintPtr@@PAU2@PAPAU2@PAIPAEG@Z
_TEXT	SEGMENT
_userOffset$ = 8					; size = 4
_buffer$ = 12						; size = 4
_bufferSize$ = 16					; size = 2
?g_GetNextEntryImpl@Class_Microsoft_Singularity_Eventing_MemoryStorage@@SIPAUuintPtr@@PAU2@PAPAU2@PAIPAEG@Z PROC ; Class_Microsoft_Singularity_Eventing_MemoryStorage::g_GetNextEntryImpl, COMDAT
; _queryHandle$ = ecx
; _typeHandle$ = edx

; 780  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b fa		 mov	 edi, edx

; 781  :     PQUERY_VIEW view = (PQUERY_VIEW)queryHandle;
; 782  : 
; 783  :     PMEMORY_HEADER entry = GetNextStorageEntry(view);

  00007	e8 00 00 00 00	 call	 ?GetNextStorageEntry@@YIPAU_MEMORY_HEADER@@PAU_QUERY_VIEW@@@Z ; GetNextStorageEntry
  0000c	8b f0		 mov	 esi, eax

; 784  : 
; 785  :     if (entry != NULL) {

  0000e	85 f6		 test	 esi, esi
  00010	74 4e		 je	 SHORT $LN2@g_GetNextE

; 786  : 
; 787  :         *typeHandle = entry->Type;

  00012	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00015	89 07		 mov	 DWORD PTR [edi], eax

; 788  : 
; 789  :         void * src = GetUserRecordStructure(entry);

  00017	f6 46 06 01	 test	 BYTE PTR [esi+6], 1
  0001b	74 18		 je	 SHORT $LN6@g_GetNextE
  0001d	66 8b 4e 18	 mov	 cx, WORD PTR [esi+24]
  00021	66 83 c1 07	 add	 cx, 7
  00025	66 03 c9	 add	 cx, cx
  00028	66 03 c9	 add	 cx, cx
  0002b	0f b7 c1	 movzx	 eax, cx
  0002e	0f b7 f8	 movzx	 edi, ax
  00031	03 fe		 add	 edi, esi
  00033	eb 03		 jmp	 SHORT $LN7@g_GetNextE
$LN6@g_GetNextE:
  00035	8d 7e 18	 lea	 edi, DWORD PTR [esi+24]
$LN7@g_GetNextE:

; 790  : 
; 791  :         if (entry->Size < bufferSize) {

  00038	0f b7 0e	 movzx	 ecx, WORD PTR [esi]
  0003b	8b 45 10	 mov	 eax, DWORD PTR _bufferSize$[ebp]
  0003e	66 3b c8	 cmp	 cx, ax
  00041	73 03		 jae	 SHORT $LN1@g_GetNextE

; 792  : 
; 793  :             bufferSize = entry->Size;

  00043	0f b7 c1	 movzx	 eax, cx
$LN1@g_GetNextE:

; 794  :         }
; 795  : 
; 796  :         memcpy(buffer, entry , bufferSize);

  00046	0f b7 d0	 movzx	 edx, ax
  00049	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  0004c	52		 push	 edx
  0004d	56		 push	 esi
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 _memcpy

; 797  :         *userOffset = (uint32)((ULONG_PTR)src - (ULONG_PTR)entry);

  00054	8b 4d 08	 mov	 ecx, DWORD PTR _userOffset$[ebp]
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	2b fe		 sub	 edi, esi
  0005c	89 39		 mov	 DWORD PTR [ecx], edi

; 798  :     }
; 799  : 
; 800  :     return (UIntPtr) entry;

  0005e	8b c6		 mov	 eax, esi
$LN2@g_GetNextE:
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi

; 801  : }

  00062	5d		 pop	 ebp
  00063	c2 0c 00	 ret	 12			; 0000000cH
?g_GetNextEntryImpl@Class_Microsoft_Singularity_Eventing_MemoryStorage@@SIPAUuintPtr@@PAU2@PAPAU2@PAIPAEG@Z ENDP ; Class_Microsoft_Singularity_Eventing_MemoryStorage::g_GetNextEntryImpl
_TEXT	ENDS
PUBLIC	?g_WalkEventDescriptorImpl@Class_Microsoft_Singularity_Eventing_MemoryStorage@@SIPAUuintPtr@@PAU2@0PAG1PA_WG@Z ; Class_Microsoft_Singularity_Eventing_MemoryStorage::g_WalkEventDescriptorImpl
EXTRN	?GetExtendedString@@YIPADPAUuintPtr@@H@Z:PROC	; GetExtendedString
EXTRN	?Handle_MEMORY_HEADER@@3PAUuintPtr@@A:DWORD	; Handle_MEMORY_HEADER
; Function compile flags: /Ogtp
;	COMDAT ?g_WalkEventDescriptorImpl@Class_Microsoft_Singularity_Eventing_MemoryStorage@@SIPAUuintPtr@@PAU2@0PAG1PA_WG@Z
_TEXT	SEGMENT
_src$ = 8						; size = 4
_offset$ = 8						; size = 4
_type$ = 12						; size = 4
_bufferName$ = 16					; size = 4
_bufferSize$ = 20					; size = 2
?g_WalkEventDescriptorImpl@Class_Microsoft_Singularity_Eventing_MemoryStorage@@SIPAUuintPtr@@PAU2@0PAG1PA_WG@Z PROC ; Class_Microsoft_Singularity_Eventing_MemoryStorage::g_WalkEventDescriptorImpl, COMDAT
; _eventHandle$ = ecx
; _currentField$ = edx

; 810  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 811  :     if (eventHandle == 0) {

  00007	85 ff		 test	 edi, edi
  00009	75 06		 jne	 SHORT $LN14@g_WalkEven

; 812  : 
; 813  :         eventHandle = Handle_MEMORY_HEADER;

  0000b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?Handle_MEMORY_HEADER@@3PAUuintPtr@@A ; Handle_MEMORY_HEADER
$LN14@g_WalkEven:

; 814  :     }
; 815  : 
; 816  :     PMEMORY_HEADER Entry = HANDLE_TO_HEADER(eventHandle);
; 817  : 
; 818  :     EV_ASSERT(Entry->Flags == RECORD_EVENT_TYPE);

  00011	0f b7 47 06	 movzx	 eax, WORD PTR [edi+6]
  00015	66 3d 00 81	 cmp	 ax, 33024		; 00008100H
  00019	74 01		 je	 SHORT $LN13@g_WalkEven
  0001b	cc		 int	 3
$LN13@g_WalkEven:

; 819  : 
; 820  :     PEVENT_DESCRIPTOR eventDescriptor = (PEVENT_DESCRIPTOR)GetUserRecordStructure(Entry);

  0001c	a8 01		 test	 al, 1
  0001e	74 18		 je	 SHORT $LN18@g_WalkEven
  00020	66 8b 47 18	 mov	 ax, WORD PTR [edi+24]
  00024	66 05 07 00	 add	 ax, 7
  00028	66 03 c0	 add	 ax, ax
  0002b	66 03 c0	 add	 ax, ax
  0002e	0f b7 c0	 movzx	 eax, ax
  00031	0f b7 c0	 movzx	 eax, ax
  00034	03 c7		 add	 eax, edi
  00036	eb 03		 jmp	 SHORT $LN19@g_WalkEven
$LN18@g_WalkEven:
  00038	8d 47 18	 lea	 eax, DWORD PTR [edi+24]
$LN19@g_WalkEven:

; 821  :     PEVENT_FIELD_DESCRIPTOR field = NULL;

  0003b	33 f6		 xor	 esi, esi

; 822  :     char * src;
; 823  : 
; 824  :     if (currentField == 0) {

  0003d	85 d2		 test	 edx, edx
  0003f	75 0c		 jne	 SHORT $LN12@g_WalkEven

; 825  : 
; 826  :         src = GetExtendedString(eventHandle, 1);

  00041	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
  00044	8b cf		 mov	 ecx, edi
  00046	e8 00 00 00 00	 call	 ?GetExtendedString@@YIPADPAUuintPtr@@H@Z ; GetExtendedString
  0004b	eb 0d		 jmp	 SHORT $LN38@g_WalkEven
$LN12@g_WalkEven:

; 827  : 
; 828  :     } else if (currentField == eventHandle) {

  0004d	3b d7		 cmp	 edx, edi
  0004f	75 1b		 jne	 SHORT $LN10@g_WalkEven

; 829  : 
; 830  :         // start now with the fields inside the event
; 831  : 
; 832  :         field = eventDescriptor->fieldsLink;

  00051	8b 30		 mov	 esi, DWORD PTR [eax]

; 842  :         }
; 843  :     }
; 844  : 
; 845  :     if (field == NULL) {

  00053	85 f6		 test	 esi, esi
  00055	75 23		 jne	 SHORT $LN7@g_WalkEven
  00057	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
$LN38@g_WalkEven:

; 846  : 
; 847  :         //  This is refers the event descriptor itself.
; 848  :         //  The type returned will be zero, the only meaningful information
; 849  :         //  will be the event name
; 850  : 
; 851  :         *offset = 0;

  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _offset$[ebp]

; 852  :         *type = 0;

  0005d	8b 55 0c	 mov	 edx, DWORD PTR _type$[ebp]
  00060	66 c7 01 00 00	 mov	 WORD PTR [ecx], 0
  00065	66 c7 02 00 00	 mov	 WORD PTR [edx], 0

; 853  : 
; 854  :     } else {

  0006a	eb 2f		 jmp	 SHORT $LN6@g_WalkEven
$LN10@g_WalkEven:

; 833  : 
; 834  :     } else {
; 835  : 
; 836  :         field = (PEVENT_FIELD_DESCRIPTOR)(currentField);
; 837  :         field = field->fieldsLink;

  0006c	8b 32		 mov	 esi, DWORD PTR [edx]

; 838  : 
; 839  :         if (field == NULL) {

  0006e	85 f6		 test	 esi, esi
  00070	75 08		 jne	 SHORT $LN7@g_WalkEven
  00072	5f		 pop	 edi

; 840  : 
; 841  :             return 0;

  00073	33 c0		 xor	 eax, eax
  00075	5e		 pop	 esi

; 888  : }

  00076	5d		 pop	 ebp
  00077	c2 10 00	 ret	 16			; 00000010H
$LN7@g_WalkEven:

; 855  : 
; 856  :         *offset = field->Offset;

  0007a	66 8b 46 04	 mov	 ax, WORD PTR [esi+4]
  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _offset$[ebp]
  00081	66 89 01	 mov	 WORD PTR [ecx], ax

; 857  :         *type = field->Type;

  00084	66 8b 56 06	 mov	 dx, WORD PTR [esi+6]
  00088	8b 45 0c	 mov	 eax, DWORD PTR _type$[ebp]
  0008b	66 89 10	 mov	 WORD PTR [eax], dx

; 858  : 
; 859  :         src = GetExtendedString((UIntPtr)((PMEMORY_HEADER)field - 1), 1);

  0008e	8d 4e e8	 lea	 ecx, DWORD PTR [esi-24]
  00091	ba 01 00 00 00	 mov	 edx, 1
  00096	e8 00 00 00 00	 call	 ?GetExtendedString@@YIPADPAUuintPtr@@H@Z ; GetExtendedString
$LN6@g_WalkEven:

; 860  :     }
; 861  : 
; 862  :     if ((bufferName != NULL) && (bufferSize != 0)) {

  0009b	8b 4d 10	 mov	 ecx, DWORD PTR _bufferName$[ebp]
  0009e	85 c9		 test	 ecx, ecx
  000a0	74 32		 je	 SHORT $LN5@g_WalkEven
  000a2	8b 55 14	 mov	 edx, DWORD PTR _bufferSize$[ebp]
  000a5	66 85 d2	 test	 dx, dx
  000a8	74 2a		 je	 SHORT $LN5@g_WalkEven
  000aa	53		 push	 ebx
  000ab	eb 03 8d 49 00	 npad	 5
$LL4@g_WalkEven:

; 863  : 
; 864  : 
; 865  :         while ((bufferSize != 0) && (*src)) {

  000b0	8a 18		 mov	 bl, BYTE PTR [eax]
  000b2	84 db		 test	 bl, bl
  000b4	74 18		 je	 SHORT $LN3@g_WalkEven

; 866  : 
; 867  :             *bufferName++ = *src++;

  000b6	66 0f be db	 movsx	 bx, bl
  000ba	66 89 19	 mov	 WORD PTR [ecx], bx

; 868  :             bufferSize -= sizeof(bartok_char);

  000bd	81 c2 fe ff 00
	00		 add	 edx, 65534		; 0000fffeH
  000c3	83 c1 02	 add	 ecx, 2
  000c6	83 c0 01	 add	 eax, 1
  000c9	66 85 d2	 test	 dx, dx
  000cc	75 e2		 jne	 SHORT $LL4@g_WalkEven
$LN3@g_WalkEven:

; 869  :         }
; 870  : 
; 871  :         if (bufferSize == 0) {
; 872  : 
; 873  :             // Move back one position to insert the null terminator.
; 874  :             // We have at least this character in the buffer due to the test two levels above
; 875  : 
; 876  :             bufferSize -= sizeof(bartok_char);
; 877  :         }
; 878  : 
; 879  :         *bufferName = 0;

  000ce	66 c7 01 00 00	 mov	 WORD PTR [ecx], 0
  000d3	5b		 pop	 ebx
$LN5@g_WalkEven:

; 880  :     }
; 881  : 
; 882  :     if (field == NULL) {

  000d4	85 f6		 test	 esi, esi

; 883  : 
; 884  :         return eventHandle;

  000d6	8b c7		 mov	 eax, edi
  000d8	74 02		 je	 SHORT $LN15@g_WalkEven

; 885  :     }
; 886  : 
; 887  :     return (UIntPtr)field;

  000da	8b c6		 mov	 eax, esi
$LN15@g_WalkEven:
  000dc	5f		 pop	 edi
  000dd	5e		 pop	 esi

; 888  : }

  000de	5d		 pop	 ebp
  000df	c2 10 00	 ret	 16			; 00000010H
?g_WalkEventDescriptorImpl@Class_Microsoft_Singularity_Eventing_MemoryStorage@@SIPAUuintPtr@@PAU2@0PAG1PA_WG@Z ENDP ; Class_Microsoft_Singularity_Eventing_MemoryStorage::g_WalkEventDescriptorImpl
_TEXT	ENDS
PUBLIC	?g_MemoryStorageCreateImpl@Class_Microsoft_Singularity_Eventing_MemoryStorage@@SIPAUuintPtr@@IPAEII@Z ; Class_Microsoft_Singularity_Eventing_MemoryStorage::g_MemoryStorageCreateImpl
; Function compile flags: /Ogtp
;	COMDAT ?g_MemoryStorageCreateImpl@Class_Microsoft_Singularity_Eventing_MemoryStorage@@SIPAUuintPtr@@IPAEII@Z
_TEXT	SEGMENT
_BufferSize$ = 8					; size = 4
_ZoneSize$ = 12						; size = 4
?g_MemoryStorageCreateImpl@Class_Microsoft_Singularity_Eventing_MemoryStorage@@SIPAUuintPtr@@IPAEII@Z PROC ; Class_Microsoft_Singularity_Eventing_MemoryStorage::g_MemoryStorageCreateImpl, COMDAT
; _Flags$ = ecx
; _InitialBuffer$ = edx

; 566  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 567  :     if (BufferSize <= sizeof(MEMORY_STORAGE)) {

  00003	83 7d 08 24	 cmp	 DWORD PTR _BufferSize$[ebp], 36 ; 00000024H
  00007	56		 push	 esi
  00008	8b f2		 mov	 esi, edx
  0000a	8b c1		 mov	 eax, ecx
  0000c	77 07		 ja	 SHORT $LN6@g_MemorySt@2

; 568  : 
; 569  :         return 0;

  0000e	33 c0		 xor	 eax, eax
  00010	5e		 pop	 esi

; 615  : }

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
$LN6@g_MemorySt@2:

; 570  :     }
; 571  : 
; 572  :     PMEMORY_STORAGE Storage = (PMEMORY_STORAGE)InitialBuffer;
; 573  :     Storage->StorageSize = 0;
; 574  :     Storage->MemoryZoneLink = NULL;
; 575  :     Storage->ZoneCursor = NULL;
; 576  :     Storage->Flags = Flags;
; 577  :     Storage->BkLink = NULL;
; 578  :     Storage->Generation = 0;
; 579  : 
; 580  :     ZoneSize = (uint32)ROUND_UP_TO_POWER2(ZoneSize, EV_ZONE_ALIGNMENT);

  00015	8b 55 0c	 mov	 edx, DWORD PTR _ZoneSize$[ebp]
  00018	33 c9		 xor	 ecx, ecx
  0001a	53		 push	 ebx
  0001b	83 c2 0f	 add	 edx, 15			; 0000000fH
  0001e	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00021	57		 push	 edi

; 581  : 
; 582  :     if (((Flags & 0xF) == MEMORY_STORAGE_FLAGS_PERMANENT)
; 583  :             ||
; 584  :         ((Flags & 0xF) == MEMORY_STORAGE_FLAGS_ACTIVE_STORAGE) ) {

  00022	83 e0 0f	 and	 eax, 15			; 0000000fH
  00025	8d 7e 14	 lea	 edi, DWORD PTR [esi+20]
  00028	8d 5e 1c	 lea	 ebx, DWORD PTR [esi+28]
  0002b	83 e2 f0	 and	 edx, -16		; fffffff0H
  0002e	83 f8 01	 cmp	 eax, 1
  00031	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00034	89 0f		 mov	 DWORD PTR [edi], ecx
  00036	89 0b		 mov	 DWORD PTR [ebx], ecx
  00038	89 4e 18	 mov	 DWORD PTR [esi+24], ecx
  0003b	89 4e 20	 mov	 DWORD PTR [esi+32], ecx
  0003e	74 05		 je	 SHORT $LN4@g_MemorySt@2
  00040	83 f8 03	 cmp	 eax, 3
  00043	75 03		 jne	 SHORT $LN9@g_MemorySt@2
$LN4@g_MemorySt@2:

; 585  : 
; 586  :         ZoneSize = BufferSize;

  00045	8b 55 08	 mov	 edx, DWORD PTR _BufferSize$[ebp]
$LN9@g_MemorySt@2:

; 587  :     }
; 588  : 
; 589  :     if (ZoneSize < sizeof(MEMORY_ZONE)) {

  00048	83 fa 20	 cmp	 edx, 32			; 00000020H
  0004b	73 11		 jae	 SHORT $LN10@g_MemorySt@2

; 590  : 
; 591  :         ZoneSize = BufferSize / EV_DEFAULT_ZONE_BUFFER_RATIO;

  0004d	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  00052	f7 65 08	 mul	 DWORD PTR _BufferSize$[ebp]
  00055	c1 ea 03	 shr	 edx, 3

; 592  :         ZoneSize = (uint32)ROUND_UP_TO_POWER2(ZoneSize, EV_ZONE_ALIGNMENT);

  00058	83 c2 0f	 add	 edx, 15			; 0000000fH
  0005b	83 e2 f0	 and	 edx, -16		; fffffff0H
$LN10@g_MemorySt@2:

; 593  :     }
; 594  : 
; 595  :     if (ZoneSize > EV_MAXIMUM_ZONE_SIZE) {

  0005e	81 fa 80 ff 00
	00		 cmp	 edx, 65408		; 0000ff80H
  00064	76 08		 jbe	 SHORT $LN2@g_MemorySt@2

; 596  :         Storage->DefaultZoneSize = EV_MAXIMUM_ZONE_SIZE;

  00066	66 c7 46 0c 80
	ff		 mov	 WORD PTR [esi+12], 65408 ; 0000ff80H

; 597  : 
; 598  :     } else {

  0006c	eb 04		 jmp	 SHORT $LN1@g_MemorySt@2
$LN2@g_MemorySt@2:

; 599  : 
; 600  :         Storage->DefaultZoneSize = ZoneSize;

  0006e	66 89 56 0c	 mov	 WORD PTR [esi+12], dx
$LN1@g_MemorySt@2:

; 601  :     }
; 602  : 
; 603  :     Storage->ZoneCount = 0;
; 604  :     InitialBuffer = (UCHAR *)(Storage + 1);
; 605  :     InitialBuffer = (UCHAR *)ROUND_UP_TO_POWER2(InitialBuffer, EV_ZONE_ALIGNMENT);

  00072	8d 56 33	 lea	 edx, DWORD PTR [esi+51]
  00075	83 e2 f0	 and	 edx, -16		; fffffff0H

; 606  : 
; 607  :     Class_Microsoft_Singularity_Eventing_MemoryStorage::g_MemoryStorageRegisterBufferImpl(
; 608  :         (UIntPtr)Storage,
; 609  :         InitialBuffer,
; 610  :         (uint32)(BufferSize - ((uint8 *)InitialBuffer - (uint8 *)Storage)));

  00078	8b c6		 mov	 eax, esi
  0007a	2b c2		 sub	 eax, edx
  0007c	03 45 08	 add	 eax, DWORD PTR _BufferSize$[ebp]
  0007f	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00082	50		 push	 eax
  00083	8b ce		 mov	 ecx, esi
  00085	e8 00 00 00 00	 call	 ?g_MemoryStorageRegisterBufferImpl@Class_Microsoft_Singularity_Eventing_MemoryStorage@@SIXPAUuintPtr@@PAEI@Z ; Class_Microsoft_Singularity_Eventing_MemoryStorage::g_MemoryStorageRegisterBufferImpl

; 611  : 
; 612  :     Storage->ZoneCursor = Storage->MemoryZoneLink;

  0008a	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0008c	5f		 pop	 edi
  0008d	89 0b		 mov	 DWORD PTR [ebx], ecx
  0008f	5b		 pop	 ebx

; 613  : 
; 614  :     return (UIntPtr)Storage;

  00090	8b c6		 mov	 eax, esi
  00092	5e		 pop	 esi

; 615  : }

  00093	5d		 pop	 ebp
  00094	c2 08 00	 ret	 8
?g_MemoryStorageCreateImpl@Class_Microsoft_Singularity_Eventing_MemoryStorage@@SIPAUuintPtr@@IPAEII@Z ENDP ; Class_Microsoft_Singularity_Eventing_MemoryStorage::g_MemoryStorageCreateImpl
_TEXT	ENDS
END
