; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	C:\Users\cc\source\repos\Singularity-OS\base\Kernel\Native\ix86\Math.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
__d_pos_inf DQ	7ff0000000000000H
__d_neg_inf DQ	fff0000000000000H
__d_ind	DQ	fff8000000000000H
__d_neg_zer DQ	8000000000000000H
_DATA	ENDS
PUBLIC	?g_ClearFp@@YIGXZ				; g_ClearFp
; Function compile flags: /Ogtp
; File c:\users\cc\source\repos\singularity-os\base\kernel\native\ix86\math.cpp
;	COMDAT ?g_ClearFp@@YIGXZ
_TEXT	SEGMENT
?g_ClearFp@@YIGXZ PROC					; g_ClearFp, COMDAT

; 101  :     __asm {
; 102  :         push ebp

  00000	55		 push	 ebp

; 103  :         mov ebp, esp

  00001	8b ec		 mov	 ebp, esp

; 104  : 
; 105  :         // Save the old SW
; 106  :         fnstsw [esp-4];

  00003	dd 7c 24 fc	 fnstsw	 WORD PTR [esp-4]

; 107  :         fnclex

  00007	db e2		 fnclex

; 108  :         mov eax, [esp-4];

  00009	8b 44 24 fc	 mov	 eax, DWORD PTR [esp-4]

; 109  :         and eax, 0xffff;

  0000d	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH

; 110  : 
; 111  :         pop ebp;

  00012	5d		 pop	 ebp

; 112  :         ret; // Returns result in EAX

  00013	c3		 ret	 0
?g_ClearFp@@YIGXZ ENDP					; g_ClearFp
_TEXT	ENDS
PUBLIC	?g_ControlFp@@YIGGG@Z				; g_ControlFp
; Function compile flags: /Ogtp
;	COMDAT ?g_ControlFp@@YIGGG@Z
_TEXT	SEGMENT
?g_ControlFp@@YIGGG@Z PROC				; g_ControlFp, COMDAT
; _newctrl$ = cx
; _mask$ = dx

; 119  :     (void)newctrl; (void)mask;  // accessed directly via ecx, edx respectively.
; 120  :     __asm {
; 121  :         push ebp

  00000	55		 push	 ebp

; 122  :         mov ebp, esp

  00001	8b ec		 mov	 ebp, esp

; 123  : 
; 124  :         // Save the old CW
; 125  :         fstcw [esp-4];

  00003	9b d9 7c 24 fc	 fstcw	 TBYTE PTR [esp-4]

; 126  :         mov eax, [esp-4];

  00008	8b 44 24 fc	 mov	 eax, DWORD PTR [esp-4]

; 127  :         and eax, 0xffff;

  0000c	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH

; 128  : 
; 129  :         // Load the new CW
; 130  :         and ecx,edx;

  00011	23 ca		 and	 ecx, edx

; 131  :         not edx;

  00013	f7 d2		 not	 edx

; 132  :         and edx,eax;

  00015	23 d0		 and	 edx, eax

; 133  :         or  edx,ecx;

  00017	0b d1		 or	 edx, ecx

; 134  :         mov [esp-4], edx;

  00019	89 54 24 fc	 mov	 DWORD PTR [esp-4], edx

; 135  :         fldcw [esp-4];

  0001d	d9 6c 24 fc	 fldcw	 TBYTE PTR [esp-4]

; 136  : 
; 137  :         pop ebp

  00021	5d		 pop	 ebp

; 138  :         ret;

  00022	c3		 ret	 0
?g_ControlFp@@YIGGG@Z ENDP				; g_ControlFp
_TEXT	ENDS
PUBLIC	?g_RestoreFp@@YIXG@Z				; g_RestoreFp
; Function compile flags: /Ogtp
;	COMDAT ?g_RestoreFp@@YIXG@Z
_TEXT	SEGMENT
?g_RestoreFp@@YIXG@Z PROC				; g_RestoreFp, COMDAT
; _newctrl$ = cx

; 145  :     (void)newctrl;  // accessed directly via ecx.
; 146  :     __asm {
; 147  :         push ebp

  00000	55		 push	 ebp

; 148  :         mov ebp, esp

  00001	8b ec		 mov	 ebp, esp

; 149  : 
; 150  :         // Load the new CW
; 151  :         and ecx, 0xffff;

  00003	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH

; 152  :         mov [esp-4], ecx;

  00009	89 4c 24 fc	 mov	 DWORD PTR [esp-4], ecx

; 153  :         fldcw [esp-4];

  0000d	d9 6c 24 fc	 fldcw	 TBYTE PTR [esp-4]

; 154  : 
; 155  :         pop ebp

  00011	5d		 pop	 ebp

; 156  :         ret;

  00012	c3		 ret	 0
?g_RestoreFp@@YIXG@Z ENDP				; g_RestoreFp
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_frnd@@YINN@Z
_TEXT	SEGMENT
_v$ = 8							; size = 8
?_frnd@@YINN@Z PROC					; _frnd, COMDAT

; 163  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 164  :     _asm {
; 165  :         fld v;

  00003	dd 45 08	 fld	 QWORD PTR _v$[ebp]

; 166  :         frndint;

  00006	d9 fc		 frndint

; 167  :     }
; 168  : }

  00008	5d		 pop	 ebp
  00009	c2 08 00	 ret	 8
?_frnd@@YINN@Z ENDP					; _frnd
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_ftoi@@YIHN@Z
_TEXT	SEGMENT
_intval$ = -12						; size = 4
_newcw$ = -8						; size = 4
_oldcw$ = -4						; size = 4
_v$ = 8							; size = 8
?_ftoi@@YIHN@Z PROC					; _ftoi, COMDAT

; 171  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 172  :     int32 intval;
; 173  :     int32 oldcw;
; 174  :     int32 newcw;
; 175  :     _asm {
; 176  :         fstcw [oldcw];      // get control word

  00006	9b d9 7d fc	 fstcw	 DWORD PTR _oldcw$[ebp]

; 177  : 
; 178  :         mov eax, [oldcw];   // round mode saved

  0000a	8b 45 fc	 mov	 eax, DWORD PTR _oldcw$[ebp]

; 179  :         or  eax, IRC_CHOP;  // set chop rounding mode

  0000d	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H

; 180  :         mov [newcw], eax;   // back to memory

  00012	89 45 f8	 mov	 DWORD PTR _newcw$[ebp], eax

; 181  : 
; 182  :         fldcw [newcw];      // reset rounding

  00015	d9 6d f8	 fldcw	 DWORD PTR _newcw$[ebp]

; 183  :         fld v;

  00018	dd 45 08	 fld	 QWORD PTR _v$[ebp]

; 184  :         fistp [intval];     // store chopped integer

  0001b	db 5d f4	 fistp	 DWORD PTR _intval$[ebp]

; 185  :         fwait;

  0001e	9b		 fwait

; 186  :         fldcw [oldcw];      // restore rounding

  0001f	d9 6d fc	 fldcw	 DWORD PTR _oldcw$[ebp]

; 187  :     }
; 188  :     return intval;

  00022	8b 45 f4	 mov	 eax, DWORD PTR _intval$[ebp]

; 189  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
?_ftoi@@YIHN@Z ENDP					; _ftoi
_TEXT	ENDS
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtp
;	COMDAT ?_abs@@YINN@Z
_TEXT	SEGMENT
_x$ = 8							; size = 8
?_abs@@YINN@Z PROC					; _abs, COMDAT

; 192  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 193  :     (*(uint64 *)&x) &= 0x7fffffffffffffff;

  00003	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00006	81 65 0c ff ff
	ff 7f		 and	 DWORD PTR _x$[ebp+4], 2147483647 ; 7fffffffH
  0000d	89 45 08	 mov	 DWORD PTR _x$[ebp], eax

; 194  :     return x;

  00010	dd 45 08	 fld	 QWORD PTR _x$[ebp]

; 195  : }

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
?_abs@@YINN@Z ENDP					; _abs
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_set_exp@@YINNH@Z
_TEXT	SEGMENT
_retval$ = -8						; size = 8
_x$ = 8							; size = 8
?_set_exp@@YINNH@Z PROC					; _set_exp, COMDAT
; _exp$ = eax

; 198  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 199  :     float64 retval = x;
; 200  :     int biased_exp = exp + D_BIASM1;
; 201  :     *D_EXP(retval) = (unsigned short) (*D_EXP(x) & 0x800f | (biased_exp << 4));

  00006	8b 4d 0e	 mov	 ecx, DWORD PTR _x$[ebp+6]
  00009	dd 45 08	 fld	 QWORD PTR _x$[ebp]
  0000c	05 fe 03 00 00	 add	 eax, 1022		; 000003feH
  00011	dd 5d f8	 fstp	 QWORD PTR _retval$[ebp]
  00014	c1 e0 04	 shl	 eax, 4
  00017	81 e1 0f 80 00
	00		 and	 ecx, 32783		; 0000800fH
  0001d	0b c1		 or	 eax, ecx
  0001f	66 89 45 fe	 mov	 WORD PTR _retval$[ebp+6], ax

; 202  :     return retval;

  00023	dd 45 f8	 fld	 QWORD PTR _retval$[ebp]

; 203  : }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_set_exp@@YINNH@Z ENDP					; _set_exp
_TEXT	ENDS
PUBLIC	?_get_exp@@YIHN@Z				; _get_exp
; Function compile flags: /Ogtp
;	COMDAT ?_get_exp@@YIHN@Z
_TEXT	SEGMENT
_x$ = 8							; size = 8
?_get_exp@@YIHN@Z PROC					; _get_exp, COMDAT

; 206  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 207  :     signed short exp;
; 208  :     exp = (signed short)((*D_EXP(x) & 0x7ff0) >> 4);
; 209  :     exp -= D_BIASM1; //unbias
; 210  :     return (int) exp;

  00003	8b 45 0e	 mov	 eax, DWORD PTR _x$[ebp+6]
  00006	c1 e8 04	 shr	 eax, 4
  00009	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0000e	2d fe 03 00 00	 sub	 eax, 1022		; 000003feH
  00013	0f bf c0	 movsx	 eax, ax

; 211  : }

  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
?_get_exp@@YIHN@Z ENDP					; _get_exp
_TEXT	ENDS
;	COMDAT ?p0@?1??r_exp_p@@YINN@Z@4NB
CONST	SEGMENT
?p0@?1??r_exp_p@@YINN@Z@4NB DQ 03fd0000000000000r ; 0.25 ; `r_exp_p'::`2'::p0
CONST	ENDS
;	COMDAT ?p1@?1??r_exp_p@@YINN@Z@4NB
CONST	SEGMENT
?p1@?1??r_exp_p@@YINN@Z@4NB DQ 03f7c70e46fb3f6e0r ; 0.0069436 ; `r_exp_p'::`2'::p1
CONST	ENDS
;	COMDAT ?p2@?1??r_exp_p@@YINN@Z@4NB
CONST	SEGMENT
?p2@?1??r_exp_p@@YINN@Z@4NB DQ 03ef152a46f58dc1cr ; 1.65203e-005 ; `r_exp_p'::`2'::p2
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?r_exp_p@@YINN@Z
_TEXT	SEGMENT
_z$ = 8							; size = 8
?r_exp_p@@YINN@Z PROC					; r_exp_p, COMDAT

; 229  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 230  :     static float64 const p0 = 0.249999999999999993e+0;
; 231  :     static float64 const p1 = 0.694360001511792852e-2;
; 232  :     static float64 const p2 = 0.165203300268279130e-4;
; 233  : 
; 234  :     return ( (p2 * (z) + p1) * (z) + p0 );

  00003	dd 45 08	 fld	 QWORD PTR _z$[ebp]
  00006	dd 05 00 00 00
	00		 fld	 QWORD PTR ?p2@?1??r_exp_p@@YINN@Z@4NB
  0000c	d8 c9		 fmul	 ST(0), ST(1)
  0000e	dc 05 00 00 00
	00		 fadd	 QWORD PTR ?p1@?1??r_exp_p@@YINN@Z@4NB
  00014	de c9		 fmulp	 ST(1), ST(0)
  00016	dc 05 00 00 00
	00		 fadd	 QWORD PTR ?p0@?1??r_exp_p@@YINN@Z@4NB

; 235  : }

  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
?r_exp_p@@YINN@Z ENDP					; r_exp_p
_TEXT	ENDS
;	COMDAT ?q0@?1??r_exp_q@@YINN@Z@4NB
CONST	SEGMENT
?q0@?1??r_exp_q@@YINN@Z@4NB DQ 03fe0000000000000r ; 0.5	; `r_exp_q'::`2'::q0
CONST	ENDS
;	COMDAT ?q1@?1??r_exp_q@@YINN@Z@4NB
CONST	SEGMENT
?q1@?1??r_exp_q@@YINN@Z@4NB DQ 03fac718e714251b3r ; 0.0555539 ; `r_exp_q'::`2'::q1
CONST	ENDS
;	COMDAT ?q2@?1??r_exp_q@@YINN@Z@4NB
CONST	SEGMENT
?q2@?1??r_exp_q@@YINN@Z@4NB DQ 03f403f996fde3809r ; 0.000495863 ; `r_exp_q'::`2'::q2
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?r_exp_q@@YINN@Z
_TEXT	SEGMENT
_z$ = 8							; size = 8
?r_exp_q@@YINN@Z PROC					; r_exp_q, COMDAT

; 238  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 239  :     static float64 const q0 = 0.500000000000000000e+0;
; 240  :     static float64 const q1 = 0.555538666969001188e-1;
; 241  :     static float64 const q2 = 0.495862884905441294e-3;
; 242  : 
; 243  :     return ( (q2 * (z) + q1) * (z) + q0 );

  00003	dd 45 08	 fld	 QWORD PTR _z$[ebp]
  00006	dd 05 00 00 00
	00		 fld	 QWORD PTR ?q2@?1??r_exp_q@@YINN@Z@4NB
  0000c	d8 c9		 fmul	 ST(0), ST(1)
  0000e	dc 05 00 00 00
	00		 fadd	 QWORD PTR ?q1@?1??r_exp_q@@YINN@Z@4NB
  00014	de c9		 fmulp	 ST(1), ST(0)
  00016	dc 05 00 00 00
	00		 fadd	 QWORD PTR ?q0@?1??r_exp_q@@YINN@Z@4NB

; 244  : }

  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
?r_exp_q@@YINN@Z ENDP					; r_exp_q
_TEXT	ENDS
PUBLIC	?_exphlp@@YINNPAH@Z				; _exphlp
;	COMDAT ?C2@?1??_exphlp@@YINNPAH@Z@4NB
CONST	SEGMENT
?C2@?1??_exphlp@@YINNPAH@Z@4NB DQ 0bf2bd0105c610ca8r ; -0.000212194 ; `_exphlp'::`2'::C2
CONST	ENDS
;	COMDAT ?C1@?1??_exphlp@@YINNPAH@Z@4NB
CONST	SEGMENT
?C1@?1??_exphlp@@YINNPAH@Z@4NB DQ 03fe6300000000000r ; 0.693359 ; `_exphlp'::`2'::C1
CONST	ENDS
;	COMDAT ?LN2INV@?1??_exphlp@@YINNPAH@Z@4NB
CONST	SEGMENT
?LN2INV@?1??_exphlp@@YINNPAH@Z@4NB DQ 03ff71547652b8ecbr ; 1.4427 ; `_exphlp'::`2'::LN2INV
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?_exphlp@@YINNPAH@Z
_TEXT	SEGMENT
$T11423 = -12						; size = 8
_rg$ = 8						; size = 8
_x$ = 8							; size = 8
?_exphlp@@YINNPAH@Z PROC				; _exphlp, COMDAT
; _pnewexp$ = ecx

; 247  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 248  :     static float64 const  LN2INV =  1.442695040889634074;      // 1/ln(2)
; 249  :     static float64 const  C1     =  0.693359375000000000;
; 250  :     static float64 const  C2     = -2.1219444005469058277e-4;
; 251  :     float64 xn;
; 252  :     float64 g,z,gpz,qz,rg;
; 253  :     int n;
; 254  : 
; 255  :     xn = _frnd(x * LN2INV);

  00006	dd 45 08	 fld	 QWORD PTR _x$[ebp]
  00009	83 ec 08	 sub	 esp, 8
  0000c	dc 0d 00 00 00
	00		 fmul	 QWORD PTR ?LN2INV@?1??_exphlp@@YINNPAH@Z@4NB
  00012	dd 1c 24	 fstp	 QWORD PTR [esp]
  00015	e8 00 00 00 00	 call	 ?_frnd@@YINN@Z		; _frnd

; 256  :     n = _ftoi(xn);
; 257  : 
; 258  :     // assume guard digit is present
; 259  :     g = (x - xn * C1) - xn * C2;

  0001a	dd 05 00 00 00
	00		 fld	 QWORD PTR ?C1@?1??_exphlp@@YINNPAH@Z@4NB
  00020	83 ec 08	 sub	 esp, 8
  00023	d8 c9		 fmul	 ST(0), ST(1)
  00025	dc 6d 08	 fsubr	 QWORD PTR _x$[ebp]
  00028	d9 c1		 fld	 ST(1)
  0002a	dc 0d 00 00 00
	00		 fmul	 QWORD PTR ?C2@?1??_exphlp@@YINNPAH@Z@4NB
  00030	de e9		 fsubp	 ST(1), ST(0)

; 260  :     z = g*g;

  00032	d9 c0		 fld	 ST(0)
  00034	d8 c9		 fmul	 ST(0), ST(1)

; 261  :     gpz = g * r_exp_p(z);

  00036	dd 05 00 00 00
	00		 fld	 QWORD PTR ?p2@?1??r_exp_p@@YINN@Z@4NB
  0003c	d8 c9		 fmul	 ST(0), ST(1)
  0003e	dc 05 00 00 00
	00		 fadd	 QWORD PTR ?p1@?1??r_exp_p@@YINN@Z@4NB
  00044	d8 c9		 fmul	 ST(0), ST(1)
  00046	dc 05 00 00 00
	00		 fadd	 QWORD PTR ?p0@?1??r_exp_p@@YINN@Z@4NB
  0004c	de ca		 fmulp	 ST(2), ST(0)

; 262  :     qz = r_exp_q(z);

  0004e	dd 05 00 00 00
	00		 fld	 QWORD PTR ?q2@?1??r_exp_q@@YINN@Z@4NB
  00054	d8 c9		 fmul	 ST(0), ST(1)
  00056	dc 05 00 00 00
	00		 fadd	 QWORD PTR ?q1@?1??r_exp_q@@YINN@Z@4NB
  0005c	de c9		 fmulp	 ST(1), ST(0)
  0005e	dd 05 00 00 00
	00		 fld	 QWORD PTR ?q0@?1??r_exp_q@@YINN@Z@4NB
  00064	dc c1		 fadd	 ST(1), ST(0)

; 263  :     rg = 0.5 + gpz/(qz-gpz);

  00066	d9 c9		 fxch	 ST(1)
  00068	d8 e2		 fsub	 ST(0), ST(2)
  0006a	de fa		 fdivp	 ST(2), ST(0)
  0006c	de c1		 faddp	 ST(1), ST(0)
  0006e	dd 55 08	 fst	 QWORD PTR _rg$[ebp]

; 264  : 
; 265  :     n++;
; 266  : 
; 267  :     *pnewexp = _get_exp(rg) + n;

  00071	dd 5d f4	 fstp	 QWORD PTR $T11423[ebp]
  00074	dd 1c 24	 fstp	 QWORD PTR [esp]
  00077	e8 00 00 00 00	 call	 ?_ftoi@@YIHN@Z		; _ftoi
  0007c	8b 55 fa	 mov	 edx, DWORD PTR $T11423[ebp+6]

; 268  :     return rg;

  0007f	dd 45 08	 fld	 QWORD PTR _rg$[ebp]
  00082	c1 ea 04	 shr	 edx, 4
  00085	81 e2 ff 07 00
	00		 and	 edx, 2047		; 000007ffH
  0008b	81 ea fe 03 00
	00		 sub	 edx, 1022		; 000003feH
  00091	0f bf d2	 movsx	 edx, dx
  00094	8d 44 10 01	 lea	 eax, DWORD PTR [eax+edx+1]
  00098	89 01		 mov	 DWORD PTR [ecx], eax

; 269  : }

  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 08 00	 ret	 8
?_exphlp@@YINNPAH@Z ENDP				; _exphlp
_TEXT	ENDS
PUBLIC	__real@0000000000000000
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?_decomp@@YINNPAH@Z
_TEXT	SEGMENT
$T11439 = -12						; size = 8
$T11433 = -12						; size = 8
_x$ = 8							; size = 8
_retval$11437 = 8					; size = 8
_retval$11431 = 8					; size = 8
?_decomp@@YINNPAH@Z PROC				; _decomp, COMDAT
; _pexp$ = edi

; 275  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 276  :     int exp;
; 277  :     float64 man;
; 278  : 
; 279  :     if (x == 0.0) {

  00003	d9 ee		 fldz
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00008	d9 c0		 fld	 ST(0)
  0000a	dd 45 08	 fld	 QWORD PTR _x$[ebp]
  0000d	dd e1		 fucom	 ST(1)
  0000f	df e0		 fnstsw	 ax
  00011	dd d9		 fstp	 ST(1)
  00013	f6 c4 44	 test	 ah, 68			; 00000044H
  00016	7a 0c		 jp	 SHORT $LN9@decomp

; 280  :         man = 0.0;
; 281  :         exp = 0;

  00018	33 c0		 xor	 eax, eax
  0001a	dd d8		 fstp	 ST(0)

; 305  :     }
; 306  : 
; 307  :     *pexp = exp;

  0001c	89 07		 mov	 DWORD PTR [edi], eax

; 308  :     return man;
; 309  : }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
$LN9@decomp:

; 282  :     }
; 283  :     else if (IS_D_DENORM(x)) {

  00024	8b 45 0e	 mov	 eax, DWORD PTR _x$[ebp+6]
  00027	a9 f0 7f 00 00	 test	 eax, 32752		; 00007ff0H
  0002c	0f 85 7d 00 00
	00		 jne	 $LN29@decomp
  00032	f7 45 0c ff ff
	0f 00		 test	 DWORD PTR _x$[ebp+4], 1048575 ; 000fffffH
  00039	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0003c	75 04		 jne	 SHORT $LN6@decomp
  0003e	85 c9		 test	 ecx, ecx
  00040	74 6d		 je	 SHORT $LN29@decomp
$LN6@decomp:

; 284  :         int neg;
; 285  : 
; 286  :         exp = 1 - D_BIASM1;
; 287  :         neg = x < 0.0;

  00042	de d9		 fcompp
  00044	56		 push	 esi
  00045	ba 03 fc ff ff	 mov	 edx, -1021		; fffffc03H
  0004a	df e0		 fnstsw	 ax
  0004c	f6 c4 05	 test	 ah, 5
  0004f	7a 07		 jp	 SHORT $LN12@decomp
  00051	be 01 00 00 00	 mov	 esi, 1
  00056	eb 02		 jmp	 SHORT $LN13@decomp
$LN12@decomp:
  00058	33 f6		 xor	 esi, esi
$LN13@decomp:

; 288  :         while((*D_EXP(x) & 0x0010) == 0) {

  0005a	b0 10		 mov	 al, 16			; 00000010H
  0005c	84 45 0e	 test	 BYTE PTR _x$[ebp+6], al
  0005f	75 18		 jne	 SHORT $LN4@decomp
$LL5@decomp:

; 289  :             // shift mantissa to the left until bit 52 is 1
; 290  :             (*D_HI(x)) <<= 1;

  00061	d1 65 0c	 shl	 DWORD PTR _x$[ebp+4], 1

; 291  :             if (*D_LO(x) & 0x80000000)

  00064	85 c9		 test	 ecx, ecx
  00066	79 04		 jns	 SHORT $LN3@decomp

; 292  :                 (*D_HI(x)) |= 0x1;

  00068	83 4d 0c 01	 or	 DWORD PTR _x$[ebp+4], 1
$LN3@decomp:

; 293  :             (*D_LO(x)) <<= 1;

  0006c	03 c9		 add	 ecx, ecx

; 294  :             exp--;

  0006e	83 ea 01	 sub	 edx, 1
  00071	84 45 0e	 test	 BYTE PTR _x$[ebp+6], al
  00074	74 eb		 je	 SHORT $LL5@decomp

; 293  :             (*D_LO(x)) <<= 1;

  00076	89 4d 08	 mov	 DWORD PTR _x$[ebp], ecx
$LN4@decomp:

; 295  :         }
; 296  :         (*D_EXP(x)) &= 0xffef; // clear bit 52

  00079	66 81 65 0e ef
	ff		 and	 WORD PTR _x$[ebp+6], 65519 ; 0000ffefH

; 297  :         if (neg) {

  0007f	85 f6		 test	 esi, esi
  00081	5e		 pop	 esi
  00082	74 06		 je	 SHORT $LN2@decomp

; 298  :             (*D_EXP(x)) |= 0x8000; // set sign bit

  00084	66 81 4d 0e 00
	80		 or	 WORD PTR _x$[ebp+6], 32768 ; 00008000H
$LN2@decomp:

; 299  :         }
; 300  :         man = _set_exp(x,0);

  0008a	dd 45 08	 fld	 QWORD PTR _x$[ebp]

; 305  :     }
; 306  : 
; 307  :     *pexp = exp;

  0008d	89 17		 mov	 DWORD PTR [edi], edx
  0008f	dd 55 f4	 fst	 QWORD PTR $T11433[ebp]
  00092	8b 45 fa	 mov	 eax, DWORD PTR $T11433[ebp+6]
  00095	dd 5d 08	 fstp	 QWORD PTR _retval$11431[ebp]
  00098	25 ef bf 00 00	 and	 eax, 49135		; 0000bfefH
  0009d	0d e0 3f 00 00	 or	 eax, 16352		; 00003fe0H
  000a2	66 89 45 0e	 mov	 WORD PTR _retval$11431[ebp+6], ax
  000a6	dd 45 08	 fld	 QWORD PTR _retval$11431[ebp]

; 308  :     return man;
; 309  : }

  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c2 08 00	 ret	 8
$LN29@decomp:

; 282  :     }
; 283  :     else if (IS_D_DENORM(x)) {

  000af	dd d9		 fstp	 ST(1)

; 301  :     }
; 302  :     else {
; 303  :         man = _set_exp(x,0);
; 304  :         exp = INTEXP(x);

  000b1	c1 e8 04	 shr	 eax, 4
  000b4	dd 55 f4	 fst	 QWORD PTR $T11439[ebp]
  000b7	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  000bc	8b 4d fa	 mov	 ecx, DWORD PTR $T11439[ebp+6]
  000bf	dd 5d 08	 fstp	 QWORD PTR _retval$11437[ebp]
  000c2	81 e1 ef bf 00
	00		 and	 ecx, 49135		; 0000bfefH
  000c8	81 c9 e0 3f 00
	00		 or	 ecx, 16352		; 00003fe0H
  000ce	66 89 4d 0e	 mov	 WORD PTR _retval$11437[ebp+6], cx
  000d2	dd 45 08	 fld	 QWORD PTR _retval$11437[ebp]
  000d5	2d fe 03 00 00	 sub	 eax, 1022		; 000003feH

; 305  :     }
; 306  : 
; 307  :     *pexp = exp;

  000da	89 07		 mov	 DWORD PTR [edi], eax

; 308  :     return man;
; 309  : }

  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c2 08 00	 ret	 8
?_decomp@@YINNPAH@Z ENDP				; _decomp
_TEXT	ENDS
EXTRN	__allshl:PROC
; Function compile flags: /Ogtp
;	COMDAT ?is_odd_integer@@YI_NN@Z
_TEXT	SEGMENT
_y$ = 8							; size = 8
?is_odd_integer@@YI_NN@Z PROC				; is_odd_integer, COMDAT

; 312  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 313  :     int exp = INTEXP(y);

  00003	8b 45 0e	 mov	 eax, DWORD PTR _y$[ebp+6]
  00006	c1 e8 04	 shr	 eax, 4
  00009	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0000e	2d fe 03 00 00	 sub	 eax, 1022		; 000003feH

; 314  :     if (exp < 1 || exp > 63) {

  00013	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00016	83 f9 3e	 cmp	 ecx, 62			; 0000003eH
  00019	77 2f		 ja	 SHORT $LN1@is_odd_int

; 316  :     }
; 317  :     return(((*(uint64*)&y) | 0x10000000000000u) << (10 + exp) == 0x8000000000000000);

  0001b	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp+4]
  0001e	8d 48 0a	 lea	 ecx, DWORD PTR [eax+10]
  00021	8b 45 08	 mov	 eax, DWORD PTR _y$[ebp]
  00024	81 ca 00 00 10
	00		 or	 edx, 1048576		; 00100000H
  0002a	e8 00 00 00 00	 call	 __allshl
  0002f	85 c0		 test	 eax, eax
  00031	75 11		 jne	 SHORT $LN5@is_odd_int
  00033	81 fa 00 00 00
	80		 cmp	 edx, -2147483648	; 80000000H
  00039	75 09		 jne	 SHORT $LN5@is_odd_int
  0003b	b8 01 00 00 00	 mov	 eax, 1

; 318  : }

  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
$LN5@is_odd_int:

; 316  :     }
; 317  :     return(((*(uint64*)&y) | 0x10000000000000u) << (10 + exp) == 0x8000000000000000);

  00044	33 c0		 xor	 eax, eax

; 318  : }

  00046	5d		 pop	 ebp
  00047	c2 08 00	 ret	 8
$LN1@is_odd_int:

; 315  :         return false;

  0004a	32 c0		 xor	 al, al

; 318  : }

  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8
?is_odd_integer@@YI_NN@Z ENDP				; is_odd_integer
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?is_even_integer@@YI_NN@Z
_TEXT	SEGMENT
_y$ = 8							; size = 8
?is_even_integer@@YI_NN@Z PROC				; is_even_integer, COMDAT

; 321  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 322  :     int exp = INTEXP(y);

  00003	8b 45 0e	 mov	 eax, DWORD PTR _y$[ebp+6]
  00006	c1 e8 04	 shr	 eax, 4
  00009	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0000e	2d fe 03 00 00	 sub	 eax, 1022		; 000003feH

; 323  :     if (exp < 1 || exp > 63) {

  00013	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00016	83 f9 3e	 cmp	 ecx, 62			; 0000003eH
  00019	77 27		 ja	 SHORT $LN1@is_even_in

; 325  :     }
; 326  :     return (((*(uint64*)&y) | 0x10000000000000u) << (10 + exp) == 0);

  0001b	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp+4]
  0001e	8d 48 0a	 lea	 ecx, DWORD PTR [eax+10]
  00021	8b 45 08	 mov	 eax, DWORD PTR _y$[ebp]
  00024	81 ca 00 00 10
	00		 or	 edx, 1048576		; 00100000H
  0002a	e8 00 00 00 00	 call	 __allshl
  0002f	0b c2		 or	 eax, edx
  00031	75 09		 jne	 SHORT $LN5@is_even_in
  00033	b8 01 00 00 00	 mov	 eax, 1

; 327  : }

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
$LN5@is_even_in:

; 325  :     }
; 326  :     return (((*(uint64*)&y) | 0x10000000000000u) << (10 + exp) == 0);

  0003c	33 c0		 xor	 eax, eax

; 327  : }

  0003e	5d		 pop	 ebp
  0003f	c2 08 00	 ret	 8
$LN1@is_even_in:

; 324  :         return false;

  00042	32 c0		 xor	 al, al

; 327  : }

  00044	5d		 pop	 ebp
  00045	c2 08 00	 ret	 8
?is_even_integer@@YI_NN@Z ENDP				; is_even_integer
_TEXT	ENDS
PUBLIC	?g_Atan2@Class_System_Math@@SINNN@Z		; Class_System_Math::g_Atan2
; Function compile flags: /Ogtp
;	COMDAT ?g_Atan2@Class_System_Math@@SINNN@Z
_TEXT	SEGMENT
_v$ = 8							; size = 8
_w$ = 16						; size = 8
?g_Atan2@Class_System_Math@@SINNN@Z PROC		; Class_System_Math::g_Atan2, COMDAT

; 332  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 333  :     __asm {
; 334  :         fld v;

  00003	dd 45 08	 fld	 QWORD PTR _v$[ebp]

; 335  :         fld w;

  00006	dd 45 10	 fld	 QWORD PTR _w$[ebp]

; 336  :         fpatan;

  00009	d9 f3		 fpatan

; 337  :     }
; 338  : }

  0000b	5d		 pop	 ebp
  0000c	c2 10 00	 ret	 16			; 00000010H
?g_Atan2@Class_System_Math@@SINNN@Z ENDP		; Class_System_Math::g_Atan2
_TEXT	ENDS
PUBLIC	?g_Abs@Class_System_Math@@SINN@Z		; Class_System_Math::g_Abs
; Function compile flags: /Ogtp
;	COMDAT ?g_Abs@Class_System_Math@@SINN@Z
_TEXT	SEGMENT
_v$ = 8							; size = 8
?g_Abs@Class_System_Math@@SINN@Z PROC			; Class_System_Math::g_Abs, COMDAT

; 341  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 342  :     __asm {
; 343  :         fld v;

  00003	dd 45 08	 fld	 QWORD PTR _v$[ebp]

; 344  :         fabs;

  00006	d9 e1		 fabs

; 345  :     }
; 346  : }

  00008	5d		 pop	 ebp
  00009	c2 08 00	 ret	 8
?g_Abs@Class_System_Math@@SINN@Z ENDP			; Class_System_Math::g_Abs
_TEXT	ENDS
PUBLIC	?g_Sqrt@Class_System_Math@@SINN@Z		; Class_System_Math::g_Sqrt
; Function compile flags: /Ogtp
;	COMDAT ?g_Sqrt@Class_System_Math@@SINN@Z
_TEXT	SEGMENT
_v$ = 8							; size = 8
?g_Sqrt@Class_System_Math@@SINN@Z PROC			; Class_System_Math::g_Sqrt, COMDAT

; 349  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 350  :     __asm {
; 351  :         fld v;

  00003	dd 45 08	 fld	 QWORD PTR _v$[ebp]

; 352  :         fsqrt;

  00006	d9 fa		 fsqrt

; 353  :     }
; 354  : }

  00008	5d		 pop	 ebp
  00009	c2 08 00	 ret	 8
?g_Sqrt@Class_System_Math@@SINN@Z ENDP			; Class_System_Math::g_Sqrt
_TEXT	ENDS
PUBLIC	?g_Log10@Class_System_Math@@SINN@Z		; Class_System_Math::g_Log10
; Function compile flags: /Ogtp
;	COMDAT ?g_Log10@Class_System_Math@@SINN@Z
_TEXT	SEGMENT
_v$ = 8							; size = 8
?g_Log10@Class_System_Math@@SINN@Z PROC			; Class_System_Math::g_Log10, COMDAT

; 357  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 358  :     __asm {
; 359  :         fld v;

  00003	dd 45 08	 fld	 QWORD PTR _v$[ebp]

; 360  :         fldlg2;

  00006	d9 ec		 fldlg2

; 361  :         fxch ST(1);

  00008	d9 c9		 fxch	 ST(1)

; 362  :         fyl2x; // Returns result in ST(0)

  0000a	d9 f1		 fyl2x

; 363  :     }
; 364  : }

  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
?g_Log10@Class_System_Math@@SINN@Z ENDP			; Class_System_Math::g_Log10
_TEXT	ENDS
PUBLIC	?g_Exp@Class_System_Math@@SINN@Z		; Class_System_Math::g_Exp
; Function compile flags: /Ogtp
;	COMDAT ?g_Exp@Class_System_Math@@SINN@Z
_TEXT	SEGMENT
_v$ = 8							; size = 8
?g_Exp@Class_System_Math@@SINN@Z PROC			; Class_System_Math::g_Exp, COMDAT

; 367  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 368  :     __asm {
; 369  :         fldl2e;

  00003	d9 ea		 fldl2e

; 370  :         fmul v;

  00005	dc 4d 08	 fmul	 QWORD PTR _v$[ebp]

; 371  :         fld ST(0);

  00008	d9 c0		 fld	 ST(0)

; 372  :         frndint;

  0000a	d9 fc		 frndint

; 373  :         fxch ST(1);

  0000c	d9 c9		 fxch	 ST(1)

; 374  :         fsub ST(0), ST(1);

  0000e	d8 e1		 fsub	 ST(0), ST(1)

; 375  :         f2xm1;

  00010	d9 f0		 f2xm1

; 376  :         fld1;

  00012	d9 e8		 fld1

; 377  :         faddp ST(1), ST(0);

  00014	de c1		 faddp	 ST(1), ST(0)

; 378  :         fscale;

  00016	d9 fd		 fscale

; 379  :         fstp ST(1); // Returns result in ST(0)

  00018	dd d9		 fstp	 ST(1)

; 380  :     }
; 381  : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
?g_Exp@Class_System_Math@@SINN@Z ENDP			; Class_System_Math::g_Exp
_TEXT	ENDS
PUBLIC	__real@4115791356533419
PUBLIC	__real@40c695c2b6941490
PUBLIC	__real@3fe944e7b86fc81b
;	COMDAT __real@4115791356533419
CONST	SEGMENT
__real@4115791356533419 DQ 04115791356533419r	; 351813
CONST	ENDS
;	COMDAT __real@40c695c2b6941490
CONST	SEGMENT
__real@40c695c2b6941490 DQ 040c695c2b6941490r	; 11563.5
CONST	ENDS
;	COMDAT ?p2@?1??r_sinh_p@@YINN@Z@4NB
CONST	SEGMENT
?p2@?1??r_sinh_p@@YINN@Z@4NB DQ 0c06478416385be4ar ; -163.758 ; `r_sinh_p'::`2'::p2
CONST	ENDS
;	COMDAT __real@3fe944e7b86fc81b
CONST	SEGMENT
__real@3fe944e7b86fc81b DQ 03fe944e7b86fc81br	; 0.789661
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?r_sinh_p@@YINN@Z
_TEXT	SEGMENT
_f$ = 8							; size = 8
?r_sinh_p@@YINN@Z PROC					; r_sinh_p, COMDAT

; 385  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 386  :     static float64 const p0 = -0.35181283430177117881e+6;
; 387  :     static float64 const p1 = -0.11563521196851768270e+5;
; 388  :     static float64 const p2 = -0.16375798202630751372e+3;
; 389  :     static float64 const p3 = -0.78966127417357099479e+0;
; 390  : 
; 391  :     return (((p3 * (f) + p2) * (f) + p1) * (f) + p0);

  00003	dd 45 08	 fld	 QWORD PTR _f$[ebp]
  00006	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3fe944e7b86fc81b
  0000c	d8 c9		 fmul	 ST(0), ST(1)
  0000e	dc 2d 00 00 00
	00		 fsubr	 QWORD PTR ?p2@?1??r_sinh_p@@YINN@Z@4NB
  00014	d8 c9		 fmul	 ST(0), ST(1)
  00016	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@40c695c2b6941490
  0001c	de c9		 fmulp	 ST(1), ST(0)
  0001e	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@4115791356533419

; 392  : }

  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?r_sinh_p@@YINN@Z ENDP					; r_sinh_p
_TEXT	ENDS
PUBLIC	__real@41401ace80be6713
PUBLIC	__real@40715bc381c97ff2
;	COMDAT __real@41401ace80be6713
CONST	SEGMENT
__real@41401ace80be6713 DQ 041401ace80be6713r	; 2.11088e+006
CONST	ENDS
;	COMDAT ?q1@?1??r_sinh_q@@YINN@Z@4NB
CONST	SEGMENT
?q1@?1??r_sinh_q@@YINN@Z@4NB DQ 040e1a85723b65ec7r ; 36162.7 ; `r_sinh_q'::`2'::q1
CONST	ENDS
;	COMDAT __real@40715bc381c97ff2
CONST	SEGMENT
__real@40715bc381c97ff2 DQ 040715bc381c97ff2r	; 277.735
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?r_sinh_q@@YINN@Z
_TEXT	SEGMENT
_f$ = 8							; size = 8
?r_sinh_q@@YINN@Z PROC					; r_sinh_q, COMDAT

; 395  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  :     static float64 const q0 = -0.21108770058106271242e+7;
; 397  :     static float64 const q1 =  0.36162723109421836460e+5;
; 398  :     static float64 const q2 = -0.27773523119650701667e+3;
; 399  :     // q3 = 1 is not used (avoid multiplication by 1)
; 400  : 
; 401  :     return ((((f) + q2) * (f) + q1) * (f) + q0);

  00003	dd 45 08	 fld	 QWORD PTR _f$[ebp]
  00006	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@40715bc381c97ff2
  0000c	d8 e9		 fsubr	 ST(0), ST(1)
  0000e	d8 c9		 fmul	 ST(0), ST(1)
  00010	dc 05 00 00 00
	00		 fadd	 QWORD PTR ?q1@?1??r_sinh_q@@YINN@Z@4NB
  00016	de c9		 fmulp	 ST(1), ST(0)
  00018	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@41401ace80be6713

; 402  : }

  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
?r_sinh_q@@YINN@Z ENDP					; r_sinh_q
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	?g_Sinh@Class_System_Math@@SINN@Z		; Class_System_Math::g_Sinh
;	COMDAT ?EPS@?1??g_Sinh@Class_System_Math@@SINN@Z@4NB
CONST	SEGMENT
?EPS@?1??g_Sinh@Class_System_Math@@SINN@Z@4NB DQ 03ab0000000000000r ; 5.16988e-026 ; `Class_System_Math::g_Sinh'::`2'::EPS
CONST	ENDS
;	COMDAT ?WMAX@?1??g_Sinh@Class_System_Math@@SINN@Z@4NB
CONST	SEGMENT
?WMAX@?1??g_Sinh@Class_System_Math@@SINN@Z@4NB DQ 0409bbc964e14f161r ; 1775.15 ; `Class_System_Math::g_Sinh'::`2'::WMAX
CONST	ENDS
;	COMDAT ?YBAR@?1??g_Sinh@Class_System_Math@@SINN@Z@4NB
CONST	SEGMENT
?YBAR@?1??g_Sinh@Class_System_Math@@SINN@Z@4NB DQ 04085e00000000000r ; 700 ; `Class_System_Math::g_Sinh'::`2'::YBAR
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?g_Sinh@Class_System_Math@@SINN@Z
_TEXT	SEGMENT
_result$ = -12						; size = 8
_v$ = 8							; size = 8
$T11495 = 8						; size = 8
_y$11070 = 8						; size = 8
_newexp$11072 = 12					; size = 4
?g_Sinh@Class_System_Math@@SINN@Z PROC			; Class_System_Math::g_Sinh, COMDAT

; 408  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 409  :     static float64 const EPS  = 5.16987882845642297e-26;    // 2^(-53) / 2
; 410  :     // exp(YBAR) should be close to but less than XMAX
; 411  :     // and 1/exp(YBAR) should not underflow
; 412  :     static float64 const YBAR = 7.00e2;
; 413  : 
; 414  :     // WMAX=ln(OVFX)+0.69 (Cody & Waite),omitted LNV, used OVFX instead of BIGX
; 415  : 
; 416  :     static float64 const WMAX = 1.77514678223345998953e+003;
; 417  : 
; 418  :     float64 result;
; 419  : 
; 420  :     if (IS_D_SPECIAL(v)) {

  00003	8b 45 0e	 mov	 eax, DWORD PTR _v$[ebp+6]
  00006	25 f0 7f 00 00	 and	 eax, 32752		; 00007ff0H
  0000b	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000e	3d f0 7f 00 00	 cmp	 eax, 32752		; 00007ff0H
  00013	75 09		 jne	 SHORT $LN27@g_Sinh

; 421  :         if (IS_D_INF(v) || IS_D_MINF(v)) {
; 422  :         }
; 423  :         else if (IS_D_QNAN(v)) {
; 424  :             // TODO: should throw a soft exception.
; 425  :         }
; 426  :         else if (IS_D_SNAN(v)) {
; 427  :             // TODO: should throw a hard exception.
; 428  :         }
; 429  :         result = v;

  00015	dd 45 08	 fld	 QWORD PTR _v$[ebp]

; 488  :             }
; 489  :         }
; 490  :     }
; 491  : 
; 492  :   exit:
; 493  :     return result;
; 494  : }

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
$LN27@g_Sinh:

; 430  :     }
; 431  :     else if (v == 0.0) {

  0001e	d9 ee		 fldz
  00020	d9 c0		 fld	 ST(0)
  00022	dd 45 08	 fld	 QWORD PTR _v$[ebp]
  00025	dd e1		 fucom	 ST(1)
  00027	df e0		 fnstsw	 ax
  00029	dd d9		 fstp	 ST(1)
  0002b	f6 c4 44	 test	 ah, 68			; 00000044H
  0002e	7a 08		 jp	 SHORT $LN17@g_Sinh
  00030	dd d9		 fstp	 ST(1)

; 488  :             }
; 489  :         }
; 490  :     }
; 491  : 
; 492  :   exit:
; 493  :     return result;
; 494  : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
$LN17@g_Sinh:

; 432  :         // no precision exception
; 433  :         result = v;
; 434  :     }
; 435  :     else {
; 436  :         bool neg = (v < 0.0);

  00038	d8 d1		 fcom	 ST(1)
  0003a	53		 push	 ebx
  0003b	df e0		 fnstsw	 ax
  0003d	f6 c4 05	 test	 ah, 5
  00040	7a 04		 jp	 SHORT $LN30@g_Sinh
  00042	b3 01		 mov	 bl, 1
  00044	eb 02		 jmp	 SHORT $LN31@g_Sinh
$LN30@g_Sinh:
  00046	32 db		 xor	 bl, bl
$LN31@g_Sinh:

; 437  :         float64 y = _abs(v);

  00048	dd 55 08	 fst	 QWORD PTR $T11495[ebp]
  0004b	8b 55 0c	 mov	 edx, DWORD PTR $T11495[ebp+4]
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR $T11495[ebp]

; 438  : 
; 439  :         if (y > 1.0) {

  00051	d9 e8		 fld1
  00053	81 e2 ff ff ff
	7f		 and	 edx, 2147483647		; 7fffffffH
  00059	89 4d 08	 mov	 DWORD PTR _y$11070[ebp], ecx
  0005c	89 55 0c	 mov	 DWORD PTR _y$11070[ebp+4], edx
  0005f	dd 45 08	 fld	 QWORD PTR _y$11070[ebp]
  00062	d8 d1		 fcom	 ST(1)
  00064	df e0		 fnstsw	 ax
  00066	dd d9		 fstp	 ST(1)
  00068	f6 c4 41	 test	 ah, 65			; 00000041H
  0006b	0f 85 9f 00 00
	00		 jne	 $LN15@g_Sinh
  00071	dd da		 fstp	 ST(2)

; 440  :             int newexp;
; 441  :             if (y > YBAR) {

  00073	dd 05 00 00 00
	00		 fld	 QWORD PTR ?YBAR@?1??g_Sinh@Class_System_Math@@SINN@Z@4NB
  00079	d8 da		 fcomp	 ST(2)
  0007b	df e0		 fnstsw	 ax
  0007d	f6 c4 05	 test	 ah, 5
  00080	7a 53		 jp	 SHORT $LN51@g_Sinh

; 442  :                 if (y > WMAX) {

  00082	dd 05 00 00 00
	00		 fld	 QWORD PTR ?WMAX@?1??g_Sinh@Class_System_Math@@SINN@Z@4NB
  00088	d8 da		 fcomp	 ST(2)
  0008a	df e0		 fnstsw	 ax
  0008c	f6 c4 05	 test	 ah, 5
  0008f	7a 0f		 jp	 SHORT $LN54@g_Sinh
  00091	dd d9		 fstp	 ST(1)
  00093	5b		 pop	 ebx

; 443  :                     // result too large, even after scaling
; 444  :                     result = v * _d_pos_inf.dbl;

  00094	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __d_pos_inf

; 488  :             }
; 489  :         }
; 490  :     }
; 491  : 
; 492  :   exit:
; 493  :     return result;
; 494  : }

  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 08 00	 ret	 8
$LN54@g_Sinh:

; 442  :                 if (y > WMAX) {

  000a0	dd d8		 fstp	 ST(0)

; 445  :                     // TODO: should through hard exception.
; 446  :                     goto exit;
; 447  :                 }
; 448  : 
; 449  :                 //
; 450  :                 // result = exp(y)/2
; 451  :                 //
; 452  : 
; 453  :                 result = _exphlp(y, &newexp);

  000a2	83 ec 08	 sub	 esp, 8
  000a5	8d 4d 0c	 lea	 ecx, DWORD PTR _newexp$11072[ebp]
  000a8	dd 1c 24	 fstp	 QWORD PTR [esp]
  000ab	e8 00 00 00 00	 call	 ?_exphlp@@YINNPAH@Z	; _exphlp

; 454  :                 newexp --;      //divide by 2

  000b0	8b 45 0c	 mov	 eax, DWORD PTR _newexp$11072[ebp]
  000b3	83 e8 01	 sub	 eax, 1

; 455  :                 if (newexp > MAXEXP) {

  000b6	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  000bb	7e 0b		 jle	 SHORT $LN11@g_Sinh
  000bd	dd d8		 fstp	 ST(0)
  000bf	5b		 pop	 ebx

; 456  :                     result = 0.0; //result = _set_exp(result, newexp-IEEE_ADJUST);

  000c0	d9 ee		 fldz

; 488  :             }
; 489  :         }
; 490  :     }
; 491  : 
; 492  :   exit:
; 493  :     return result;
; 494  : }

  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c2 08 00	 ret	 8
$LN11@g_Sinh:

; 457  :                     // TODO: should through hard exception.
; 458  :                     goto exit;
; 459  :                 }
; 460  :                 else {
; 461  :                     result = _set_exp(result, newexp);

  000c8	83 ec 08	 sub	 esp, 8
  000cb	dd 1c 24	 fstp	 QWORD PTR [esp]
  000ce	e8 00 00 00 00	 call	 ?_set_exp@@YINNH@Z	; _set_exp

; 462  :                 }
; 463  : 
; 464  :             }
; 465  :             else {

  000d3	eb 2a		 jmp	 SHORT $LN8@g_Sinh
$LN51@g_Sinh:

; 440  :             int newexp;
; 441  :             if (y > YBAR) {

  000d5	dd d8		 fstp	 ST(0)

; 466  :                 float64 z = _exphlp(y, &newexp);

  000d7	83 ec 08	 sub	 esp, 8
  000da	8d 4d 0c	 lea	 ecx, DWORD PTR _newexp$11072[ebp]
  000dd	dd 1c 24	 fstp	 QWORD PTR [esp]
  000e0	e8 00 00 00 00	 call	 ?_exphlp@@YINNPAH@Z	; _exphlp

; 467  :                 z = _set_exp(z, newexp);

  000e5	8b 45 0c	 mov	 eax, DWORD PTR _newexp$11072[ebp]
  000e8	83 ec 08	 sub	 esp, 8
  000eb	dd 1c 24	 fstp	 QWORD PTR [esp]
  000ee	e8 00 00 00 00	 call	 ?_set_exp@@YINNH@Z	; _set_exp

; 468  :                 result = (z - 1.0/z) / 2.0;

  000f3	d9 e8		 fld1
  000f5	d8 f1		 fdiv	 ST(0), ST(1)
  000f7	de e9		 fsubp	 ST(1), ST(0)
  000f9	dc 0d 00 00 00
	00		 fmul	 QWORD PTR ?q0@?1??r_exp_q@@YINN@Z@4NB
$LN8@g_Sinh:

; 469  :             }
; 470  : 
; 471  :             if (neg) {

  000ff	84 db		 test	 bl, bl
  00101	0f 84 87 00 00
	00		 je	 $LN38@g_Sinh

; 472  :                 result = -result;

  00107	d9 e0		 fchs
  00109	5b		 pop	 ebx

; 488  :             }
; 489  :         }
; 490  :     }
; 491  : 
; 492  :   exit:
; 493  :     return result;
; 494  : }

  0010a	8b e5		 mov	 esp, ebp
  0010c	5d		 pop	 ebp
  0010d	c2 08 00	 ret	 8
$LN15@g_Sinh:

; 473  :             }
; 474  :         }
; 475  :         else {
; 476  :             if (y < EPS) {

  00110	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR ?EPS@?1??g_Sinh@Class_System_Math@@SINN@Z@4NB
  00116	df e0		 fnstsw	 ax
  00118	f6 c4 05	 test	 ah, 5
  0011b	7a 24		 jp	 SHORT $LN64@g_Sinh

; 477  :                 result = v;

  0011d	dd 55 f4	 fst	 QWORD PTR _result$[ebp]

; 478  :                 if (IS_D_DENORM(result)) {

  00120	f7 45 fa f0 7f
	00 00		 test	 DWORD PTR _result$[ebp+6], 32752 ; 00007ff0H
  00127	75 63		 jne	 SHORT $LN72@g_Sinh
  00129	f7 45 f8 ff ff
	0f 00		 test	 DWORD PTR _result$[ebp+4], 1048575 ; 000fffffH
  00130	75 06		 jne	 SHORT $LN73@g_Sinh
  00132	83 7d f4 00	 cmp	 DWORD PTR _result$[ebp], 0
  00136	74 54		 je	 SHORT $LN72@g_Sinh
$LN73@g_Sinh:
  00138	dd d8		 fstp	 ST(0)
  0013a	5b		 pop	 ebx

; 488  :             }
; 489  :         }
; 490  :     }
; 491  : 
; 492  :   exit:
; 493  :     return result;
; 494  : }

  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c2 08 00	 ret	 8
$LN64@g_Sinh:

; 473  :             }
; 474  :         }
; 475  :         else {
; 476  :             if (y < EPS) {

  00141	dd d9		 fstp	 ST(1)
  00143	5b		 pop	 ebx

; 479  :                     result = 0.0; // result = _add_exp(result, IEEE_ADJUST);
; 480  :                     // TODO: should through hard exception.
; 481  :                     goto exit;
; 482  :                 }
; 483  :             }
; 484  :             else {
; 485  :                 float64 f = v * v;

  00144	d9 c0		 fld	 ST(0)
  00146	d8 c9		 fmul	 ST(0), ST(1)

; 486  :                 float64 r = f * (r_sinh_p(f) / r_sinh_q(f));

  00148	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3fe944e7b86fc81b
  0014e	d8 c9		 fmul	 ST(0), ST(1)
  00150	dc 2d 00 00 00
	00		 fsubr	 QWORD PTR ?p2@?1??r_sinh_p@@YINN@Z@4NB
  00156	d8 c9		 fmul	 ST(0), ST(1)
  00158	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@40c695c2b6941490
  0015e	d8 c9		 fmul	 ST(0), ST(1)
  00160	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@4115791356533419
  00166	d9 c1		 fld	 ST(1)
  00168	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@40715bc381c97ff2
  0016e	d8 ca		 fmul	 ST(0), ST(2)
  00170	dc 05 00 00 00
	00		 fadd	 QWORD PTR ?q1@?1??r_sinh_q@@YINN@Z@4NB
  00176	d8 ca		 fmul	 ST(0), ST(2)
  00178	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@41401ace80be6713
  0017e	de f9		 fdivp	 ST(1), ST(0)
  00180	de c9		 fmulp	 ST(1), ST(0)

; 487  :                 result = v + v * r;

  00182	d8 c9		 fmul	 ST(0), ST(1)
  00184	de c1		 faddp	 ST(1), ST(0)

; 488  :             }
; 489  :         }
; 490  :     }
; 491  : 
; 492  :   exit:
; 493  :     return result;
; 494  : }

  00186	8b e5		 mov	 esp, ebp
  00188	5d		 pop	 ebp
  00189	c2 08 00	 ret	 8
$LN72@g_Sinh:

; 478  :                 if (IS_D_DENORM(result)) {

  0018c	dd d9		 fstp	 ST(1)
$LN38@g_Sinh:
  0018e	5b		 pop	 ebx
$exit$11075:

; 488  :             }
; 489  :         }
; 490  :     }
; 491  : 
; 492  :   exit:
; 493  :     return result;
; 494  : }

  0018f	8b e5		 mov	 esp, ebp
  00191	5d		 pop	 ebp
  00192	c2 08 00	 ret	 8
?g_Sinh@Class_System_Math@@SINN@Z ENDP			; Class_System_Math::g_Sinh
_TEXT	ENDS
PUBLIC	?g_Cosh@Class_System_Math@@SINN@Z		; Class_System_Math::g_Cosh
; Function compile flags: /Ogtp
;	COMDAT ?g_Cosh@Class_System_Math@@SINN@Z
_TEXT	SEGMENT
$T11558 = -20						; size = 8
_retval$11556 = -8					; size = 8
_v$ = 8							; size = 8
$T11552 = 8						; size = 8
_y$11118 = 8						; size = 8
_newexp$11128 = 12					; size = 4
_newexp$11123 = 12					; size = 4
?g_Cosh@Class_System_Math@@SINN@Z PROC			; Class_System_Math::g_Cosh, COMDAT

; 501  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 502  :     // exp(YBAR) should be close to but less than XMAX
; 503  :     // and 1/exp(YBAR) should not underflow
; 504  :     static float64 const YBAR = 7.00e2;
; 505  : 
; 506  :     // WMAX=ln(OVFX)+0.69 (Cody & Waite),omitted LNV, used OVFX instead of BIGX
; 507  :     static float64 const WMAX = 1.77514678223345998953e+003;
; 508  : 
; 509  :     float64 result;
; 510  : 
; 511  :     if (IS_D_SPECIAL(v)) {

  00003	8b 45 0e	 mov	 eax, DWORD PTR _v$[ebp+6]
  00006	8b c8		 mov	 ecx, eax
  00008	81 e1 f0 7f 00
	00		 and	 ecx, 32752		; 00007ff0H
  0000e	83 ec 14	 sub	 esp, 20			; 00000014H
  00011	81 f9 f0 7f 00
	00		 cmp	 ecx, 32752		; 00007ff0H
  00017	75 39		 jne	 SHORT $LN17@g_Cosh

; 512  :         if (IS_D_INF(v) || IS_D_MINF(v)) {

  00019	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp+4]
  0001c	81 f9 00 00 f0
	7f		 cmp	 ecx, 2146435072		; 7ff00000H
  00022	75 14		 jne	 SHORT $LN14@g_Cosh
  00024	83 7d 08 00	 cmp	 DWORD PTR _v$[ebp], 0
  00028	74 1c		 je	 SHORT $LN15@g_Cosh
$LN16@g_Cosh:

; 514  : 
; 515  :         }
; 516  :         else if (IS_D_QNAN(v)) {

  0002a	25 f8 7f 00 00	 and	 eax, 32760		; 00007ff8H

; 517  :             // TODO: should throw a soft exception.
; 518  :             result = v;

  0002f	dd 45 08	 fld	 QWORD PTR _v$[ebp]

; 558  :         }
; 559  :         // TODO: should throw a hard exception if exactness is required.
; 560  :     }
; 561  : 
; 562  :   exit:
; 563  :     return result;
; 564  : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
$LN14@g_Cosh:

; 512  :         if (IS_D_INF(v) || IS_D_MINF(v)) {

  00038	81 f9 00 00 f0
	ff		 cmp	 ecx, -1048576		; fff00000H
  0003e	75 ea		 jne	 SHORT $LN16@g_Cosh
  00040	83 7d 08 00	 cmp	 DWORD PTR _v$[ebp], 0
  00044	75 e4		 jne	 SHORT $LN16@g_Cosh
$LN15@g_Cosh:

; 513  :             result = _d_pos_inf.dbl;

  00046	dd 05 00 00 00
	00		 fld	 QWORD PTR __d_pos_inf

; 558  :         }
; 559  :         // TODO: should throw a hard exception if exactness is required.
; 560  :     }
; 561  : 
; 562  :   exit:
; 563  :     return result;
; 564  : }

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 08 00	 ret	 8
$LN17@g_Cosh:

; 519  :         }
; 520  :         else {
; 521  :             // TODO: should throw a hard exception.
; 522  :             result = v;
; 523  :         }
; 524  :     }
; 525  :     else if (v == 0.0) {

  00052	d9 ee		 fldz
  00054	dd 45 08	 fld	 QWORD PTR _v$[ebp]
  00057	dd e1		 fucom	 ST(1)
  00059	df e0		 fnstsw	 ax
  0005b	dd d9		 fstp	 ST(1)
  0005d	f6 c4 44	 test	 ah, 68			; 00000044H
  00060	7a 0a		 jp	 SHORT $LN9@g_Cosh
  00062	dd d8		 fstp	 ST(0)

; 526  :         result = 1.0;

  00064	d9 e8		 fld1

; 558  :         }
; 559  :         // TODO: should throw a hard exception if exactness is required.
; 560  :     }
; 561  : 
; 562  :   exit:
; 563  :     return result;
; 564  : }

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 08 00	 ret	 8
$LN9@g_Cosh:

; 527  :     }
; 528  :     else {
; 529  :         float64 y = _abs(v);

  0006c	dd 55 08	 fst	 QWORD PTR $T11552[ebp]
  0006f	8b 45 0c	 mov	 eax, DWORD PTR $T11552[ebp+4]
  00072	8b 55 08	 mov	 edx, DWORD PTR $T11552[ebp]

; 530  :         if (y > YBAR) {

  00075	dd 05 00 00 00
	00		 fld	 QWORD PTR ?YBAR@?1??g_Sinh@Class_System_Math@@SINN@Z@4NB
  0007b	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH
  00080	89 45 0c	 mov	 DWORD PTR _y$11118[ebp+4], eax
  00083	89 55 08	 mov	 DWORD PTR _y$11118[ebp], edx
  00086	dd 45 08	 fld	 QWORD PTR _y$11118[ebp]
  00089	d8 d1		 fcom	 ST(1)
  0008b	df e0		 fnstsw	 ax
  0008d	dd d9		 fstp	 ST(1)
  0008f	f6 c4 41	 test	 ah, 65			; 00000041H
  00092	75 4f		 jne	 SHORT $LN28@g_Cosh

; 531  :             if (y > WMAX) {

  00094	dd 05 00 00 00
	00		 fld	 QWORD PTR ?WMAX@?1??g_Sinh@Class_System_Math@@SINN@Z@4NB
  0009a	d8 d9		 fcomp	 ST(1)
  0009c	df e0		 fnstsw	 ax
  0009e	f6 c4 05	 test	 ah, 5
  000a1	7a 08		 jp	 SHORT $LN31@g_Cosh
  000a3	dd d8		 fstp	 ST(0)

; 558  :         }
; 559  :         // TODO: should throw a hard exception if exactness is required.
; 560  :     }
; 561  : 
; 562  :   exit:
; 563  :     return result;
; 564  : }

  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c2 08 00	 ret	 8
$LN31@g_Cosh:

; 531  :             if (y > WMAX) {

  000ab	dd d9		 fstp	 ST(1)

; 532  :                 // TODO: should throw a hard exception.
; 533  :                 result = v;
; 534  :                 goto exit;
; 535  :             }
; 536  : 
; 537  :             //
; 538  :             // result =     exp(y)/2
; 539  :             //
; 540  : 
; 541  :             int newexp;
; 542  :             result = _exphlp(y, &newexp);

  000ad	83 ec 08	 sub	 esp, 8
  000b0	8d 4d 0c	 lea	 ecx, DWORD PTR _newexp$11123[ebp]
  000b3	dd 1c 24	 fstp	 QWORD PTR [esp]
  000b6	e8 00 00 00 00	 call	 ?_exphlp@@YINNPAH@Z	; _exphlp

; 543  :             newexp --;          //divide by 2

  000bb	8b 45 0c	 mov	 eax, DWORD PTR _newexp$11123[ebp]
  000be	83 e8 01	 sub	 eax, 1

; 544  :             if (newexp > MAXEXP) {

  000c1	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  000c6	7e 0a		 jle	 SHORT $LN4@g_Cosh
  000c8	dd d8		 fstp	 ST(0)

; 545  :                 // TODO: should throw a hard exception.
; 546  :                 result = 0.0; //result = _set_exp(result, newexp-IEEE_ADJUST);

  000ca	d9 ee		 fldz

; 558  :         }
; 559  :         // TODO: should throw a hard exception if exactness is required.
; 560  :     }
; 561  : 
; 562  :   exit:
; 563  :     return result;
; 564  : }

  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c2 08 00	 ret	 8
$LN4@g_Cosh:

; 547  :                 goto exit;
; 548  :             }
; 549  :             else {
; 550  :                 result = _set_exp(result, newexp);

  000d2	83 ec 08	 sub	 esp, 8
  000d5	dd 1c 24	 fstp	 QWORD PTR [esp]
  000d8	e8 00 00 00 00	 call	 ?_set_exp@@YINNH@Z	; _set_exp

; 558  :         }
; 559  :         // TODO: should throw a hard exception if exactness is required.
; 560  :     }
; 561  : 
; 562  :   exit:
; 563  :     return result;
; 564  : }

  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c2 08 00	 ret	 8
$LN28@g_Cosh:

; 530  :         if (y > YBAR) {

  000e3	dd d9		 fstp	 ST(1)

; 551  :             }
; 552  :         }
; 553  :         else {
; 554  :             int newexp;
; 555  :             float64 z = _exphlp(y, &newexp);

  000e5	83 ec 08	 sub	 esp, 8
  000e8	8d 4d 0c	 lea	 ecx, DWORD PTR _newexp$11128[ebp]
  000eb	dd 1c 24	 fstp	 QWORD PTR [esp]
  000ee	e8 00 00 00 00	 call	 ?_exphlp@@YINNPAH@Z	; _exphlp

; 556  :             z = _set_exp(z, newexp);

  000f3	dd 55 ec	 fst	 QWORD PTR $T11558[ebp]
  000f6	8b 4d 0c	 mov	 ecx, DWORD PTR _newexp$11128[ebp]
  000f9	dd 5d f8	 fstp	 QWORD PTR _retval$11556[ebp]
  000fc	8b 55 f2	 mov	 edx, DWORD PTR $T11558[ebp+6]

; 557  :             result = (z + 1.0/z) / 2.0;

  000ff	d9 e8		 fld1
  00101	81 c1 fe 03 00
	00		 add	 ecx, 1022		; 000003feH
  00107	c1 e1 04	 shl	 ecx, 4
  0010a	81 e2 0f 80 00
	00		 and	 edx, 32783		; 0000800fH
  00110	0b ca		 or	 ecx, edx
  00112	66 89 4d fe	 mov	 WORD PTR _retval$11556[ebp+6], cx
  00116	dd 45 f8	 fld	 QWORD PTR _retval$11556[ebp]
$exit$11121:
  00119	dc f9		 fdiv	 ST(1), ST(0)
  0011b	de c1		 faddp	 ST(1), ST(0)
  0011d	dc 0d 00 00 00
	00		 fmul	 QWORD PTR ?q0@?1??r_exp_q@@YINN@Z@4NB

; 558  :         }
; 559  :         // TODO: should throw a hard exception if exactness is required.
; 560  :     }
; 561  : 
; 562  :   exit:
; 563  :     return result;
; 564  : }

  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	c2 08 00	 ret	 8
?g_Cosh@Class_System_Math@@SINN@Z ENDP			; Class_System_Math::g_Cosh
_TEXT	ENDS
PUBLIC	__real@409935a5c9be1e18
PUBLIC	__real@3feedc28cefba77f
;	COMDAT ?q0@?1??r_tanh@@YINN@Z@4NB
CONST	SEGMENT
?q0@?1??r_tanh@@YINN@Z@4NB DQ 040b2e83c574e9693r ; 4840.24 ; `r_tanh'::`2'::q0
CONST	ENDS
;	COMDAT ?q1@?1??r_tanh@@YINN@Z@4NB
CONST	SEGMENT
?q1@?1??r_tanh@@YINN@Z@4NB DQ 040a1738b4d01f0f3r ; 2233.77 ; `r_tanh'::`2'::q1
CONST	ENDS
;	COMDAT ?q2@?1??r_tanh@@YINN@Z@4NB
CONST	SEGMENT
?q2@?1??r_tanh@@YINN@Z@4NB DQ 0405c2fa9e1ebf7far ; 112.745 ; `r_tanh'::`2'::q2
CONST	ENDS
;	COMDAT __real@409935a5c9be1e18
CONST	SEGMENT
__real@409935a5c9be1e18 DQ 0409935a5c9be1e18r	; 1613.41
CONST	ENDS
;	COMDAT ?p1@?1??r_tanh@@YINN@Z@4NB
CONST	SEGMENT
?p1@?1??r_tanh@@YINN@Z@4NB DQ 0c058ce75a1ba5cccr ; -99.2259 ; `r_tanh'::`2'::p1
CONST	ENDS
;	COMDAT __real@3feedc28cefba77f
CONST	SEGMENT
__real@3feedc28cefba77f DQ 03feedc28cefba77fr	; 0.964375
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?r_tanh@@YINN@Z
_TEXT	SEGMENT
_g$ = 8							; size = 8
?r_tanh@@YINN@Z PROC					; r_tanh, COMDAT

; 571  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 572  :     // constants for rational approximation
; 573  :     static float64 const p0 = -0.16134119023996228053e+4;
; 574  :     static float64 const p1 = -0.99225929672236083313e+2;
; 575  :     static float64 const p2 = -0.96437492777225469787e+0;
; 576  :     static float64 const q0 =  0.48402357071988688686e+4;
; 577  :     static float64 const q1 =  0.22337720718962312926e+4;
; 578  :     static float64 const q2 =  0.11274474380534949335e+3;
; 579  :     static float64 const q3 =  0.10000000000000000000e+1;
; 580  : 
; 581  :     return ((((p2 * (g) + p1) * (g) + p0) * (g)) / ((((g) + q2) * (g) + q1) * (g) + q0));

  00003	dd 45 08	 fld	 QWORD PTR _g$[ebp]
  00006	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3feedc28cefba77f
  0000c	d8 c9		 fmul	 ST(0), ST(1)
  0000e	dc 2d 00 00 00
	00		 fsubr	 QWORD PTR ?p1@?1??r_tanh@@YINN@Z@4NB
  00014	d8 c9		 fmul	 ST(0), ST(1)
  00016	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@409935a5c9be1e18
  0001c	d8 c9		 fmul	 ST(0), ST(1)
  0001e	d9 c1		 fld	 ST(1)
  00020	dc 05 00 00 00
	00		 fadd	 QWORD PTR ?q2@?1??r_tanh@@YINN@Z@4NB
  00026	d8 ca		 fmul	 ST(0), ST(2)
  00028	dc 05 00 00 00
	00		 fadd	 QWORD PTR ?q1@?1??r_tanh@@YINN@Z@4NB
  0002e	de ca		 fmulp	 ST(2), ST(0)
  00030	d9 c9		 fxch	 ST(1)
  00032	dc 05 00 00 00
	00		 fadd	 QWORD PTR ?q0@?1??r_tanh@@YINN@Z@4NB
  00038	de f9		 fdivp	 ST(1), ST(0)

; 582  : }

  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
?r_tanh@@YINN@Z ENDP					; r_tanh
_TEXT	ENDS
PUBLIC	__real@bff0000000000000
PUBLIC	?g_Tanh@Class_System_Math@@SINN@Z		; Class_System_Math::g_Tanh
;	COMDAT ?C0@?1??g_Tanh@Class_System_Math@@SINN@Z@4NB
CONST	SEGMENT
?C0@?1??g_Tanh@Class_System_Math@@SINN@Z@4NB DQ 03fe193ea7aad030br ; 0.549306 ; `Class_System_Math::g_Tanh'::`2'::C0
CONST	ENDS
;	COMDAT ?XBIG@?1??g_Tanh@Class_System_Math@@SINN@Z@4NB
CONST	SEGMENT
?XBIG@?1??g_Tanh@Class_System_Math@@SINN@Z@4NB DQ 040330fc1931f09car ; 19.0615 ; `Class_System_Math::g_Tanh'::`2'::XBIG
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?g_Tanh@Class_System_Math@@SINN@Z
_TEXT	SEGMENT
_v$ = 8							; size = 8
?g_Tanh@Class_System_Math@@SINN@Z PROC			; Class_System_Math::g_Tanh, COMDAT

; 585  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 586  :     // constants
; 587  :     static float64 const EPS  = 5.16987882845642297e-26;     // 2^(-53) / 2
; 588  :     static float64 const XBIG = 1.90615474653984960096e+001; // ln(2)(53+2)/2
; 589  :     static float64 const C0   = 0.54930614433405484570;      // ln(3)/2
; 590  : 
; 591  :     if (IS_D_SPECIAL(v)) {

  00003	8b 45 0e	 mov	 eax, DWORD PTR _v$[ebp+6]
  00006	25 f0 7f 00 00	 and	 eax, 32752		; 00007ff0H
  0000b	3d f0 7f 00 00	 cmp	 eax, 32752		; 00007ff0H
  00010	75 39		 jne	 SHORT $LN22@g_Tanh

; 592  :         if (IS_D_INF(v)) {

  00012	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp+4]
  00015	3d 00 00 f0 7f	 cmp	 eax, 2146435072		; 7ff00000H
  0001a	75 10		 jne	 SHORT $LN21@g_Tanh
  0001c	83 7d 08 00	 cmp	 DWORD PTR _v$[ebp], 0
  00020	0f 85 c3 00 00
	00		 jne	 $LN31@g_Tanh

; 593  :             v = 1.0;

  00026	d9 e8		 fld1

; 635  : }

  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
$LN21@g_Tanh:

; 594  :         }
; 595  :         else if (IS_D_MINF(v)) {

  0002c	3d 00 00 f0 ff	 cmp	 eax, -1048576		; fff00000H
  00031	0f 85 b2 00 00
	00		 jne	 $LN31@g_Tanh
  00037	83 7d 08 00	 cmp	 DWORD PTR _v$[ebp], 0
  0003b	0f 85 a8 00 00
	00		 jne	 $LN31@g_Tanh

; 596  :             v = -1.0;

  00041	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@bff0000000000000

; 635  : }

  00047	5d		 pop	 ebp
  00048	c2 08 00	 ret	 8
$LN22@g_Tanh:

; 597  :         }
; 598  :         else if (IS_D_QNAN(v)) {
; 599  :             // TODO: should throw a soft exception.
; 600  :         }
; 601  :         else if (IS_D_SNAN(v)) {
; 602  :             // TODO: should throw a hard exception.
; 603  :         }
; 604  :     }
; 605  :     else if (v == 0.0) {

  0004b	d9 ee		 fldz
  0004d	d9 c0		 fld	 ST(0)
  0004f	dd 45 08	 fld	 QWORD PTR _v$[ebp]
  00052	dd e1		 fucom	 ST(1)
  00054	df e0		 fnstsw	 ax
  00056	dd d9		 fstp	 ST(1)
  00058	f6 c4 44	 test	 ah, 68			; 00000044H
  0005b	0f 8b 82 00 00
	00		 jnp	 $LN33@g_Tanh

; 606  :         // no precision exception
; 607  :     }
; 608  :     else {
; 609  :         bool neg = false;
; 610  :         if (v < 0.0) {

  00061	d8 d1		 fcom	 ST(1)
  00063	32 c9		 xor	 cl, cl
  00065	df e0		 fnstsw	 ax
  00067	dd d9		 fstp	 ST(1)
  00069	f6 c4 05	 test	 ah, 5
  0006c	7a 07		 jp	 SHORT $LN10@g_Tanh

; 611  :             neg = true;
; 612  :             v = -v;

  0006e	d9 e0		 fchs
  00070	b1 01		 mov	 cl, 1
  00072	dd 55 08	 fst	 QWORD PTR _v$[ebp]
$LN10@g_Tanh:

; 613  :         }
; 614  : 
; 615  :         if (v > XBIG) {

  00075	dd 05 00 00 00
	00		 fld	 QWORD PTR ?XBIG@?1??g_Tanh@Class_System_Math@@SINN@Z@4NB
  0007b	d8 d9		 fcomp	 ST(1)
  0007d	df e0		 fnstsw	 ax
  0007f	f6 c4 05	 test	 ah, 5
  00082	7a 06		 jp	 SHORT $LN9@g_Tanh
  00084	dd d8		 fstp	 ST(0)

; 616  :             v = 1;

  00086	d9 e8		 fld1
  00088	eb 4f		 jmp	 SHORT $LN2@g_Tanh
$LN9@g_Tanh:

; 617  :         }
; 618  :         else if (v > C0) {

  0008a	dd 05 00 00 00
	00		 fld	 QWORD PTR ?C0@?1??g_Tanh@Class_System_Math@@SINN@Z@4NB
  00090	d8 d9		 fcomp	 ST(1)
  00092	df e0		 fnstsw	 ax
  00094	f6 c4 05	 test	 ah, 5
  00097	7a 1d		 jp	 SHORT $LN7@g_Tanh

; 619  :             v = 0.5 - 1.0 / (g_Exp(v+v) + 1.0);

  00099	dc c0		 fadd	 ST(0), ST(0)
  0009b	83 ec 08	 sub	 esp, 8
  0009e	dd 1c 24	 fstp	 QWORD PTR [esp]
  000a1	e8 00 00 00 00	 call	 ?g_Exp@Class_System_Math@@SINN@Z ; Class_System_Math::g_Exp
  000a6	d9 e8		 fld1
  000a8	dc c1		 fadd	 ST(1), ST(0)
  000aa	de f1		 fdivrp	 ST(1), ST(0)
  000ac	dc 2d 00 00 00
	00		 fsubr	 QWORD PTR ?q0@?1??r_exp_q@@YINN@Z@4NB

; 620  :             v = v + v;

  000b2	dc c0		 fadd	 ST(0), ST(0)
  000b4	eb 23		 jmp	 SHORT $LN2@g_Tanh
$LN7@g_Tanh:

; 621  :         }
; 622  :         else if (v < EPS) {

  000b6	dd 05 00 00 00
	00		 fld	 QWORD PTR ?EPS@?1??g_Sinh@Class_System_Math@@SINN@Z@4NB
  000bc	d8 d9		 fcomp	 ST(1)
  000be	df e0		 fnstsw	 ax
  000c0	f6 c4 41	 test	 ah, 65			; 00000041H
  000c3	74 14		 je	 SHORT $LN2@g_Tanh

; 623  :             if (IS_D_DENORM(v)) {
; 624  :                 // TODO: should throw a heard exception.
; 625  :             }
; 626  :         }
; 627  :         else {
; 628  :             v = v + v * r_tanh(v * v);

  000c5	dc c8		 fmul	 ST(0), ST(0)
  000c7	83 ec 08	 sub	 esp, 8
  000ca	dd 1c 24	 fstp	 QWORD PTR [esp]
  000cd	e8 00 00 00 00	 call	 ?r_tanh@@YINN@Z		; r_tanh
  000d2	dd 45 08	 fld	 QWORD PTR _v$[ebp]
  000d5	dc c9		 fmul	 ST(1), ST(0)
  000d7	de c1		 faddp	 ST(1), ST(0)
$LN2@g_Tanh:

; 629  :         }
; 630  :         if (neg) {

  000d9	84 c9		 test	 cl, cl
  000db	74 0f		 je	 SHORT $LN1@g_Tanh

; 631  :             v = -v;

  000dd	d9 e0		 fchs

; 635  : }

  000df	5d		 pop	 ebp
  000e0	c2 08 00	 ret	 8
$LN33@g_Tanh:

; 597  :         }
; 598  :         else if (IS_D_QNAN(v)) {
; 599  :             // TODO: should throw a soft exception.
; 600  :         }
; 601  :         else if (IS_D_SNAN(v)) {
; 602  :             // TODO: should throw a hard exception.
; 603  :         }
; 604  :     }
; 605  :     else if (v == 0.0) {

  000e3	dd d9		 fstp	 ST(1)

; 635  : }

  000e5	5d		 pop	 ebp
  000e6	c2 08 00	 ret	 8
$LN31@g_Tanh:

; 632  :         }
; 633  :     }
; 634  :     return v;

  000e9	dd 45 08	 fld	 QWORD PTR _v$[ebp]
$LN1@g_Tanh:

; 635  : }

  000ec	5d		 pop	 ebp
  000ed	c2 08 00	 ret	 8
?g_Tanh@Class_System_Math@@SINN@Z ENDP			; Class_System_Math::g_Tanh
_TEXT	ENDS
PUBLIC	?g_Acos@Class_System_Math@@SINN@Z		; Class_System_Math::g_Acos
; Function compile flags: /Ogtp
;	COMDAT ?g_Acos@Class_System_Math@@SINN@Z
_TEXT	SEGMENT
_v$ = 8							; size = 8
?g_Acos@Class_System_Math@@SINN@Z PROC			; Class_System_Math::g_Acos, COMDAT

; 638  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 639  :     __asm {
; 640  :         fld v;

  00003	dd 45 08	 fld	 QWORD PTR _v$[ebp]

; 641  :         fld1;               // load 1.0

  00006	d9 e8		 fld1

; 642  :         fadd st, st(1);     // 1+x

  00008	d8 c1		 fadd	 ST(0), ST(1)

; 643  :         fld1;               // load 1.0

  0000a	d9 e8		 fld1

; 644  :         fsub st, st(2);     // 1-x

  0000c	d8 e2		 fsub	 ST(0), ST(2)

; 645  :         fmul;               // (1+x)(1-x)

  0000e	de c9		 fmulp	 ST(1), ST(0)

; 646  :         fsqrt;              // sqrt((1+x)(1-x))

  00010	d9 fa		 fsqrt

; 647  :         fxch;

  00012	d9 c9		 fxch	 ST(1)

; 648  :         fpatan;             // fpatan(x,sqrt((1+x)(1-x)))

  00014	d9 f3		 fpatan

; 649  :     }
; 650  : }

  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
?g_Acos@Class_System_Math@@SINN@Z ENDP			; Class_System_Math::g_Acos
_TEXT	ENDS
PUBLIC	?g_Asin@Class_System_Math@@SINN@Z		; Class_System_Math::g_Asin
; Function compile flags: /Ogtp
;	COMDAT ?g_Asin@Class_System_Math@@SINN@Z
_TEXT	SEGMENT
_v$ = 8							; size = 8
?g_Asin@Class_System_Math@@SINN@Z PROC			; Class_System_Math::g_Asin, COMDAT

; 653  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 654  :     __asm {
; 655  :         fld v;

  00003	dd 45 08	 fld	 QWORD PTR _v$[ebp]

; 656  :         fld1;               // load 1.0

  00006	d9 e8		 fld1

; 657  :         fadd st, st(1);     // 1+x

  00008	d8 c1		 fadd	 ST(0), ST(1)

; 658  :         fld1;               // load 1.0

  0000a	d9 e8		 fld1

; 659  :         fsub st, st(2);     // 1-x

  0000c	d8 e2		 fsub	 ST(0), ST(2)

; 660  :         fmul;               // (1+x)(1-x)

  0000e	de c9		 fmulp	 ST(1), ST(0)

; 661  :         fsqrt;              // sqrt((1+x)(1-x))

  00010	d9 fa		 fsqrt

; 662  :         fpatan;             // fpatan(x,sqrt((1+x)(1-x)))

  00012	d9 f3		 fpatan

; 663  :     }
; 664  : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
?g_Asin@Class_System_Math@@SINN@Z ENDP			; Class_System_Math::g_Asin
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_fastpow@@YINNN@Z
_TEXT	SEGMENT
_v$ = 8							; size = 8
_w$ = 16						; size = 8
?_fastpow@@YINNN@Z PROC					; _fastpow, COMDAT

; 667  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 668  :     __asm {
; 669  :         fld w;              // neither v or w can be a boundary cases.

  00003	dd 45 10	 fld	 QWORD PTR _w$[ebp]

; 670  :         fld v;

  00006	dd 45 08	 fld	 QWORD PTR _v$[ebp]

; 671  :         fyl2x;              // compute y*log2(x)

  00009	d9 f1		 fyl2x

; 672  :         fld st(0);          // duplicate stack top

  0000b	d9 c0		 fld	 ST(0)

; 673  :         frndint;            // N = round(y)

  0000d	d9 fc		 frndint

; 674  :         fsubr st(1), st;

  0000f	dc e1		 fsubr	 ST(1), ST(0)

; 675  :         fxch;

  00011	d9 c9		 fxch	 ST(1)

; 676  :         fchs;               // g = y - N where abs(g) < 1

  00013	d9 e0		 fchs

; 677  :         f2xm1;              // 2**g - 1

  00015	d9 f0		 f2xm1

; 678  :         fld1;

  00017	d9 e8		 fld1

; 679  :         fadd;               // 2**g

  00019	de c1		 faddp	 ST(1), ST(0)

; 680  :         fscale;             // (2**g) * (2**N) - gives 2**y

  0001b	d9 fd		 fscale

; 681  :         fstp st(1);         // pop extra stuff from fp stack

  0001d	dd d9		 fstp	 ST(1)

; 682  :     }
; 683  : }

  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
?_fastpow@@YINNN@Z ENDP					; _fastpow
_TEXT	ENDS
PUBLIC	?g_Pow@Class_System_Math@@SINNN@Z		; Class_System_Math::g_Pow
; Function compile flags: /Ogtp
;	COMDAT ?g_Pow@Class_System_Math@@SINNN@Z
_TEXT	SEGMENT
_v$ = 8							; size = 8
_w$ = 16						; size = 8
$T11629 = 16						; size = 8
$T11625 = 16						; size = 8
_absv$11224 = 16					; size = 8
_absv$11213 = 16					; size = 8
?g_Pow@Class_System_Math@@SINNN@Z PROC			; Class_System_Math::g_Pow, COMDAT

; 686  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 687  :     float64 result = 0.0;
; 688  : 
; 689  :     // check for infinity or NAN
; 690  :     if (IS_D_SPECIAL(w) || IS_D_SPECIAL(v)) {

  00003	8b 45 16	 mov	 eax, DWORD PTR _w$[ebp+6]
  00006	d9 ee		 fldz
  00008	25 f0 7f 00 00	 and	 eax, 32752		; 00007ff0H
  0000d	d9 c0		 fld	 ST(0)
  0000f	3d f0 7f 00 00	 cmp	 eax, 32752		; 00007ff0H
  00014	0f 84 e9 00 00
	00		 je	 $LN39@g_Pow
  0001a	8b 4d 0e	 mov	 ecx, DWORD PTR _v$[ebp+6]
  0001d	81 e1 f0 7f 00
	00		 and	 ecx, 32752		; 00007ff0H
  00023	81 f9 f0 7f 00
	00		 cmp	 ecx, 32752		; 00007ff0H
  00029	0f 84 d4 00 00
	00		 je	 $LN39@g_Pow
  0002f	dd d8		 fstp	 ST(0)

; 736  :             }
; 737  :             else {
; 738  :                 result = 1.0;
; 739  :             }
; 740  :         }
; 741  :     }
; 742  :     else if (w == 0.0) {

  00031	d9 c0		 fld	 ST(0)
  00033	dd 45 10	 fld	 QWORD PTR _w$[ebp]
  00036	dd e1		 fucom	 ST(1)
  00038	df e0		 fnstsw	 ax
  0003a	dd d9		 fstp	 ST(1)
  0003c	f6 c4 44	 test	 ah, 68			; 00000044H
  0003f	7a 0a		 jp	 SHORT $LN12@g_Pow
  00041	dd d9		 fstp	 ST(1)
  00043	dd d8		 fstp	 ST(0)

; 743  :         result = 1.0;

  00045	d9 e8		 fld1

; 768  :     }
; 769  : 
; 770  :   exit:
; 771  :     return result;
; 772  : }

  00047	5d		 pop	 ebp
  00048	c2 10 00	 ret	 16			; 00000010H
$LN12@g_Pow:

; 744  :     }
; 745  :     else if (v == 0.0) {

  0004b	d9 c1		 fld	 ST(1)
  0004d	dd 45 08	 fld	 QWORD PTR _v$[ebp]
  00050	dd e1		 fucom	 ST(1)
  00052	df e0		 fnstsw	 ax
  00054	dd d9		 fstp	 ST(1)
  00056	f6 c4 44	 test	 ah, 68			; 00000044H
  00059	7a 2b		 jp	 SHORT $LN10@g_Pow

; 746  :         if (w < 0.0) {

  0005b	d9 c9		 fxch	 ST(1)

; 747  :             // TODO: Should throw a hard exception.
; 748  :             result = is_odd_integer(v) ? _d_neg_inf.dbl : _d_pos_inf.dbl;

  0005d	83 ec 08	 sub	 esp, 8
  00060	d8 da		 fcomp	 ST(2)
  00062	df e0		 fnstsw	 ax
  00064	dd d9		 fstp	 ST(1)
  00066	f6 c4 05	 test	 ah, 5
  00069	dd 1c 24	 fstp	 QWORD PTR [esp]
  0006c	0f 8b ab 01 00
	00		 jnp	 $LN117@g_Pow

; 749  :         }
; 750  :         else {
; 751  :             result = is_odd_integer(v) ? w : 0.0;

  00072	e8 00 00 00 00	 call	 ?is_odd_integer@@YI_NN@Z ; is_odd_integer
  00077	84 c0		 test	 al, al
  00079	0f 84 d5 01 00
	00		 je	 $LN45@g_Pow
  0007f	dd 45 10	 fld	 QWORD PTR _w$[ebp]

; 768  :     }
; 769  : 
; 770  :   exit:
; 771  :     return result;
; 772  : }

  00082	5d		 pop	 ebp
  00083	c2 10 00	 ret	 16			; 00000010H
$LN10@g_Pow:

; 752  :         }
; 753  :     }
; 754  :     else if (v < 0.0) {

  00086	d8 d2		 fcom	 ST(2)
  00088	df e0		 fnstsw	 ax
  0008a	dd da		 fstp	 ST(2)
  0008c	f6 c4 05	 test	 ah, 5
  0008f	7a 5f		 jp	 SHORT $LN6@g_Pow

; 755  :         if (is_odd_integer(w)) {

  00091	83 ec 08	 sub	 esp, 8
  00094	dd d9		 fstp	 ST(1)
  00096	dd 1c 24	 fstp	 QWORD PTR [esp]
  00099	e8 00 00 00 00	 call	 ?is_odd_integer@@YI_NN@Z ; is_odd_integer
  0009e	84 c0		 test	 al, al

; 756  :             result = - _fastpow(-v, w);

  000a0	dd 45 10	 fld	 QWORD PTR _w$[ebp]
  000a3	74 1a		 je	 SHORT $LN5@g_Pow
  000a5	83 ec 10	 sub	 esp, 16			; 00000010H
  000a8	dd 5c 24 08	 fstp	 QWORD PTR [esp+8]
  000ac	dd 45 08	 fld	 QWORD PTR _v$[ebp]
  000af	d9 e0		 fchs
  000b1	dd 1c 24	 fstp	 QWORD PTR [esp]
  000b4	e8 00 00 00 00	 call	 ?_fastpow@@YINNN@Z	; _fastpow
  000b9	d9 e0		 fchs

; 768  :     }
; 769  : 
; 770  :   exit:
; 771  :     return result;
; 772  : }

  000bb	5d		 pop	 ebp
  000bc	c2 10 00	 ret	 16			; 00000010H
$LN5@g_Pow:

; 757  :         }
; 758  :         else if (is_even_integer(w)) {

  000bf	83 ec 08	 sub	 esp, 8
  000c2	dd 1c 24	 fstp	 QWORD PTR [esp]
  000c5	e8 00 00 00 00	 call	 ?is_even_integer@@YI_NN@Z ; is_even_integer
  000ca	84 c0		 test	 al, al
  000cc	74 1b		 je	 SHORT $LN3@g_Pow

; 759  :             result = _fastpow(-v, w);

  000ce	dd 45 10	 fld	 QWORD PTR _w$[ebp]
  000d1	83 ec 10	 sub	 esp, 16			; 00000010H
  000d4	dd 5c 24 08	 fstp	 QWORD PTR [esp+8]
  000d8	dd 45 08	 fld	 QWORD PTR _v$[ebp]
  000db	d9 e0		 fchs
  000dd	dd 1c 24	 fstp	 QWORD PTR [esp]
  000e0	e8 00 00 00 00	 call	 ?_fastpow@@YINNN@Z	; _fastpow

; 768  :     }
; 769  : 
; 770  :   exit:
; 771  :     return result;
; 772  : }

  000e5	5d		 pop	 ebp
  000e6	c2 10 00	 ret	 16			; 00000010H
$LN3@g_Pow:

; 760  :         }
; 761  :         else {
; 762  :             // TODO: Should throw a hard exception.
; 763  :             result = v;

  000e9	dd 45 08	 fld	 QWORD PTR _v$[ebp]

; 768  :     }
; 769  : 
; 770  :   exit:
; 771  :     return result;
; 772  : }

  000ec	5d		 pop	 ebp
  000ed	c2 10 00	 ret	 16			; 00000010H
$LN6@g_Pow:

; 764  :         }
; 765  :     }
; 766  :     else {
; 767  :         result = _fastpow(v, w);

  000f0	83 ec 10	 sub	 esp, 16			; 00000010H
  000f3	dd 5c 24 08	 fstp	 QWORD PTR [esp+8]
  000f7	dd 1c 24	 fstp	 QWORD PTR [esp]
  000fa	e8 00 00 00 00	 call	 ?_fastpow@@YINNN@Z	; _fastpow

; 768  :     }
; 769  : 
; 770  :   exit:
; 771  :     return result;
; 772  : }

  000ff	5d		 pop	 ebp
  00100	c2 10 00	 ret	 16			; 00000010H
$LN39@g_Pow:

; 691  :         if (IS_D_INF(w)) {

  00103	8b 45 14	 mov	 eax, DWORD PTR _w$[ebp+4]
  00106	3d 00 00 f0 7f	 cmp	 eax, 2146435072		; 7ff00000H
  0010b	75 5a		 jne	 SHORT $LN38@g_Pow
  0010d	83 7d 10 00	 cmp	 DWORD PTR _w$[ebp], 0
  00111	0f 85 a2 00 00
	00		 jne	 $LN31@g_Pow
  00117	dd d8		 fstp	 ST(0)

; 692  :             float64 absv = _abs(v);

  00119	dd 45 08	 fld	 QWORD PTR _v$[ebp]
  0011c	dd 5d 10	 fstp	 QWORD PTR $T11625[ebp]
  0011f	8b 45 14	 mov	 eax, DWORD PTR $T11625[ebp+4]

; 693  :             if (absv > 1.0) {

  00122	d9 e8		 fld1
  00124	8b 55 10	 mov	 edx, DWORD PTR $T11625[ebp]
  00127	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH
  0012c	89 45 14	 mov	 DWORD PTR _absv$11213[ebp+4], eax
  0012f	89 55 10	 mov	 DWORD PTR _absv$11213[ebp], edx
  00132	dd 45 10	 fld	 QWORD PTR _absv$11213[ebp]
  00135	d8 d1		 fcom	 ST(1)
  00137	df e0		 fnstsw	 ax
  00139	f6 c4 41	 test	 ah, 65			; 00000041H
  0013c	75 10		 jne	 SHORT $LN37@g_Pow
  0013e	dd d9		 fstp	 ST(1)
  00140	dd d9		 fstp	 ST(1)
  00142	dd d8		 fstp	 ST(0)

; 694  :                 result = _d_pos_inf.dbl;

  00144	dd 05 00 00 00
	00		 fld	 QWORD PTR __d_pos_inf

; 768  :     }
; 769  : 
; 770  :   exit:
; 771  :     return result;
; 772  : }

  0014a	5d		 pop	 ebp
  0014b	c2 10 00	 ret	 16			; 00000010H
$LN37@g_Pow:

; 695  :             }
; 696  :             else if (absv < 1.0) {

  0014e	de d9		 fcompp
  00150	df e0		 fnstsw	 ax
  00152	f6 c4 05	 test	 ah, 5

; 701  :                 // TODO: Should throw a hard exception.
; 702  :                 goto exit;
; 703  :             }

  00155	0f 8b 01 01 00
	00		 jnp	 $exit$11218

; 695  :             }
; 696  :             else if (absv < 1.0) {

  0015b	dd d8		 fstp	 ST(0)
$LN28@g_Pow:

; 697  :                 result = 0.0;
; 698  :             }
; 699  :             else {
; 700  :                 result = _d_ind.dbl;

  0015d	dd 05 00 00 00
	00		 fld	 QWORD PTR __d_ind

; 768  :     }
; 769  : 
; 770  :   exit:
; 771  :     return result;
; 772  : }

  00163	5d		 pop	 ebp
  00164	c2 10 00	 ret	 16			; 00000010H
$LN38@g_Pow:

; 704  :         }
; 705  :         else if (IS_D_MINF(w)) {

  00167	3d 00 00 f0 ff	 cmp	 eax, -1048576		; fff00000H
  0016c	75 4b		 jne	 SHORT $LN31@g_Pow
  0016e	83 7d 10 00	 cmp	 DWORD PTR _w$[ebp], 0
  00172	75 45		 jne	 SHORT $LN31@g_Pow
  00174	dd d8		 fstp	 ST(0)

; 706  :             float64 absv = _abs(v);

  00176	dd 45 08	 fld	 QWORD PTR _v$[ebp]
  00179	dd 5d 10	 fstp	 QWORD PTR $T11629[ebp]
  0017c	8b 55 14	 mov	 edx, DWORD PTR $T11629[ebp+4]

; 707  :             if (absv > 1.0) {

  0017f	d9 e8		 fld1
  00181	8b 4d 10	 mov	 ecx, DWORD PTR $T11629[ebp]
  00184	81 e2 ff ff ff
	7f		 and	 edx, 2147483647		; 7fffffffH
  0018a	89 4d 10	 mov	 DWORD PTR _absv$11224[ebp], ecx
  0018d	89 55 14	 mov	 DWORD PTR _absv$11224[ebp+4], edx
  00190	dd 45 10	 fld	 QWORD PTR _absv$11224[ebp]
  00193	d8 d1		 fcom	 ST(1)
  00195	df e0		 fnstsw	 ax
  00197	f6 c4 41	 test	 ah, 65			; 00000041H
  0019a	75 08		 jne	 SHORT $LN114@g_Pow
  0019c	dd d9		 fstp	 ST(1)
  0019e	dd d8		 fstp	 ST(0)

; 768  :     }
; 769  : 
; 770  :   exit:
; 771  :     return result;
; 772  : }

  001a0	5d		 pop	 ebp
  001a1	c2 10 00	 ret	 16			; 00000010H
$LN114@g_Pow:

; 707  :             if (absv > 1.0) {

  001a4	dd da		 fstp	 ST(2)

; 708  :                 result = 0.0;
; 709  :             }
; 710  :             else if (absv < 1.0) {

  001a6	de d9		 fcompp
  001a8	df e0		 fnstsw	 ax
  001aa	f6 c4 41	 test	 ah, 65			; 00000041H
  001ad	75 ae		 jne	 SHORT $LN28@g_Pow
$LN43@g_Pow:

; 711  :                 result = _d_pos_inf.dbl;

  001af	dd 05 00 00 00
	00		 fld	 QWORD PTR __d_pos_inf

; 768  :     }
; 769  : 
; 770  :   exit:
; 771  :     return result;
; 772  : }

  001b5	5d		 pop	 ebp
  001b6	c2 10 00	 ret	 16			; 00000010H
$LN31@g_Pow:

; 712  :             }
; 713  :             else {
; 714  :                 result = _d_ind.dbl;
; 715  :                 // TODO: Should throw a hard exception.
; 716  :                 goto exit;
; 717  :             }
; 718  :         }
; 719  :         else if (IS_D_INF(v)) {

  001b9	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp+4]
  001bc	3d 00 00 f0 7f	 cmp	 eax, 2146435072		; 7ff00000H
  001c1	75 37		 jne	 SHORT $LN24@g_Pow
  001c3	83 7d 08 00	 cmp	 DWORD PTR _v$[ebp], 0
  001c7	0f 85 8d 00 00
	00		 jne	 $LN101@g_Pow
  001cd	dd d8		 fstp	 ST(0)

; 720  :             if (w > 0.0) {

  001cf	dd 45 10	 fld	 QWORD PTR _w$[ebp]
  001d2	d8 d1		 fcom	 ST(1)
  001d4	df e0		 fnstsw	 ax
  001d6	f6 c4 41	 test	 ah, 65			; 00000041H
  001d9	75 0e		 jne	 SHORT $LN23@g_Pow
  001db	dd d8		 fstp	 ST(0)
  001dd	dd d8		 fstp	 ST(0)

; 721  :                 result = _d_pos_inf.dbl;

  001df	dd 05 00 00 00
	00		 fld	 QWORD PTR __d_pos_inf

; 768  :     }
; 769  : 
; 770  :   exit:
; 771  :     return result;
; 772  : }

  001e5	5d		 pop	 ebp
  001e6	c2 10 00	 ret	 16			; 00000010H
$LN23@g_Pow:

; 722  :             }
; 723  :             else if (w < 0.0) {

  001e9	d8 d9		 fcomp	 ST(1)
  001eb	df e0		 fnstsw	 ax
  001ed	f6 c4 05	 test	 ah, 5

; 724  :                 result = 0.0;
; 725  :             }
; 726  :             else {

  001f0	7b 6a		 jnp	 SHORT $exit$11218
$LN107@g_Pow:

; 722  :             }
; 723  :             else if (w < 0.0) {

  001f2	dd d8		 fstp	 ST(0)

; 727  :                 result = 1.0;

  001f4	d9 e8		 fld1

; 768  :     }
; 769  : 
; 770  :   exit:
; 771  :     return result;
; 772  : }

  001f6	5d		 pop	 ebp
  001f7	c2 10 00	 ret	 16			; 00000010H
$LN24@g_Pow:

; 728  :             }
; 729  :         }
; 730  :         else if (IS_D_MINF(v)) {

  001fa	3d 00 00 f0 ff	 cmp	 eax, -1048576		; fff00000H
  001ff	75 59		 jne	 SHORT $LN101@g_Pow
  00201	83 7d 08 00	 cmp	 DWORD PTR _v$[ebp], 0
  00205	75 53		 jne	 SHORT $LN101@g_Pow
  00207	dd d8		 fstp	 ST(0)

; 731  :             if (w > 0.0) {

  00209	dd 45 10	 fld	 QWORD PTR _w$[ebp]
  0020c	d8 d1		 fcom	 ST(1)
  0020e	df e0		 fnstsw	 ax
  00210	f6 c4 41	 test	 ah, 65			; 00000041H
  00213	75 1b		 jne	 SHORT $LN17@g_Pow
  00215	dd d9		 fstp	 ST(1)

; 732  :                 result = is_odd_integer(w) ? _d_neg_inf.dbl : _d_pos_inf.dbl;

  00217	83 ec 08	 sub	 esp, 8
  0021a	dd 1c 24	 fstp	 QWORD PTR [esp]
$LN117@g_Pow:
  0021d	e8 00 00 00 00	 call	 ?is_odd_integer@@YI_NN@Z ; is_odd_integer
  00222	84 c0		 test	 al, al
  00224	74 89		 je	 SHORT $LN43@g_Pow
  00226	dd 05 00 00 00
	00		 fld	 QWORD PTR __d_neg_inf

; 768  :     }
; 769  : 
; 770  :   exit:
; 771  :     return result;
; 772  : }

  0022c	5d		 pop	 ebp
  0022d	c2 10 00	 ret	 16			; 00000010H
$LN17@g_Pow:

; 733  :             }
; 734  :             else if (w < 0.0) {

  00230	d8 d1		 fcom	 ST(1)
  00232	df e0		 fnstsw	 ax
  00234	dd d9		 fstp	 ST(1)
  00236	f6 c4 05	 test	 ah, 5
  00239	7a b7		 jp	 SHORT $LN107@g_Pow

; 735  :                 result = is_odd_integer(w) ? _d_neg_zer.dbl : 0.0;

  0023b	83 ec 08	 sub	 esp, 8
  0023e	dd 1c 24	 fstp	 QWORD PTR [esp]
  00241	e8 00 00 00 00	 call	 ?is_odd_integer@@YI_NN@Z ; is_odd_integer
  00246	84 c0		 test	 al, al
  00248	74 0a		 je	 SHORT $LN45@g_Pow
  0024a	dd 05 00 00 00
	00		 fld	 QWORD PTR __d_neg_zer

; 768  :     }
; 769  : 
; 770  :   exit:
; 771  :     return result;
; 772  : }

  00250	5d		 pop	 ebp
  00251	c2 10 00	 ret	 16			; 00000010H
$LN45@g_Pow:

; 735  :                 result = is_odd_integer(w) ? _d_neg_zer.dbl : 0.0;

  00254	d9 ee		 fldz

; 768  :     }
; 769  : 
; 770  :   exit:
; 771  :     return result;
; 772  : }

  00256	5d		 pop	 ebp
  00257	c2 10 00	 ret	 16			; 00000010H
$LN101@g_Pow:

; 728  :             }
; 729  :         }
; 730  :         else if (IS_D_MINF(v)) {

  0025a	dd d9		 fstp	 ST(1)
$exit$11218:

; 768  :     }
; 769  : 
; 770  :   exit:
; 771  :     return result;
; 772  : }

  0025c	5d		 pop	 ebp
  0025d	c2 10 00	 ret	 16			; 00000010H
?g_Pow@Class_System_Math@@SINNN@Z ENDP			; Class_System_Math::g_Pow
_TEXT	ENDS
PUBLIC	?g_Mod@Class_System_Math@@SINNN@Z		; Class_System_Math::g_Mod
; Function compile flags: /Ogtp
;	COMDAT ?g_Mod@Class_System_Math@@SINNN@Z
_TEXT	SEGMENT
$T11716 = -60						; size = 8
$T11710 = -48						; size = 8
$T11704 = -36						; size = 8
_retval$11714 = -24					; size = 8
_fx$11301 = -24						; size = 8
_retval$11708 = -16					; size = 8
_retval$11702 = -16					; size = 8
_result$ = -16						; size = 8
_ty$11300 = -8						; size = 8
_x$ = 8							; size = 8
$T11698 = 8						; size = 8
_nx$11303 = 12						; size = 4
_y$ = 16						; size = 8
_ny$11304 = 20						; size = 4
?g_Mod@Class_System_Math@@SINNN@Z PROC			; Class_System_Math::g_Mod, COMDAT

; 775  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 776  :     float64 result = 0.0;
; 777  : 
; 778  :     // check for infinity or NAN
; 779  :     if (IS_D_SPECIAL(y) || IS_D_SPECIAL(x)) {

  00003	8b 45 16	 mov	 eax, DWORD PTR _y$[ebp+6]
  00006	d9 ee		 fldz
  00008	8b c8		 mov	 ecx, eax
  0000a	d9 c0		 fld	 ST(0)
  0000c	81 e1 f0 7f 00
	00		 and	 ecx, 32752		; 00007ff0H
  00012	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00015	81 f9 f0 7f 00
	00		 cmp	 ecx, 32752		; 00007ff0H
  0001b	8b 4d 0e	 mov	 ecx, DWORD PTR _x$[ebp+6]
  0001e	0f 84 60 01 00
	00		 je	 $LN46@g_Mod
  00024	8b d1		 mov	 edx, ecx
  00026	81 e2 f0 7f 00
	00		 and	 edx, 32752		; 00007ff0H
  0002c	81 fa f0 7f 00
	00		 cmp	 edx, 32752		; 00007ff0H
  00032	0f 84 4c 01 00
	00		 je	 $LN46@g_Mod

; 788  :             // TODO: Should throw a hard exception.
; 789  :         }
; 790  :     }
; 791  :     else if (y == 0.0) {

  00038	d9 c1		 fld	 ST(1)
  0003a	dd 45 10	 fld	 QWORD PTR _y$[ebp]
  0003d	dd e1		 fucom	 ST(1)
  0003f	df e0		 fnstsw	 ax
  00041	dd d9		 fstp	 ST(1)
  00043	f6 c4 44	 test	 ah, 68			; 00000044H
  00046	0f 8b 85 01 00
	00		 jnp	 $LN49@g_Mod
  0004c	dd d9		 fstp	 ST(1)

; 792  :         // TODO: Should throw a hard exception.
; 793  :     }
; 794  :     else if (x == 0.0) {

  0004e	d9 c1		 fld	 ST(1)
  00050	dd 45 08	 fld	 QWORD PTR _x$[ebp]
  00053	dd e1		 fucom	 ST(1)
  00055	df e0		 fnstsw	 ax
  00057	dd d9		 fstp	 ST(1)
  00059	f6 c4 44	 test	 ah, 68			; 00000044H
  0005c	7a 0a		 jp	 SHORT $LN11@g_Mod
  0005e	dd da		 fstp	 ST(2)
  00060	dd d8		 fstp	 ST(0)

; 842  :         }
; 843  :     }
; 844  : 
; 845  :     return result;
; 846  : }

  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c2 10 00	 ret	 16			; 00000010H
$LN11@g_Mod:

; 795  :         result = x;
; 796  :     }
; 797  :     else {
; 798  :         const int SCALE = 53;
; 799  :         bool neg = false;
; 800  :         bool denorm = false;
; 801  :         float64 d,ty,fx,fy;
; 802  :         int nx, ny, nexp;
; 803  : 
; 804  :         if (x < 0.0) {

  00068	d8 d2		 fcom	 ST(2)
  0006a	53		 push	 ebx
  0006b	32 db		 xor	 bl, bl
  0006d	df e0		 fnstsw	 ax
  0006f	dd da		 fstp	 ST(2)
  00071	f6 c4 05	 test	 ah, 5

; 805  :             result = -x;

  00074	d9 c9		 fxch	 ST(1)
  00076	7a 04		 jp	 SHORT $LN9@g_Mod
  00078	d9 e0		 fchs

; 806  :             neg = 1;

  0007a	b3 01		 mov	 bl, 1
$LN9@g_Mod:

; 807  :         }
; 808  :         else {
; 809  :             result = x;

  0007c	dd 55 f0	 fst	 QWORD PTR _result$[ebp]

; 810  :         }
; 811  : 
; 812  :         ty = _abs(y);

  0007f	d9 c9		 fxch	 ST(1)
  00081	dd 5d 08	 fstp	 QWORD PTR $T11698[ebp]
  00084	8b 4d 0c	 mov	 ecx, DWORD PTR $T11698[ebp+4]
  00087	8b 45 08	 mov	 eax, DWORD PTR $T11698[ebp]
  0008a	81 e1 ff ff ff
	7f		 and	 ecx, 2147483647		; 7fffffffH
  00090	89 45 f8	 mov	 DWORD PTR _ty$11300[ebp], eax
  00093	89 4d fc	 mov	 DWORD PTR _ty$11300[ebp+4], ecx

; 813  : 
; 814  :         while (result >= ty) {

  00096	dd 45 f8	 fld	 QWORD PTR _ty$11300[ebp]
  00099	d8 d9		 fcomp	 ST(1)
  0009b	df e0		 fnstsw	 ax
  0009d	f6 c4 41	 test	 ah, 65			; 00000041H
  000a0	0f 8a d1 00 00
	00		 jp	 $LN6@g_Mod
  000a6	56		 push	 esi
  000a7	57		 push	 edi
$LN7@g_Mod:

; 815  :             fx = _decomp(result, &nx);

  000a8	83 ec 08	 sub	 esp, 8
  000ab	8d 7d 0c	 lea	 edi, DWORD PTR _nx$11303[ebp]
  000ae	dd 1c 24	 fstp	 QWORD PTR [esp]
  000b1	e8 00 00 00 00	 call	 ?_decomp@@YINNPAH@Z	; _decomp
  000b6	dd 5d e8	 fstp	 QWORD PTR _fx$11301[ebp]

; 816  :             fy = _decomp(ty, &ny);

  000b9	dd 45 f8	 fld	 QWORD PTR _ty$11300[ebp]
  000bc	83 ec 08	 sub	 esp, 8
  000bf	8d 7d 14	 lea	 edi, DWORD PTR _ny$11304[ebp]
  000c2	dd 1c 24	 fstp	 QWORD PTR [esp]
  000c5	e8 00 00 00 00	 call	 ?_decomp@@YINNPAH@Z	; _decomp

; 817  : 
; 818  :             if (nx < MINEXP) {
; 819  :                 // result is a denormalized number
; 820  :                 denorm = true;
; 821  :                 nx += SCALE;
; 822  :                 ny += SCALE;
; 823  :                 result = _set_exp(fx, nx);

  000ca	dd 45 e8	 fld	 QWORD PTR _fx$11301[ebp]
  000cd	8b 4d 0c	 mov	 ecx, DWORD PTR _nx$11303[ebp]
  000d0	81 f9 03 fc ff
	ff		 cmp	 ecx, -1021		; fffffc03H
  000d6	7d 57		 jge	 SHORT $LN40@g_Mod
  000d8	8b 45 14	 mov	 eax, DWORD PTR _ny$11304[ebp]
  000db	dd 55 dc	 fst	 QWORD PTR $T11704[ebp]
  000de	8b 75 e2	 mov	 esi, DWORD PTR $T11704[ebp+6]
  000e1	dd 55 f0	 fst	 QWORD PTR _retval$11702[ebp]
  000e4	83 c1 35	 add	 ecx, 53			; 00000035H
  000e7	8d 91 fe 03 00
	00		 lea	 edx, DWORD PTR [ecx+1022]
  000ed	c1 e2 04	 shl	 edx, 4
  000f0	81 e6 0f 80 00
	00		 and	 esi, 32783		; 0000800fH
  000f6	0b d6		 or	 edx, esi
  000f8	66 89 55 f6	 mov	 WORD PTR _retval$11702[ebp+6], dx
  000fc	dd 45 f0	 fld	 QWORD PTR _retval$11702[ebp]
  000ff	83 c0 35	 add	 eax, 53			; 00000035H

; 824  :                 ty = _set_exp(fy, ny);

  00102	d9 ca		 fxch	 ST(2)
  00104	89 45 14	 mov	 DWORD PTR _ny$11304[ebp], eax
  00107	dd 55 d0	 fst	 QWORD PTR $T11710[ebp]
  0010a	05 fe 03 00 00	 add	 eax, 1022		; 000003feH
  0010f	8b 55 d6	 mov	 edx, DWORD PTR $T11710[ebp+6]
  00112	dd 55 f0	 fst	 QWORD PTR _retval$11708[ebp]
  00115	c1 e0 04	 shl	 eax, 4
  00118	81 e2 0f 80 00
	00		 and	 edx, 32783		; 0000800fH
  0011e	0b c2		 or	 eax, edx
  00120	66 89 45 f6	 mov	 WORD PTR _retval$11708[ebp+6], ax
  00124	dd 45 f0	 fld	 QWORD PTR _retval$11708[ebp]
  00127	89 4d 0c	 mov	 DWORD PTR _nx$11303[ebp], ecx
  0012a	dd 5d f8	 fstp	 QWORD PTR _ty$11300[ebp]
  0012d	eb 05		 jmp	 SHORT $LN5@g_Mod
$LN40@g_Mod:
  0012f	dd 45 f0	 fld	 QWORD PTR _result$[ebp]
  00132	d9 ca		 fxch	 ST(2)
$LN5@g_Mod:

; 825  :             }
; 826  : 
; 827  : 
; 828  :             if (fx >= fy) {

  00134	d8 d1		 fcom	 ST(1)
  00136	df e0		 fnstsw	 ax
  00138	dd d9		 fstp	 ST(1)
  0013a	f6 c4 41	 test	 ah, 65			; 00000041H

; 829  :                 nexp = nx ;
; 830  :             }
; 831  :             else {

  0013d	7b 03		 jnp	 SHORT $LN3@g_Mod

; 832  :                 nexp = nx - 1;

  0013f	83 c1 ff	 add	 ecx, -1
$LN3@g_Mod:

; 833  :             }
; 834  :             d = _set_exp(fy, nexp);

  00142	dd 55 c4	 fst	 QWORD PTR $T11716[ebp]
  00145	81 c1 fe 03 00
	00		 add	 ecx, 1022		; 000003feH
  0014b	8b 45 ca	 mov	 eax, DWORD PTR $T11716[ebp+6]
  0014e	dd 5d e8	 fstp	 QWORD PTR _retval$11714[ebp]
  00151	25 0f 80 00 00	 and	 eax, 32783		; 0000800fH
  00156	c1 e1 04	 shl	 ecx, 4
  00159	0b c8		 or	 ecx, eax
  0015b	66 89 4d ee	 mov	 WORD PTR _retval$11714[ebp+6], cx

; 835  :             result -= d;

  0015f	dc 65 e8	 fsub	 QWORD PTR _retval$11714[ebp]
  00162	dd 55 f0	 fst	 QWORD PTR _result$[ebp]
  00165	dd 45 f8	 fld	 QWORD PTR _ty$11300[ebp]
  00168	d8 d9		 fcomp	 ST(1)
  0016a	df e0		 fnstsw	 ax
  0016c	f6 c4 41	 test	 ah, 65			; 00000041H
  0016f	0f 8b 33 ff ff
	ff		 jnp	 $LN7@g_Mod
  00175	5f		 pop	 edi
  00176	5e		 pop	 esi
$LN6@g_Mod:

; 836  :         }
; 837  :         if (denorm) {
; 838  :             // TODO: should raise only FP_U exception.
; 839  :         }
; 840  :         if (neg) {

  00177	84 db		 test	 bl, bl
  00179	5b		 pop	 ebx
  0017a	74 59		 je	 SHORT $LN16@g_Mod

; 841  :             result = -result;

  0017c	d9 e0		 fchs

; 842  :         }
; 843  :     }
; 844  : 
; 845  :     return result;
; 846  : }

  0017e	8b e5		 mov	 esp, ebp
  00180	5d		 pop	 ebp
  00181	c2 10 00	 ret	 16			; 00000010H
$LN46@g_Mod:

; 780  :         if (IS_D_SNAN(y) || IS_D_SNAN(x)) {

  00184	25 f8 7f 00 00	 and	 eax, 32760		; 00007ff8H
  00189	dd d9		 fstp	 ST(1)
  0018b	66 3d f0 7f	 cmp	 ax, 32752		; 00007ff0H
  0018f	ba ff ff 07 00	 mov	 edx, 524287		; 0007ffffH
  00194	75 0b		 jne	 SHORT $LN41@g_Mod
  00196	85 55 14	 test	 DWORD PTR _y$[ebp+4], edx
  00199	75 3a		 jne	 SHORT $LN16@g_Mod
  0019b	83 7d 10 00	 cmp	 DWORD PTR _y$[ebp], 0
  0019f	75 34		 jne	 SHORT $LN16@g_Mod
$LN41@g_Mod:
  001a1	81 e1 f8 7f 00
	00		 and	 ecx, 32760		; 00007ff8H
  001a7	66 81 f9 f0 7f	 cmp	 cx, 32752		; 00007ff0H
  001ac	75 0b		 jne	 SHORT $LN25@g_Mod
  001ae	85 55 0c	 test	 DWORD PTR _x$[ebp+4], edx
  001b1	75 22		 jne	 SHORT $LN16@g_Mod
  001b3	83 7d 08 00	 cmp	 DWORD PTR _x$[ebp], 0

; 781  :             // TODO: Should throw a hard exception.
; 782  :         }
; 783  :         else if (IS_D_QNAN(y) || IS_D_QNAN(x)) {

  001b7	75 1c		 jne	 SHORT $LN16@g_Mod
$LN25@g_Mod:
  001b9	66 3d f8 7f	 cmp	 ax, 32760		; 00007ff8H
  001bd	74 07		 je	 SHORT $LN88@g_Mod
  001bf	66 81 f9 f8 7f	 cmp	 cx, 32760		; 00007ff8H

; 786  :         }
; 787  :         else if (IS_D_INF(x) || IS_D_MINF(x)) {

  001c4	75 0f		 jne	 SHORT $LN16@g_Mod
$LN88@g_Mod:
  001c6	dd d8		 fstp	 ST(0)

; 784  :             // TODO: Should throw a soft exception.
; 785  :             result = x;

  001c8	dd 45 08	 fld	 QWORD PTR _x$[ebp]

; 842  :         }
; 843  :     }
; 844  : 
; 845  :     return result;
; 846  : }

  001cb	8b e5		 mov	 esp, ebp
  001cd	5d		 pop	 ebp
  001ce	c2 10 00	 ret	 16			; 00000010H
$LN49@g_Mod:

; 784  :             // TODO: Should throw a soft exception.
; 785  :             result = x;

  001d1	dd da		 fstp	 ST(2)
  001d3	dd d9		 fstp	 ST(1)
$LN16@g_Mod:

; 842  :         }
; 843  :     }
; 844  : 
; 845  :     return result;
; 846  : }

  001d5	8b e5		 mov	 esp, ebp
  001d7	5d		 pop	 ebp
  001d8	c2 10 00	 ret	 16			; 00000010H
?g_Mod@Class_System_Math@@SINNN@Z ENDP			; Class_System_Math::g_Mod
_TEXT	ENDS
END
