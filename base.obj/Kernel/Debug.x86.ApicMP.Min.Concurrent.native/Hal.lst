; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	C:\Users\cc\source\repos\Singularity-OS\base\Kernel\Native\Hal.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?CpuRuntimeType@@3PAUClass_System_RuntimeType@@A ; CpuRuntimeType
PUBLIC	?PlatformRuntimeType@@3PAUClass_System_RuntimeType@@A ; PlatformRuntimeType
EXTRN	?_type@Class_Microsoft_Singularity_Hal_Platform@@2UClass_System_RuntimeType@@A:BYTE ; Class_Microsoft_Singularity_Hal_Platform::_type
EXTRN	?_type@Class_Microsoft_Singularity_Hal_Cpu@@2UClass_System_RuntimeType@@A:BYTE ; Class_Microsoft_Singularity_Hal_Cpu::_type
_DATA	SEGMENT
?CpuRuntimeType@@3PAUClass_System_RuntimeType@@A DD FLAT:?_type@Class_Microsoft_Singularity_Hal_Cpu@@2UClass_System_RuntimeType@@A ; CpuRuntimeType
?PlatformRuntimeType@@3PAUClass_System_RuntimeType@@A DD FLAT:?_type@Class_Microsoft_Singularity_Hal_Platform@@2UClass_System_RuntimeType@@A ; PlatformRuntimeType
_DATA	ENDS
EXTRN	__aulldiv:PROC
EXTRN	__aullrem:PROC
; Function compile flags: /Odtp
; File c:\users\cc\source\repos\singularity-os\base\boot\include\strformat.cpp
;	COMDAT ?do_base@@YIPADPAD_KID@Z
_TEXT	SEGMENT
tv73 = -120						; size = 4
_nBase$ = -116						; size = 4
_pszOut$ = -112						; size = 4
_n$11525 = -108						; size = 4
_szTmp$ = -104						; size = 96
_nDigit$ = -4						; size = 4
_nValue$ = 8						; size = 8
_xtra$ = 16						; size = 1
?do_base@@YIPADPAD_KID@Z PROC				; do_base, COMDAT
; _pszOut$ = ecx
; _nBase$ = edx

; 50   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	89 55 8c	 mov	 DWORD PTR _nBase$[ebp], edx
  00009	89 4d 90	 mov	 DWORD PTR _pszOut$[ebp], ecx

; 51   :     char szTmp[96];
; 52   :     int nDigit = sizeof(szTmp)-2;

  0000c	c7 45 fc 5e 00
	00 00		 mov	 DWORD PTR _nDigit$[ebp], 94 ; 0000005eH
  00013	eb 09		 jmp	 SHORT $LN9@do_base
$LN8@do_base:

; 53   :     for (; nDigit >= 0; nDigit--) {

  00015	8b 45 fc	 mov	 eax, DWORD PTR _nDigit$[ebp]
  00018	83 e8 01	 sub	 eax, 1
  0001b	89 45 fc	 mov	 DWORD PTR _nDigit$[ebp], eax
$LN9@do_base:
  0001e	83 7d fc 00	 cmp	 DWORD PTR _nDigit$[ebp], 0
  00022	7c 59		 jl	 SHORT $LN7@do_base

; 54   :         UINT n = (UINT)(nValue % nBase);

  00024	8b 4d 8c	 mov	 ecx, DWORD PTR _nBase$[ebp]
  00027	33 d2		 xor	 edx, edx
  00029	52		 push	 edx
  0002a	51		 push	 ecx
  0002b	8b 45 0c	 mov	 eax, DWORD PTR _nValue$[ebp+4]
  0002e	50		 push	 eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _nValue$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 __aullrem
  00038	89 45 94	 mov	 DWORD PTR _n$11525[ebp], eax

; 55   :         szTmp[nDigit] = ((n < 10) ? '0' : (xtra - 10)) + n;

  0003b	83 7d 94 0a	 cmp	 DWORD PTR _n$11525[ebp], 10 ; 0000000aH
  0003f	73 09		 jae	 SHORT $LN12@do_base
  00041	c7 45 88 30 00
	00 00		 mov	 DWORD PTR tv73[ebp], 48	; 00000030H
  00048	eb 0a		 jmp	 SHORT $LN13@do_base
$LN12@do_base:
  0004a	0f be 55 10	 movsx	 edx, BYTE PTR _xtra$[ebp]
  0004e	83 ea 0a	 sub	 edx, 10			; 0000000aH
  00051	89 55 88	 mov	 DWORD PTR tv73[ebp], edx
$LN13@do_base:
  00054	8b 45 88	 mov	 eax, DWORD PTR tv73[ebp]
  00057	03 45 94	 add	 eax, DWORD PTR _n$11525[ebp]
  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _nDigit$[ebp]
  0005d	88 44 0d 98	 mov	 BYTE PTR _szTmp$[ebp+ecx], al

; 56   :         nValue /= nBase;

  00061	8b 55 8c	 mov	 edx, DWORD PTR _nBase$[ebp]
  00064	33 c0		 xor	 eax, eax
  00066	50		 push	 eax
  00067	52		 push	 edx
  00068	8b 4d 0c	 mov	 ecx, DWORD PTR _nValue$[ebp+4]
  0006b	51		 push	 ecx
  0006c	8b 55 08	 mov	 edx, DWORD PTR _nValue$[ebp]
  0006f	52		 push	 edx
  00070	e8 00 00 00 00	 call	 __aulldiv
  00075	89 45 08	 mov	 DWORD PTR _nValue$[ebp], eax
  00078	89 55 0c	 mov	 DWORD PTR _nValue$[ebp+4], edx

; 57   :     }

  0007b	eb 98		 jmp	 SHORT $LN8@do_base
$LN7@do_base:

; 58   :     for (nDigit = 0; nDigit < sizeof(szTmp) - 2 && szTmp[nDigit] == '0'; nDigit++) {

  0007d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _nDigit$[ebp], 0
  00084	eb 09		 jmp	 SHORT $LN6@do_base
$LN5@do_base:
  00086	8b 45 fc	 mov	 eax, DWORD PTR _nDigit$[ebp]
  00089	83 c0 01	 add	 eax, 1
  0008c	89 45 fc	 mov	 DWORD PTR _nDigit$[ebp], eax
$LN6@do_base:
  0008f	83 7d fc 5e	 cmp	 DWORD PTR _nDigit$[ebp], 94 ; 0000005eH
  00093	73 0f		 jae	 SHORT $LN4@do_base
  00095	8b 4d fc	 mov	 ecx, DWORD PTR _nDigit$[ebp]
  00098	0f be 54 0d 98	 movsx	 edx, BYTE PTR _szTmp$[ebp+ecx]
  0009d	83 fa 30	 cmp	 edx, 48			; 00000030H
  000a0	75 02		 jne	 SHORT $LN4@do_base

; 59   :         // skip leading zeros.
; 60   :     }

  000a2	eb e2		 jmp	 SHORT $LN5@do_base
$LN4@do_base:

; 61   :     for (; nDigit < sizeof(szTmp) - 1; nDigit++) {

  000a4	eb 09		 jmp	 SHORT $LN3@do_base
$LN2@do_base:
  000a6	8b 45 fc	 mov	 eax, DWORD PTR _nDigit$[ebp]
  000a9	83 c0 01	 add	 eax, 1
  000ac	89 45 fc	 mov	 DWORD PTR _nDigit$[ebp], eax
$LN3@do_base:
  000af	83 7d fc 5f	 cmp	 DWORD PTR _nDigit$[ebp], 95 ; 0000005fH
  000b3	73 17		 jae	 SHORT $LN1@do_base

; 62   :         *pszOut++ = szTmp[nDigit];

  000b5	8b 4d 90	 mov	 ecx, DWORD PTR _pszOut$[ebp]
  000b8	8b 55 fc	 mov	 edx, DWORD PTR _nDigit$[ebp]
  000bb	8a 44 15 98	 mov	 al, BYTE PTR _szTmp$[ebp+edx]
  000bf	88 01		 mov	 BYTE PTR [ecx], al
  000c1	8b 4d 90	 mov	 ecx, DWORD PTR _pszOut$[ebp]
  000c4	83 c1 01	 add	 ecx, 1
  000c7	89 4d 90	 mov	 DWORD PTR _pszOut$[ebp], ecx

; 63   :     }

  000ca	eb da		 jmp	 SHORT $LN2@do_base
$LN1@do_base:

; 64   :     *pszOut = '\0';

  000cc	8b 55 90	 mov	 edx, DWORD PTR _pszOut$[ebp]
  000cf	c6 02 00	 mov	 BYTE PTR [edx], 0

; 65   :     return pszOut;

  000d2	8b 45 90	 mov	 eax, DWORD PTR _pszOut$[ebp]

; 66   : }

  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c2 0c 00	 ret	 12			; 0000000cH
?do_base@@YIPADPAD_KID@Z ENDP				; do_base
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_str@@YIPADPAD0@Z
_TEXT	SEGMENT
?do_str@@YIPADPAD0@Z PROC				; do_str, COMDAT
; _pszOut$ = eax
; _pszIn$ = edx

; 72   :     while (*pszIn) {

  00000	8a 0a		 mov	 cl, BYTE PTR [edx]
  00002	84 c9		 test	 cl, cl
  00004	74 0e		 je	 SHORT $LN7@do_str
$LL2@do_str:

; 73   :         *pszOut++ = *pszIn++;

  00006	83 c2 01	 add	 edx, 1
  00009	88 08		 mov	 BYTE PTR [eax], cl
  0000b	8a 0a		 mov	 cl, BYTE PTR [edx]
  0000d	83 c0 01	 add	 eax, 1
  00010	84 c9		 test	 cl, cl
  00012	75 f2		 jne	 SHORT $LL2@do_str
$LN7@do_str:

; 74   :     }
; 75   :     *pszOut = '\0';

  00014	c6 00 00	 mov	 BYTE PTR [eax], 0

; 76   :     return pszOut;
; 77   : }

  00017	c3		 ret	 0
?do_str@@YIPADPAD0@Z ENDP				; do_str
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_wstr@@YIPADPADPAF@Z
_TEXT	SEGMENT
?do_wstr@@YIPADPADPAF@Z PROC				; do_wstr, COMDAT
; _pszOut$ = eax
; _pszIn$ = ecx

; 81   :     while (*pszIn) {

  00000	66 83 39 00	 cmp	 WORD PTR [ecx], 0
  00004	74 10		 je	 SHORT $LN7@do_wstr
$LL2@do_wstr:

; 82   :         *pszOut++ = (char)*pszIn++;

  00006	8a 11		 mov	 dl, BYTE PTR [ecx]
  00008	88 10		 mov	 BYTE PTR [eax], dl
  0000a	83 c1 02	 add	 ecx, 2
  0000d	83 c0 01	 add	 eax, 1
  00010	66 83 39 00	 cmp	 WORD PTR [ecx], 0
  00014	75 f0		 jne	 SHORT $LL2@do_wstr
$LN7@do_wstr:

; 83   :     }
; 84   :     *pszOut = '\0';

  00016	c6 00 00	 mov	 BYTE PTR [eax], 0

; 85   :     return pszOut;
; 86   : }

  00019	c3		 ret	 0
?do_wstr@@YIPADPADPAF@Z ENDP				; do_wstr
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_out@@YIHP6IXPAXD@Z0PAD@Z
_TEXT	SEGMENT
_pfOutput$ = 8						; size = 4
?do_out@@YIHP6IXPAXD@Z0PAD@Z PROC			; do_out, COMDAT
; _pContext$ = ebx
; _pszIn$ = eax

; 89   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f0		 mov	 esi, eax

; 90   :     int nOut = 0;
; 91   : 
; 92   :     while (*pszIn) {

  00006	8a 16		 mov	 dl, BYTE PTR [esi]
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	84 d2		 test	 dl, dl
  0000d	74 13		 je	 SHORT $LN7@do_out
  0000f	90		 npad	 1
$LL2@do_out:

; 93   :         pfOutput(pContext, *pszIn++);

  00010	8b cb		 mov	 ecx, ebx
  00012	ff 55 08	 call	 DWORD PTR _pfOutput$[ebp]
  00015	8a 56 01	 mov	 dl, BYTE PTR [esi+1]
  00018	83 c6 01	 add	 esi, 1

; 94   :         nOut++;

  0001b	83 c7 01	 add	 edi, 1
  0001e	84 d2		 test	 dl, dl
  00020	75 ee		 jne	 SHORT $LL2@do_out
$LN7@do_out:

; 95   :     }
; 96   :     return nOut;

  00022	8b c7		 mov	 eax, edi
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi

; 97   : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?do_out@@YIHP6IXPAXD@Z0PAD@Z ENDP			; do_out
_TEXT	ENDS
PUBLIC	??_C@_06CBHGEMFM@?$DMNULL?$DO?$AA@		; `string'
PUBLIC	??_C@_02HDBOMKFI@0b?$AA@			; `string'
PUBLIC	??_C@_01GBGANLPD@0?$AA@				; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
PUBLIC	??_C@_01MIFGBAGJ@?$CL?$AA@			; `string'
PUBLIC	??_C@_01JOAMLHOP@?9?$AA@			; `string'
PUBLIC	??_C@_02FGLHBECB@0X?$AA@			; `string'
PUBLIC	??_C@_02MDDDDAID@0x?$AA@			; `string'
PUBLIC	?strformat@@YIHP6IXPAXD@Z0PBDPAD@Z		; strformat
;	COMDAT ??_C@_06CBHGEMFM@?$DMNULL?$DO?$AA@
CONST	SEGMENT
??_C@_06CBHGEMFM@?$DMNULL?$DO?$AA@ DB '<NULL>', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02HDBOMKFI@0b?$AA@
CONST	SEGMENT
??_C@_02HDBOMKFI@0b?$AA@ DB '0b', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT
??_C@_01GBGANLPD@0?$AA@ DB '0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01MIFGBAGJ@?$CL?$AA@
CONST	SEGMENT
??_C@_01MIFGBAGJ@?$CL?$AA@ DB '+', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9?$AA@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9?$AA@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02FGLHBECB@0X?$AA@
CONST	SEGMENT
??_C@_02FGLHBECB@0X?$AA@ DB '0X', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MDDDDAID@0x?$AA@
CONST	SEGMENT
??_C@_02MDDDDAID@0x?$AA@ DB '0x', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?strformat@@YIHP6IXPAXD@Z0PBDPAD@Z
_TEXT	SEGMENT
_szTemp$11572 = -184					; size = 128
_fBlank$11581 = -56					; size = 4
_fSmall$11584 = -52					; size = 4
_fPositive$11579 = -48					; size = 4
_pszArg$11587 = -44					; size = 4
_fZero$11582 = -40					; size = 4
_fLeft$11578 = -36					; size = 4
_fLarge$11585 = -32					; size = 4
_nPrecision$11577 = -28					; size = 4
_fPound$11580 = -24					; size = 4
_nWidth$11576 = -20					; size = 4
_pContext$ = -16					; size = 4
_pfOutput$ = -12					; size = 4
_szHead$11573 = -8					; size = 4
_nOut$ = -4						; size = 4
_nLen$11575 = 8						; size = 4
_pszFmt$ = 8						; size = 4
_args$ = 12						; size = 4
?strformat@@YIHP6IXPAXD@Z0PBDPAD@Z PROC			; strformat, COMDAT
; _pfOutput$ = ecx
; _pContext$ = edx

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00009	89 4d f4	 mov	 DWORD PTR _pfOutput$[ebp], ecx

; 102  :     int nOut = 0;
; 103  : 
; 104  :     while (*pszFmt) {

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _pszFmt$[ebp]
  0000f	89 55 f0	 mov	 DWORD PTR _pContext$[ebp], edx
  00012	8a 11		 mov	 dl, BYTE PTR [ecx]
  00014	33 c0		 xor	 eax, eax
  00016	84 d2		 test	 dl, dl
  00018	89 45 fc	 mov	 DWORD PTR _nOut$[ebp], eax
  0001b	0f 84 6b 07 00
	00		 je	 $LN105@strformat
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	8b 7d 08	 mov	 edi, DWORD PTR _nLen$11575[ebp]
  00027	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL224@strformat:
  00030	33 c0		 xor	 eax, eax

; 105  :         if (*pszFmt == '%') {

  00032	80 fa 25	 cmp	 dl, 37			; 00000025H
  00035	0f 85 2d 07 00
	00		 jne	 $LN104@strformat

; 106  :             char szTemp[128];
; 107  :             char szHead[4] = "";
; 108  :             int nLen;
; 109  :             int nWidth = 0;
; 110  :             int nPrecision = 0;
; 111  :             int fLeft = 0;
; 112  :             int fPositive = 0;
; 113  :             int fPound = 0;
; 114  :             int fBlank = 0;
; 115  :             int fZero = 0;
; 116  :             int fDigit = 0;
; 117  :             int fSmall = 0;
; 118  :             int fLarge = 0;
; 119  :             int fString = 0;
; 120  :             const char * pszArg = pszFmt;

  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _pszFmt$[ebp]
  0003e	33 db		 xor	 ebx, ebx
  00040	8b d1		 mov	 edx, ecx
  00042	88 45 f8	 mov	 BYTE PTR _szHead$11573[ebp], al
  00045	66 89 45 f9	 mov	 WORD PTR _szHead$11573[ebp+1], ax
  00049	88 45 fb	 mov	 BYTE PTR _szHead$11573[ebp+3], al
  0004c	89 5d ec	 mov	 DWORD PTR _nWidth$11576[ebp], ebx
  0004f	89 45 e4	 mov	 DWORD PTR _nPrecision$11577[ebp], eax
  00052	89 45 dc	 mov	 DWORD PTR _fLeft$11578[ebp], eax
  00055	89 45 d0	 mov	 DWORD PTR _fPositive$11579[ebp], eax
  00058	89 45 e8	 mov	 DWORD PTR _fPound$11580[ebp], eax
  0005b	89 45 c8	 mov	 DWORD PTR _fBlank$11581[ebp], eax
  0005e	89 45 d8	 mov	 DWORD PTR _fZero$11582[ebp], eax
  00061	89 45 cc	 mov	 DWORD PTR _fSmall$11584[ebp], eax
  00064	89 45 e0	 mov	 DWORD PTR _fLarge$11585[ebp], eax
  00067	89 55 d4	 mov	 DWORD PTR _pszArg$11587[ebp], edx

; 121  : 
; 122  :             pszFmt++;

  0006a	be 01 00 00 00	 mov	 esi, 1
$LN102@strformat:

; 123  : 
; 124  :             for (; (*pszFmt == '-' ||
; 125  :                     *pszFmt == '+' ||
; 126  :                     *pszFmt == '#' ||
; 127  :                     *pszFmt == ' ' ||
; 128  :                     *pszFmt == '0'); pszFmt++) {

  0006f	8a 04 31	 mov	 al, BYTE PTR [ecx+esi]
  00072	03 ce		 add	 ecx, esi
  00074	3c 2d		 cmp	 al, 45			; 0000002dH
  00076	74 10		 je	 SHORT $LN100@strformat
  00078	3c 2b		 cmp	 al, 43			; 0000002bH
  0007a	74 0c		 je	 SHORT $LN100@strformat
  0007c	3c 23		 cmp	 al, 35			; 00000023H
  0007e	74 08		 je	 SHORT $LN100@strformat
  00080	3c 20		 cmp	 al, 32			; 00000020H
  00082	74 04		 je	 SHORT $LN100@strformat
  00084	3c 30		 cmp	 al, 48			; 00000030H
  00086	75 32		 jne	 SHORT $LN101@strformat
$LN100@strformat:

; 129  :                 switch (*pszFmt) {

  00088	0f be c0	 movsx	 eax, al
  0008b	83 c0 e0	 add	 eax, -32		; ffffffe0H
  0008e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00091	77 dc		 ja	 SHORT $LN102@strformat
  00093	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN207@strformat[eax]
  0009a	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN243@strformat[eax*4]
$LN97@strformat:

; 130  :                   case '-': fLeft = 1; break;

  000a1	89 75 dc	 mov	 DWORD PTR _fLeft$11578[ebp], esi
  000a4	eb c9		 jmp	 SHORT $LN102@strformat
$LN96@strformat:

; 131  :                   case '+': fPositive = 1; break;

  000a6	89 75 d0	 mov	 DWORD PTR _fPositive$11579[ebp], esi
  000a9	eb c4		 jmp	 SHORT $LN102@strformat
$LN95@strformat:

; 132  :                   case '#': fPound = 1; break;

  000ab	89 75 e8	 mov	 DWORD PTR _fPound$11580[ebp], esi
  000ae	eb bf		 jmp	 SHORT $LN102@strformat
$LN94@strformat:

; 133  :                   case ' ': fBlank = 1; break;

  000b0	89 75 c8	 mov	 DWORD PTR _fBlank$11581[ebp], esi
  000b3	eb ba		 jmp	 SHORT $LN102@strformat
$LN93@strformat:

; 134  :                   case '0': fZero = 1; break;

  000b5	89 75 d8	 mov	 DWORD PTR _fZero$11582[ebp], esi

; 123  : 
; 124  :             for (; (*pszFmt == '-' ||
; 125  :                     *pszFmt == '+' ||
; 126  :                     *pszFmt == '#' ||
; 127  :                     *pszFmt == ' ' ||
; 128  :                     *pszFmt == '0'); pszFmt++) {

  000b8	eb b5		 jmp	 SHORT $LN102@strformat
$LN101@strformat:

; 135  :                 }
; 136  :             }
; 137  : 
; 138  :             if (*pszFmt == '*') {

  000ba	8a 01		 mov	 al, BYTE PTR [ecx]
  000bc	3c 2a		 cmp	 al, 42			; 0000002aH
  000be	89 4d 08	 mov	 DWORD PTR _pszFmt$[ebp], ecx
  000c1	75 16		 jne	 SHORT $LN163@strformat

; 139  :                 nWidth = va_arg(args, int);

  000c3	8b 75 0c	 mov	 esi, DWORD PTR _args$[ebp]
  000c6	8b 1e		 mov	 ebx, DWORD PTR [esi]
  000c8	83 c6 04	 add	 esi, 4

; 140  :                 pszFmt++;

  000cb	83 c1 01	 add	 ecx, 1
  000ce	89 75 0c	 mov	 DWORD PTR _args$[ebp], esi
  000d1	89 5d ec	 mov	 DWORD PTR _nWidth$11576[ebp], ebx
  000d4	89 4d 08	 mov	 DWORD PTR _pszFmt$[ebp], ecx

; 141  :             }
; 142  :             else {

  000d7	eb 26		 jmp	 SHORT $LN89@strformat
$LN163@strformat:

; 143  :                 while (*pszFmt >= '0' && *pszFmt <= '9') {

  000d9	3c 30		 cmp	 al, 48			; 00000030H
  000db	7c 1f		 jl	 SHORT $LN226@strformat
  000dd	8d 49 00	 npad	 3
$LL90@strformat:
  000e0	3c 39		 cmp	 al, 57			; 00000039H
  000e2	7f 12		 jg	 SHORT $LN235@strformat

; 144  :                     nWidth = nWidth * 10 + (*pszFmt++ - '0');

  000e4	0f be c0	 movsx	 eax, al
  000e7	8d 1c 9b	 lea	 ebx, DWORD PTR [ebx+ebx*4]
  000ea	03 ce		 add	 ecx, esi
  000ec	8d 5c 58 d0	 lea	 ebx, DWORD PTR [eax+ebx*2-48]
  000f0	8a 01		 mov	 al, BYTE PTR [ecx]
  000f2	3c 30		 cmp	 al, 48			; 00000030H
  000f4	7d ea		 jge	 SHORT $LL90@strformat
$LN235@strformat:
  000f6	89 5d ec	 mov	 DWORD PTR _nWidth$11576[ebp], ebx
  000f9	89 4d 08	 mov	 DWORD PTR _pszFmt$[ebp], ecx
$LN226@strformat:

; 143  :                 while (*pszFmt >= '0' && *pszFmt <= '9') {

  000fc	8b 75 0c	 mov	 esi, DWORD PTR _args$[ebp]
$LN89@strformat:

; 145  :                 }
; 146  :             }
; 147  :             if (*pszFmt == '.') {

  000ff	80 39 2e	 cmp	 BYTE PTR [ecx], 46	; 0000002eH
  00102	75 44		 jne	 SHORT $LN84@strformat

; 148  :                 pszFmt++;
; 149  :                 fDigit = 1;
; 150  :                 if (*pszFmt == '*') {

  00104	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00107	83 c1 01	 add	 ecx, 1
  0010a	3c 2a		 cmp	 al, 42			; 0000002aH
  0010c	89 4d 08	 mov	 DWORD PTR _pszFmt$[ebp], ecx
  0010f	75 10		 jne	 SHORT $LN164@strformat

; 151  :                     nPrecision = va_arg(args, int);

  00111	8b 06		 mov	 eax, DWORD PTR [esi]
  00113	83 c6 04	 add	 esi, 4
  00116	89 75 0c	 mov	 DWORD PTR _args$[ebp], esi
  00119	89 45 e4	 mov	 DWORD PTR _nPrecision$11577[ebp], eax

; 152  :                     pszFmt++;

  0011c	83 c1 01	 add	 ecx, 1

; 153  :                 }
; 154  :                 else {

  0011f	eb 24		 jmp	 SHORT $LN236@strformat
$LN164@strformat:

; 155  :                     while (*pszFmt >= '0' && *pszFmt <= '9') {

  00121	3c 30		 cmp	 al, 48			; 00000030H
  00123	7c 23		 jl	 SHORT $LN84@strformat
$LL85@strformat:
  00125	3c 39		 cmp	 al, 57			; 00000039H
  00127	7f 1c		 jg	 SHORT $LN236@strformat

; 156  :                         nPrecision = nPrecision * 10 + (*pszFmt++ - '0');

  00129	8b 5d e4	 mov	 ebx, DWORD PTR _nPrecision$11577[ebp]
  0012c	0f be c0	 movsx	 eax, al
  0012f	8d 1c 9b	 lea	 ebx, DWORD PTR [ebx+ebx*4]
  00132	8d 44 58 d0	 lea	 eax, DWORD PTR [eax+ebx*2-48]
  00136	8b 5d ec	 mov	 ebx, DWORD PTR _nWidth$11576[ebp]
  00139	83 c1 01	 add	 ecx, 1
  0013c	89 45 e4	 mov	 DWORD PTR _nPrecision$11577[ebp], eax
  0013f	8a 01		 mov	 al, BYTE PTR [ecx]
  00141	3c 30		 cmp	 al, 48			; 00000030H
  00143	7d e0		 jge	 SHORT $LL85@strformat
$LN236@strformat:
  00145	89 4d 08	 mov	 DWORD PTR _pszFmt$[ebp], ecx
$LN84@strformat:

; 157  :                     }
; 158  :                 }
; 159  :             }
; 160  : 
; 161  :             if (*pszFmt == 'h') {

  00148	8a 01		 mov	 al, BYTE PTR [ecx]
  0014a	3c 68		 cmp	 al, 104			; 00000068H
  0014c	75 09		 jne	 SHORT $LN83@strformat

; 162  :                 fSmall = 1;

  0014e	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR _fSmall$11584[ebp], 1

; 163  :                 pszFmt++;

  00155	eb 0f		 jmp	 SHORT $LN237@strformat
$LN83@strformat:

; 164  :             }
; 165  :             else if (*pszFmt == 'l' || *pszFmt == 'L') {

  00157	3c 6c		 cmp	 al, 108			; 0000006cH
  00159	74 04		 je	 SHORT $LN80@strformat
  0015b	3c 4c		 cmp	 al, 76			; 0000004cH
  0015d	75 0d		 jne	 SHORT $LN81@strformat
$LN80@strformat:

; 166  :                 fLarge = 1;

  0015f	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _fLarge$11585[ebp], 1
$LN237@strformat:

; 167  :                 pszFmt++;

  00166	83 c1 01	 add	 ecx, 1
  00169	89 4d 08	 mov	 DWORD PTR _pszFmt$[ebp], ecx
$LN81@strformat:

; 168  :             }
; 169  : 
; 170  :             if (*pszFmt == 's' || *pszFmt == 'S' ||
; 171  :                 *pszFmt == 'c' || *pszFmt == 'C') {

  0016c	8a 01		 mov	 al, BYTE PTR [ecx]
  0016e	3c 73		 cmp	 al, 115			; 00000073H
  00170	0f 84 9a 04 00
	00		 je	 $LN222@strformat
  00176	3c 53		 cmp	 al, 83			; 00000053H
  00178	0f 84 92 04 00
	00		 je	 $LN222@strformat
  0017e	3c 63		 cmp	 al, 99			; 00000063H
  00180	0f 84 54 04 00
	00		 je	 $LN220@strformat
  00186	3c 43		 cmp	 al, 67			; 00000043H
  00188	0f 84 4c 04 00
	00		 je	 $LN220@strformat

; 228  :                 }
; 229  :             }
; 230  :             else if (*pszFmt == 'p' || *pszFmt == 'u' ||
; 231  :                      *pszFmt == 'd' || *pszFmt == 'i' || *pszFmt == 'o' ||
; 232  :                      *pszFmt == 'x' || *pszFmt == 'X' || *pszFmt == 'b') {

  0018e	3c 70		 cmp	 al, 112			; 00000070H
  00190	74 52		 je	 SHORT $LN214@strformat
  00192	3c 75		 cmp	 al, 117			; 00000075H
  00194	74 4e		 je	 SHORT $LN214@strformat
  00196	3c 64		 cmp	 al, 100			; 00000064H
  00198	74 4a		 je	 SHORT $LN214@strformat
  0019a	3c 69		 cmp	 al, 105			; 00000069H
  0019c	74 46		 je	 SHORT $LN214@strformat
  0019e	3c 6f		 cmp	 al, 111			; 0000006fH
  001a0	74 42		 je	 SHORT $LN214@strformat
  001a2	3c 78		 cmp	 al, 120			; 00000078H
  001a4	74 3e		 je	 SHORT $LN214@strformat
  001a6	3c 58		 cmp	 al, 88			; 00000058H
  001a8	74 3a		 je	 SHORT $LN214@strformat
  001aa	3c 62		 cmp	 al, 98			; 00000062H
  001ac	74 36		 je	 SHORT $LN214@strformat

; 352  :                 pszFmt++;

  001ae	83 c1 01	 add	 ecx, 1

; 353  :                 while (pszArg < pszFmt) {

  001b1	3b d1		 cmp	 edx, ecx
  001b3	89 4d 08	 mov	 DWORD PTR _pszFmt$[ebp], ecx
  001b6	0f 83 bd 05 00
	00		 jae	 $LN223@strformat
  001bc	8b 5d f0	 mov	 ebx, DWORD PTR _pContext$[ebp]
  001bf	8b f1		 mov	 esi, ecx
  001c1	2b ca		 sub	 ecx, edx
  001c3	01 4d fc	 add	 DWORD PTR _nOut$[ebp], ecx
  001c6	eb 03		 jmp	 SHORT $LN3@strformat
$LL231@strformat:

; 352  :                 pszFmt++;

  001c8	8b 55 d4	 mov	 edx, DWORD PTR _pszArg$11587[ebp]
$LN3@strformat:

; 354  :                     pfOutput(pContext, *pszArg++);

  001cb	8a 12		 mov	 dl, BYTE PTR [edx]
  001cd	8b cb		 mov	 ecx, ebx
  001cf	ff 55 f4	 call	 DWORD PTR _pfOutput$[ebp]
  001d2	8b 45 d4	 mov	 eax, DWORD PTR _pszArg$11587[ebp]
  001d5	83 c0 01	 add	 eax, 1
  001d8	3b c6		 cmp	 eax, esi
  001da	89 45 d4	 mov	 DWORD PTR _pszArg$11587[ebp], eax
  001dd	72 e9		 jb	 SHORT $LL231@strformat

; 123  : 
; 124  :             for (; (*pszFmt == '-' ||
; 125  :                     *pszFmt == '+' ||
; 126  :                     *pszFmt == '#' ||
; 127  :                     *pszFmt == ' ' ||
; 128  :                     *pszFmt == '0'); pszFmt++) {

  001df	e9 95 05 00 00	 jmp	 $LN223@strformat
$LN214@strformat:

; 233  : 
; 234  :                 ULARGEST value;
; 235  :                 if (fLarge) {

  001e4	83 7d e0 00	 cmp	 DWORD PTR _fLarge$11585[ebp], 0

; 236  :                     value = va_arg(args, ULARGEST);

  001e8	8b 4d 0c	 mov	 ecx, DWORD PTR _args$[ebp]
  001eb	74 0a		 je	 SHORT $LN53@strformat
  001ed	8b 31		 mov	 esi, DWORD PTR [ecx]
  001ef	8b 59 04	 mov	 ebx, DWORD PTR [ecx+4]
  001f2	83 c1 08	 add	 ecx, 8

; 237  :                 }
; 238  :                 else {

  001f5	eb 07		 jmp	 SHORT $LN239@strformat
$LN53@strformat:

; 239  :                     value = va_arg(args, unsigned int);

  001f7	8b 31		 mov	 esi, DWORD PTR [ecx]
  001f9	83 c1 04	 add	 ecx, 4
  001fc	33 db		 xor	 ebx, ebx
$LN239@strformat:

; 240  :                 }
; 241  : 
; 242  :                 if (*pszFmt == 'p') {

  001fe	3c 70		 cmp	 al, 112			; 00000070H
  00200	89 4d 0c	 mov	 DWORD PTR _args$[ebp], ecx
  00203	75 73		 jne	 SHORT $LN51@strformat

; 243  :                     if (nWidth == 0) {

  00205	83 7d ec 00	 cmp	 DWORD PTR _nWidth$11576[ebp], 0
  00209	75 19		 jne	 SHORT $LN50@strformat

; 244  :                         nWidth = fLarge ? 2 * sizeof(ULARGEST) : 2 * sizeof(unsigned int);

  0020b	33 d2		 xor	 edx, edx
  0020d	39 55 e0	 cmp	 DWORD PTR _fLarge$11585[ebp], edx

; 245  :                         fZero = 1;

  00210	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _fZero$11582[ebp], 1
  00217	0f 95 c2	 setne	 dl
  0021a	8d 14 d5 08 00
	00 00		 lea	 edx, DWORD PTR [edx*8+8]
  00221	89 55 ec	 mov	 DWORD PTR _nWidth$11576[ebp], edx
$LN50@strformat:

; 246  :                     }
; 247  :                     pszFmt++;

  00224	83 45 08 01	 add	 DWORD PTR _pszFmt$[ebp], 1

; 248  :                     nLen = (int) (do_base(szTemp, value, 16, 'a') - szTemp);

  00228	6a 61		 push	 97			; 00000061H
  0022a	53		 push	 ebx
  0022b	56		 push	 esi
  0022c	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00231	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _szTemp$11572[ebp]
  00237	e8 00 00 00 00	 call	 ?do_base@@YIPADPAD_KID@Z ; do_base
  0023c	8b f8		 mov	 edi, eax
  0023e	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR _szTemp$11572[ebp]
  00244	2b f8		 sub	 edi, eax

; 249  :                     if (fPound && value) {

  00246	83 7d e8 00	 cmp	 DWORD PTR _fPound$11580[ebp], 0
  0024a	0f 84 70 02 00
	00		 je	 $LN225@strformat
  00250	0b f3		 or	 esi, ebx
  00252	0f 84 68 02 00
	00		 je	 $LN225@strformat

; 250  :                         do_str(szHead, "0x");

  00258	8d 45 f8	 lea	 eax, DWORD PTR _szHead$11573[ebp]
  0025b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02MDDDDAID@0x?$AA@
  00260	8b f0		 mov	 esi, eax
  00262	b1 30		 mov	 cl, 48			; 00000030H
  00264	2b d6		 sub	 edx, esi
$LL130@strformat:
  00266	88 08		 mov	 BYTE PTR [eax], cl
  00268	8a 4c 10 01	 mov	 cl, BYTE PTR [eax+edx+1]
  0026c	83 c0 01	 add	 eax, 1
  0026f	84 c9		 test	 cl, cl
  00271	75 f3		 jne	 SHORT $LL130@strformat

; 251  :                     }
; 252  :                 }

  00273	e9 45 02 00 00	 jmp	 $LN240@strformat
$LN51@strformat:

; 253  :                 else if (*pszFmt == 'x' || *pszFmt == 'p') {

  00278	3c 78		 cmp	 al, 120			; 00000078H
  0027a	0f 84 ef 01 00
	00		 je	 $LN46@strformat

; 258  :                     }
; 259  :                 }
; 260  :                 else if (*pszFmt == 'X') {

  00280	3c 58		 cmp	 al, 88			; 00000058H
  00282	75 54		 jne	 SHORT $LN43@strformat

; 261  :                     pszFmt++;

  00284	83 45 08 01	 add	 DWORD PTR _pszFmt$[ebp], 1

; 262  :                     nLen = (int) (do_base(szTemp, value, 16, 'A') - szTemp);

  00288	6a 41		 push	 65			; 00000041H
  0028a	53		 push	 ebx
  0028b	56		 push	 esi
  0028c	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00291	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _szTemp$11572[ebp]
  00297	e8 00 00 00 00	 call	 ?do_base@@YIPADPAD_KID@Z ; do_base
  0029c	8b f8		 mov	 edi, eax
  0029e	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _szTemp$11572[ebp]
  002a4	2b f9		 sub	 edi, ecx

; 263  :                     if (fPound && value) {

  002a6	83 7d e8 00	 cmp	 DWORD PTR _fPound$11580[ebp], 0
  002aa	0f 84 10 02 00
	00		 je	 $LN225@strformat
  002b0	0b f3		 or	 esi, ebx
  002b2	0f 84 08 02 00
	00		 je	 $LN225@strformat

; 264  :                         do_str(szHead, "0X");

  002b8	8d 45 f8	 lea	 eax, DWORD PTR _szHead$11573[ebp]
  002bb	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02FGLHBECB@0X?$AA@
  002c0	8b f0		 mov	 esi, eax
  002c2	b1 30		 mov	 cl, 48			; 00000030H
  002c4	2b d6		 sub	 edx, esi
$LL138@strformat:
  002c6	88 08		 mov	 BYTE PTR [eax], cl
  002c8	8a 4c 10 01	 mov	 cl, BYTE PTR [eax+edx+1]
  002cc	83 c0 01	 add	 eax, 1
  002cf	84 c9		 test	 cl, cl
  002d1	75 f3		 jne	 SHORT $LL138@strformat

; 265  :                     }
; 266  :                 }

  002d3	e9 e5 01 00 00	 jmp	 $LN240@strformat
$LN43@strformat:

; 267  :                 else if (*pszFmt == 'd') {

  002d8	3c 64		 cmp	 al, 100			; 00000064H
  002da	0f 85 b3 00 00
	00		 jne	 $LN40@strformat

; 268  :                     pszFmt++;

  002e0	83 45 08 01	 add	 DWORD PTR _pszFmt$[ebp], 1

; 269  :                     if ((LARGEST)value < 0) {

  002e4	85 db		 test	 ebx, ebx
  002e6	7f 2a		 jg	 SHORT $LN39@strformat
  002e8	7c 04		 jl	 SHORT $LN208@strformat
  002ea	85 f6		 test	 esi, esi
  002ec	73 24		 jae	 SHORT $LN39@strformat
$LN208@strformat:

; 270  :                         value = -(LARGEST)value;

  002ee	f7 de		 neg	 esi
  002f0	83 d3 00	 adc	 ebx, 0

; 271  :                         do_str(szHead, "-");

  002f3	8d 45 f8	 lea	 eax, DWORD PTR _szHead$11573[ebp]
  002f6	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01JOAMLHOP@?9?$AA@
  002fb	8b f8		 mov	 edi, eax
  002fd	f7 db		 neg	 ebx
  002ff	b1 2d		 mov	 cl, 45			; 0000002dH
  00301	2b d7		 sub	 edx, edi
$LL142@strformat:
  00303	88 08		 mov	 BYTE PTR [eax], cl
  00305	8a 4c 02 01	 mov	 cl, BYTE PTR [edx+eax+1]
  00309	83 c0 01	 add	 eax, 1
  0030c	84 c9		 test	 cl, cl
  0030e	75 f3		 jne	 SHORT $LL142@strformat
  00310	eb 5b		 jmp	 SHORT $LN241@strformat
$LN39@strformat:

; 272  :                     }
; 273  :                     else if (fPositive) {

  00312	83 7d d0 00	 cmp	 DWORD PTR _fPositive$11579[ebp], 0
  00316	74 27		 je	 SHORT $LN37@strformat

; 274  :                         if (value > 0) {

  00318	85 db		 test	 ebx, ebx
  0031a	77 04		 ja	 SHORT $LN209@strformat
  0031c	85 f6		 test	 esi, esi
  0031e	76 50		 jbe	 SHORT $LN151@strformat
$LN209@strformat:

; 275  :                             do_str(szHead, "+");

  00320	8d 45 f8	 lea	 eax, DWORD PTR _szHead$11573[ebp]
  00323	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01MIFGBAGJ@?$CL?$AA@
  00328	8b f8		 mov	 edi, eax
  0032a	b1 2b		 mov	 cl, 43			; 0000002bH
  0032c	2b d7		 sub	 edx, edi
  0032e	8b ff		 npad	 2
$LL146@strformat:
  00330	88 08		 mov	 BYTE PTR [eax], cl
  00332	8a 4c 02 01	 mov	 cl, BYTE PTR [edx+eax+1]
  00336	83 c0 01	 add	 eax, 1
  00339	84 c9		 test	 cl, cl
  0033b	75 f3		 jne	 SHORT $LL146@strformat

; 276  :                         }
; 277  :                     }

  0033d	eb 2e		 jmp	 SHORT $LN241@strformat
$LN37@strformat:

; 278  :                     else if (fBlank) {

  0033f	83 7d c8 00	 cmp	 DWORD PTR _fBlank$11581[ebp], 0
  00343	74 2b		 je	 SHORT $LN151@strformat

; 279  :                         if (value > 0) {

  00345	85 db		 test	 ebx, ebx
  00347	77 04		 ja	 SHORT $LN210@strformat
  00349	85 f6		 test	 esi, esi
  0034b	76 23		 jbe	 SHORT $LN151@strformat
$LN210@strformat:

; 280  :                             do_str(szHead, " ");

  0034d	8d 45 f8	 lea	 eax, DWORD PTR _szHead$11573[ebp]
  00350	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01CLKCMJKC@?5?$AA@
  00355	8b f8		 mov	 edi, eax
  00357	b1 20		 mov	 cl, 32			; 00000020H
  00359	2b d7		 sub	 edx, edi
  0035b	eb 03 8d 49 00	 npad	 5
$LL150@strformat:
  00360	88 08		 mov	 BYTE PTR [eax], cl
  00362	8a 4c 02 01	 mov	 cl, BYTE PTR [edx+eax+1]
  00366	83 c0 01	 add	 eax, 1
  00369	84 c9		 test	 cl, cl
  0036b	75 f3		 jne	 SHORT $LL150@strformat
$LN241@strformat:
  0036d	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN151@strformat:

; 281  :                         }
; 282  :                     }
; 283  :                     nLen = (int) (do_base(szTemp, value, 10, 'a') - szTemp);

  00370	6a 61		 push	 97			; 00000061H
  00372	53		 push	 ebx
  00373	56		 push	 esi
  00374	ba 0a 00 00 00	 mov	 edx, 10			; 0000000aH
  00379	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _szTemp$11572[ebp]
  0037f	e8 00 00 00 00	 call	 ?do_base@@YIPADPAD_KID@Z ; do_base
  00384	8b f8		 mov	 edi, eax
  00386	8d 95 48 ff ff
	ff		 lea	 edx, DWORD PTR _szTemp$11572[ebp]
  0038c	2b fa		 sub	 edi, edx

; 284  :                     nPrecision = 0;

  0038e	e9 2d 01 00 00	 jmp	 $LN225@strformat
$LN40@strformat:

; 285  :                 }
; 286  :                 else if (*pszFmt == 'u') {

  00393	3c 75		 cmp	 al, 117			; 00000075H
  00395	75 27		 jne	 SHORT $LN31@strformat

; 287  :                     pszFmt++;

  00397	83 45 08 01	 add	 DWORD PTR _pszFmt$[ebp], 1

; 288  :                     nLen = (int) (do_base(szTemp, value, 10, 'a') - szTemp);

  0039b	6a 61		 push	 97			; 00000061H
  0039d	53		 push	 ebx
  0039e	56		 push	 esi
  0039f	ba 0a 00 00 00	 mov	 edx, 10			; 0000000aH
  003a4	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _szTemp$11572[ebp]
  003aa	e8 00 00 00 00	 call	 ?do_base@@YIPADPAD_KID@Z ; do_base
  003af	8b f8		 mov	 edi, eax
  003b1	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR _szTemp$11572[ebp]
  003b7	2b f8		 sub	 edi, eax

; 289  :                     nPrecision = 0;

  003b9	e9 02 01 00 00	 jmp	 $LN225@strformat
$LN31@strformat:

; 290  :                 }
; 291  :                 else if (*pszFmt == 'o') {

  003be	3c 6f		 cmp	 al, 111			; 0000006fH
  003c0	75 54		 jne	 SHORT $LN29@strformat

; 292  :                     pszFmt++;

  003c2	83 45 08 01	 add	 DWORD PTR _pszFmt$[ebp], 1

; 293  :                     nLen = (int) (do_base(szTemp, value, 8, 'a') - szTemp);

  003c6	6a 61		 push	 97			; 00000061H
  003c8	53		 push	 ebx
  003c9	56		 push	 esi
  003ca	ba 08 00 00 00	 mov	 edx, 8
  003cf	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _szTemp$11572[ebp]
  003d5	e8 00 00 00 00	 call	 ?do_base@@YIPADPAD_KID@Z ; do_base
  003da	8b f8		 mov	 edi, eax
  003dc	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _szTemp$11572[ebp]
  003e2	2b f9		 sub	 edi, ecx

; 294  :                     nPrecision = 0;
; 295  : 
; 296  :                     if (fPound && value) {

  003e4	83 7d e8 00	 cmp	 DWORD PTR _fPound$11580[ebp], 0
  003e8	0f 84 d2 00 00
	00		 je	 $LN225@strformat
  003ee	0b f3		 or	 esi, ebx
  003f0	0f 84 ca 00 00
	00		 je	 $LN225@strformat

; 297  :                         do_str(szHead, "0");

  003f6	8d 45 f8	 lea	 eax, DWORD PTR _szHead$11573[ebp]
  003f9	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01GBGANLPD@0?$AA@
  003fe	8b f0		 mov	 esi, eax
  00400	b1 30		 mov	 cl, 48			; 00000030H
  00402	2b d6		 sub	 edx, esi
$LL154@strformat:
  00404	88 08		 mov	 BYTE PTR [eax], cl
  00406	8a 4c 02 01	 mov	 cl, BYTE PTR [edx+eax+1]
  0040a	83 c0 01	 add	 eax, 1
  0040d	84 c9		 test	 cl, cl
  0040f	75 f3		 jne	 SHORT $LL154@strformat

; 298  :                     }
; 299  :                 }

  00411	e9 a7 00 00 00	 jmp	 $LN240@strformat
$LN29@strformat:

; 300  :                 else if (*pszFmt == 'b') {

  00416	3c 62		 cmp	 al, 98			; 00000062H
  00418	0f 85 a2 00 00
	00		 jne	 $LN225@strformat

; 301  :                     pszFmt++;

  0041e	83 45 08 01	 add	 DWORD PTR _pszFmt$[ebp], 1

; 302  :                     nLen = (int) (do_base(szTemp, value, 2, 'a') - szTemp);

  00422	6a 61		 push	 97			; 00000061H
  00424	53		 push	 ebx
  00425	56		 push	 esi
  00426	ba 02 00 00 00	 mov	 edx, 2
  0042b	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _szTemp$11572[ebp]
  00431	e8 00 00 00 00	 call	 ?do_base@@YIPADPAD_KID@Z ; do_base
  00436	8b f8		 mov	 edi, eax
  00438	8d 95 48 ff ff
	ff		 lea	 edx, DWORD PTR _szTemp$11572[ebp]
  0043e	2b fa		 sub	 edi, edx

; 303  :                     nPrecision = 0;
; 304  : 
; 305  :                     if (fPound && value) {

  00440	83 7d e8 00	 cmp	 DWORD PTR _fPound$11580[ebp], 0
  00444	74 7a		 je	 SHORT $LN225@strformat
  00446	0b f3		 or	 esi, ebx
  00448	74 76		 je	 SHORT $LN225@strformat

; 306  :                         do_str(szHead, "0b");

  0044a	8d 45 f8	 lea	 eax, DWORD PTR _szHead$11573[ebp]
  0044d	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02HDBOMKFI@0b?$AA@
  00452	8b f0		 mov	 esi, eax
  00454	b1 30		 mov	 cl, 48			; 00000030H
  00456	2b d6		 sub	 edx, esi
  00458	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL158@strformat:
  00460	88 08		 mov	 BYTE PTR [eax], cl
  00462	8a 4c 02 01	 mov	 cl, BYTE PTR [edx+eax+1]
  00466	83 c0 01	 add	 eax, 1
  00469	84 c9		 test	 cl, cl
  0046b	75 f3		 jne	 SHORT $LL158@strformat
  0046d	eb 4e		 jmp	 SHORT $LN240@strformat
$LN46@strformat:

; 254  :                     pszFmt++;

  0046f	83 45 08 01	 add	 DWORD PTR _pszFmt$[ebp], 1

; 255  :                     nLen = (int) (do_base(szTemp, value, 16, 'a') - szTemp);

  00473	6a 61		 push	 97			; 00000061H
  00475	53		 push	 ebx
  00476	56		 push	 esi
  00477	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  0047c	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _szTemp$11572[ebp]
  00482	e8 00 00 00 00	 call	 ?do_base@@YIPADPAD_KID@Z ; do_base
  00487	8b f8		 mov	 edi, eax
  00489	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR _szTemp$11572[ebp]
  0048f	2b f8		 sub	 edi, eax

; 256  :                     if (fPound && value) {

  00491	83 7d e8 00	 cmp	 DWORD PTR _fPound$11580[ebp], 0
  00495	74 29		 je	 SHORT $LN225@strformat
  00497	0b f3		 or	 esi, ebx
  00499	74 25		 je	 SHORT $LN225@strformat

; 257  :                         do_str(szHead, "0x");

  0049b	8d 45 f8	 lea	 eax, DWORD PTR _szHead$11573[ebp]
  0049e	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02MDDDDAID@0x?$AA@
  004a3	8b f0		 mov	 esi, eax
  004a5	b1 30		 mov	 cl, 48			; 00000030H
  004a7	2b d6		 sub	 edx, esi
  004a9	8d a4 24 00 00
	00 00		 npad	 7
$LL134@strformat:
  004b0	88 08		 mov	 BYTE PTR [eax], cl
  004b2	8a 4c 10 01	 mov	 cl, BYTE PTR [eax+edx+1]
  004b6	83 c0 01	 add	 eax, 1
  004b9	84 c9		 test	 cl, cl
  004bb	75 f3		 jne	 SHORT $LL134@strformat
$LN240@strformat:
  004bd	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN225@strformat:

; 307  :                     }
; 308  :                 }
; 309  : 
; 310  :                 int nHead = 0;

  004c0	33 f6		 xor	 esi, esi

; 311  :                 for (; szHead[nHead]; nHead++) {

  004c2	80 7d f8 00	 cmp	 BYTE PTR _szHead$11573[ebp], 0
  004c6	74 12		 je	 SHORT $LN22@strformat
  004c8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL24@strformat:
  004d0	83 c6 01	 add	 esi, 1
  004d3	80 7c 35 f8 00	 cmp	 BYTE PTR _szHead$11573[ebp+esi], 0
  004d8	75 f6		 jne	 SHORT $LL24@strformat
$LN22@strformat:

; 312  :                     // Count characters in head string.
; 313  :                 }
; 314  : 
; 315  :                 if (fLeft) {

  004da	83 7d dc 00	 cmp	 DWORD PTR _fLeft$11578[ebp], 0
  004de	74 51		 je	 SHORT $LN21@strformat

; 316  :                     if (nHead) {

  004e0	85 f6		 test	 esi, esi

; 317  :                         nOut += do_out(pfOutput, pContext, szHead);

  004e2	8b 5d f0	 mov	 ebx, DWORD PTR _pContext$[ebp]
  004e5	74 11		 je	 SHORT $LN20@strformat
  004e7	8b 4d f4	 mov	 ecx, DWORD PTR _pfOutput$[ebp]
  004ea	51		 push	 ecx
  004eb	8d 45 f8	 lea	 eax, DWORD PTR _szHead$11573[ebp]
  004ee	e8 00 00 00 00	 call	 ?do_out@@YIHP6IXPAXD@Z0PAD@Z ; do_out
  004f3	01 45 fc	 add	 DWORD PTR _nOut$[ebp], eax

; 318  :                         nLen += nHead;

  004f6	03 fe		 add	 edi, esi
$LN20@strformat:

; 319  :                     }
; 320  :                     nOut += do_out(pfOutput, pContext, szTemp);

  004f8	8b 55 f4	 mov	 edx, DWORD PTR _pfOutput$[ebp]
  004fb	52		 push	 edx
  004fc	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR _szTemp$11572[ebp]
  00502	e8 00 00 00 00	 call	 ?do_out@@YIHP6IXPAXD@Z0PAD@Z ; do_out

; 321  :                     for (; nLen < nWidth; nLen++) {

  00507	8b 75 ec	 mov	 esi, DWORD PTR _nWidth$11576[ebp]
  0050a	01 45 fc	 add	 DWORD PTR _nOut$[ebp], eax
  0050d	3b fe		 cmp	 edi, esi
  0050f	0f 8d 64 02 00
	00		 jge	 $LN223@strformat
  00515	2b f7		 sub	 esi, edi
  00517	01 75 fc	 add	 DWORD PTR _nOut$[ebp], esi
  0051a	03 fe		 add	 edi, esi
  0051c	8d 64 24 00	 npad	 4
$LL19@strformat:

; 322  :                         pfOutput(pContext, ' ');

  00520	b2 20		 mov	 dl, 32			; 00000020H
  00522	8b cb		 mov	 ecx, ebx
  00524	ff 55 f4	 call	 DWORD PTR _pfOutput$[ebp]
  00527	83 ee 01	 sub	 esi, 1
  0052a	75 f4		 jne	 SHORT $LL19@strformat

; 323  :                         nOut++;
; 324  :                     }
; 325  :                 }
; 326  :                 else if (fZero) {

  0052c	e9 48 02 00 00	 jmp	 $LN223@strformat
$LN21@strformat:
  00531	83 7d d8 00	 cmp	 DWORD PTR _fZero$11582[ebp], 0
  00535	74 4d		 je	 SHORT $LN15@strformat

; 327  :                     if (nHead) {

  00537	85 f6		 test	 esi, esi
  00539	74 14		 je	 SHORT $LN14@strformat

; 328  :                         nOut += do_out(pfOutput, pContext, szHead);

  0053b	8b 45 f4	 mov	 eax, DWORD PTR _pfOutput$[ebp]
  0053e	8b 5d f0	 mov	 ebx, DWORD PTR _pContext$[ebp]
  00541	50		 push	 eax
  00542	8d 45 f8	 lea	 eax, DWORD PTR _szHead$11573[ebp]
  00545	e8 00 00 00 00	 call	 ?do_out@@YIHP6IXPAXD@Z0PAD@Z ; do_out
  0054a	01 45 fc	 add	 DWORD PTR _nOut$[ebp], eax

; 329  :                         nLen += nHead;

  0054d	03 fe		 add	 edi, esi
$LN14@strformat:

; 330  :                     }
; 331  :                     for (; nLen < nWidth; nLen++) {

  0054f	3b 7d ec	 cmp	 edi, DWORD PTR _nWidth$11576[ebp]
  00552	7d 19		 jge	 SHORT $LN11@strformat
  00554	8b 75 ec	 mov	 esi, DWORD PTR _nWidth$11576[ebp]
  00557	8b 5d f0	 mov	 ebx, DWORD PTR _pContext$[ebp]
  0055a	2b f7		 sub	 esi, edi
  0055c	01 75 fc	 add	 DWORD PTR _nOut$[ebp], esi
  0055f	03 fe		 add	 edi, esi
$LL13@strformat:

; 332  :                         pfOutput(pContext, '0');

  00561	b2 30		 mov	 dl, 48			; 00000030H
  00563	8b cb		 mov	 ecx, ebx
  00565	ff 55 f4	 call	 DWORD PTR _pfOutput$[ebp]
  00568	83 ee 01	 sub	 esi, 1
  0056b	75 f4		 jne	 SHORT $LL13@strformat
$LN11@strformat:

; 333  :                         nOut++;
; 334  :                     }
; 335  :                     nOut += do_out(pfOutput, pContext, szTemp);

  0056d	8b 4d f4	 mov	 ecx, DWORD PTR _pfOutput$[ebp]
  00570	8b 5d f0	 mov	 ebx, DWORD PTR _pContext$[ebp]
  00573	51		 push	 ecx
  00574	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR _szTemp$11572[ebp]
  0057a	e8 00 00 00 00	 call	 ?do_out@@YIHP6IXPAXD@Z0PAD@Z ; do_out

; 336  :                 }
; 337  :                 else {

  0057f	e9 f2 01 00 00	 jmp	 $LN242@strformat
$LN15@strformat:

; 338  :                     if (nHead) {

  00584	85 f6		 test	 esi, esi
  00586	74 02		 je	 SHORT $LN9@strformat

; 339  :                         nLen += nHead;

  00588	03 fe		 add	 edi, esi
$LN9@strformat:

; 340  :                     }
; 341  :                     for (; nLen < nWidth; nLen++) {

  0058a	3b 7d ec	 cmp	 edi, DWORD PTR _nWidth$11576[ebp]
  0058d	7d 1e		 jge	 SHORT $LN6@strformat
  0058f	8b 5d ec	 mov	 ebx, DWORD PTR _nWidth$11576[ebp]
  00592	2b df		 sub	 ebx, edi
  00594	01 5d fc	 add	 DWORD PTR _nOut$[ebp], ebx
  00597	03 fb		 add	 edi, ebx
  00599	8d a4 24 00 00
	00 00		 npad	 7
$LL8@strformat:

; 342  :                         pfOutput(pContext, ' ');

  005a0	8b 4d f0	 mov	 ecx, DWORD PTR _pContext$[ebp]
  005a3	b2 20		 mov	 dl, 32			; 00000020H
  005a5	ff 55 f4	 call	 DWORD PTR _pfOutput$[ebp]
  005a8	83 eb 01	 sub	 ebx, 1
  005ab	75 f3		 jne	 SHORT $LL8@strformat
$LN6@strformat:

; 343  :                         nOut++;
; 344  :                     }
; 345  :                     if (nHead) {

  005ad	85 f6		 test	 esi, esi
  005af	74 12		 je	 SHORT $LN229@strformat

; 346  :                         nOut += do_out(pfOutput, pContext, szHead);

  005b1	8b 55 f4	 mov	 edx, DWORD PTR _pfOutput$[ebp]
  005b4	8b 5d f0	 mov	 ebx, DWORD PTR _pContext$[ebp]
  005b7	52		 push	 edx
  005b8	8d 45 f8	 lea	 eax, DWORD PTR _szHead$11573[ebp]
  005bb	e8 00 00 00 00	 call	 ?do_out@@YIHP6IXPAXD@Z0PAD@Z ; do_out
  005c0	01 45 fc	 add	 DWORD PTR _nOut$[ebp], eax
$LN229@strformat:

; 347  :                     }
; 348  :                     nOut += do_out(pfOutput, pContext, szTemp);

  005c3	8b 45 f4	 mov	 eax, DWORD PTR _pfOutput$[ebp]
  005c6	8b 5d f0	 mov	 ebx, DWORD PTR _pContext$[ebp]
  005c9	50		 push	 eax
  005ca	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR _szTemp$11572[ebp]
  005d0	e8 00 00 00 00	 call	 ?do_out@@YIHP6IXPAXD@Z0PAD@Z ; do_out

; 349  :                 }
; 350  :             }
; 351  :             else {

  005d5	e9 9c 01 00 00	 jmp	 $LN242@strformat
$LN220@strformat:

; 172  :                 if (*pszFmt == 's' || *pszFmt == 'S') {

  005da	3c 53		 cmp	 al, 83			; 00000053H
  005dc	74 32		 je	 SHORT $LN222@strformat

; 196  :                 }
; 197  :                 else if (*pszFmt == 'c' || *pszFmt == 'C') {

  005de	3c 63		 cmp	 al, 99			; 00000063H
  005e0	74 08		 je	 SHORT $LN67@strformat
  005e2	3c 43		 cmp	 al, 67			; 00000043H
  005e4	0f 85 d0 00 00
	00		 jne	 $LN212@strformat
$LN67@strformat:

; 198  :                     if (*pszFmt == 'S') {
; 199  :                         fLarge = 1;
; 200  :                     }
; 201  :                     pszFmt++;

  005ea	83 c1 01	 add	 ecx, 1

; 202  : 
; 203  :                     fString = 1;
; 204  : 
; 205  :                     szTemp[0] = (char)va_arg(args, int);

  005ed	83 c6 04	 add	 esi, 4
  005f0	89 4d 08	 mov	 DWORD PTR _pszFmt$[ebp], ecx
  005f3	8a 4e fc	 mov	 cl, BYTE PTR [esi-4]
  005f6	89 75 0c	 mov	 DWORD PTR _args$[ebp], esi
  005f9	88 8d 48 ff ff
	ff		 mov	 BYTE PTR _szTemp$11572[ebp], cl

; 206  :                     szTemp[1] = '\0';

  005ff	c6 85 49 ff ff
	ff 00		 mov	 BYTE PTR _szTemp$11572[ebp+1], 0

; 207  :                     nLen = 1;

  00606	bf 01 00 00 00	 mov	 edi, 1
  0060b	e9 aa 00 00 00	 jmp	 $LN212@strformat
$LN222@strformat:

; 173  :                     char * pszDst = szTemp;
; 174  :                     void * pvData = va_arg(args, void *);

  00610	83 c6 04	 add	 esi, 4
  00613	89 75 0c	 mov	 DWORD PTR _args$[ebp], esi
  00616	8b 76 fc	 mov	 esi, DWORD PTR [esi-4]

; 175  : 
; 176  :                     if (*pszFmt == 'S') {

  00619	3c 53		 cmp	 al, 83			; 00000053H

; 177  :                         fLarge = 1;

  0061b	b8 01 00 00 00	 mov	 eax, 1
  00620	74 03		 je	 SHORT $LN75@strformat
  00622	8b 45 e0	 mov	 eax, DWORD PTR _fLarge$11585[ebp]
$LN75@strformat:

; 178  :                     }
; 179  :                     pszFmt++;

  00625	83 c1 01	 add	 ecx, 1

; 180  : 
; 181  :                     fString = 1;
; 182  :                     if (fSmall) {

  00628	83 7d cc 00	 cmp	 DWORD PTR _fSmall$11584[ebp], 0
  0062c	89 4d 08	 mov	 DWORD PTR _pszFmt$[ebp], ecx
  0062f	74 02		 je	 SHORT $LN74@strformat

; 183  :                         fLarge = 0;

  00631	33 c0		 xor	 eax, eax
$LN74@strformat:

; 184  :                     }
; 185  : 
; 186  :                     if (!pvData) {

  00633	85 f6		 test	 esi, esi
  00635	75 28		 jne	 SHORT $LN73@strformat

; 187  :                         pszDst = do_str(pszDst, "<NULL>");

  00637	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR _szTemp$11572[ebp]
  0063d	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_06CBHGEMFM@?$DMNULL?$DO?$AA@
  00642	8b f0		 mov	 esi, eax
  00644	b1 3c		 mov	 cl, 60			; 0000003cH
  00646	2b d6		 sub	 edx, esi
  00648	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL110@strformat:
  00650	88 08		 mov	 BYTE PTR [eax], cl
  00652	8a 4c 02 01	 mov	 cl, BYTE PTR [edx+eax+1]
  00656	83 c0 01	 add	 eax, 1
  00659	84 c9		 test	 cl, cl
  0065b	75 f3		 jne	 SHORT $LL110@strformat
  0065d	eb 4e		 jmp	 SHORT $LN117@strformat
$LN73@strformat:

; 188  :                     }
; 189  :                     else if (fLarge) {

  0065f	85 c0		 test	 eax, eax
  00661	74 25		 je	 SHORT $LN71@strformat

; 190  :                         pszDst = do_wstr(pszDst, (short *)pvData);

  00663	66 83 3e 00	 cmp	 WORD PTR [esi], 0
  00667	8b c6		 mov	 eax, esi
  00669	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _szTemp$11572[ebp]
  0066f	74 10		 je	 SHORT $LN113@strformat
$LL114@strformat:
  00671	8a 10		 mov	 dl, BYTE PTR [eax]
  00673	88 11		 mov	 BYTE PTR [ecx], dl
  00675	83 c0 02	 add	 eax, 2
  00678	83 c1 01	 add	 ecx, 1
  0067b	66 83 38 00	 cmp	 WORD PTR [eax], 0
  0067f	75 f0		 jne	 SHORT $LL114@strformat
$LN113@strformat:
  00681	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00684	8b c1		 mov	 eax, ecx

; 191  :                     }
; 192  :                     else {

  00686	eb 28		 jmp	 SHORT $LN70@strformat
$LN71@strformat:

; 193  :                         pszDst = do_str(pszDst, (char *)pvData);

  00688	8a 0e		 mov	 cl, BYTE PTR [esi]
  0068a	84 c9		 test	 cl, cl
  0068c	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR _szTemp$11572[ebp]
  00692	74 19		 je	 SHORT $LN117@strformat
  00694	8b d6		 mov	 edx, esi
  00696	8b f0		 mov	 esi, eax
  00698	2b d6		 sub	 edx, esi
  0069a	8d 9b 00 00 00
	00		 npad	 6
$LL118@strformat:
  006a0	88 08		 mov	 BYTE PTR [eax], cl
  006a2	8a 4c 02 01	 mov	 cl, BYTE PTR [edx+eax+1]
  006a6	83 c0 01	 add	 eax, 1
  006a9	84 c9		 test	 cl, cl
  006ab	75 f3		 jne	 SHORT $LL118@strformat
$LN117@strformat:
  006ad	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN70@strformat:

; 194  :                     }
; 195  :                     nLen = (int) (pszDst - szTemp);

  006b0	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _szTemp$11572[ebp]
  006b6	2b c1		 sub	 eax, ecx
  006b8	8b f8		 mov	 edi, eax
$LN212@strformat:

; 208  :                 }
; 209  : 
; 210  :                 if (nPrecision && nLen > nPrecision) {

  006ba	8b 45 e4	 mov	 eax, DWORD PTR _nPrecision$11577[ebp]
  006bd	85 c0		 test	 eax, eax
  006bf	74 0e		 je	 SHORT $LN65@strformat
  006c1	3b f8		 cmp	 edi, eax
  006c3	7e 0a		 jle	 SHORT $LN65@strformat

; 211  :                     nLen = nPrecision;

  006c5	8b f8		 mov	 edi, eax

; 212  :                     szTemp[nLen] = '\0';

  006c7	c6 84 05 48 ff
	ff ff 00	 mov	 BYTE PTR _szTemp$11572[ebp+eax], 0
$LN65@strformat:

; 213  :                 }
; 214  : 
; 215  :                 if (fLeft) {

  006cf	83 7d dc 00	 cmp	 DWORD PTR _fLeft$11578[ebp], 0
  006d3	74 49		 je	 SHORT $LN64@strformat

; 216  :                     nOut += do_out(pfOutput, pContext, szTemp);

  006d5	8a 95 48 ff ff
	ff		 mov	 dl, BYTE PTR _szTemp$11572[ebp]
  006db	33 f6		 xor	 esi, esi
  006dd	84 d2		 test	 dl, dl
  006df	74 16		 je	 SHORT $LN121@strformat
  006e1	8b 5d f0	 mov	 ebx, DWORD PTR _pContext$[ebp]
$LL122@strformat:
  006e4	8b cb		 mov	 ecx, ebx
  006e6	ff 55 f4	 call	 DWORD PTR _pfOutput$[ebp]
  006e9	8a 94 35 49 ff
	ff ff		 mov	 dl, BYTE PTR _szTemp$11572[ebp+esi+1]
  006f0	83 c6 01	 add	 esi, 1
  006f3	84 d2		 test	 dl, dl
  006f5	75 ed		 jne	 SHORT $LL122@strformat
$LN121@strformat:
  006f7	01 75 fc	 add	 DWORD PTR _nOut$[ebp], esi

; 217  :                     for (; nLen < nWidth; nLen++) {

  006fa	3b 7d ec	 cmp	 edi, DWORD PTR _nWidth$11576[ebp]
  006fd	7d 7a		 jge	 SHORT $LN223@strformat
  006ff	8b 75 ec	 mov	 esi, DWORD PTR _nWidth$11576[ebp]
  00702	8b 5d f0	 mov	 ebx, DWORD PTR _pContext$[ebp]
  00705	2b f7		 sub	 esi, edi
  00707	01 75 fc	 add	 DWORD PTR _nOut$[ebp], esi
  0070a	03 fe		 add	 edi, esi
  0070c	8d 64 24 00	 npad	 4
$LL63@strformat:

; 218  :                         pfOutput(pContext, ' ');

  00710	b2 20		 mov	 dl, 32			; 00000020H
  00712	8b cb		 mov	 ecx, ebx
  00714	ff 55 f4	 call	 DWORD PTR _pfOutput$[ebp]
  00717	83 ee 01	 sub	 esi, 1
  0071a	75 f4		 jne	 SHORT $LL63@strformat

; 219  :                         nOut++;
; 220  :                     }
; 221  :                 }
; 222  :                 else {

  0071c	eb 5b		 jmp	 SHORT $LN223@strformat
$LN64@strformat:

; 223  :                     for (; nLen < nWidth; nLen++) {

  0071e	3b fb		 cmp	 edi, ebx
  00720	7d 1c		 jge	 SHORT $LN230@strformat
  00722	2b df		 sub	 ebx, edi
  00724	8b f3		 mov	 esi, ebx
  00726	8b 5d f0	 mov	 ebx, DWORD PTR _pContext$[ebp]
  00729	03 fe		 add	 edi, esi
  0072b	eb 03 8d 49 00	 npad	 5
$LL59@strformat:

; 224  :                         pfOutput(pContext, ' ');

  00730	b2 20		 mov	 dl, 32			; 00000020H
  00732	8b cb		 mov	 ecx, ebx
  00734	ff 55 f4	 call	 DWORD PTR _pfOutput$[ebp]
  00737	83 ee 01	 sub	 esi, 1
  0073a	75 f4		 jne	 SHORT $LL59@strformat

; 223  :                     for (; nLen < nWidth; nLen++) {

  0073c	eb 03		 jmp	 SHORT $LN57@strformat
$LN230@strformat:
  0073e	8b 5d f0	 mov	 ebx, DWORD PTR _pContext$[ebp]
$LN57@strformat:

; 225  :                         nOut++;
; 226  :                     }
; 227  :                     nOut = do_out(pfOutput, pContext, szTemp);

  00741	8a 95 48 ff ff
	ff		 mov	 dl, BYTE PTR _szTemp$11572[ebp]
  00747	33 f6		 xor	 esi, esi
  00749	84 d2		 test	 dl, dl
  0074b	74 16		 je	 SHORT $LN125@strformat
  0074d	8d 49 00	 npad	 3
$LL126@strformat:
  00750	8b cb		 mov	 ecx, ebx
  00752	ff 55 f4	 call	 DWORD PTR _pfOutput$[ebp]
  00755	8a 94 35 49 ff
	ff ff		 mov	 dl, BYTE PTR _szTemp$11572[ebp+esi+1]
  0075c	83 c6 01	 add	 esi, 1
  0075f	84 d2		 test	 dl, dl
  00761	75 ed		 jne	 SHORT $LL126@strformat
$LN125@strformat:
  00763	89 75 fc	 mov	 DWORD PTR _nOut$[ebp], esi

; 355  :                     nOut++;
; 356  :                 }
; 357  :             }
; 358  :         }
; 359  :         else {

  00766	eb 11		 jmp	 SHORT $LN223@strformat
$LN104@strformat:

; 360  :             pfOutput(pContext, *pszFmt++);

  00768	8b 4d f0	 mov	 ecx, DWORD PTR _pContext$[ebp]
  0076b	ff 55 f4	 call	 DWORD PTR _pfOutput$[ebp]
  0076e	b8 01 00 00 00	 mov	 eax, 1
  00773	01 45 08	 add	 DWORD PTR _pszFmt$[ebp], eax
$LN242@strformat:

; 361  :             nOut++;

  00776	01 45 fc	 add	 DWORD PTR _nOut$[ebp], eax
$LN223@strformat:

; 102  :     int nOut = 0;
; 103  : 
; 104  :     while (*pszFmt) {

  00779	8b 55 08	 mov	 edx, DWORD PTR _pszFmt$[ebp]
  0077c	8a 12		 mov	 dl, BYTE PTR [edx]
  0077e	84 d2		 test	 dl, dl
  00780	0f 85 aa f8 ff
	ff		 jne	 $LL224@strformat

; 362  :         }
; 363  :     }
; 364  :     return nOut;

  00786	8b 45 fc	 mov	 eax, DWORD PTR _nOut$[ebp]
  00789	5f		 pop	 edi
  0078a	5e		 pop	 esi
  0078b	5b		 pop	 ebx
$LN105@strformat:

; 365  : }

  0078c	8b e5		 mov	 esp, ebp
  0078e	5d		 pop	 ebp
  0078f	c2 08 00	 ret	 8
  00792	8b ff		 npad	 2
$LN243@strformat:
  00794	00 00 00 00	 DD	 $LN94@strformat
  00798	00 00 00 00	 DD	 $LN95@strformat
  0079c	00 00 00 00	 DD	 $LN96@strformat
  007a0	00 00 00 00	 DD	 $LN97@strformat
  007a4	00 00 00 00	 DD	 $LN93@strformat
  007a8	00 00 00 00	 DD	 $LN102@strformat
$LN207@strformat:
  007ac	00		 DB	 0
  007ad	05		 DB	 5
  007ae	05		 DB	 5
  007af	01		 DB	 1
  007b0	05		 DB	 5
  007b1	05		 DB	 5
  007b2	05		 DB	 5
  007b3	05		 DB	 5
  007b4	05		 DB	 5
  007b5	05		 DB	 5
  007b6	05		 DB	 5
  007b7	02		 DB	 2
  007b8	05		 DB	 5
  007b9	03		 DB	 3
  007ba	05		 DB	 5
  007bb	05		 DB	 5
  007bc	04		 DB	 4
?strformat@@YIHP6IXPAXD@Z0PBDPAD@Z ENDP			; strformat
_TEXT	ENDS
PUBLIC	?g_HalGetLinkDate@Class_Microsoft_Singularity_Kernel@@SIPA_WXZ ; Class_Microsoft_Singularity_Kernel::g_HalGetLinkDate
EXTRN	?_LinkDate@@3PA_WA:BYTE				; _LinkDate
; Function compile flags: /Ogtp
; File c:\users\cc\source\repos\singularity-os\base\kernel\native\hal.cpp
;	COMDAT ?g_HalGetLinkDate@Class_Microsoft_Singularity_Kernel@@SIPA_WXZ
_TEXT	SEGMENT
?g_HalGetLinkDate@Class_Microsoft_Singularity_Kernel@@SIPA_WXZ PROC ; Class_Microsoft_Singularity_Kernel::g_HalGetLinkDate, COMDAT

; 40   :     return (bartok_char *)_LinkDate;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_LinkDate@@3PA_WA ; _LinkDate

; 41   : }

  00005	c3		 ret	 0
?g_HalGetLinkDate@Class_Microsoft_Singularity_Kernel@@SIPA_WXZ ENDP ; Class_Microsoft_Singularity_Kernel::g_HalGetLinkDate
_TEXT	ENDS
PUBLIC	?fail_assert@@YIXPBD@Z				; fail_assert
; Function compile flags: /Ogtp
;	COMDAT ?fail_assert@@YIXPBD@Z
_TEXT	SEGMENT
?fail_assert@@YIXPBD@Z PROC				; fail_assert, COMDAT
; _expr$ = ecx

; 45   :     // TODO: wire up something useful here.
; 46   :     __debugbreak();

  00000	cc		 int	 3

; 47   : }

  00001	c3		 ret	 0
?fail_assert@@YIXPBD@Z ENDP				; fail_assert
_TEXT	ENDS
PUBLIC	?g_GetCurrentCpu@Class_Microsoft_Singularity_Hal_Platform@@SIPAUClass_Microsoft_Singularity_Hal_Cpu@@XZ ; Class_Microsoft_Singularity_Hal_Platform::g_GetCurrentCpu
EXTRN	?g_GetCurrentProcessorContext@Class_Microsoft_Singularity_Processor@@SIPAUStruct_Microsoft_Singularity_ProcessorContext@@XZ:PROC ; Class_Microsoft_Singularity_Processor::g_GetCurrentProcessorContext
; Function compile flags: /Ogtp
;	COMDAT ?g_GetCurrentCpu@Class_Microsoft_Singularity_Hal_Platform@@SIPAUClass_Microsoft_Singularity_Hal_Cpu@@XZ
_TEXT	SEGMENT
?g_GetCurrentCpu@Class_Microsoft_Singularity_Hal_Platform@@SIPAUClass_Microsoft_Singularity_Hal_Cpu@@XZ PROC ; Class_Microsoft_Singularity_Hal_Platform::g_GetCurrentCpu, COMDAT

; 56   :     return (Class_Microsoft_Singularity_Hal_Cpu *)
; 57   :         Class_Microsoft_Singularity_Processor::g_GetCurrentProcessorContext()->halCpu;

  00000	e8 00 00 00 00	 call	 ?g_GetCurrentProcessorContext@Class_Microsoft_Singularity_Processor@@SIPAUStruct_Microsoft_Singularity_ProcessorContext@@XZ ; Class_Microsoft_Singularity_Processor::g_GetCurrentProcessorContext
  00005	8b 80 a0 04 00
	00		 mov	 eax, DWORD PTR [eax+1184]

; 58   : }

  0000b	c3		 ret	 0
?g_GetCurrentCpu@Class_Microsoft_Singularity_Hal_Platform@@SIPAUClass_Microsoft_Singularity_Hal_Cpu@@XZ ENDP ; Class_Microsoft_Singularity_Hal_Platform::g_GetCurrentCpu
_TEXT	ENDS
PUBLIC	?g_HalReleaseMpStartupLock@Struct_Microsoft_Singularity_MpBootInfo@@SIXXZ ; Struct_Microsoft_Singularity_MpBootInfo::g_HalReleaseMpStartupLock
EXTRN	?c_thePlatform@Class_Microsoft_Singularity_Hal_Platform@@2PAU1@A:DWORD ; Class_Microsoft_Singularity_Hal_Platform::c_thePlatform
; Function compile flags: /Ogtp
;	COMDAT ?g_HalReleaseMpStartupLock@Struct_Microsoft_Singularity_MpBootInfo@@SIXXZ
_TEXT	SEGMENT
?g_HalReleaseMpStartupLock@Struct_Microsoft_Singularity_MpBootInfo@@SIXXZ PROC ; Struct_Microsoft_Singularity_MpBootInfo::g_HalReleaseMpStartupLock, COMDAT

; 62   :     uint32 lockAddr =
; 63   :         (uint32)Class_Microsoft_Singularity_Hal_Platform::c_thePlatform->MpStartupLock32;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?c_thePlatform@Class_Microsoft_Singularity_Hal_Platform@@2PAU1@A ; Class_Microsoft_Singularity_Hal_Platform::c_thePlatform
  00005	8b 80 b4 01 00
	00		 mov	 eax, DWORD PTR [eax+436]

; 64   :     if (lockAddr != 0) {

  0000b	85 c0		 test	 eax, eax
  0000d	74 05		 je	 SHORT $LN1@g_HalRelea

; 65   :         *((uint16*) lockAddr) = 0;

  0000f	66 c7 00 00 00	 mov	 WORD PTR [eax], 0
$LN1@g_HalRelea:

; 66   :     }
; 67   : }

  00014	c3		 ret	 0
?g_HalReleaseMpStartupLock@Struct_Microsoft_Singularity_MpBootInfo@@SIXXZ ENDP ; Struct_Microsoft_Singularity_MpBootInfo::g_HalReleaseMpStartupLock
_TEXT	ENDS
PUBLIC	?InitCpu@@YIXPAUClass_Microsoft_Singularity_Hal_Cpu@@@Z ; InitCpu
EXTRN	?g_InitializeCpuDispatchTable@Class_Microsoft_Singularity_Isal_Isa@@SIXXZ:PROC ; Class_Microsoft_Singularity_Isal_Isa::g_InitializeCpuDispatchTable
EXTRN	?m_Initialize@Class_Microsoft_Singularity_Hal_Cpu@@SIXPAU1@@Z:PROC ; Class_Microsoft_Singularity_Hal_Cpu::m_Initialize
; Function compile flags: /Ogtp
;	COMDAT ?InitCpu@@YIXPAUClass_Microsoft_Singularity_Hal_Cpu@@@Z
_TEXT	SEGMENT
?InitCpu@@YIXPAUClass_Microsoft_Singularity_Hal_Cpu@@@Z PROC ; InitCpu, COMDAT
; _pi$ = ecx

; 71   :     ArmSerialOut("InitCpu0\n");
; 72   :     ArmSerialOutHex(pi->Id);
; 73   :     ArmSerialOut("\n");
; 74   : 
; 75   :     Class_Microsoft_Singularity_Hal_Cpu *hpi = (Class_Microsoft_Singularity_Hal_Cpu*) pi;
; 76   : 
; 77   :     hpi->postHeader.vtableObject = CpuRuntimeType->classVtable;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CpuRuntimeType@@3PAUClass_System_RuntimeType@@A ; CpuRuntimeType
  00005	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  00008	89 11		 mov	 DWORD PTR [ecx], edx

; 78   : 
; 79   :     ArmSerialOut("InitCpu1\n");
; 80   : 
; 81   :     Class_Microsoft_Singularity_Hal_Cpu::m_Initialize(hpi);

  0000a	e8 00 00 00 00	 call	 ?m_Initialize@Class_Microsoft_Singularity_Hal_Cpu@@SIXPAU1@@Z ; Class_Microsoft_Singularity_Hal_Cpu::m_Initialize

; 82   : 
; 83   :     ArmSerialOut("InitCpu2\n");
; 84   : 
; 85   :     Class_Microsoft_Singularity_Isal_Isa::g_InitializeCpuDispatchTable();

  0000f	e9 00 00 00 00	 jmp	 ?g_InitializeCpuDispatchTable@Class_Microsoft_Singularity_Isal_Isa@@SIXXZ ; Class_Microsoft_Singularity_Isal_Isa::g_InitializeCpuDispatchTable
?InitCpu@@YIXPAUClass_Microsoft_Singularity_Hal_Cpu@@@Z ENDP ; InitCpu
_TEXT	ENDS
PUBLIC	?ShutdownCpu@@YIXPAUClass_Microsoft_Singularity_Hal_Cpu@@@Z ; ShutdownCpu
EXTRN	?g_PollForBreak@Class_Microsoft_Singularity_DebugStub@@SI_NXZ:PROC ; Class_Microsoft_Singularity_DebugStub::g_PollForBreak
EXTRN	?g_DisableInterrupts@Class_Microsoft_Singularity_Processor@@SI_NXZ:PROC ; Class_Microsoft_Singularity_Processor::g_DisableInterrupts
; Function compile flags: /Ogtp
;	COMDAT ?ShutdownCpu@@YIXPAUClass_Microsoft_Singularity_Hal_Cpu@@@Z
_TEXT	SEGMENT
tv166 = -4						; size = 4
?ShutdownCpu@@YIXPAUClass_Microsoft_Singularity_Hal_Cpu@@@Z PROC ; ShutdownCpu, COMDAT
; _pi$ = ecx

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f1		 mov	 esi, ecx

; 92   : #if ISA_IX86 || ISA_IX64
; 93   :     // Disable Interrupts and then spin a screen icon waiting to be reset.
; 94   :     Class_Microsoft_Singularity_Processor::g_DisableInterrupts();

  00009	e8 00 00 00 00	 call	 ?g_DisableInterrupts@Class_Microsoft_Singularity_Processor@@SI_NXZ ; Class_Microsoft_Singularity_Processor::g_DisableInterrupts

; 95   : 
; 96   :     int cpu = pi->Id;

  0000e	8b 76 08	 mov	 esi, DWORD PTR [esi+8]

; 97   :     for (int i = 0; i != i + 1; i++) {

  00011	81 c6 ff b7 00
	00		 add	 esi, 47103		; 0000b7ffH
  00017	33 db		 xor	 ebx, ebx
  00019	c1 e6 04	 shl	 esi, 4
  0001c	89 75 fc	 mov	 DWORD PTR tv166[ebp], esi
  0001f	eb 03		 jmp	 SHORT $LN12@ShutdownCp
$LL21@ShutdownCp:
  00021	8b 75 fc	 mov	 esi, DWORD PTR tv166[ebp]
$LN12@ShutdownCp:

; 98   :         uint16* p = (uint16*)(0xb8000 + (cpu - 1) * 2 * 8);

  00024	8b fe		 mov	 edi, esi
  00026	be 1c 00 00 00	 mov	 esi, 28			; 0000001cH
  0002b	eb 03 8d 49 00	 npad	 5
$LL9@ShutdownCp:

; 99   :         for (int r = 0; r < 8; r++) {
; 100  :             uint16 t = (uint16)(i >> (28 - r * 4));

  00030	8b c3		 mov	 eax, ebx
  00032	8b ce		 mov	 ecx, esi
  00034	d3 f8		 sar	 eax, cl

; 101  :             t &= 0xf;

  00036	83 e0 0f	 and	 eax, 15			; 0000000fH

; 102  :             if (t > 9) {

  00039	66 3d 09 00	 cmp	 ax, 9
  0003d	76 07		 jbe	 SHORT $LN6@ShutdownCp

; 103  :                 t += 0x1f00 + 'a' - 10;

  0003f	05 57 1f 00 00	 add	 eax, 8023		; 00001f57H

; 104  :             }
; 105  :             else {

  00044	eb 05		 jmp	 SHORT $LN5@ShutdownCp
$LN6@ShutdownCp:

; 106  :                 t += 0x1f00 + '0';

  00046	05 30 1f 00 00	 add	 eax, 7984		; 00001f30H
$LN5@ShutdownCp:

; 107  :             }
; 108  :             *p++ = t;

  0004b	66 89 07	 mov	 WORD PTR [edi], ax
  0004e	83 c7 02	 add	 edi, 2

; 109  :             if (Class_Microsoft_Singularity_DebugStub::g_PollForBreak() == true) {

  00051	e8 00 00 00 00	 call	 ?g_PollForBreak@Class_Microsoft_Singularity_DebugStub@@SI_NXZ ; Class_Microsoft_Singularity_DebugStub::g_PollForBreak
  00056	3c 01		 cmp	 al, 1
  00058	75 01		 jne	 SHORT $LN4@ShutdownCp

; 110  :                 __debugbreak();

  0005a	cc		 int	 3
$LN4@ShutdownCp:

; 111  :             }
; 112  :             for (int i = 0; i < 50000; i++) {

  0005b	b8 50 c3 00 00	 mov	 eax, 50000		; 0000c350H
$LL3@ShutdownCp:
  00060	83 e8 01	 sub	 eax, 1

; 113  :                 __nop();

  00063	90		 npad	 1
  00064	75 fa		 jne	 SHORT $LL3@ShutdownCp
  00066	83 ee 04	 sub	 esi, 4
  00069	83 fe fc	 cmp	 esi, -4			; fffffffcH
  0006c	7f c2		 jg	 SHORT $LL9@ShutdownCp
  0006e	83 c3 01	 add	 ebx, 1
  00071	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  00074	3b d8		 cmp	 ebx, eax
  00076	75 a9		 jne	 SHORT $LL21@ShutdownCp
  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx

; 114  :             }
; 115  :         }
; 116  :     }
; 117  : #endif
; 118  : }

  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
?ShutdownCpu@@YIXPAUClass_Microsoft_Singularity_Hal_Cpu@@@Z ENDP ; ShutdownCpu
_TEXT	ENDS
PUBLIC	??_C@_0BB@POKCPCIE@DebugPort?3?5?$CF04x?6?$AA@	; `string'
PUBLIC	?InitPlatform@@YIXPAUClass_Microsoft_Singularity_Hal_Platform@@PAUClass_Microsoft_Singularity_Hal_Cpu@@@Z ; InitPlatform
EXTRN	?KdpSerialInit@@YI_NPAUClass_Microsoft_Singularity_Hal_Platform@@@Z:PROC ; KdpSerialInit
EXTRN	?kdprintf@@YAXPBDZZ:PROC			; kdprintf
EXTRN	?m_Initialize@Class_Microsoft_Singularity_Hal_Platform@@SIXPAU1@PAUClass_Microsoft_Singularity_Hal_Cpu@@@Z:PROC ; Class_Microsoft_Singularity_Hal_Platform::m_Initialize
EXTRN	?g_InitializeDispatchTable@Class_Microsoft_Singularity_Isal_Isa@@SIXXZ:PROC ; Class_Microsoft_Singularity_Isal_Isa::g_InitializeDispatchTable
;	COMDAT ??_C@_0BB@POKCPCIE@DebugPort?3?5?$CF04x?6?$AA@
CONST	SEGMENT
??_C@_0BB@POKCPCIE@DebugPort?3?5?$CF04x?6?$AA@ DB 'DebugPort: %04x', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?InitPlatform@@YIXPAUClass_Microsoft_Singularity_Hal_Platform@@PAUClass_Microsoft_Singularity_Hal_Cpu@@@Z
_TEXT	SEGMENT
?InitPlatform@@YIXPAUClass_Microsoft_Singularity_Hal_Platform@@PAUClass_Microsoft_Singularity_Hal_Cpu@@@Z PROC ; InitPlatform, COMDAT
; _bi$ = ecx
; _pi$ = edx

; 122  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b fa		 mov	 edi, edx
  00004	8b f1		 mov	 esi, ecx

; 123  :     ArmSerialOut("InitPlatform0");
; 124  : 
; 125  : #ifndef ISA_ARM
; 126  :     Class_Microsoft_Singularity_Isal_Isa::g_InitializeDispatchTable();

  00006	e8 00 00 00 00	 call	 ?g_InitializeDispatchTable@Class_Microsoft_Singularity_Isal_Isa@@SIXXZ ; Class_Microsoft_Singularity_Isal_Isa::g_InitializeDispatchTable

; 127  : #endif
; 128  : 
; 129  :     InitCpu(pi);

  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CpuRuntimeType@@3PAUClass_System_RuntimeType@@A ; CpuRuntimeType
  00010	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00013	89 0f		 mov	 DWORD PTR [edi], ecx
  00015	8b cf		 mov	 ecx, edi
  00017	e8 00 00 00 00	 call	 ?m_Initialize@Class_Microsoft_Singularity_Hal_Cpu@@SIXPAU1@@Z ; Class_Microsoft_Singularity_Hal_Cpu::m_Initialize
  0001c	e8 00 00 00 00	 call	 ?g_InitializeCpuDispatchTable@Class_Microsoft_Singularity_Isal_Isa@@SIXXZ ; Class_Microsoft_Singularity_Isal_Isa::g_InitializeCpuDispatchTable

; 130  : 
; 131  :     ArmSerialOut("InitPlatform2");
; 132  : 
; 133  :     Class_Microsoft_Singularity_Hal_Platform *nbi = (Class_Microsoft_Singularity_Hal_Platform *) bi;
; 134  :     nbi->postHeader.vtableObject = PlatformRuntimeType->classVtable;

  00021	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?PlatformRuntimeType@@3PAUClass_System_RuntimeType@@A ; PlatformRuntimeType
  00027	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]

; 135  : 
; 136  :     // Call early init routines
; 137  : 
; 138  :     Class_Microsoft_Singularity_Hal_Platform::m_Initialize(nbi,
; 139  :                                                       (Class_Microsoft_Singularity_Hal_Cpu *) pi);

  0002a	8b d7		 mov	 edx, edi
  0002c	8b ce		 mov	 ecx, esi
  0002e	89 06		 mov	 DWORD PTR [esi], eax
  00030	e8 00 00 00 00	 call	 ?m_Initialize@Class_Microsoft_Singularity_Hal_Platform@@SIXPAU1@PAUClass_Microsoft_Singularity_Hal_Cpu@@@Z ; Class_Microsoft_Singularity_Hal_Platform::m_Initialize

; 140  : 
; 141  :     ArmSerialOut("InitPlatform3");
; 142  : 
; 143  :     kdprintf("DebugPort: %04x\n", nbi->DebugBasePort);

  00035	0f b7 8e ac 00
	00 00		 movzx	 ecx, WORD PTR [esi+172]
  0003c	51		 push	 ecx
  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@POKCPCIE@DebugPort?3?5?$CF04x?6?$AA@
  00042	e8 00 00 00 00	 call	 ?kdprintf@@YAXPBDZZ	; kdprintf
  00047	83 c4 08	 add	 esp, 8

; 144  : 
; 145  :     ArmSerialOut("InitPlatform4");
; 146  : 
; 147  :     // Initialize the debugger hardware
; 148  : 
; 149  :     if (KdpSerialInit(nbi)) {

  0004a	8b ce		 mov	 ecx, esi
  0004c	e8 00 00 00 00	 call	 ?KdpSerialInit@@YI_NPAUClass_Microsoft_Singularity_Hal_Platform@@@Z ; KdpSerialInit
  00051	f6 d8		 neg	 al
  00053	5f		 pop	 edi
  00054	1b c0		 sbb	 eax, eax
  00056	f7 d8		 neg	 eax
  00058	89 86 a0 00 00
	00		 mov	 DWORD PTR [esi+160], eax
  0005e	5e		 pop	 esi

; 150  :         nbi->DebuggerType = Class_Microsoft_Singularity_Hal_Platform_DEBUGGER_SERIAL;
; 151  :     }
; 152  :     else {
; 153  :         nbi->DebuggerType = Class_Microsoft_Singularity_Hal_Platform_DEBUGGER_NONE;
; 154  :     }
; 155  : 
; 156  :     ArmSerialOut("Calling Kernel.Main:\n");
; 157  : }

  0005f	c3		 ret	 0
?InitPlatform@@YIXPAUClass_Microsoft_Singularity_Hal_Platform@@PAUClass_Microsoft_Singularity_Hal_Cpu@@@Z ENDP ; InitPlatform
_TEXT	ENDS
PUBLIC	?ShutdownPlatform@@YIXPAUClass_Microsoft_Singularity_Hal_Platform@@@Z ; ShutdownPlatform
; Function compile flags: /Ogtp
;	COMDAT ?ShutdownPlatform@@YIXPAUClass_Microsoft_Singularity_Hal_Platform@@@Z
_TEXT	SEGMENT
?ShutdownPlatform@@YIXPAUClass_Microsoft_Singularity_Hal_Platform@@@Z PROC ; ShutdownPlatform, COMDAT
; _bi$ = ecx

; 161  : }

  00000	c3		 ret	 0
?ShutdownPlatform@@YIXPAUClass_Microsoft_Singularity_Hal_Platform@@@Z ENDP ; ShutdownPlatform
_TEXT	ENDS
PUBLIC	@HalEntryPoint@8
EXTRN	?g_MpMain@Class_Microsoft_Singularity_Kernel@@SIHH@Z:PROC ; Class_Microsoft_Singularity_Kernel::g_MpMain
EXTRN	?g_Main@Class_Microsoft_Singularity_Kernel@@SIHXZ:PROC ; Class_Microsoft_Singularity_Kernel::g_Main
EXTRN	?KdInitialize@@YIXPAUClass_Microsoft_Singularity_Hal_Platform@@@Z:PROC ; KdInitialize
EXTRN	?g_Initialize@Class_Microsoft_Singularity_Tracing@@SIXXZ:PROC ; Class_Microsoft_Singularity_Tracing::g_Initialize
EXTRN	?ProcessorInitialize@@YIXPAUClass_Microsoft_Singularity_Hal_Cpu@@@Z:PROC ; ProcessorInitialize
EXTRN	?g_InitializeCpu@Class_Microsoft_Singularity_Isal_Isa@@SIXPAUStruct_Microsoft_Singularity_Isal_CpuRecord@@HPAUuintPtr@@@Z:PROC ; Class_Microsoft_Singularity_Isal_Isa::g_InitializeCpu
EXTRN	?g_Initialize@Class_Microsoft_Singularity_Isal_Isa@@SIXHH@Z:PROC ; Class_Microsoft_Singularity_Isal_Isa::g_Initialize
EXTRN	?_cinit@@YAHXZ:PROC				; _cinit
; Function compile flags: /Ogtp
;	COMDAT @HalEntryPoint@8
_TEXT	SEGMENT
@HalEntryPoint@8 PROC					; COMDAT
; _bi$ = ecx
; _pi$ = edx

; 170  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 171  :     ArmSerialInit((UINT32 *) 0xffd82300);
; 172  :     ArmSerialOut("HalEntry 1\n");
; 173  : 
; 174  :     if (bi->Size != sizeof(Class_Microsoft_Singularity_Hal_Platform)) {

  00004	81 7f 04 d8 01
	00 00		 cmp	 DWORD PTR [edi+4], 472	; 000001d8H
  0000b	8b f2		 mov	 esi, edx
  0000d	74 09		 je	 SHORT $LN5@

; 175  :         __debugbreak();

  0000f	cc		 int	 3
  00010	5f		 pop	 edi

; 176  :         return Class_Microsoft_Singularity_Hal_Platform_ERROR_BAD_SIZE;

  00011	b8 01 00 00 00	 mov	 eax, 1
  00016	5e		 pop	 esi

; 258  :     }
; 259  : }

  00017	c3		 ret	 0
$LN5@:

; 177  :     }
; 178  : 
; 179  :     if (pi->Id == 0) {

  00018	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0001b	85 d2		 test	 edx, edx
  0001d	75 53		 jne	 SHORT $LN4@

; 180  : 
; 181  :         // Static C++ constructors.  Ideally, there would be none.
; 182  :         _cinit();

  0001f	e8 00 00 00 00	 call	 ?_cinit@@YAHXZ		; _cinit

; 183  : 
; 184  :         ArmSerialOut("HalEntry 2\n");
; 185  : 
; 186  :         // Initialize the target.
; 187  :         Class_Microsoft_Singularity_Isal_Isa::g_Initialize(bi->CpuRecordPointerOffset,
; 188  :                                                              bi->ThreadRecordPointerOffset);

  00024	8b 57 78	 mov	 edx, DWORD PTR [edi+120]
  00027	8b 4f 74	 mov	 ecx, DWORD PTR [edi+116]
  0002a	e8 00 00 00 00	 call	 ?g_Initialize@Class_Microsoft_Singularity_Isal_Isa@@SIXHH@Z ; Class_Microsoft_Singularity_Isal_Isa::g_Initialize

; 189  : 
; 190  :         Class_Microsoft_Singularity_Isal_Isa::g_InitializeCpu(
; 191  :             (Struct_Microsoft_Singularity_Isal_CpuRecord *)pi->CpuRecordPage,
; 192  :             pi->Id,
; 193  :             (UIntPtr) pi->KernelStackLimit);

  0002f	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00032	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00035	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?g_InitializeCpu@Class_Microsoft_Singularity_Isal_Isa@@SIXPAUStruct_Microsoft_Singularity_Isal_CpuRecord@@HPAUuintPtr@@@Z ; Class_Microsoft_Singularity_Isal_Isa::g_InitializeCpu

; 194  : 
; 195  :         ArmSerialOut("HalEntry 3\n");
; 196  : 
; 197  :         // Initialize processor context
; 198  :         ProcessorInitialize(pi);

  0003e	8b ce		 mov	 ecx, esi
  00040	e8 00 00 00 00	 call	 ?ProcessorInitialize@@YIXPAUClass_Microsoft_Singularity_Hal_Cpu@@@Z ; ProcessorInitialize

; 199  : 
; 200  :         ArmSerialOut("HalEntry 4\n");
; 201  : 
; 202  :         // Assert that processor local store is working correctly
; 203  :         if (Class_Microsoft_Singularity_Hal_Platform::g_GetCurrentCpu() != pi) {

  00045	e8 00 00 00 00	 call	 ?g_GetCurrentProcessorContext@Class_Microsoft_Singularity_Processor@@SIPAUStruct_Microsoft_Singularity_ProcessorContext@@XZ ; Class_Microsoft_Singularity_Processor::g_GetCurrentProcessorContext
  0004a	39 b0 a0 04 00
	00		 cmp	 DWORD PTR [eax+1184], esi
  00050	74 01		 je	 SHORT $LN3@

; 204  :             __debugbreak();

  00052	cc		 int	 3
$LN3@:

; 205  :         }
; 206  : 
; 207  :         ArmSerialOut("HalEntry 6\n");
; 208  : 
; 209  :         // Set up native-only constants
; 210  :         // Initialize platform (in a platform-specific way)
; 211  :         InitPlatform(bi, pi);

  00053	8b d6		 mov	 edx, esi
  00055	8b cf		 mov	 ecx, edi
  00057	e8 00 00 00 00	 call	 ?InitPlatform@@YIXPAUClass_Microsoft_Singularity_Hal_Platform@@PAUClass_Microsoft_Singularity_Hal_Cpu@@@Z ; InitPlatform

; 212  :         ArmSerialOut("HalEntry 7\n");
; 213  : 
; 214  :         // Initialize tracing
; 215  :         Class_Microsoft_Singularity_Tracing::g_Initialize();

  0005c	e8 00 00 00 00	 call	 ?g_Initialize@Class_Microsoft_Singularity_Tracing@@SIXXZ ; Class_Microsoft_Singularity_Tracing::g_Initialize

; 216  : 
; 217  :         ArmSerialOut("HalEntry 8\n");
; 218  : 
; 219  :         // Initialize debugger
; 220  :         KdInitialize(bi);

  00061	8b cf		 mov	 ecx, edi
  00063	e8 00 00 00 00	 call	 ?KdInitialize@@YIXPAUClass_Microsoft_Singularity_Hal_Platform@@@Z ; KdInitialize

; 221  : 
; 222  :         ArmSerialOut("HalEntry 9\n");
; 223  : 
; 224  :         // Initial breakpoint - uncomment me to do early debugging
; 225  :         //if (bi->DebuggerType != Class_Microsoft_Singularity_Hal_Platform_DEBUGGER_NONE) {
; 226  :         //    __debugbreak();
; 227  :         //}
; 228  : 
; 229  :         Class_Microsoft_Singularity_Kernel::g_Main();

  00068	e8 00 00 00 00	 call	 ?g_Main@Class_Microsoft_Singularity_Kernel@@SIHXZ ; Class_Microsoft_Singularity_Kernel::g_Main
  0006d	5f		 pop	 edi

; 256  : 
; 257  :         return Class_Microsoft_Singularity_Hal_Platform_SUCCESS;

  0006e	33 c0		 xor	 eax, eax
  00070	5e		 pop	 esi

; 258  :     }
; 259  : }

  00071	c3		 ret	 0
$LN4@:

; 230  : 
; 231  :         ShutdownPlatform(bi);
; 232  :         // Native exits by returning back to the undump/bootloader
; 233  :         return 0;
; 234  :     }
; 235  :     else {
; 236  :         // Initialize the target cpu.
; 237  :         Class_Microsoft_Singularity_Isal_Isa::g_InitializeCpu(
; 238  :             (Struct_Microsoft_Singularity_Isal_CpuRecord *)pi->CpuRecordPage,
; 239  :             pi->Id,
; 240  :             (UIntPtr) pi->KernelStackLimit);

  00072	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00075	51		 push	 ecx
  00076	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00079	e8 00 00 00 00	 call	 ?g_InitializeCpu@Class_Microsoft_Singularity_Isal_Isa@@SIXPAUStruct_Microsoft_Singularity_Isal_CpuRecord@@HPAUuintPtr@@@Z ; Class_Microsoft_Singularity_Isal_Isa::g_InitializeCpu

; 241  : 
; 242  :         // Initialize processor context
; 243  :         ProcessorInitialize(pi);

  0007e	8b ce		 mov	 ecx, esi
  00080	e8 00 00 00 00	 call	 ?ProcessorInitialize@@YIXPAUClass_Microsoft_Singularity_Hal_Cpu@@@Z ; ProcessorInitialize

; 244  : 
; 245  :         // Initialize platform processor
; 246  :         InitCpu(pi);

  00085	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?CpuRuntimeType@@3PAUClass_System_RuntimeType@@A ; CpuRuntimeType
  0008b	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0008e	8b ce		 mov	 ecx, esi
  00090	89 06		 mov	 DWORD PTR [esi], eax
  00092	e8 00 00 00 00	 call	 ?m_Initialize@Class_Microsoft_Singularity_Hal_Cpu@@SIXPAU1@@Z ; Class_Microsoft_Singularity_Hal_Cpu::m_Initialize
  00097	e8 00 00 00 00	 call	 ?g_InitializeCpuDispatchTable@Class_Microsoft_Singularity_Isal_Isa@@SIXXZ ; Class_Microsoft_Singularity_Isal_Isa::g_InitializeCpuDispatchTable

; 247  : 
; 248  :         // Assert that processor local store is working correctly
; 249  :         if (Class_Microsoft_Singularity_Hal_Platform::g_GetCurrentCpu() != pi) {

  0009c	e8 00 00 00 00	 call	 ?g_GetCurrentProcessorContext@Class_Microsoft_Singularity_Processor@@SIPAUStruct_Microsoft_Singularity_ProcessorContext@@XZ ; Class_Microsoft_Singularity_Processor::g_GetCurrentProcessorContext
  000a1	39 b0 a0 04 00
	00		 cmp	 DWORD PTR [eax+1184], esi
  000a7	74 01		 je	 SHORT $LN1@

; 250  :             __debugbreak();

  000a9	cc		 int	 3
$LN1@:

; 251  :         }
; 252  : 
; 253  :         int result = Class_Microsoft_Singularity_Kernel::g_MpMain(pi->Id);

  000aa	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000ad	e8 00 00 00 00	 call	 ?g_MpMain@Class_Microsoft_Singularity_Kernel@@SIHH@Z ; Class_Microsoft_Singularity_Kernel::g_MpMain

; 254  : 
; 255  :         ShutdownCpu(pi);

  000b2	8b ce		 mov	 ecx, esi
  000b4	e8 00 00 00 00	 call	 ?ShutdownCpu@@YIXPAUClass_Microsoft_Singularity_Hal_Cpu@@@Z ; ShutdownCpu
  000b9	5f		 pop	 edi

; 256  : 
; 257  :         return Class_Microsoft_Singularity_Hal_Platform_SUCCESS;

  000ba	33 c0		 xor	 eax, eax
  000bc	5e		 pop	 esi

; 258  :     }
; 259  : }

  000bd	c3		 ret	 0
@HalEntryPoint@8 ENDP
_TEXT	ENDS
END
