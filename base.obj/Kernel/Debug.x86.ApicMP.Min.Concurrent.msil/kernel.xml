<?xml version="1.0"?>
<doc>
    <assembly>
        <name>kernel</name>
    </assembly>
    <members>
        <member name="M:System.Object.GcMark(System.UIntPtr)">
            <summary>
            Test and set the state of the GC mark bit to be the same
            as the passed flag. Note that this operation is not
            synchronized so it is possible for multiple marking threads
            to 'mark' the same object.
            </summary>
        </member>
        <member name="M:System.Object.GcMark">
            <summary>
            Return the current state of the GC mark bit.
            </summary>
        </member>
        <member name="T:System.ObjectDisposedException">
            <devdoc>
               <para> The exception that is thrown when accessing an object that was
                  disposed.</para>
            </devdoc>
        </member>
        <member name="M:System.ObjectDisposedException.#ctor(System.String)">
            <devdoc>
            <para>Initializes a new instance of the <see cref="T:System.ObjectDisposedException"/> class.</para>
            </devdoc>
        </member>
        <member name="M:System.ObjectDisposedException.#ctor(System.String,System.String)">
            <devdoc>
            <para>Initializes a new instance of the <see cref="T:System.ObjectDisposedException"/> class.</para>
            </devdoc>
        </member>
        <member name="P:System.ObjectDisposedException.Message">
            <devdoc>
               <para>Gets the text for the message for this exception.</para>
            </devdoc>
        </member>
        <member name="M:System.Array.#ctor">
            <internalonly/>
        </member>
        <member name="P:System.CharEnumerator.System#Collections#IEnumerator#Current">
            <internalonly/>
        </member>
        <member name="P:System.RuntimeType.BaseType">
            Returns the base class for a class.  If this is an interface or has
            no base class null is returned.  Object is the only Type that does not 
            have a base class.  
        </member>
        <member name="M:System.RuntimeTypeHash.ComputeHash(System.Byte[],System.Int64@,System.Int64@)">
            
              Needs to be replaced with real hash computed over the
              signature of the type
            
        </member>
        <member name="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
            
        </member>
        <member name="M:System.String.StringCTOR(System.Char[],System.Int32,System.Int32)">
            
        </member>
        <member name="M:System.String.StringCTOR(System.Char[])">
            
        </member>
        <member name="M:System.String.SetChar(System.Int32,System.Char)">
            <internalonly/>
        </member>
        <member name="M:System.String.AppendInPlace(System.Char,System.Int32)">
            <internalonly/>
        </member>
        <member name="M:System.String.AppendInPlace(System.Char,System.Int32,System.Int32)">
            <internalonly/>
        </member>
        <member name="M:System.String.AppendInPlace(System.String,System.Int32)">
            <internalonly/>
        </member>
        <member name="M:System.String.AppendInPlace(System.Char[],System.Int32,System.Int32,System.Int32)">
            <internalonly/>
        </member>
        <member name="M:System.String.ReplaceCharInPlace(System.Char,System.Char,System.Int32,System.Int32,System.Int32)">
            <internalonly/>
        </member>
        <member name="M:System.String.GetStringForStringBuilder(System.String,System.Int32)">
            <internalonly/>
        </member>
        <member name="M:System.String.NullTerminate">
            <internalonly/>
        </member>
        <member name="M:System.String.ClearPostNullChar">
            <internalonly/>
        </member>
        <member name="M:System.String.SetLength(System.Int32)">
            <internalonly/>
        </member>
        <member name="M:System.String.System#Collections#IEnumerable#GetEnumerator">
            <internalonly/>
        </member>
        <member name="M:System.String.StringCTOR(System.Char*)">
             Creates a new string with the characters copied in from <i>ptr</i>. If
             <i>ptr</i> is null, a string initialized to
             &quot;&lt;No Object&gt;&quot; (i.e., <code>String.NullString</code>)
             is created.
            
             Issue: This method is only accessible from VC.
             @issue The verifier needs to recognize that this is not necessarily
              secure.
            
             @param ptr this is a WCHAR *.
            
        </member>
        <member name="M:System.String.InternalLength">
            This is an EE implemented function so that the JIT can recognise it and
            treat it specially by eliminating checks on character fetches.
        </member>
        <member name="P:System.String.ArrayLength">
            <internalonly/>
        </member>
        <member name="P:System.String.StringState">
            <summary>
            Get or set the string state for this string.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Processor.InitializeDispatcher(System.Int32)">
            
             <summary>
                 Initialize dispatcher
             </summary>
            
             <param name="processorId">Id of the processor dispatcher belongs to</param>
            
        </member>
        <member name="M:Microsoft.Singularity.Processor.ActivateTimer(System.Int32)">
            
             <summary>
                 Activate Timer
             </summary>
            
            
        </member>
        <member name="M:Microsoft.Singularity.Processor.IsOnInterruptStack(System.Threading.Thread)">
            
             <summary>
                 Verify if thread currently is running on interrupt stack
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Processor.SetNextTimerInterrupt(System.TimeSpan)">
            
             <summary>
             Set next alarm: timer that we are interested in
             </summary>
            
             <param name="delta">Time until the next time we would like to be awaken</param>
            
        </member>
        <member name="M:Microsoft.Singularity.Processor.StartApProcessors(System.Int32)">
            <summary> Start application processors. </summary>
        </member>
        <member name="M:Microsoft.Singularity.Processor.StopApProcessors">
            <summary> Stop application processors. </summary>
        </member>
        <member name="M:Microsoft.Singularity.Processor.GetRunningProcessorCount">
            <summary> Gets the number of processors in use by
            the system. </summary>
        </member>
        <member name="M:Microsoft.Singularity.Processor.GetProcessorCount">
            <summary> Gets the total number of processors known
            to the system.  This includes processors not
            currently in use by the system. </summary>
        </member>
        <member name="F:Microsoft.Singularity.Processor.ExpectedProcessors">
            <summary> Count of the number of processors expected to be running </summary>
        </member>
        <member name="F:Microsoft.Singularity.Processor.processorTable">
            <summary> Global processor table </summary>
        </member>
        <member name="F:Microsoft.Singularity.Processor.context">
            <summary> Processor contexts </summary>
        </member>
        <member name="F:Microsoft.Singularity.Processor.dispatcher">
            <summary> Processor dispatcher </summary>
        </member>
        <member name="F:Microsoft.Singularity.Processor.timer">
            <summary> Per processor HalTimer </summary>
        </member>
        <member name="F:Microsoft.Singularity.Processor.clock">
            <summary> Per processor HalClock </summary>
        </member>
        <member name="F:Microsoft.Singularity.Processor.halMemory">
            <summary> Hal memory interface </summary>
        </member>
        <member name="F:Microsoft.Singularity.Processor.timerInterrupt">
            <summary> Id of a timer interrupt </summary>
        </member>
        <member name="F:Microsoft.Singularity.Processor.clockInterrupt">
            <summary> Id of a clock interrupt</summary>
        </member>
        <member name="F:Microsoft.Singularity.Processor.inInterruptContext">
            <summary> Shows if a processor currently in a context of interrupt </summary>
        </member>
        <member name="F:Microsoft.Singularity.Processor.halted">
            <summary> Shows if a processor currently in halt state </summary>
        </member>
        <member name="F:Microsoft.Singularity.Processor.processorIndex">
            <summary> Processor Index </summary>
        </member>
        <member name="F:Microsoft.Singularity.Processor.NumExceptions">
            <summary> A number of exception occured on this processor </summary>
        </member>
        <member name="F:Microsoft.Singularity.Processor.NumInterrupts">
            <summary> A number of interrupts occrued on this processor </summary>
        </member>
        <member name="F:Microsoft.Singularity.Processor.NumContextSwitches">
            <summary> A number of context switches </summary>
        </member>
        <member name="F:Microsoft.Singularity.Processor.interruptCounts">
            <summary> A interrupt statistics per processor </summary>
        </member>
        <member name="F:Microsoft.Singularity.Processor.cyclesPerSecond">
            <summary> A number of cycles per second on a given processor </summary>
        </member>
        <member name="F:Microsoft.Singularity.Processor.runningCpus">
            <summary> A number of active Processors </summary>
        </member>
        <member name="F:Microsoft.Singularity.Processor.kernelThread">
            <summary> An initial per processor kernel thread </summary>
        </member>
        <member name="F:Microsoft.Singularity.Processor.kernelStackBegin">
            <summary>Beginning of kernel thread stack </summary>
        </member>
        <member name="F:Microsoft.Singularity.Processor.kernelStackLimit">
            <summary> Limit of kernel thread stack </summary>
        </member>
        <member name="P:Microsoft.Singularity.Processor.Dispatcher">
            
             <summary>
                 Retrieve current dispatcher
             </summary>
        </member>
        <member name="P:Microsoft.Singularity.Processor.IsUP">
            
             <summary>
                 Is system MP or UP
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Isal.Isa.GetStackReturnAddresses(System.UIntPtr@,System.UIntPtr@,System.UIntPtr@)">
            <summary>
            Provides a mini stack trace starting from the caller of the caller
            of this method.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Isal.Isa.GetStackReturnAddresses(System.UIntPtr[])">
            <summary>
            Provides the full stack trace starting from the caller of the caller
            of this method.
            </summary>
            <returns>Return address values in stack array from top to bottom</returns>
        </member>
        <member name="T:Microsoft.Singularity.Scheduling.ProcessorDispatcher">
            
             <summary>
             A Processor Dispatcher is responsible for handling processor runnable queue,
             timer and i/o interrupts as well as forwarding a dispatching event to a proper scheduler
             if required
            
             </summary>
            
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.ProcessorDispatcher.maxStoppedThreadQueueLength">
            <summary>Length of the stopped thread queue</summary>
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.StaticInitialize(Microsoft.Singularity.Scheduling.Scheduler)">
            
             <summary>
             Initialize processor dispatcher
             </summary>
            
             <param name="schedulerToUse">Scheduler to use</param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.#ctor">
            
             <summary>
               Constructor
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.Initialize(Microsoft.Singularity.Processor)">
            
             <summary>
             First part of the initialization of processor dispatcher
             </summary>
            
             <param name="myProcessor">Processor dispatcher belongs to</param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.Finalize">
            
             <summary>
             Finalize method
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.IsIdleThread(System.Int32)">
            
             <summary>
             Check if thread index maps to idle thread
             </summary>
            
             <param name="threadIndex">Thread index to check if it is actually idle or not</param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.IsIdleThread(System.Threading.Thread)">
            
             <summary>
             Check if thread is an idle thread
             </summary>
            
             <param name="thread">Thread to check if it is idle</param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.IsMyIdleThread(System.Threading.Thread)">
            
             <summary>
             Check if thread is an idle thread
             </summary>
            
             <param name="thread">Thread to check if it is idle</param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.IsOneOfMyDispatcherThreads(System.Threading.Thread)">
            
             <summary>
             Check if thread is one of a dispatcher's threads
             </summary>
            
             <param name="thread">Thread to check if it is idle</param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.HandleIOReschedule">
            
             <summary>
             Handle I/O interrupt and perform context switch if required
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.HandlePreemptionReschedule(Microsoft.Singularity.Hal.HalTimer)">
            
             <summary>
             Handle timer interrupt and perform context switch if required
             </summary>
            
             <preconditions>
             Interrupts disabled
             Thread is not running from processor point of view
             </preconditions>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.NotifyTimerInterrupt(System.Int32,System.SchedulerTime)">
            
             <summary>
             Actual implementation of notifying the scheduler about the timer interrupt
             </summary>
            
             <param name="processorId">Id of the processor, correspond to affinity of the threads.
             Note during system shutdown this is virtualized.</param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.AddRunnableThread(System.Threading.Thread)">
            
             <summary>
             Add runnable thread to runnable queue
             </summary>
            
             <param name="threadToAdd">Thread to add to runnable queue</param>
            
             <remark>
             During this operation we have to keep interrupts disabled even though we might
             be adding a thread to different dispatcher - the problem is if we enable interrupts we
             might get reschedule to the dispatcher which lock we currently holding  - that will
             cause definite deadlock
             </remark>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.SwitchContext(System.Threading.ThreadState)">
            
             <summary>
             Switch to the new thread context.
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.OnProcessorShutdown(System.Threading.Thread)">
            
             <summary>
             Shutdown this processor as part of system shutdown. All running and runnable
             threads on this processor will be run on the boot processor after this.
            
             This must NOT be called on the boot processor.
            
             To avoid race conditions, the shutdown was done by letting the boot processor
             work with the scheduler to run all runnable threads on the system. The scheduler
             doesn't have any knowledge of the shutdown, ProcessorDispatcher takes care of all
             the necessary plumbing.
            
             See also comments on data members: isDispatcherInUse and isActingForEntireSystem.
             </summary>
            
             <param name="currentThread">Thread currently running </param>
            
             <remarks>This method should be called with interrupt disabled</remarks>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.AddRunnableThreadIfRunnable(System.Threading.Thread,System.Threading.ThreadState)">
            
             <summary>
             Add threadToAdd to its scheduler's runnable queue if it's in the right state.
             It's possible that the thread is ready to be blocked, in which case this
             function call will change the thread's state to blocked and it will not be
             added to the runnable queue.
             </summary>
            
             <param name="threadToAdd">Thread to add to runnable queue</param>
             <param name="schedulerAction">The state of the thread</param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.FindSchedulerThreadToRun(System.Threading.Thread,System.Threading.ThreadState,System.SchedulerTime)">
            
             <summary>
             Run the scheduler to find a thread to run.
             </summary>
            
             <param name="schedulerThread">Thread that was previously running</param>
             <param name="schedulerAction">Whether the previously running thread is blocked</param>
             <param name="currentTime">Current wall clock time</param>.
             <returns> The thread to run next, null if there is no thread to run</returns>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.FindSchedulerThreadToRunInternal(System.Threading.Thread,System.Threading.ThreadState,System.Int32,System.SchedulerTime)">
            
             <summary>
             Actual implementation to run the scheduler to find a thread to run.
             </summary>
            
             <param name="schedulerThread">Thread that was previously running</param>
             <param name="schedulerAction">Whether the previously running thread is blocked</param>
             <param name="processorId">Id of the processor, correspond to affinity of the threads.
             Note during system shutdown this is virtualized.</param>
             <param name="currentTime">Current wall clock time</param>.
             <returns> The thread to run next, null if there is no thread to run</returns>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.ChooseThreadOrScavengerToRun(System.Threading.Thread,System.Threading.ThreadState,System.SchedulerTime)">
            
             <summary>
             Run schedulers Helper method finds actual threads to run
             </summary>
            
             <param name="schedulerThread">If currentThread is idle or scavenger, then
             schedulerThread is null, otherwise it's same as currentThread</param>
             <param name="schedulerAction">State of the currentThread</param>
             <param name="currentTime">Current wall clock time</param>.
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.RunScheduler(System.Threading.Thread,System.Threading.ThreadState,System.SchedulerTime)">
            
             <summary>
             Run scheduler and retrieve a thread to run
             </summary>
            
             <param name="currentThread">The current running thread</param>
             <param name="schedulerAction">State of the currentThread</param>
             <param name="currentTime">Current wall clock time</param>.
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.SwitchThreadContextInternal(System.Threading.Thread,System.Threading.Thread)">
            
             <summary>
             Switch to the new thread context.  This works differently depending on
             whether we are in interrupt mode or not.
             </summary>
            
             <param name="currentThread">Thread we are currently executing on</param>
             <param name="threadSwitchTo">Thread switch to</param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.TransferToThreadContext(Microsoft.Singularity.ThreadContext@,Microsoft.Singularity.ThreadContext@)">
            
             <summary>
             Transfer control from the current to a new thread context, obeying the
             synchronization requirements
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.SwitchTo(System.Threading.Thread)">
            
             <summary>
             Switch processor to this thread
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.TryMarkIdle">
            
             <summary>
             Try to mark dispather as idle we only can do it if we still in context switch state
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.MarkActive">
            
             <summary>
             Mark dispather as active - should be always called from the thread running on
             dispatcher
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.MarkActiveWithRequest">
            
             <summary>
             Try to mark dispatcher as active with request - should be always called from the thread running on
             dispatcher
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.GetNextDispatcherToActivate">
            
             <summary>
             Calculate next disaptcher to activate
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.ActivateDispatcher">
            
             <summary>
             Activate disaptcher - if it is idle send IPI
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.IdleThreadLoop">
            
             <summary>
             Ilde thread loop
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.ScavengerThreadLoop">
            
             <summary>
             Scavenger thread loop
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.EnqueueStoppedThread(System.Threading.Thread)">
            
             <summary>
             Enqueue stopped thread
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.ValidateCommonInvariantsOnEnter(System.Threading.Thread)">
            
             <summary>
             Validated common invariants that should hold true for every entry point
             to dispatcher, except for addrunnable thred
             </summary>
            
             <param name="currentThread">Thread dispatcher is currently bound to"</param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.ValidateCommonInvariantsOnExit(System.Threading.Thread)">
            
             <summary>
             Validated common invariant that should hold true for every exit point
             from dispatcher, except for addrunnable thred
             </summary>
            
             <param name="currentThread">Thread dispatcher is currently bound to"</param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.ValidateInvariantsOnInterruptEnter(System.Threading.Thread)">
            
             <summary>
             Validate invariants that should hold true for every entry point
             to dispatcher on interrupt
             </summary>
            
             <param name="currentThread">Thread dispatcher is currently bound to"</param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.ValidateInvariantsOnInterruptExit">
            
             <summary>
             Validate invariants that should hold true for every exit point
             from dispatcher's interrupt handler
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.ValidateInvariantsOnSwitchContexEnter(System.Threading.Thread)">
            
             <summary>
             Validate invariants that should hold true for entry point
             to dispatcher through SwitchContext call
             </summary>
            
             <param name="currentThread">Thread dispatcher is currently bound to"</param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.ValidateInvariantsOnSwitchContextExit">
            
             <summary>
             Validate invariants that should hold true for exit point
             from dispatcher's SwitchContext call
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.ValidateInvariantsOnAddRunnableThreadEnter(System.Threading.Thread,System.Threading.Thread)">
            
             <summary>
             Validate invariants that should hold true for entry point
             to dispatcher through AddRunnableThread call
             </summary>
            
             <param name="currentThread">Thread dispatcher is currently bound to"</param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.ValidateInvariantsOnAddRunnableThreadExit(System.Threading.Thread,System.Threading.Thread)">
            
             <summary>
             Validate invariants that should hold true for entry point
             from dispatcher's AddRunnableThread call. At this point we can't make any
             assumptions about new thread
             </summary>
            
             <param name="currentThread">Thread dispatcher is currently bound to"</param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.AssertCurrentProcessor(System.Int32)">
            
             <summary>
             Assert that we are running on the processor we are thinking we are running on
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ProcessorDispatcher.UpdateStats(System.Threading.Thread,System.Threading.Thread)">
            
             <summary>
             Record debugging event
             </summary>
            
             <param name="currentThread">Current thread</param>
             <param name="threadSwitchTo">Thread we are switchint to</param>
            
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.ProcessorDispatcher.isDispatcherInUse">
            <summary>
            True if the processor is in use, including halted during idle.
            False only if the processor is down during system shutdown.
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.ProcessorDispatcher.isActingForEntireSystem">
            <summary>
            True only on boot processor during shutdown when all other processors are down
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.ProcessorDispatcher.nextVirtualProcessorId">
            <summary>
            Only used when isActingForEntireSystem is true, the next processorId to simulate
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.ProcessorDispatcher.numberOfDispatchers">
            <summary>Number of dispatchers in the system</summary>
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.ProcessorDispatcher.nextDispatcherToActivate">
            <summary> Next dispatcher to activate </summary>
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.ProcessorDispatcher.scheduler">
            <summary>Threre is a single dispatch lock per processor dispatcher</summary>
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.ProcessorDispatcher.id">
            <summary>Dispatcher Id</summary>
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.ProcessorDispatcher.myProcessor">
            <summary> Processor object to which dispatcher is bound </summary>
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.ProcessorDispatcher.stoppedThreadQueue">
            <summary> Thread queue is used to collect stopped threads </summary>
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.ProcessorDispatcher.stoppedThreadQueueLength">
            <summary>Length of the stopped thread queue</summary>
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.ProcessorDispatcher.scavengerThreadQueue">
            <summary> Thread queue is used to scavanged stopped threads </summary>
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.ProcessorDispatcher.idleThread">
            <summary> A pool of idle thread used by dispatcher </summary>
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.ProcessorDispatcher.scavengerThread">
            <summary> A dispatcher helper thread that is performing scavanging and other types of work </summary>
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.ProcessorDispatcher.runningThread">
            <summary> A current thread currently running on the processor </summary>
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.ProcessorDispatcher.currentState">
            <summary> State of the dispatcher - (idle, halted, running) </summary>
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.ProcessorDispatcher.isScavengerRunning">
            <summary> State of scavenger thread </summary>
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.ProcessorDispatcher.screenPos">
            <summary> Possition twiddle on the screen</summary>
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.ProcessorDispatcher.screenPtr">
            <summary>Virtual address of the screen memory</summary>
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.ProcessorDispatcher.tpos">
            <summary> Current possition inside of array</summary>
        </member>
        <member name="P:Microsoft.Singularity.Scheduling.ProcessorDispatcher.Processor">
            
             <summary>
             Retrieve Kernel scheduler
             </summary>
            
        </member>
        <member name="T:Microsoft.Singularity.Scheduling.ProcessorDispatcher.Affinity">
            
             <summary>
             Affinity consts states
             </summary>
            
        </member>
        <member name="T:Microsoft.Singularity.Scheduling.ProcessorDispatcher.State">
            
             <summary>
             Dispatcher State
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.Scheduler.#ctor">
            
             <summary>
             Constructor - is used to generate scheduler Ids
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.Scheduler.RunPolicy(System.Int32,System.Threading.Thread,System.Threading.ThreadState,System.SchedulerTime)">
            
             <summary>
             Run scheduling policy to decide the next thread to run
             </summary>
            
             <param name="affinity">Set the returned running thread to this affinity.</param>
             <param name="currentThread">the thread currently running</param>
             <param name="schedulerAction">thread state to change to for the current thread</param>
             <param name="currentTime">Current system time</param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.Scheduler.RetrieveSchedulerLock(System.Int32)">
            
             <summary>
             Retrieve scheduler lock - used by dispatcher to protect scheduler state
             </summary>
            
        </member>
        <member name="T:Microsoft.Singularity.Scheduling.Scheduler.Hint">
            
             <summary>
                Scheduler hints for enquing threads
             </summary>
            
        </member>
        <member name="T:Microsoft.Singularity.Scheduling.SchedulerLock">
            
             <summary>
             Scheduler lock class is used to wrap a spinlock structure so that it can be shared with a
             dispatcher.
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.SchedulerLock.#ctor">
            
             <summary>
             Constructor
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.SchedulerLock.Acquire(System.Threading.Thread)">
            
             <summary>
             A method is used to acquire scheduler lock
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.SchedulerLock.Release(System.Threading.Thread)">
            
             <summary>
             A method is used to release scheduler lock
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.SchedulerLock.Acquire">
            
             <summary>
             A method is used to acquire scheduler lock
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.SchedulerLock.TryAcquire">
            
             <summary>
             Try to acquire the spin lock. Always return immediately.
             </summary>
             <returns> true if the spin lock is acquired. </returns>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.SchedulerLock.Release">
            
             <summary>
             A method is used to release scheduler lock
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.SchedulerLock.IsHeldBy(System.Threading.Thread)">
            
             <summary>
             Check if thread holds the spinlock
             </summary>
            
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.SchedulerLock.spinlock">
            <summary> Actual spinlock that class wraps </summary>
        </member>
        <member name="P:Microsoft.Singularity.Scheduling.ThreadEntry.Id">
            
             <summary>
                 Set/Get Entry Id
             </summary>
            
        </member>
        <member name="T:Microsoft.Singularity.Scheduling.ThreadEntryEnum">
            
             <summary>
             Class to enumerate thread entries in a queue
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ThreadEntryEnum.#ctor(Microsoft.Singularity.Scheduling.ThreadEntry)">
            
             <summary>
             Constructor
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.ThreadEntryEnum.GetNext">
            
             <summary>
             GetNext element in enumarator
             </summary>
            
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.ThreadEntryEnum.current">
            <summary> Current element in enumerator</summary>
        </member>
        <member name="T:Microsoft.Singularity.Scheduling.MinScheduler">
            <summary>
            Summary description for MinScheduler.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.MinScheduler.#ctor">
            
             <summary>
             Constructor for MinScheduler object
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.MinScheduler.Initialize">
             <summary>
             Initialize min scheduler
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.MinScheduler.Finalize">
             <summary>
             Finalize scheduler object
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.MinScheduler.OnDispatcherInitialize(System.Int32)">
            
             <summary>
             Notify scheduler about new dispatcher
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.MinScheduler.OnThreadStateInitialize(System.Threading.Thread,System.Boolean)">
             <summary>
             Attach thread to scheduler: thread specific initializtion
             </summary>
            
             <param name="thread">Thread to attach </param>
             <param name="constructorCalled">Have we called thread constructor </param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.MinScheduler.RetrieveSchedulerLock(System.Int32)">
            
             <summary>
             Retrieve scheduler lock - used by dispatcher to protect scheduler state
             </summary>
            
             <param name="affinity">Affinity of dispatcher making actual call</param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.MinScheduler.RunPolicy(System.Int32,System.Threading.Thread,System.Threading.ThreadState,System.SchedulerTime)">
            
             <summary>
             Run scheduling policy. This method is called by dispatcher when both interrupts
             disabled and disptach lock is acquired. As long as multiple dispatchers don't have access
             to the this method no protection is required.
             </summary>
            
             <param name="affinity">Set the returned running thread to this affinity.</param>
             <param name="currentThread">the thread currently running</param>
             <param name="schedulerAction">thread state to change to for the current thread</param>
             <param name="currentTime">Current system time</param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.MinScheduler.AddRunnableThread(System.Threading.Thread)">
            
             <summary>
             Add thread to runnable queue.  This method is called by dispatcher at the
             point when both dispatcher lock and interrupts are disabled
             </summary>
            
             <param name="thread">Thread to add to runnable queue </param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.MinScheduler.OnThreadStart(System.Threading.Thread)">
            
             <summary>
             Start thread - put a thread on dispatcher's runnable queue so it can be run
             </summary>
            
             <param name="thread">Thread to start </param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.MinScheduler.OnThreadBlocked(System.Threading.Thread,System.SchedulerTime)">
            
             <summary>
             Block thread -process thread blocking including putting it on a timer queue if
             timeout is specified.
             </summary>
            
             <param name="thread">Thread that blocks </param>
             <param name="stop">Amount of time for the thread to be blocked</param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.MinScheduler.OnThreadUnblocked(System.Threading.Thread)">
            
             <summary>
             Unblock thread - resume thread by putting it on the dispatcher runnable  queue.
             This method can be invoked by threads running on other processors
             </summary>
            
             <param name="thread">Thread to resume </param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.MinScheduler.OnThreadYield(System.Threading.Thread)">
            
             <summary>
             Yield thread - suspend thread based on time slice
             </summary>
            
             <param name="thread">Thread that is yielding </param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.MinScheduler.OnThreadStop(System.Threading.Thread)">
            
             <summary>
             Stop thread execution
             </summary>
            
             <param name="thread">Thread that is stopping </param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.MinScheduler.OnThreadFreezeIncrement(System.Threading.Thread)">
            
             <summary>
             Increment frozen counter
             </summary>
            
             <param name="thread">Thread for which to increment freeze counter </param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.MinScheduler.OnThreadFreezeDecrement(System.Threading.Thread)">
            
             <summary>
             Decrement frozen counter
             </summary>
            
             <param name="thread">Thread for which to update freeze counter </param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.MinScheduler.Suspend(System.Threading.Thread)">
            
             <summary>
             Suspend thread and wait until it is suspended.
             </summary>
            
             <param name="thread">Thread to suspend </param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.MinScheduler.Resume(System.Threading.Thread)">
            
             <summary>
             Resume thread from being suspended
             </summary>
            
             <param name="thread">Thread to resume </param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.MinScheduler.OnTimerInterrupt(System.Int32,System.SchedulerTime)">
            
             <summary>
             Dispatch timer interrupt. This method is called by dispather when interrupts are
             disabled.
             </summary>
            
             <param name = "affinity">Processor affinity</param>
             <param name = "now">Current time</param>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.MinScheduler.RemoveTimer(System.Threading.Thread)">
            
             <summary>
             Remove a timer from timer queue: if thread is still on a timer queue. Need to
             disable interrupts before acquire timer lock - dispatcher always calls into timer
             with interrupts disable. If we don't disable interrupts we will get into possible deadlock
             with dispatcher
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.Scheduling.MinScheduler.EnqueueTimer(System.Threading.Thread,System.SchedulerTime)">
            
             <summary>
             Park blocking thread in a timer queue with a given time out. Need to
             disable interrupts before acquiring timer lock - dispatcher always calls into timer
             with interrupts disable. If we don't disable interrupts we will get into deadlock
             </summary>
            
             <param name="thread">Thread to block</param>
             <param name="stop">Period of time for a thread to wait before timeout</param>
            
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.MinScheduler.runnableLock">
            <summary> A spinlock protecting state of the timer queue </summary>
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.MinScheduler.timerLock">
            <summary> A spinlock protecting state of the timer queue </summary>
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.MinScheduler.unblockedThreads">
            <summary> List of recently runnable, but unscheduled threads. </summary>
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.MinScheduler.runnableThreads">
            <summary> List of runnable, but unscheduled threads. </summary>
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.MinScheduler.timerThreads">
            <summary> List of blocked threads, sorted by wait time. </summary>
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.MinScheduler.affinity">
            <summary> Scheduler affinity </summary>
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.MinScheduler.nextTimer">
            <summary> List of frozen threads (unsorted) </summary>
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.MinScheduler.idleThread">
            <summary> Idle thread </summary>
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.MinScheduler.minSlice">
            <summary> Run time slice </summary>
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.MinScheduler.idleSlice">
            <summary> Run time for idle slice </summary>
        </member>
        <member name="F:Microsoft.Singularity.Scheduling.MinScheduler.isIpiNeeded">
            <summary> Check if need to process interprocess interrupt </summary>
        </member>
        <member name="P:Microsoft.Singularity.Scheduling.MinScheduler.MyLock">
            
             <summary>
             Property to get to the scheduler runnable queue lock
             </summary>
            
        </member>
        <member name="P:Microsoft.Singularity.Scheduling.MinScheduler.Affinity">
            
             <summary>
             Get the affinity of this base scheduler
             </summary>
            
        </member>
        <member name="T:System.Threading.AutoResetEvent">
            
             <summary>
                 Event class implementing an event with auto reset symantics such event automatically
                 reset to non signaled state when single wait is satisfied
             </summary>
            
        </member>
        <member name="T:System.Threading.WaitHandle">
            
             <summary>
             Base class for all synchronization objects such as events and mutex
             </summary>
            
        </member>
        <member name="T:System.Threading.WaitHandleBase">
            
             <summary>
             Base class for all synchronization objects such as events and mutex
             </summary>
            
        </member>
        <member name="F:System.Threading.WaitHandleBase.WaitTimeout">
            <summary > Time out constant</summary>
        </member>
        <member name="F:System.Threading.WaitHandleBase.UninitWait">
            <summary > Time out constant</summary>
        </member>
        <member name="F:System.Threading.WaitHandleBase.InfinityTimeout">
            <summary> Infinite time out </summary>
        </member>
        <member name="F:System.Threading.WaitHandleBase.UnblockedByGC">
            <summary> GC uses this for unblocked by information </summary>
        </member>
        <member name="F:System.Threading.WaitHandleBase.UnblockedByAbort">
            <summary> Unblocked by abort </summary>
        </member>
        <member name="M:System.Threading.WaitHandleBase.#ctor(System.Threading.WaitHandleBase.SignalState,System.Threading.WaitHandleBase.SignalState)">
            
             <summary>
             Constructor
             </summary>
            
             <param name="initialState">Initial state of an handle </param>
             <param name="signalStateAfterImediateWait">
                Value represents a state of a handle when wait satisfied right a way
             </param>
            
        </member>
        <member name="M:System.Threading.WaitHandleBase.SignalOneWithNoWakeup(System.Threading.WaitHandleBase.SignalState)">
            
             <summary>
             Perform the work to signal wait handle or if there are no waiters
             set handle to specified stated. Put the signaled waiter to a deferred
             wakeup queue if there is any and return the queue.
             </summary>
            
             <param name="signalStateIfNoWaiters">
             Set the wait handle into specified state if no waiters present
             </param>
            
        </member>
        <member name="M:System.Threading.WaitHandleBase.WakeupOneWaiter(Microsoft.Singularity.Scheduling.ThreadQueueStruct)">
            
             <summary>
             Wakeup a single waiter in the deferred queue if there is one.
             </summary>
            
             <param name="deferredWakeupQueue">The queue that contains the waiter thread</param>
            
        </member>
        <member name="M:System.Threading.WaitHandleBase.SignalAllWithNoWakeup(System.Threading.WaitHandleBase.SignalState,System.Threading.WaitHandleBase.SignalState)">
            
             <summary>
             Perform the work to signal all waiters and then set handle to specified stated.
             Put the signaled waiters to a deferred wakeup queue if there is any and
             return the queue.
             </summary>
            
             <param name="signalStateIfNoWaiters">
             Set the wait handle into specified state if no waiters present
             </param>
            
             <param name="signalStateIfWaiters">
             Set the wait handle into specified state if waiter are present
             </param>
            
        </member>
        <member name="M:System.Threading.WaitHandleBase.WakeupAllWaiters(Microsoft.Singularity.Scheduling.ThreadQueueStruct)">
            
             <summary>
             Wakeup all waiters in the deferred queue if there are any
             </summary>
            
             <param name="deferredWakeupQueue">The queue that contains the waiter threads</param>
            
        </member>
        <member name="M:System.Threading.WaitHandleBase.AcquireOrEnqueue(Microsoft.Singularity.Scheduling.ThreadEntry,System.Int32)">
            
             <summary>
             Depending on the state of a handle decide either to acquire handle or wait
             </summary>
            
             <param name="entry">
             Thread entry to enqueu onto waiting queue when can't satisfy request
             </param>
             <param name="handleId">
             Id of the handle that we are trying to acquire - is used to check if thread can be unblocked
             </param>
            
        </member>
        <member name="M:System.Threading.WaitHandleBase.PreWaitAnyInternal(System.Threading.Thread,System.Threading.WaitHandleBase[],Microsoft.Singularity.Scheduling.ThreadEntry[],System.Int32)">
            
             <summary>
             Associate a thread with wait handles if one of the waits satisfied return
             waithandle id - actual unblocker. if none of the states satisfied return UninitWait
             indicating that thread has to proceede with blocking
             </summary>
            
        </member>
        <member name="M:System.Threading.WaitHandleBase.PostWaitAnyInternal(System.Threading.Thread,System.Threading.WaitHandleBase[],Microsoft.Singularity.Scheduling.ThreadEntry[],System.Int32)">
            
             <summary>
             Post wait is to dissasociate thread from all handlers
             </summary>
            
        </member>
        <member name="M:System.Threading.WaitHandleBase.WaitDone(Microsoft.Singularity.Scheduling.ThreadEntry,System.Int32,Microsoft.Singularity.Scheduling.ThreadQueueStruct@)">
            
             <summary>
             This method is called when a synchronization object completes the wait for
             thread.
             </summary>
            
             <param name="entry">Thread entry to signal</param>
             <param name="handleId">Id of wait handle</param>
             <param name="deferredQueue">Deferred queue to use for deferred wakeup</param>
            
        </member>
        <member name="M:System.Threading.WaitHandleBase.MoveEntryToSignalQueue(Microsoft.Singularity.Scheduling.ThreadEntry)">
            
             <summary>
             This method is called when a synchrnoization object completes the wait for
             thread.
             </summary>
            
             <param name="entry">Thread entry to move from unsignaled queue to singlaed</param>
            
        </member>
        <member name="M:System.Threading.WaitHandleBase.Remove(Microsoft.Singularity.Scheduling.ThreadEntry)">
            
             <summary>
             Remove entry from the wait handle
             </summary>
            
             <param name="entry">
             Entry to remove
             </param>
            
        </member>
        <member name="M:System.Threading.WaitHandleBase.GetBeneficiary">
            
             <summary>
             Return owner of a handle
             </summary>
            
             <remark>
             Consider removing this method
             </remark>
        </member>
        <member name="M:System.Threading.WaitHandleBase.CompleteWait(System.Threading.Thread)">
            
             <summary>
             Complete wait - used by mutex to record ownership
             </summary>
            
             <param name="ownerThread">Thread owner</param>
            
        </member>
        <member name="F:System.Threading.WaitHandleBase.signaled">
            <summary>State of the handler</summary>
        </member>
        <member name="F:System.Threading.WaitHandleBase.signalStateAfterImediateWait">
            <summary> Signal state after wait - policy of the child class </summary>
        </member>
        <member name="F:System.Threading.WaitHandleBase.owner">
            <summary> An owner of the handler </summary>
        </member>
        <member name="F:System.Threading.WaitHandleBase.waitingQueue">
            <summary> A waiting queue </summary>
        </member>
        <member name="F:System.Threading.WaitHandleBase.signaledQueue">
            <summary> A signaled queue </summary>
        </member>
        <member name="F:System.Threading.WaitHandleBase.id">
            <summary> A unique id of wait handler </summary>
        </member>
        <member name="F:System.Threading.WaitHandleBase.idGenerator">
            <summary> Uniqifier </summary>
        </member>
        <member name="F:System.Threading.WaitHandleBase.myLock">
            <summary> Lock to protect queues </summary>
        </member>
        <member name="T:System.Threading.WaitHandleBase.SignalState">
            <summary> The state of the handle, signaled or unsignaled </summary>
        </member>
        <member name="M:System.Threading.WaitHandle.#ctor(System.Threading.WaitHandleBase.SignalState,System.Threading.WaitHandleBase.SignalState,System.Threading.SpinLock.Types)">
            
             <summary>
             Constructor
             </summary>
            
             <param name="initialState">Initial state of an handle </param>
             <param name="signalStateAfterImediateWait">
              Value represents a state of a handle when wait satisfied right a way
             </param>
             <param name="spinLockType">The spin lock type of the wait handle</param>
            
        </member>
        <member name="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)">
            
             <summary>
             Wait on a handle with a specified time out.
             </summary>
            
             <param name="timeout">Time out </param>
            
        </member>
        <member name="M:System.Threading.WaitHandle.WaitOne(System.SchedulerTime)">
            
             <summary>
             Wait on a handle with a specified time out.
             </summary>
            
             <param name="stop">Time out </param>
            
        </member>
        <member name="M:System.Threading.WaitHandle.WaitOne">
            
             <summary>
             Wait on a handle without time out
             </summary>
            
        </member>
        <member name="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)">
            
             <summary>
             Wait on a set of handles until one of them becomes signaled with a specified time out.
             </summary>
            
             <param name="waitHandles">Wait handles to wait on </param>
             <param name="timeout">Time out </param>
            
        </member>
        <member name="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.SchedulerTime)">
            
             <summary>
             Wait on a set of handles until one of them becomes signaled with a specified time out.
             </summary>
            
             <param name="waitHandles">Wait handles to wait on </param>
             <param name="stop">Time out </param>
            
        </member>
        <member name="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])">
            
             <summary>
             Wait on a set of handles until one of them becomes signaled without timeout.
             </summary>
            
             <param name="waitHandles">Wait handles to wait on </param>
            
        </member>
        <member name="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.TimeSpan)">
            
             <summary>
             Wait on a set of handles until one of them becomes signaled with a specified time out.
             </summary>
            
             <param name="waitHandles">Wait handles to wait on </param>
             <param name="waitHandlesCount">A number of wait handles to wait on </param>
             <param name="timeout">Time out </param>
            
        </member>
        <member name="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.SchedulerTime)">
            
             <summary>
             Wait on a set of handles until one of them becomes signaled with a specified time out.
             </summary>
            
             <param name="waitHandles">Wait handles to wait on </param>
             <param name="waitHandlesCount">A number of wait handles to wait on </param>
             <param name="stop">Time out </param>
            
        </member>
        <member name="M:System.Threading.WaitHandle.SignalOne(System.Threading.WaitHandleBase.SignalState)">
            
             <summary>
             Signal wait handle by waking up a single waiter or if there are no waiters
             set handle to specified stated
             </summary>
            
             <param name="signalStateIfNoWaiters">
             Set the wait handle into specified state if no waiters   present
             </param>
            
        </member>
        <member name="M:System.Threading.WaitHandle.SignalAll(System.Threading.WaitHandleBase.SignalState,System.Threading.WaitHandleBase.SignalState)">
            
             <summary>
             Signal wait handle by waking up all waiters. Set wait handle into specified state
             in both cases when waiters present and not
             </summary>
            
             <param name="signalStateIfNoWaiters">
             Set the wait handle into specified state if no waiters present
             </param>
            
             <param name="signalStateIfWaiters">
             Set the wait handle into specified state if waiter are present
             </param>
            
        </member>
        <member name="F:System.Threading.WaitHandle.singleHandle">
            <summary>
            This field is an array of length 1 containing 'this'.
            It is used to avoid allocation when calling WaitAny from WaitOne.
            </summary>
        </member>
        <member name="M:System.Threading.AutoResetEvent.#ctor(System.Boolean)">
            
             <summary>
                 Constructor
            </summary>
            
             <param name="initialState">Initial state of an event true indciates that event is signaled</param>
            
        </member>
        <member name="M:System.Threading.AutoResetEvent.Reset">
            
             <summary>
                 Reset an event state to non signaled
            </summary>
            
        </member>
        <member name="M:System.Threading.AutoResetEvent.Set">
            
             <summary>
                 Wake up one waiter, if no waiters present set event into signaled state
            </summary>
            
        </member>
        <member name="M:System.Threading.AutoResetEvent.SetAll">
            
             <summary>
                 Wake up all waiters and if event is not signaled set it into signaled state
            </summary>
            
        </member>
        <member name="T:System.Threading.ManualResetEvent">
            
             <summary>
                 Event class implementing an event with manual reset symantics such event has to 
                 be manually set to unsignaled state
             </summary>
            
        </member>
        <member name="M:System.Threading.ManualResetEvent.#ctor(System.Boolean)">
            
             <summary>
                 Constructor
            </summary>
            
             <param name="initialState">Initial state of an event true indciates that event is signaled</param>
            
        </member>
        <member name="M:System.Threading.ManualResetEvent.Reset">
            
             <summary>
                 Reset an event state to non signaled
            </summary>
            
        </member>
        <member name="M:System.Threading.ManualResetEvent.Set">
            
             <summary>
                 Wake up all waiters and leave state signaled, if no waiters present set event into signaled state
            </summary>
            
        </member>
        <member name="T:System.Threading.Monitor">
             <summary>
             A monitor is used for synchronization. Only a single thread can
             hold the monitor at any given time.
            
             The monitor maintains two lists of threads: one for threads waiting
             to enter the monitor, and one for threads waiting for a pulse within
             the monitor.
             </summary>
            <summary>
            A monitor is used for synchronization. Only a single thread can
            hold the monitor at any given time.
            </summary>
        </member>
        <member name="M:System.Threading.Monitor.#ctor">
            <summary>
            Private so that only we can create instances.
            </summary>
        </member>
        <member name="M:System.Threading.Monitor.Pulse(System.Object)">
            <summary>
            Wake up a thread waiting on the monitor.
            </summary>
        </member>
        <member name="M:System.Threading.Monitor.PulseAll(System.Object)">
            <summary>
            Wake up all threads waiting on the monitor.
            </summary>
        </member>
        <member name="M:System.Threading.Monitor.TryEnter(System.Object)">
            <summary>
            Attempt to enter the monitor, returning immediately if it is
            already held by another thread.
            </summary>
        </member>
        <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
            <summary>
            Attempt to enter the monitor, returning if it can not be taken
            within the specified timeout.
            </summary>
        </member>
        <member name="M:System.Threading.Monitor.Wait(System.Object)">
            <summary>
            Wait to be woken up by a holder of the monitor.
            </summary>
        </member>
        <member name="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
            <summary>
            Wait to be woken up by a holder of the monitor. Give up after
            a specified timeout.
            </summary>
        </member>
        <member name="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
             <summary>
             Wait to be woken up by a holder of the monitor. Give up after
             a specified timeout.
            
             Overload exists to match the CLR. Exit Context not supported.
             </summary>
        </member>
        <member name="M:System.Threading.Monitor.Enter">
            <summary>
            Enter the monitor, blocking until it is held.
            </summary>
        </member>
        <member name="M:System.Threading.Monitor.Exit">
            <summary>
            Exit the monitor.
            </summary>
        </member>
        <member name="M:System.Threading.Monitor.Pulse">
            <summary>
            Wake up a single thread waiting on the monitor.
            </summary>
        </member>
        <member name="M:System.Threading.Monitor.PulseAll">
            <summary>
            Wake up all threads waiting on the monitor.
            </summary>
        </member>
        <member name="M:System.Threading.Monitor.TryEnter">
            <summary>
            Try to enter the monitor, returning immediately if it is
            already held.
            </summary>
        </member>
        <member name="M:System.Threading.Monitor.TryEnter(System.SchedulerTime)">
            <summary>
            Try to enter the monitor, giving up if it cannot be
            entered after a timeout.
            </summary>
        </member>
        <member name="M:System.Threading.Monitor.Wait(System.SchedulerTime)">
            <summary>
            Wait within the monitor for a Pulse.
            </summary>
        </member>
        <member name="M:System.Threading.Monitor.CreateMonitor(System.Object)">
            <summary>
            Ensure that the passed object has a monitor (and associated
            SyncBlock) allocated.
            </summary>
        </member>
        <member name="M:System.Threading.Monitor.FromAddress(System.UIntPtr)">
             <summary>
             Internal Type conversion method.
             Note: we don't use VTable.fromAddress because we
             cannot do a checked cast from Object to Monitor during GC
             (because the GC may be using the vtable word)
             </summary>
            
        </member>
        <member name="M:System.Threading.Monitor.GetMonitorFromObject(System.Object)">
            <summary>
            Look up the Monitor for the specified object in the SyncBlock
            tables. If no Monitor exists for the object then one is created.
            </summary>
        </member>
        <member name="M:System.Threading.Monitor.Dequeue">
             <summary>
             Dequeue a thread from the singly linked list from head to tail,
             acquiring the ListLock if necessary.
            
             If the list is empty then this method returns null.
             </summary>
        </member>
        <member name="M:System.Threading.Monitor.Remove(System.Threading.Thread)">
             <summary>
             Search the linked list and remove the specified thread if
             it is linked in.
            
             Acquires the ListLock if necessary.
             </summary>
        </member>
        <member name="M:System.Threading.Monitor.Enqueue(System.Threading.Thread)">
             <summary>
             Append a thread at the tail of a queue. If the queue is
             currently null this method initializes it.
            
             Acquires the ListLock if necessary.
             </summary>
        </member>
        <member name="F:System.Threading.Monitor.depth">
            <summary>
            The recursion depth of the current holder of the monitor.
            </summary>
        </member>
        <member name="F:System.Threading.Monitor.mutex">
            <summary>
            The mutex that is held by the thread that holds the monitor
            </summary>
        </member>
        <member name="M:System.Threading.Monitor.Enter(System.Object)">
            <summary>
            Attempt to enter the monitor, blocking until it is held.
            </summary>
        </member>
        <member name="M:System.Threading.Monitor.Exit(System.Object)">
            <summary>
            Exit the monitor.
            </summary>
        </member>
        <member name="T:System.Threading.Mutex">
            
             <summary>
                 Mutex class implementing a mutex functionality
             </summary>
            
        </member>
        <member name="M:System.Threading.Mutex.#ctor">
            
             <summary>
                 Default constructor
            </summary>
            
        </member>
        <member name="M:System.Threading.Mutex.#ctor(System.Boolean)">
            
             <summary>
                 Constructor
            </summary>
            
             <param name="initiallyOwned">Initial state of a mutex</param>
            
             <remark> We assume that mutex can initially be owned by current thread only </remark>
            
        </member>
        <member name="M:System.Threading.Mutex.#ctor(System.Boolean,System.Boolean)">
            
             <summary>
                 Constructor
            </summary>
            
             <param name="initiallyOwned">Initial state of a mutex</param>
             <param name="isKernelObject">
                 True if this mutex is created by kernel and therefore used by kernel threads. 
                 False if this mutex is created by a SIP and therefore used only by the SIP.
             
                 A kernel thread is not allowed to be forcibly stopped while owning a mutex,
                 whereas SIP threads can be forcibly stopped while owning a mutex. This doesn't
                 create problems for SIPs because the only time a SIP thread is forced to stop is
                 during process torn down.
             </param>
            
             <remark> We assume that mutex can initially be owned by current thread only </remark>
            
        </member>
        <member name="M:System.Threading.Mutex.Finalize">
            
             <summary>
                 Finalize method - release mutex by hand if it is going away
            </summary>
            
        </member>
        <member name="M:System.Threading.Mutex.AcquireMutex">
            
             <summary>
                 Acquire mutex without time out specified
            </summary>
            
        </member>
        <member name="M:System.Threading.Mutex.AcquireMutex(System.SchedulerTime)">
            
             <summary>
                 Acquire mutex with time out specified
            </summary>
            
             <param name="stop">Specified time out</param>
            
        </member>
        <member name="M:System.Threading.Mutex.ReleaseMutex">
            
             <summary>
                 Release mutex 
            </summary>
            
        </member>
        <member name="M:System.Threading.Mutex.IsOwnedByCurrentThread">
            
             <summary>
                 Check if mutex is owned by the current thread
            </summary>
            
        </member>
        <member name="M:System.Threading.Mutex.AcquireOrEnqueue(Microsoft.Singularity.Scheduling.ThreadEntry,System.Int32)">
            
             <summary>
                 Try to acquire a mutex if acquire fail entry will be enqueued onto wait queue
            </summary>
            
             <param name="entry">Entry represents a thread attempting to acquire mutex</param>
             <param name="handleId">
                 Id of the handle that we are trying to acquire - is used to check if thread can be unblocked
             </param>
            
        </member>
        <member name="M:System.Threading.Mutex.CompleteWait(System.Threading.Thread)">
            
             <summary>
                 Complete wait - used by mutex to record ownership
            </summary>
            
             <param name="ownerThread">Thread owner</param>
            
        </member>
        <member name="F:System.Threading.Mutex.acquired">
            <summary> 
                Recursion counter indicating number of times mutex is acquired by the same
                thread
            </summary>
        </member>
        <member name="F:System.Threading.Mutex.isKernelObject">
            <summary>
                True if this mutex is created by kernel and therefore used by kernel threads. 
                False if this mutex is created by a SIP and therefore used only by the SIP.
                
                A kernel thread is not allowed to be forcibly stopped while owning a mutex,
                whereas SIP threads can be forcibly stopped while owning a mutex. This doesn't
                create problems for SIPs because the only time a SIP thread is forced to stop is
                during process torn down.
            </summary>
        </member>
        <member name="T:System.Threading.Thread">
            
             <summary>
             Class implements thread functionality in Singluarity
             </summary>
            
            
             <summary>
                 Class implements thread functionality in Singluarity
             </summary>
            
        </member>
        <member name="F:System.Threading.Thread.maxThreads">
            <summary> A maximum number of threads , must be power of 2 >=64</summary>
        </member>
        <member name="M:System.Threading.Thread.#ctor(Microsoft.Singularity.Process)">
            
             <summary>
             Constructor to create a new thread
            </summary>
            
             <param name="process">A process to which thread belongs to</param>
            
        </member>
        <member name="M:System.Threading.Thread.#ctor(System.Boolean)">
            
             <summary>
             Idle thread constructor, deligates major initialization to main constructor by
             using idle process
            </summary>
            
             <param name="idle">Indicates if thread is idle or not</param>
            
        </member>
        <member name="M:System.Threading.Thread.#ctor(Microsoft.Singularity.Process,System.Threading.ThreadStart)">
            
             <summary>
             A thread constructor with a start routine, deligates major initialization to main constructor by
             using idle process
            </summary>
            
             <param name="process">A process to which thread belongs to</param>
             <param name="start">Thread's start routine</param>
            
        </member>
        <member name="M:System.Threading.Thread.CreateIdleThread(Microsoft.Singularity.Processor)">
            
             <summary>
             An API to create a thread
            </summary>
            
             <param name="processor">An idle thread for a given processor </param>
            
        </member>
        <member name="M:System.Threading.Thread.CreateThread(Microsoft.Singularity.Process,System.Threading.ThreadStart)">
            
             <summary>
             An API to create a thread
            </summary>
            
             <param name="process">A process to which thread belongs to</param>
             <param name="start">Thread's start routine</param>
            
        </member>
        <member name="M:System.Threading.Thread.CreateThread(Microsoft.Singularity.Process,System.Threading.ThreadStart,System.Boolean)">
            
             <summary>
             An API to create a thread
            </summary>
            
             <param name="process">A process to which thread belongs to</param>
             <param name="start">Thread's start routine</param>
             <param name="needThreadHandle">Whether a thread handle should be created</param>
            
        </member>
        <member name="M:System.Threading.Thread.Start">
            
             <summary>
             Spawns off a new thread which will begin executing at the
             ThreadStart delegate passed in the constructor. Once the thread is
             dead, it cannot be restarted with another call to Start.
             </summary>
            
        </member>
        <member name="M:System.Threading.Thread.SetMainThreadRunning">
            
             <summary>
             Start running main thread inside of process
             </summary>
            
            <remark> precondition: process.processLock held </remark>
        </member>
        <member name="M:System.Threading.Thread.StartRunningThread">
            
             <summary>
             Start thread running: Attach to GC and process's scheduler
             </summary>
            
        </member>
        <member name="M:System.Threading.Thread.DispatcherThreadStub(System.Int32)">
            
             <summary>
             An entry point for an idle thread. ThreadContext.InitializeIdle sets
             DispatcherThreadStub as the first instruction to be executed in a new thread context.
             </summary>
            
             <remarks>
             There are currently only two dispatcher threads: Idle and Scavenger. Both
             of them are created during processor startup
             </remarks>
            
             <param name="index">An index represents a thread we are starting</param>
            
        </member>
        <member name="M:System.Threading.Thread.ThreadStub(System.Int32)">
            
             <summary>
             An entry point for any thread.  ThreadContext.Initialize sets ThreadStub as
             the first instruction to be executed in a new thread context.
             </summary>
            
             <param name="threadIndex">An index represents a thread we are starting</param>
            
        </member>
        <member name="M:System.Threading.Thread.ServiceStopped">
            
             <summary>
             Service a stop thread - Method perfoms final tearing down of thread it is called
             on special service thread.
             </summary>
            
        </member>
        <member name="M:System.Threading.Thread.Join">
            
             <summary>
             Wait for thread to stop
             </summary>
            
             <remark>
             Exceptions: ThreadStateException if the thread has not been started yet.
             </remark>
        </member>
        <member name="M:System.Threading.Thread.Join(System.TimeSpan)">
            
             <summary>
             Wait for thread to stop or specified timeout expires
             </summary>
            
             <remark>
             Exceptions: ThreadStateException if the thread has not been started yet.
             </remark>
        </member>
        <member name="M:System.Threading.Thread.Join(System.SchedulerTime)">
            
             <summary>
             Wait for thread to stop or specified timeout expires
             </summary>
            
             <remark>
             Exceptions: ThreadStateException if the thread has not been started yet.
             </remark>
        </member>
        <member name="M:System.Threading.Thread.SetAffinity(System.Int32)">
            
             <summary>
             Set thread's affinity
             </summary>
            
        </member>
        <member name="M:System.Threading.Thread.SignalGCEvent(System.Int32)">
            
             <summary>
             Signal thread's GC event, we can't use actual event object as it might allow
             unneccesasry reentrancy.
             </summary>
            
        </member>
        <member name="M:System.Threading.Thread.WaitForGCEvent(System.Int32,System.SchedulerTime)">
            
             <summary>
             Wait for GC - method is called by GC to park thread while GC is up and running
             At this point we chose not to use autoresetevent as it might introduce reentrancy.
             In this method we closely mimic to what we are doing in WaitAny when waiting on handles
             </summary>
            
        </member>
        <member name="M:System.Threading.Thread.SignalGCEvent(System.Int32,System.Int32)">
            
             <summary>
             Signal thread's GC event. For more information see WaitForGCEvent
             </summary>
            
        </member>
        <member name="M:System.Threading.Thread.Suspend(System.Boolean)">
            
             <summary>
             Suspend thread and wait till it is suspended
             </summary>
            
        </member>
        <member name="M:System.Threading.Thread.Resume">
            
             <summary>
             Resume thread
             </summary>
            
        </member>
        <member name="M:System.Threading.Thread.ProcessAbortIfRequested(System.Threading.AbortRequestSource)">
            
             <summary>
             Handle abort - if abort is requested for the current thread, calling this
             method stops the thread immediately. Note this method can only be called
             by the current thread
             </summary>
            
             <param name="source"> Where the request come from, for debugging purpose</param>
            
        </member>
        <member name="M:System.Threading.Thread.Stop">
            
             <summary>
             Abort thread - thread will be aborted right a way unless dealy abort bit is set
             </summary>
            
        </member>
        <member name="M:System.Threading.Thread.StopSuspended">
            
             <summary>
             Abort suspended thread - thread will be aborted right a way unless dealy abort bit is set
             Once stop call is processed, thread will be resumed to finish stop
             </summary>
            
        </member>
        <member name="M:System.Threading.Thread.Abort">
            
             <summary>
             Move thread abort status to abort state
             </summary>
            
        </member>
        <member name="M:System.Threading.Thread.ProcessAbortIfRequired">
            
             <summary>
             Handle Abort - if abort is set and we are not in dealy abort scope throw
             abort exception
             </summary>
            
        </member>
        <member name="M:System.Threading.Thread.DelayStop(System.Boolean)">
            
             <summary>
             Enable/Disable delay abort on the thread depending on the passed in flag
             </summary>
            
             <param name="shouldDelayAbort">Flag indicating if abort has to be enabled or disabled </param>
            
        </member>
        <member name="M:System.Threading.Thread.ShouldStop">
            
             <summary>
             Handle Abort - if abort is set and we are not in dealy abort scope throw
             abort exception
             </summary>
            
        </member>
        <member name="M:System.Threading.Thread.IsAbortDelayed">
            
             <summary>
             Check if we can abort thread
             </summary>
            
        </member>
        <member name="M:System.Threading.Thread.IsAborted">
            
             <summary>
             Check if thread has abort bit set
             </summary>
            
        </member>
        <member name="M:System.Threading.Thread.NotifySpinLockAboutToAcquire(System.Int32)">
            
             <summary>
             Notify thread that it acquired spinlock of specific rank
             </summary>
            
             <param name="type">Type of a spinlock </param>
            
        </member>
        <member name="M:System.Threading.Thread.NotifySpinLockReleased(System.Int32)">
            
             <summary>
             Notify thread that released a spinlock of specific rank
             </summary>
            
             <param name="type">Type of a spinlock </param>
            
        </member>
        <member name="M:System.Threading.Thread.GetThreadFromThreadId(System.Int32)">
            
             <summary>
             Given a thread id return thread
             </summary>
            
             <param name="threadId">Thread Id</param>
            
        </member>
        <member name="M:System.Threading.Thread.PrepareKernelThread(Microsoft.Singularity.Processor)">
            <summary> Prepares a new Thread to take on role as kernel thread
            for upcoming processor.  Called by Bootstrap processor. </summary>
        </member>
        <member name="M:System.Threading.Thread.PrepareForBlocking">
            
             <summary>
             Prepare thread for blocking - initialize UnblockedBy state
             </summary>
            
        </member>
        <member name="M:System.Threading.Thread.Unblock(System.Int32)">
            
             <summary>
             Finish blocking - only changes blocking state if UnblockedBy is uninitialized
             </summary>
            
             <param name="unblockedBy">
             Id of waithandle that is attempting to unblock thread
             </param>
            
        </member>
        <member name="M:System.Threading.Thread.BlockThread">
            
             <summary>
             Block thread - only changes blocking state if UnblockedBy is uninitialized
             </summary>
            
        </member>
        <member name="M:System.Threading.Thread.IncrementFreezeCounter">
            
             <summary>
             Increment thread's freeze counter
             </summary>
            
        </member>
        <member name="M:System.Threading.Thread.DecrementFreezeCounter(System.Boolean@)">
            
             <summary>
             Decrement thread's freeze counter, if thread was really suspended meaing
             its state was marked suspended by scheduler, return this information so that
             </summary>
            
             <param name="shouldPutOnRunnableQueue">
             Indicates if caller has to put thread on a runnable queue
             </param>
            
        </member>
        <member name="M:System.Threading.Thread.ShouldCallSchedulerUnBlock(System.Int32)">
            
             <summary>
                Verifies if caller has to call scheduler unblock - this will only required if thread is
             in blocked state, was unblocked by caller and blocking version is off by one
             </summary>
            
             <param name="unblocker">Id of handle unblocker that is attempting to unblock thread</param>
            
        </member>
        <member name="M:System.Threading.Thread.DeriveCurrentSchedulerState(System.Threading.Thread.SchedulerInfo)">
            
             <summary>
             Given complete thread's scheduler information derive scheduler state
             </summary>
            
             <param name="threadSchedulerInfo">Given scheduler atomic info to use for derivation</param>
            
             <remark> Scheduler info is complex state that consist of three states: Sceduler state
             unblocked by information and freeze count. We need to examine all three peices
             of information as well current thread state to derive real scheduelr state
            </remark>
            
        </member>
        <member name="M:System.Threading.Thread.DeriveNewSchedulerState(System.Threading.Thread.SchedulerInfo,System.Threading.ThreadState)">
            
             <summary>
             Derive new scheduler state
             </summary>
            
             <param name="threadSchedulerInfo">Given scheduler atomic info to use for derivation</param>
             <param name="schedulingAction">scheduling action thread is performing: for now maps to states</param>
            
             <remark> Scheduler info is complex state that consist of three states: Scheduler state
             unblocked by information and freeze count. We need to examine all three peices
             of information as well current thread state to derive real scheduler state
            </remark>
            
        </member>
        <member name="M:System.Threading.Thread.ChangeSchedulerState(System.Threading.ThreadState)">
            
             <summary>
             Set new scheduler state on thread
             </summary>
            
             <param name="schedulerAction">Scheduler action</param>
            
        </member>
        <member name="M:System.Threading.Thread.TryChangeSchedulerState(System.Threading.ThreadState,System.Threading.Thread.SchedulerInfo)">
            
             <summary>
             Try to change scheduler state to a new state. New state usually is derived from
             calling DeriveSchedulerState method. For more info see comments to that method
             </summary>
            
             <param name="newState">New scheduling state</param>
             <param name="previousInfo">Scheduling information base on which we derived new state</param>
            
        </member>
        <member name="M:System.Threading.Thread.WaitUntilReadyForContextSwitch">
            
             <summary>
             Wait for reschedule - wait until thread is allowed to be running. This method
             should be exclusively used by processor dispatcher
             </summary>
            
        </member>
        <member name="M:System.Threading.Thread.TurnOnInsideOfContextSwitch">
            
             <summary>
             Turn on  thread's state inside of context switch
             </summary>
            
        </member>
        <member name="M:System.Threading.Thread.TurnOffInsideOfContextSwitch">
            
             <summary>
             Turn off thread's state inside of context switch
             </summary>
            
        </member>
        <member name="M:System.Threading.Thread.IsInsideOfContextSwitch">
            
             <summary>
             Find out if we inside of context switch
             </summary>
            
        </member>
        <member name="F:System.Threading.Thread.localDataStoreMgr">
            <summary>
            This manager is responsible for storing the global data that is  shared amongst all
            the thread local stores.
            </summary>
        </member>
        <member name="F:System.Threading.Thread.threadIndexGenerator">
            <summary> A global counter to generate next thread index </summary>
        </member>
        <member name="F:System.Threading.Thread.insideOfContextSwitchDepth">
            <summary> Thread is inside of context switch </summary>
        </member>
        <member name="F:System.Threading.Thread.externalMultiUseObjAllocListHead">
            <summary> MultiUseWord (object header) head</summary>
        </member>
        <member name="F:System.Threading.Thread.externalMultiUseObjAllocListTail">
            <summary>MultiUseWord (object header) tail </summary>
        </member>
        <member name="F:System.Threading.Thread.processThreadIndex">
            <summary> Thread index inside of a prcess </summary>
        </member>
        <member name="F:System.Threading.Thread.threadIndex">
            <summary> Global thread index </summary>
        </member>
        <member name="F:System.Threading.Thread.threadStart">
            <summary> A method to start a thread</summary>
        </member>
        <member name="F:System.Threading.Thread.schedulerInfo">
            <summary> A state of a thread from scheduler point of view </summary>
        </member>
        <member name="F:System.Threading.Thread.prevSchedulerInfo">
            <summary> Previous scheduler info as seen by record event, used for debugging purposes</summary>
        </member>
        <member name="F:System.Threading.Thread.dispatcher">
            <summary> Thread state from dispatcher point of view </summary>
        </member>
        <member name="F:System.Threading.Thread.nonPreemptibleRegionCount">
            <summary> Indicates if a thread is executing in a nonPreemptible region </summary>
        </member>
        <member name="F:System.Threading.Thread.autoEvent">
            <summary> Thread's event used by monitor </summary>
        </member>
        <member name="F:System.Threading.Thread.gcEventSignaled">
            <summary> Indicates if thread's gc event has been signaled </summary>
        </member>
        <member name="F:System.Threading.Thread.joinEvent">
            <summary>Thread's join event</summary>
        </member>
        <member name="F:System.Threading.Thread.blockingCctorThread">
            <summary> This is needed for Bartok </summary>
        </member>
        <member name="F:System.Threading.Thread.localServiceRequest">
            <summary>Preallocated services request object</summary>
        </member>
        <member name="F:System.Threading.Thread.blockedUntil">
            <summary>A timer indicating till when thread is blocked</summary>
        </member>
        <member name="F:System.Threading.Thread.schedulerEntry">
            <summary>An entry used by scheduler queues to manipulate wit thread</summary>
        </member>
        <member name="F:System.Threading.Thread.timerEntry">
            <summary>An entry used by timer quieue to manipulate with thread</summary>
        </member>
        <member name="F:System.Threading.Thread.deferredEntry">
            <summary>An entry used by wait handle to put thread on deferred queue during wakeup</summary>
        </member>
        <member name="F:System.Threading.Thread.context">
            <summary>Thread context</summary>
        </member>
        <member name="F:System.Threading.Thread.process">
            <summary>Thread's process</summary>
        </member>
        <member name="F:System.Threading.Thread.threadHandle">
            <summary>Thread's handle</summary>
        </member>
        <member name="F:System.Threading.Thread.threadLocalValue">
            <summary>Thread local value - single place for local storage</summary>
        </member>
        <member name="F:System.Threading.Thread.lastUncaughtException">
            <summary>
            Most recently thrown exception object that the thread
            did not catch at all (i.e. that propagated to the bottom
            of the stack without encountering an appropriate catch clause).
            </summary>
        </member>
        <member name="F:System.Threading.Thread.nextThread">
            <summary>
            Monitor link list of threads. Remove these and Monitor as soon as
            stack is out of kernel.
            </summary>
        </member>
        <member name="F:System.Threading.Thread.exceptionStateInfo">
            <summary>  </summary>
        </member>
        <member name="F:System.Threading.Thread.threadTable">
            <summary>Global thread table</summary>
        </member>
        <member name="F:System.Threading.Thread.threadTableLock">
            <summary>A lock protecting access to global trhead table</summary>
        </member>
        <member name="F:System.Threading.Thread.localDataStore">
            <summary>Thread local storage</summary>
        </member>
        <member name="F:System.Threading.Thread.initialThread">
            <summary>First thread in Singularity</summary>
        </member>
        <member name="F:System.Threading.Thread.threadLock">
            <summary>Spinlock protecting thread state</summary>
        </member>
        <member name="F:System.Threading.Thread.processStopException">
            <summary>An exception object to stop process </summary>
        </member>
        <member name="F:System.Threading.Thread.Affinity">
            <summary> The processor ID this thread is running on or ran on last time </summary>
        </member>
        <member name="F:System.Threading.Thread.type">
            <summary> Thread type </summary>
        </member>
        <member name="F:System.Threading.Thread.spinLockRankMask">
            <summary> SpinLock ranking masks </summary>
        </member>
        <member name="F:System.Threading.Thread.numberOfSpinlocksHeld">
            <summary>A number of spinlocks held by a thread</summary>
        </member>
        <member name="F:System.Threading.Thread.segregatedFreeList">
            <summary> Thread specific heap allocator </summary>
        </member>
        <member name="F:System.Threading.Thread.bumpAllocator">
            <summary>Thread specific bump allocator </summary>
        </member>
        <member name="F:System.Threading.Thread.tryAllManager">
             <summary>
                  Bartok specific field: Support for try_all { ... } construct
            </summary>
        </member>
        <member name="P:System.Threading.Thread.Dispatcher">
            
             <summary>
             Retrieve thread's scheduler for a thread
             </summary>
            
        </member>
        <member name="P:System.Threading.Thread.ThreadSchedulerInfo">
            
             <summary>
             Retrieve thread's scheduler info
             </summary>
            
        </member>
        <member name="P:System.Threading.Thread.IsSuspended">
            
             <summary>
             Find out if thread is suspended
             </summary>
            
        </member>
        <member name="P:System.Threading.Thread.IsBlocked">
            
             <summary>
             Find out if thread is blocked
             </summary>
            
        </member>
        <member name="P:System.Threading.Thread.IsIdle">
            
             <summary>
                Check if thread is idle
             </summary>
            
        </member>
        <member name="P:System.Threading.Thread.IsScavenger">
            
             <summary>
                Check if thread is idle
             </summary>
            
        </member>
        <member name="P:System.Threading.Thread.Type">
            
             <summary>
                Check if thread is idle
             </summary>
            
        </member>
        <member name="P:System.Threading.Thread.IsRunnable">
            
             <summary>
             Find out if thread is runnable
             </summary>
            
        </member>
        <member name="P:System.Threading.Thread.IsRunning">
            
             <summary>
             Find out if thread is running
             </summary>
            
        </member>
        <member name="P:System.Threading.Thread.UnblockedBy">
            
             <summary>
             Find out who unblocked the thread
             </summary>
            
        </member>
        <member name="P:System.Threading.Thread.FreezeCount">
            
             <summary>
             Find out thread freeze count
             </summary>
            
        </member>
        <member name="P:System.Threading.Thread.IsAlive">
            
             <summary>
             Thread is alive only if it has been started and it is not stopped. There is no
             gurantee as this call returns thread will stay alive. You will need to provide extra
             synchronization
             </summary>
            
        </member>
        <member name="P:System.Threading.Thread.ThreadState">
            
             <summary>
             Retrieve thread's state
             </summary>
            
        </member>
        <member name="P:System.Threading.Thread.BlockedUntil">
            <summary>  </summary>
        </member>
        <member name="T:System.Threading.Thread.SchedulerInfo">
            
             <summary>
             Scheduler specific information. Includes scheduler state, wait version and
             unblocked by information
             </summary>
            
        </member>
        <member name="F:System.Threading.Thread.SchedulerInfo.Data">
            
             <summary>
             This separated into 5 different fields. We use a single 64-bit integer so that
             we can use Interlocked operations on this struct. The layout is:
            
             State            : byte  : byte 0               : mask 00000000000000FF
             DelayAbortCount  : byte  : bit 0-6 of byte 1    : mask 0000000000007F00
             IsAborted        : bool  : bit 7 of byte 1      : mask 0000000000008000
             FreezeCount      : UInt16: byte 2-3             : mask 00000000FFFF0000
             UnblockedBy      : Int32 : byte 4-7             : mask FFFFFFFF00000000
             </summary>
            
        </member>
        <member name="M:System.Threading.Thread.SchedulerInfo.IncrementDelayAbortCount">
            
             <summary>
             Increment the delay abort count.
             Thread is not allowed to die with non zero DelayAbortCount.
             </summary>
            
        </member>
        <member name="M:System.Threading.Thread.SchedulerInfo.DecrementDelayAbortCount">
            
             <summary>
             Decrement the delay abort count.
             Thread is not allowed to die with non zero DelayAbortCount.
             </summary>
            
        </member>
        <member name="P:System.Threading.Thread.SchedulerInfo.State">
            
             <summary>
             State of a thread with respect to scheduler: Runable, Running and etc...
             </summary>
            
        </member>
        <member name="P:System.Threading.Thread.SchedulerInfo.DelayAbortCount">
            
             <summary>
             Reference counter of delay abort.
             Thread is not allowed to die with non zero DelayAbortCount.
             </summary>
            
        </member>
        <member name="P:System.Threading.Thread.SchedulerInfo.IsAborted">
            
             <summary>
             Get or set whether the thread is aborted
             </summary>
            
        </member>
        <member name="P:System.Threading.Thread.SchedulerInfo.FreezeCount">
            
             <summary>
             A reference counter of how many times the thread is suspended. Threads
             with non zero FreezeCount are not allowed to run.
             </summary>
            
        </member>
        <member name="P:System.Threading.Thread.SchedulerInfo.UnblockedBy">
            
             <summary>
             Filed represents an id of WaitHandle that performed unblock operation
             </summary>
            
        </member>
        <member name="T:System.Threading.Thread.ThreadType">
            
             <summary>
             Thread type
             </summary>
            
        </member>
        <member name="T:System.Threading.ThreadState">
            
             <summary>
                Scheduler thread state
             </summary>
            
        </member>
        <member name="T:System.Threading.ThreadActions">
            
             <summary>
                Scheduler thread's actions
             </summary>
            
        </member>
        <member name="T:System.Threading.InterruptAwareWaitHandle">
            
             <summary>
             Base class for all interrupt aware synchronization objects
            
             This class is interrupt aware: interrupts are disabled during the period when the
             spin lock is held.
             </summary>
            
        </member>
        <member name="M:System.Threading.InterruptAwareWaitHandle.#ctor(System.Threading.WaitHandleBase.SignalState,System.Threading.WaitHandleBase.SignalState,System.Threading.SpinLock.Types)">
            
             <summary>
             Constructor
             </summary>
            
             <param name="initialState">Initial state of an handle </param>
             <param name="signalStateAfterImediateWait">
                Value represents a state of a handle when wait satisfied right a way
             </param>
             <param name="spinLockType">The spin lock type of the wait handle</param>
            
        </member>
        <member name="M:System.Threading.InterruptAwareWaitHandle.InterruptAwareSignalOne(System.Threading.WaitHandleBase.SignalState)">
            
             <summary>
             Signal wait handle by waking up a single waiter or if there are no waiters
             set handle to specified stated.
             </summary>
            
             <param name="signalStateIfNoWaiters">
             Set the wait handle into specified state if no waiters present
             </param>
            
        </member>
        <member name="M:System.Threading.InterruptAwareWaitHandle.InterruptAwarePreWaitAnyInternal(System.Threading.Thread,System.Threading.WaitHandleBase[],Microsoft.Singularity.Scheduling.ThreadEntry[],System.Int32)">
            
             <summary>
             Associate a thread with wait handles if one of the waits satisfied return
             waithandle id - actual unblocker. if none of the states satisfied return UninitWait
             indicating that thread has to proceede with blocking
             </summary>
            
        </member>
        <member name="M:System.Threading.InterruptAwareWaitHandle.InterruptAwarePostWaitAnyInternal(System.Threading.Thread,System.Threading.WaitHandleBase[],Microsoft.Singularity.Scheduling.ThreadEntry[],System.Int32)">
            
             <summary>
             Post wait is to disassociate thread from all handlers
             </summary>
            
        </member>
        <member name="M:System.Threading.InterruptAwareWaitHandle.InterruptAwareWaitOne">
            
             <summary>
             Wait on a set of handles until one of them becomes signaled with a specified time out.
            
             !!! If you change this method, please review WaitHandle.WaitAny()
             and see if the changes need to be propagated there.
             </summary>
            
        </member>
        <member name="F:System.Threading.InterruptAwareWaitHandle.singleHandle">
            <summary>
            This field is an array of length 1 containing 'this'.
            It is used to avoid allocation when calling WaitAny from WaitOne.
            </summary>
        </member>
        <member name="T:System.Threading.InterruptAwareAutoResetEvent">
            
             <summary>
                 Event class implementing an event with auto reset symantics such event automatically
                 reset to non signaled state when single wait is satisfied. 
             
                 This class is interrupt aware: interrupts are disabled during the period when the 
                 spin lock is held. Code that deals with interrupt handling, for example HAL 
                 communication, that could be reentrant during interrupt handling should use
                 this class instead of AutoResetEvent
             </summary>
            
        </member>
        <member name="M:System.Threading.InterruptAwareAutoResetEvent.#ctor(System.Boolean)">
            
             <summary>
                 Constructor
            </summary>
            
             <param name="initialState">Initial state of an event true indciates that event is signaled</param>
            
        </member>
        <member name="T:Microsoft.Singularity.Scheduling.ListNode">
            <summary>
            Summary description for ListNode.
            </summary>
        </member>
        <member name="T:System.Collections.Specialized.ListDictionary">
            <devdoc>
             <para>
               This is a simple implementation of IDictionary using a singly linked list. This
               will be smaller and faster than a Hashtable if the number of elements is 10 or less.
               This should not be used if performance is important for large numbers of elements.
             </para>
            </devdoc>
        </member>
        <member name="M:System.Collections.Specialized.ListDictionary.#ctor">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Collections.Specialized.ListDictionary.#ctor(System.Collections.IComparer)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Collections.Specialized.ListDictionary.Add(System.Object,System.Object)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Collections.Specialized.ListDictionary.Clear">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Collections.Specialized.ListDictionary.Contains(System.Object)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Collections.Specialized.ListDictionary.CopyTo(System.Array,System.Int32)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Collections.Specialized.ListDictionary.GetEnumerator">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Collections.Specialized.ListDictionary.Remove(System.Object)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Collections.Specialized.ListDictionary.Item(System.Object)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Collections.Specialized.ListDictionary.Count">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Collections.Specialized.ListDictionary.Keys">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Collections.Specialized.ListDictionary.IsReadOnly">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Collections.Specialized.ListDictionary.IsFixedSize">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Collections.Specialized.ListDictionary.IsSynchronized">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Collections.Specialized.ListDictionary.SyncRoot">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Collections.Specialized.ListDictionary.Values">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Collections.Specialized.StringDictionary">
            <devdoc>
               <para>Implements a hashtable with the key strongly typed to be
                  a string rather than an object. </para>
            </devdoc>
        </member>
        <member name="M:System.Collections.Specialized.StringDictionary.#ctor">
            <devdoc>
            <para>Initializes a new instance of the System.Windows.Forms.StringDictionary class.</para>
            </devdoc>
        </member>
        <member name="M:System.Collections.Specialized.StringDictionary.Add(System.String,System.String)">
            <devdoc>
            <para>Adds an entry with the specified key and value into the System.Windows.Forms.StringDictionary.</para>
            </devdoc>
        </member>
        <member name="M:System.Collections.Specialized.StringDictionary.Clear">
            <devdoc>
            <para>Removes all entries from the System.Windows.Forms.StringDictionary.</para>
            </devdoc>
        </member>
        <member name="M:System.Collections.Specialized.StringDictionary.ContainsKey(System.String)">
            <devdoc>
               <para>Determines if the string dictionary contains a specific key</para>
            </devdoc>
        </member>
        <member name="M:System.Collections.Specialized.StringDictionary.ContainsValue(System.String)">
            <devdoc>
            <para>Determines if the System.Windows.Forms.StringDictionary contains a specific value.</para>
            </devdoc>
        </member>
        <member name="M:System.Collections.Specialized.StringDictionary.CopyTo(System.Array,System.Int32)">
            <devdoc>
            <para>Copies the string dictionary values to a one-dimensional <see cref="T:System.Array"/> instance at the
               specified index.</para>
            </devdoc>
        </member>
        <member name="M:System.Collections.Specialized.StringDictionary.GetEnumerator">
            <devdoc>
               <para>Returns an enumerator that can iterate through the string dictionary.</para>
            </devdoc>
        </member>
        <member name="M:System.Collections.Specialized.StringDictionary.Remove(System.String)">
            <devdoc>
               <para>Removes the entry with the specified key from the string dictionary.</para>
            </devdoc>
        </member>
        <member name="P:System.Collections.Specialized.StringDictionary.Count">
            <devdoc>
            <para>Gets the number of key-and-value pairs in the System.Windows.Forms.StringDictionary.</para>
            </devdoc>
        </member>
        <member name="P:System.Collections.Specialized.StringDictionary.IsSynchronized">
            <devdoc>
            <para>Indicates whether access to the System.Windows.Forms.StringDictionary is synchronized (thread-safe). This property is
               read-only.</para>
            </devdoc>
        </member>
        <member name="P:System.Collections.Specialized.StringDictionary.Item(System.String)">
            <devdoc>
               <para>Gets or sets the value associated with the specified key.</para>
            </devdoc>
        </member>
        <member name="P:System.Collections.Specialized.StringDictionary.Keys">
            <devdoc>
            <para>Gets a collection of keys in the System.Windows.Forms.StringDictionary.</para>
            </devdoc>
        </member>
        <member name="P:System.Collections.Specialized.StringDictionary.SyncRoot">
            <devdoc>
            <para>Gets an object that can be used to synchronize access to the System.Windows.Forms.StringDictionary.</para>
            </devdoc>
        </member>
        <member name="P:System.Collections.Specialized.StringDictionary.Values">
            <devdoc>
            <para>Gets a collection of values in the System.Windows.Forms.StringDictionary.</para>
            </devdoc>
        </member>
        <member name="T:System.Diagnostics.Debugger">
            <summary>
            This class provides some of the methods defined by the CLR's version of
            the Debugger static class.  This makes writing portable apps easier.
            </summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Regex">
            <devdoc>
               <para>
                  Represents an immutable, compiled regular expression. Also
                  contains static methods that allow use of regular expressions without instantiating
                  a Regex explicitly.
               </para>
            </devdoc>
        </member>
        <member name="F:System.Text.RegularExpressions.Regex.pattern">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Text.RegularExpressions.Regex.roptions">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Text.RegularExpressions.Regex.caps">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Text.RegularExpressions.Regex.capnames">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Text.RegularExpressions.Regex.capslist">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Text.RegularExpressions.Regex.capsize">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
            <devdoc>
               <para>
                  Creates and compiles a regular expression object for the specified regular
                  expression.
               </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
            <devdoc>
               <para>
                  Creates and compiles a regular expression object for the
                  specified regular expression
                  with options that modify the pattern.
               </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.Finalize">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
            <devdoc>
               <para>
                  Escapes
                     a minimal set of metacharacters (\, *, +, ?, |, {, [, (, ), ^, $, ., #, and
                     whitespace) by replacing them with their \ codes. This converts a string so that
                     it can be used as a constant within a regular expression safely. (Note that the
                     reason # and whitespace must be escaped is so the string can be used safely
                     within an expression parsed with x mode. If future Regex features add
                     additional metacharacters, developers should depend on Escape to escape those
                     characters as well.)
                  </para>
               </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
            <devdoc>
               <para>
                  Unescapes any escaped characters in the input string.
               </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.ToString">
            <devdoc>
               <para>
                  Returns the regular expression pattern passed into the constructor
               </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.GetGroupNames">
            <devdoc>
               Returns
                  the GroupNameCollection for the regular expression. This collection contains the
                  set of strings used to name capturing groups in the expression.
               </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
            <devdoc>
               returns
                  the integer group number corresponding to a group name.
               </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
            <devdoc>
               <para>
                  Retrieves a group name that corresponds to a group number.
               </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
            <devdoc>
               <para>
                  Returns a group number that corresponds to a group name.
               </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
               <devdoc>
                  <para>
                     Searches the input
                        string for one or more occurrences of the text supplied in the pattern
                        parameter.
                  </para>
               </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
            <devdoc>
               <para>
                  Searches the input string for one or more occurrences of the text
                     supplied in the pattern parameter with matching options supplied in the options
                     parameter.
                  </para>
               </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
            <devdoc>
               <para>
                  Searches the input string for one or
                     more matches using the previous pattern, options, and starting
                     position.
                  </para>
               </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
            <devdoc>
               <para>
                  Searches the input
                     string for one or more matches using the previous pattern and options, with
                     a new starting position.
               </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
               <devdoc>
                  <para>
                     Searches the input string for one or more occurrences of the text
                        supplied in the pattern parameter.
                  </para>
               </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
            <devdoc>
               <para>
                  Searches the input string for one or more occurrences of the text
                     supplied in the pattern parameter. Matching is modified with an option
                     string.
                  </para>
               </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.Match(System.String)">
            <devdoc>
               <para>
                  Matches a regular expression with a string and returns
                  the precise result as a RegexMatch object.
               </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
            <devdoc>
               Matches a regular expression with a string and returns
               the precise result as a RegexMatch object.
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
            <devdoc>
               <para>
                  Matches a
                  regular expression with a string and returns the precise result as a
                  RegexMatch object.
               </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
               <devdoc>
                  <para>
                     Returns all the successful matches as if Match were
                     called iteratively numerous times.
                  </para>
               </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
            <devdoc>
               <para>
                  Returns all the successful matches as if Match were called iteratively
                  numerous times.
               </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
            <devdoc>
               <para>
                  Returns
                  all the successful matches as if Match was called iteratively numerous
                  times.
               </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
            <devdoc>
               <para>
                  Returns
                  all the successful matches as if Match was called iteratively numerous
                  times.
               </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
            <devdoc>
               <para>
                  Replaces
                     all occurrences of the pattern with the <paramref name="replacement"/> pattern, starting at
                     the first character in the input string.
                  </para>
               </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
            <devdoc>
               <para>
                  Replaces all occurrences of
                     the <paramref name="pattern "/>with the <paramref name="replacement "/>
                     pattern, starting at the first character in the input string.
                  </para>
               </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
            <devdoc>
               <para>
                  Replaces all occurrences of
                     the <paramref name="pattern "/> with the <paramref name="replacement"/> pattern, starting at the
                     first character in the input string, using the previous patten.
                  </para>
               </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
            <devdoc>
               <para>
               Replaces all occurrences of the (previously defined) <paramref name="pattern "/>with the
               <paramref name="replacement"/> pattern, starting at the first character in the input string.
            </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
            <devdoc>
               <para>
               Replaces all occurrences of the <paramref name="pattern "/>with the recent
               <paramref name="replacement"/> pattern, starting at the character position
               <paramref name="startat."/>
            </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
            <devdoc>
               <para>
               Replaces all occurrences of the <paramref name="pattern "/>with the
               <paramref name="replacement"/> pattern
               <paramref name="."/>
            </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
            <devdoc>
               <para>
               Replaces all occurrences of the <paramref name="pattern "/>with the recent
               <paramref name="replacement"/> pattern, starting at the first character<paramref name="."/>
            </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
            <devdoc>
               <para>
               Replaces all occurrences of the <paramref name="pattern "/>with the recent
               <paramref name="replacement"/> pattern, starting at the first character
               position<paramref name="."/>
            </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
            <devdoc>
               <para>
               Replaces all occurrences of the <paramref name="pattern "/>with the recent
               <paramref name="replacement"/> pattern, starting at the first character
               position<paramref name="."/>
            </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
            <devdoc>
               <para>
               Replaces all occurrences of the (previously defined) <paramref name="pattern "/>with
                  the recent <paramref name="replacement"/> pattern, starting at the character
               position<paramref name=" startat."/>
            </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
               <devdoc>
                  <para>
                     Splits the <paramref name="input "/>string at the position defined
                     by <paramref name="pattern"/>.
                  </para>
               </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
            <devdoc>
               <para>
                  Splits the <paramref name="input "/>string at the position defined by <paramref name="pattern"/>.
               </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.Split(System.String)">
            <devdoc>
               <para>
                  Splits the <paramref name="input "/>string at the position defined by
                  a previous <paramref name="pattern"/>
                  .
               </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
            <devdoc>
               <para>
                  Splits the <paramref name="input "/>string at the position defined by a previous
               <paramref name="pattern"/> .
               </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
            <devdoc>
               <para>
                  Splits the <paramref name="input "/>string at the position defined by a previous
               <paramref name="pattern"/> .
               </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.InitializeReferences">
            <devdoc>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.UseOptionC">
            <internalonly/>
            <devdoc>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Regex.UseOptionR">
            <internalonly/>
            <devdoc>
            </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.Regex.RightToLeft">
            <devdoc>
               <para>
                  Indicates whether the regular expression matches from right to
                  left.
               </para>
            </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.Regex.Options">
            <devdoc>
               <para>
                  Returns the options passed into the constructor
               </para>
            </devdoc>
        </member>
        <member name="T:System.Text.RegularExpressions.MatchEvaluator">
            <devdoc>
            </devdoc>
        </member>
        <member name="T:System.Text.RegularExpressions.Capture">
            <devdoc>
               <para> 
                  Represents the results from a single subexpression capture. The object represents
                  one substring for a single successful capture.</para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Capture.ToString">
            <devdoc>
               <para>
                  Returns 
                     the substring that was matched.
                  </para>
               </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.Capture.Index">
            <devdoc>
               <para>Returns the position in the original string where the first character of
                  captured substring was found.</para>
            </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.Capture.Length">
            <devdoc>
               <para>
                  Returns the length of the captured substring.
               </para>
            </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.Capture.Value">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Text.RegularExpressions.CaptureCollection">
            <devdoc>
               <para>
                  Represents a sequence of capture substrings. The object is used
                  to return the set of captures done by a single capturing group.
               </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.CaptureCollection.CopyTo(System.Array,System.Int32)">
            <devdoc>
               <para>
                  Copies all the elements of the collection to the given array
                  beginning at the given index.
               </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.CaptureCollection.GetEnumerator">
            <devdoc>
               <para>
                  Provides an enumerator in the same order as Item[].
               </para>
            </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.CaptureCollection.SyncRoot">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.CaptureCollection.IsSynchronized">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.CaptureCollection.IsReadOnly">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.CaptureCollection.Count">
            <devdoc>
               <para>
                  Returns the number of captures.
               </para>
            </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.CaptureCollection.Item(System.Int32)">
            <devdoc>
               <para>
                  Provides a means of accessing a specific capture in the collection.
               </para>
            </devdoc>
        </member>
        <member name="T:System.Text.RegularExpressions.RegexCompilationInfo">
            <devdoc>
               <para>
                  [To be supplied]
               </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.RegexCompilationInfo.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.String,System.String,System.Boolean)">
            <devdoc>
               <para>
                  [To be supplied]
               </para>
            </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.RegexCompilationInfo.Pattern">
            <devdoc>
               <para>
                  [To be supplied]
               </para>
            </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.RegexCompilationInfo.Options">
            <devdoc>
               <para>
                  [To be supplied]
               </para>
            </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.RegexCompilationInfo.Name">
            <devdoc>
               <para>
                  [To be supplied]
               </para>
            </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.RegexCompilationInfo.Namespace">
            <devdoc>
               <para>
                  [To be supplied]
               </para>
            </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.RegexCompilationInfo.IsPublic">
            <devdoc>
               <para>
                  [To be supplied]
               </para>
            </devdoc>
        </member>
        <member name="T:System.Text.RegularExpressions.Group">
            <devdoc>
               Group 
                  represents the results from a single capturing group. A capturing group can
                  capture zero, one, or more strings in a single match because of quantifiers, so
                  Group supplies a collection of Capture objects. 
               </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Group.Synchronized(System.Text.RegularExpressions.Group)">
            <devdoc>
               <para>Returns 
                  a Group object equivalent to the one supplied that is safe to share between
                  multiple threads.</para>
            </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.Group.Success">
            <devdoc>
               <para>Indicates whether the match is successful.</para>
            </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.Group.Captures">
            <devdoc>
               <para>
                  Returns a collection of all the captures matched by the capturing
                  group, in innermost-leftmost-first order (or innermost-rightmost-first order if
                  compiled with the "r" option). The collection may have zero or more items.
               </para>
            </devdoc>
        </member>
        <member name="T:System.Text.RegularExpressions.GroupCollection">
            <devdoc>
               <para>
                  Represents a sequence of capture substrings. The object is used
                  to return the set of captures done by a single capturing group.
               </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.GroupCollection.CopyTo(System.Array,System.Int32)">
            <devdoc>
               <para>
                  Copies all the elements of the collection to the given array
                  beginning at the given index.
               </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.GroupCollection.GetEnumerator">
            <devdoc>
               <para>
                  Provides an enumerator in the same order as Item[].
               </para>
            </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.GroupCollection.SyncRoot">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.GroupCollection.IsSynchronized">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.GroupCollection.IsReadOnly">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.GroupCollection.Count">
            <devdoc>
               <para>
                  Returns the number of groups.
               </para>
            </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.GroupCollection.Item(System.Int32)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.GroupCollection.Item(System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Text.RegularExpressions.RegexRunner">
            <internalonly/>
        </member>
        <member name="T:System.Text.RegularExpressions.Match">
            <devdoc>
               <para>
                  Represents 
                     the results from a single regular expression match.
                  </para>
               </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Match.NextMatch">
            <devdoc>
               <para>Returns a new Match with the results for the next match, starting
                  at the position at which the last match ended (at the character beyond the last
                  matched character).</para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Match.Result(System.String)">
            <devdoc>
               <para>
                  Returns the expansion of the passed replacement pattern. For
                  example, if the replacement pattern is ?$1$2?, Result returns the concatenation
                  of Group(1).ToString() and Group(2).ToString().
               </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.Match.Synchronized(System.Text.RegularExpressions.Match)">
            <devdoc>
               <para>
                  Returns a Match instance equivalent to the one supplied that is safe to share
                  between multiple threads.
               </para>
            </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.Match.Empty">
            <devdoc>
               <para>
                  Returns an empty Match object.
               </para>
            </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.Match.Groups">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Text.RegularExpressions.MatchCollection">
            <devdoc>
               <para>
                  Represents the set of names appearing as capturing group
                  names in a regular expression.
               </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.MatchCollection.CopyTo(System.Array,System.Int32)">
            <devdoc>
               <para>
                  Copies all the elements of the collection to the given array
                  starting at the given index.
               </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.MatchCollection.GetEnumerator">
            <devdoc>
               <para>
                  Provides an enumerator in the same order as Item[i].
               </para>
            </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.MatchCollection.Count">
            <devdoc>
               <para>
                  Returns the number of captures.
               </para>
            </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.MatchCollection.SyncRoot">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.MatchCollection.IsSynchronized">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.MatchCollection.IsReadOnly">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Text.RegularExpressions.MatchCollection.Item(System.Int32)">
            <devdoc>
               <para>
                  Returns the ith Match in the collection.
               </para>
            </devdoc>
        </member>
        <member name="T:System.Text.RegularExpressions.RegexOptions">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Text.RegularExpressions.RegexOptions.None">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Text.RegularExpressions.RegexOptions.IgnoreCase">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Text.RegularExpressions.RegexOptions.Multiline">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Text.RegularExpressions.RegexOptions.ExplicitCapture">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Text.RegularExpressions.RegexOptions.Compiled">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Text.RegularExpressions.RegexOptions.Singleline">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Text.RegularExpressions.RegexOptions.RightToLeft">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Text.RegularExpressions.RegexOptions.ECMAScript">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Text.RegularExpressions.RegexOptions.CultureInvariant">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Runtime.InteropServices.Marshal.StructSize(System.Type)">
            
             Used by the shared heap to allocate structs.
            
        </member>
        <member name="M:Microsoft.Singularity.V1.Processes.ProcessHandle.BindToService(Microsoft.Singularity.V1.Processes.ProcessHandle,Microsoft.Singularity.V1.Types.SystemType,Microsoft.Singularity.V1.Types.SystemType,System.Char*,System.Int32,System.Int32,System.Int32)">
            <summary>
            Given 2 system types generate and initialize the two endpoints of
            a channel. The imp side will be set in the processes startup endpoint array
            at position "index". The exp side will be bound to a service based on global policy
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.V1.Services.EndpointCore.deliveryHandle">
            <summary>
            Handle to the actual message delivery mechanism
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.V1.Services.EndpointCore.collectionEvent">
            <summary>
            Event handle in case this endpoint is part of a collection
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.V1.Services.EndpointCore.cachedMessageEvent">
            <summary>
            Event on which sends are signaled to this endpoint.
            The handle is owned by the kernel, since the endpoint can move.
            The kernel deallocates the handle when the channel is deallocated.
            NOTE: stays valid until the entire channel gets collected.
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.V1.Services.EndpointCore.cachedClosed">
            <summary>
            Closed flag
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.V1.Services.EndpointCore.cachedOwnerProcessId">
            <summary>
            Contains the process id of the process currently owning this end of the
            channel.
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.V1.Services.EndpointCore.cachedChannelId">
            <summary>
            Contains the channelId (positive on the EXP endpoint, negative on the imp endpoint)
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.V1.Services.EndpointCore.cachedMarshall">
            <summary>
            Whether to marshall or not
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.V1.Services.EndpointCore.cachedPeer">
            <summary>
            Points to the peer endpoint
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.V1.Services.EndpointCore.peerStateValid">
            <summary>
            If true then the peer state can be queried directly from cachedPeer
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.V1.Services.EndpointCore.Allocate(System.UInt32,Microsoft.Singularity.V1.Types.SystemType)">
            <summary>
            Used to allocate a channel endpoint. The size must be correctly computed by
            the trusted caller (currently trusted code NewChannel)
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.V1.Services.EndpointCore.Dispose(Microsoft.Singularity.V1.Services.EndpointCore@)">
            <summary>
            Closes this end of the channel and frees associated resources, EXCEPT the block
            of memory for this endpoint. It must be released by the caller. Sing# does this
            for the programmer.
            Returns true for success, false for failure.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.V1.Services.EndpointCore.Free(Microsoft.Singularity.V1.Services.SharedHeapService.Allocation*)">
            <summary>
            Deallocates this end of the channel. If other end is also
            deallocated, the entire channel is deallocated.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.V1.Services.EndpointCore.Connect(Microsoft.Singularity.V1.Services.SharedHeapService.Allocation*,Microsoft.Singularity.V1.Services.SharedHeapService.Allocation*,Microsoft.Singularity.V1.Services.SharedHeapService.Allocation*)">
            <summary>
            Performs the initialization of the core part of each endpoint and cross links
            them to form a channel.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.V1.Services.EndpointCore.Closed(Microsoft.Singularity.V1.Services.EndpointCore@)">
            <summary>
            Indicates if this endpoint is closed
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.V1.Services.EndpointCore.PeerClosed(Microsoft.Singularity.V1.Services.EndpointCore@)">
            <summary>
            Indicates if the peer endpoint is closed
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.V1.Services.EndpointCore.PeerClosedABI(Microsoft.Singularity.V1.Services.EndpointCore@)">
            <summary>
            Indicates if the peer endpoint is closed (ABI call)
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.V1.Services.EndpointCore.Close(Microsoft.Singularity.V1.Services.EndpointCore@)">
            <summary>
            Set this end to closed
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.V1.Services.EndpointCore.GetPeer(Microsoft.Singularity.V1.Services.EndpointCore@,System.Boolean@)">
            <summary>
            The endpoint to which this endpoint is connected.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.V1.Services.EndpointCore.GetWaitHandle(Microsoft.Singularity.V1.Services.EndpointCore@)">
            <summary>
            The event to wait for messages on this endpoint. Used by Select.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.V1.Services.EndpointCore.NotifyPeer(Microsoft.Singularity.V1.Services.EndpointCore@)">
            <summary>
            Notify the owner of this endpoint that a message is ready.
            Notifies the set owner if this endpoint is part of a set.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.V1.Services.EndpointCore.Wait(Microsoft.Singularity.V1.Services.EndpointCore@)">
            <summary>
            Wait for a message to arrive on this endpoint.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.V1.Services.EndpointCore.TransferBlockOwnership(Microsoft.Singularity.V1.Services.SharedHeapService.Allocation*,Microsoft.Singularity.V1.Services.EndpointCore@)">
            <summary>
            Transfer the given Allocation block to the target endpoint
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.V1.Services.EndpointCore.TransferContentOwnership(Microsoft.Singularity.V1.Services.EndpointCore@,Microsoft.Singularity.V1.Services.EndpointCore@)">
            <summary>
            Transfer any contents that needs to be adjusted from the transferee to the target
            endpoint. Currently, this means setting the ownerProcessId of the
            transferee to that of the target.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.V1.Services.EndpointCore.LinkIntoCollection(Microsoft.Singularity.V1.Services.EndpointCore@,Microsoft.Singularity.V1.Threads.AutoResetEventHandle)">
            <summary>
            Instruct the selectable object to signal events on the given AutoResetEvent
            rather than its normal event in order to aggregate signalling into a set.
            A selectable object need only support being part of a single collection at
            any point in time.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.V1.Services.EndpointCore.UnlinkFromCollection(Microsoft.Singularity.V1.Services.EndpointCore@,Microsoft.Singularity.V1.Threads.AutoResetEventHandle)">
            <summary>
            Instruct the selectable object to stop signalling events on the given
            AutoResetEvent.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.V1.Services.SharedHeapService.Free(Microsoft.Singularity.V1.Services.SharedHeapService.Allocation*)">
            <returns>true if last reference was freed</returns>
        </member>
        <member name="F:Microsoft.Singularity.V1.Types.SystemType.id">
            A handle to a RuntimeSystemType
        </member>
        <member name="M:Microsoft.Singularity.V1.Types.SystemType.Register(System.String,System.Int64,System.Int64,Microsoft.Singularity.V1.Types.SystemType)">
            Called from Binder which lives in a separate dll.
        </member>
        <member name="T:Microsoft.SingSharp.ClaimsAttribute">
             <summary>
             Can be used on parameters of ITracked type to override the default Borrowed semantics.
            
             Means that parameter ownership is not returned by method.
            
             If the attribute appears on an instance method, the attribute applies to the receiver parameter.
             </summary>
        </member>
        <member name="T:Microsoft.SingSharp.BorrowedAttribute">
             <summary>
             Can be used on return of ITracked type to override the default Owned semantics.
             
             Means that the returned value is part of the 'receivers' representation and cannot outlive the receiver.
            
             </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.DeliveryHandle.GetImpl(Microsoft.Singularity.Channels.DeliveryHandle)">
            <summary>
            Returns the delivery implementation object associated with the
            given handle.
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.Channels.DeliveryImpl.endpointAlloc">
            <summary>
            Allocation which holds the endpoint core associated with this
            delivery implementation
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.Channels.DeliveryImpl.endpoint">
            <summary>
            Endpoint core associated with this delivery implementation
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.Channels.DeliveryImpl.principalHandle">
            <summary>
            Handle to the owning Principal
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.Channels.DeliveryImpl.delegationState">
            <summary>
            Delegation state to control delegation through the principal
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.Channels.DeliveryImpl.receiveCount">
            <summary>
            Contains the number of sends to this endpoint.
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.Channels.DeliveryImpl.shadowMessageEvent">
            <summary>
            Event on which sends are signaled to this endpoint.
            The handle is owned by the kernel, since the endpoint can move.
            The kernel deallocates the handle when the channel is deallocated.
            NOTE: stays valid until the entire channel gets collected.
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.Channels.DeliveryImpl.shadowClosed">
            <summary>
            Closed flag
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.Channels.DeliveryImpl.shadowProcessId">
            <summary>
            Contains the process id of the process currently owning this end of the
            channel.
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.Channels.DeliveryImpl.shadowChannelId">
            <summary>
            Contains the channelId (positive on the EXP endpoint, negative on the imp endpoint)
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.Channels.DeliveryImpl.shadowMarshall">
            <summary>
            Whether or not to marshall messages
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.DeliveryImpl.Dispose">
             <summary>
             Closes this end of the channel and frees associated resources,
             EXCEPT the block of memory for this endpoint. It must be released
             by the caller. Sing# does this for the programmer.
            
             This runs in the kernel to avoid a race condition with Process.Stop
             </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.DeliveryImpl.Close">
            <summary>
            Set this end to closed
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.DeliveryImpl.Notify">
            <summary>
            Notify the owner of this endpoint that a message is ready.
            Notifies the set owner if this endpoint is part of a set.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.DeliveryImpl.MoveData(Microsoft.Singularity.Memory.SharedHeap,Microsoft.Singularity.Memory.SharedHeap,Microsoft.Singularity.Process,Microsoft.Singularity.Memory.SharedHeap.Allocation*)">
            <summary>
            Generic copy (either from kernel or to kernel)
            Determines if the thing we are moving is an endpoint and copies it accordingly.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.DeliveryImpl.Peer">
            <summary>
            Return the associated peer of this endpoint
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.DeliveryImpl.MoveEndpoint(Microsoft.Singularity.Memory.SharedHeap,Microsoft.Singularity.Memory.SharedHeap,Microsoft.Singularity.Process)">
            <summary>
            Move endpoint data to a new process
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.DeliveryImpl.IsMechanismInitialized">
            <summary>
            Returns true if this delivery mechanism has been initialised and
            can be used for channel transport.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.DeliveryImpl.GetImplName">
            <summary>
            Returns the name of the delivery implementation actually being used
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.DeliveryImpl.NotifyPeer">
            <summary>
            Notify the peer that a message is ready.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.DeliveryImpl.ClosePeer">
            <summary>
            Close peer endpoint.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.DeliveryImpl.PeerClosed">
            <summary>
            Is peer endpoint closed.
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.Channels.EndpointCore.deliveryHandle">
            <summary>
            Handle to the actual message delivery mechanism
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.Channels.EndpointCore.collectionEvent">
            <summary>
            Event handle in case this endpoint is part of a collection
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.Channels.EndpointCore.cachedMessageEvent">
            <summary>
            Event on which sends are signaled to this endpoint.
            The handle is owned by the kernel, since the endpoint can move.
            The kernel deallocates the handle when the channel is deallocated.
            NOTE: stays valid until the entire channel gets collected.
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.Channels.EndpointCore.cachedClosed">
            <summary>
            Closed flag
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.Channels.EndpointCore.cachedOwnerProcessId">
            <summary>
            Contains the process id of the process currently owning this end of the
            channel.
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.Channels.EndpointCore.cachedChannelId">
            <summary>
            Contains the channelId (positive on the EXP endpoint, negative on the imp endpoint)
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.Channels.EndpointCore.cachedMarshall">
            <summary>
            Whether to marshall or not
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.Channels.EndpointCore.cachedPeer">
            <summary>
            Points to the peer endpoint
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.Channels.EndpointCore.peerStateValid">
            <summary>
            If true then the peer state can be queried directly from cachedPeer
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.Channels.EndpointCore.openChannelCount">
            <summary>
            Number of open channels (using any delivery mechanism)
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.Channels.EndpointCore.channelIdGenerator">
            <summary>
            Channel id generator used to create unique channel id's accross delivery
            mechanisms.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.EndpointCore.AllocationEndpointDeliveryImpl(Microsoft.Singularity.Memory.SharedHeap.Allocation*)">
            <summary>
            Retrieve underlying delivery mechanism for a given endpoint allocation pointer
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.EndpointCore.AllocationEndpointDeliveryImplUnchecked(Microsoft.Singularity.Memory.SharedHeap.Allocation*)">
            <summary>
            Retrieve underlying delivery mechanism for a given endpoint allocation pointer
            using GetDataUnchecked.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.EndpointCore.Connect(Microsoft.Singularity.Memory.SharedHeap.Allocation*,Microsoft.Singularity.Memory.SharedHeap.Allocation*,Microsoft.Singularity.Memory.SharedHeap.Allocation*)">
            <summary>
            Performs the initialization of the core part of each endpoint and cross links
            them to form a channel.  Uses the standard shared address space delivery
            mechanism.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.EndpointCore.Connect(Microsoft.Singularity.Memory.SharedHeap.Allocation*,Microsoft.Singularity.Memory.SharedHeap.Allocation*,Microsoft.Singularity.Memory.SharedHeap.Allocation*,System.String)">
            <summary>
            Performs the initialization of the core part of each endpoint and cross links
            them to form a channel.  Uses the given delivery mechanism.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.EndpointCore.Close">
            <summary>
            Set this end to closed
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.EndpointCore.Dispose">
             <summary>
             Closes this end of the channel and frees associated resources, EXCEPT the block
             of memory for this endpoint. It must be released by the caller. Sing# does this
             for the programmer.
            
             This runs in the kernel to avoid a race condition with Process.Stop.
             </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.EndpointCore.Free(Microsoft.Singularity.Memory.SharedHeap.Allocation*)">
             <summary>
             Explicitly frees this end of the channel.
            
             Since both threads on the channel could try to do this simultaneously,
             we use the ref counting on the underlying endpoints to let the last
             free operation (the one pulling the ref count to 0) to free the associated
             event.
             </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.EndpointCore.GetWaitHandle">
            <summary>
            The event to wait for messages on this endpoint. Used by Select.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.EndpointCore.GetAreHandle">
            <summary>
            Get the AutoResetEventHandle
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.EndpointCore.NotifyPeer">
            <summary>
            Notify the peer of this endpoint that a message is ready.
            Notifies the set owner if this endpoint is part of a set.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.EndpointCore.MoveEndpoint(Microsoft.Singularity.Memory.SharedHeap,Microsoft.Singularity.Memory.SharedHeap,Microsoft.Singularity.Process,Microsoft.Singularity.Memory.SharedHeap.Allocation*)">
             <summary>
             Used internally by the kernel to transfer an endpoint to a new owner
            
             Can be used to transfer ANY kind of shared heap data, not just endpoints.
             </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.EndpointCore.TransferBlockOwnership(Microsoft.Singularity.Memory.SharedHeap.Allocation*,Microsoft.Singularity.Channels.EndpointCore@)">
            <summary>
            Transfer the given Allocation block to the target endpoint
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.EndpointCore.TransferContentOwnership(Microsoft.Singularity.Channels.EndpointCore@,Microsoft.Singularity.Channels.EndpointCore@)">
            <summary>
            Transfer any contents that needs to be adjusted from the transferee to the target
            endpoint.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.EndpointCore.Peer(System.Boolean@)">
            <summary>
            Return a handle for the peer
            </summary>
        </member>
        <member name="P:Microsoft.Singularity.Channels.EndpointCore.EndpointDeliveryImpl">
            <summary>
            Retrieve underlying delivery mechanism for this endpoint
            </summary>
        </member>
        <member name="T:Microsoft.SingSharp.IBorrowed">
            <summary>
            Marker interface for interfaces that custom heap pointers can be boxed to, while
            preventing the loss of ownership tracking.
            Upcasts from an interface deriving from IBorrowed are only allowed if target interface
            also derives from IBorrowed.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.ISelectable.HeadMatches(System.Int32,System.Boolean@,System.Object@)">
             <summary>
             Tests if the message at the head of the queue matches the given tag. If so,
             returns true.
            
             If no match is possible in the future given the current message, possible must
             be set to false. 
             Implementations are disallowed from setting possible to true
             so that the context can chain them.
            
             If the underlying object is an endpoint set, it also returns an object that
             serves to extract the endpoint having the match from the set later.
            
             Again, implementations are disallowed from setting match setMatch to null
             so that the context can chain the calls.
            
             </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.ISelectable.GetWaitHandle">
            <summary>
            Allow the context to get a handle to wait on an event for this object
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.ISelectable.ResetWaitSignal">
            <summary>
            Reset the associated event to avoid spurious wake-ups. This is called by
            Select prior to scanning the state of the ISelectable object.
            </summary>
        </member>
        <member name="T:Microsoft.SingSharp.ITracked">
             <summary>
             ITracked is a marker interface that marks a GC type as linearly tracked.
             
             Upcasts of a class C deriving from ITracked are only allowed if 
             a) the target also derives from ITracked, in which case linear tracking continues, or
             b) the target is an interface deriving from IBorrowed. In this case, the resulting value
                is prevented from escaping the static scope it is in. The checker must make sure that the
                original tracked object isn't used until the borrowed reference dies.
              By default, any parameter of type ITracked is treated as borrowed, meaning that it must
              be owned on entry and ownership is returned on exit.
            
              By default, any out parameter or return value of type ITracked is interpreted as passing fresh
              ownership from callee to caller.
            
              The only overrides needed are for parameters that claim ownership. The Claims attribute below serves
              that purpose.
             </summary>
        </member>
        <member name="M:Microsoft.SingSharp.ITracked.Release">
             <summary>
             Called when a thread releases a tracked object so it can be acquired by another thread.
             Gives implementor of tracked type chance to
             know that current thread no longer owns this tracked resource
            
             Normal clients should not call this method.
             </summary>
        </member>
        <member name="M:Microsoft.SingSharp.ITracked.Acquire">
             <summary>
             Called when a thread acquired a tracked object not owned by it. Gives implementor of tracked type chance to
             know that current thread now owns this tracked resource.
            
             Note, this method cannot block.
            
             Normal clients should not call this method.
             </summary>
        </member>
        <member name="M:Microsoft.SingSharp.ITracked.Dispose">
            <summary>
            Called to delete the associated resource.
            </summary>
        </member>
        <member name="M:Microsoft.SingSharp.ITracked.Expose">
            <summary>
            This is a marker method called at the beginning of expose blocks.
            Expose blocks provide scoped access to the tracked fields of tracked objects.
            </summary>
        </member>
        <member name="M:Microsoft.SingSharp.ITracked.UnExpose">
            <summary>
            This is a marker method called at the end of an expose blocks.
            Expose blocks provide scoped access to the tracked fields of tracked objects.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.IEventCollectionElement.LinkIntoCollection(Microsoft.Singularity.V1.Threads.AutoResetEventHandle)">
            <summary>
            Instruct the selectable object to signal events on the given AutoResetEvent
            rather than its normal event in order to aggregate signalling into a set.
            A selectable object need only support being part of a single collection at
            any point in time.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.IEventCollectionElement.UnlinkFromCollection(Microsoft.Singularity.V1.Threads.AutoResetEventHandle)">
            <summary>
            Instruct the selectable object to stop signalling events on the given
            AutoResetEvent.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.SingleAddrSpaceDelivery.Free(Microsoft.Singularity.Channels.SingleAddrSpaceDelivery)">
            <summary>
            Explicitly frees this end of the channel. If other end is also
            freed, the channel is deallocated, meaning we have to deallocate
            the kernel handles for the auto reset events.
            Since both threads on the channel could try to do this simultaneously,
            we use the ref counting on the underlying endpoints to let the last
            free operation (the one pulling the ref count to 0) to free the associated
            event.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.SingleAddrSpaceDelivery.TryFreeResources(Microsoft.Singularity.Memory.SharedHeap.Allocation*,Microsoft.Singularity.Memory.SharedHeap.AllocationOwnerId)">
            <summary>
            The peer thread might try this too, so we use the ref count of the
            underlying memory to allow only the last freeer to also free the
            associated auto-reset event handle.  Make sure to grab the handle
            before freeing the endpoint.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.SingleAddrSpaceDelivery.NotifyPeer">
            <summary>
            Notify the peer that a message is ready.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.SingleAddrSpaceDelivery.ClosePeer">
            <summary>
            Close peer endpoint.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Channels.SingleAddrSpaceDelivery.PeerClosed">
            <summary>
            Is peer endpoint closed.
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.Hal.Platform.RecSize">
            Platform
        </member>
        <member name="M:Microsoft.Singularity.Hal.HalClock.ClearInterrupt">
            <summary>
            Notification that system has received and processed clock
            interrupt.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Hal.HalClock.GetKernelTicks">
            <summary>Get the time elapsed since booting.
            <returns>Ticks of 100ns of uptime. </returns>
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Hal.HalClock.CpuResumeFromHaltEvent">
            <summary>
            Notification that processor is resuming from halted state.
            Provides clock to re-sync if it uses the CPU timestamp counter.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Hal.HalClock.GetRtcTime">
            <summary>Get time from Real-Time Clock.</summary>
            <returns>The number of 100-nanosecond intervals that
            have elapsed since 12:00 A.M., January 1, 0001.
            </returns>
        </member>
        <member name="M:Microsoft.Singularity.Hal.HalClock.SetRtcTime(System.Int64)">
            <summary>Set time of Real-Time Clock.</summary>
            <param name="rtcTicks">The number of 100-nanosecond intervals
            that have elapsed since 12:00 A.M., January 1, 0001.
            </param>
        </member>
        <member name="M:Microsoft.Singularity.Hal.HalPic.InterruptToIrq(System.Byte)">
            <summary>
            Convert interrupt vector to interrupt request line.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Hal.HalPic.IrqToInterrupt(System.Byte)">
            <summary>
            Convert interrupt request line to interrupt vector.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Hal.HalPic.AckIrq(System.Byte)">
            <summary>
            Acknowledge the interrupt request.  (EOI)
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Hal.HalPic.EnableIrq(System.Byte)">
            <summary>
            Enable interrupt request by removing mask.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Hal.HalPic.DisableIrq(System.Byte)">
            <summary>
            Disable interrupt request by applying mask.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Hal.HalPic.ClearInterrupt(System.Byte)">
            <summary>
            Acknowledge and mask interrupt.
            </summary>
        </member>
        <member name="P:Microsoft.Singularity.Hal.HalPic.MaximumIrq">
            <summary>
            Maximum valid IRQ property.  On legacy PC systems this value is
            15.  On APIC PC systems this number will usually be larger.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Hal.HalTimer.ClearInterrupt">
            <summary>
            Clear interrupt associated with timer.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Hal.HalTimer.SetNextInterrupt(System.TimeSpan)">
             <summary>
             Set relative time of next interrupt.
            
             <param name="delta">
             Relative time of next interrupt.
             The time should be with the range between from <c>SetNextInterruptMinDelta</c> to
             <c>SetNextInterruptMaxDelta</c></param>.
             </summary>
        </member>
        <member name="P:Microsoft.Singularity.Hal.HalTimer.MaxInterruptInterval">
            <value>
            Maximum value accepted by SetNextInterrupt.
            </value>
        </member>
        <member name="P:Microsoft.Singularity.Hal.HalTimer.MinInterruptInterval">
            <value>
            Minimum value accepted by SetNextInterrupt.
            </value>
        </member>
        <member name="T:Microsoft.Singularity.Io.IoConfig">
            <summary>
            Instances of this class represent a set of I/O resources that have been assigned
            to a specific device driver instance.
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.Io.IoConfig.Ids">
            <summary>
            Contains the list of device IDs for this device.  These IDs are created (assigned)
            by the bus driver that enumerated this device.  The bus driver may assign any
            number of IDs.  The first ID should always be the Singularity-compatible ID,
            which uses a path-like syntax, e.g. /pnp/PNP0303 for devices enumerated by the
            PNP BIOS / ISAPNP bus device, or /pci/02/00/8086/... for devices enumerated by
            the PCI bus enumerator.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Io.IoConfig.ToPrint">
            <summary>
            Builds a description of this IoConfig instance.
            </summary>
            <returns>The description text.</returns>
        </member>
        <member name="M:Microsoft.Singularity.Io.IoConfig.ToPrint(System.Text.StringBuilder)">
            <summary>
            Builds a description of this IoConfig instance.
            </summary>
            <param name="text">The text buffer in which to write the description.</param>
        </member>
        <member name="M:Microsoft.Singularity.Io.IoConfig.Print">
            <summary>
            Prints a description of this I/O configuration to the debug port.
            </summary>
        </member>
        <member name="P:Microsoft.Singularity.Io.IoConfig.Id">
            <summary>
            This property exists for compatibility with drivers that assume a single device ID.
            It returns the first device ID in the list.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Io.PciConfig.GetIds">
             <summary>
             <para>
             Builds the list of device IDs for this PCI device.  We generate the same
             strings that Windows uses for its hardware IDs and compatible IDs.
             The order is significant; the PNP manager will search the device IDs,
             one by one, for a device driver that matches.  The list is ordered from
             most specific to least specific.
             </para>
            
             <para>
             WDM "hardware IDs":
                  PCI\VEN_xxxy&amp;DEV_yyyy&amp;SUBSYS_zzzzzzzz&amp;REV_rr
                  PCI\VEN_xxxy&amp;DEV_yyyy&amp;SUBSYS_zzzzzzzz
                  PCI\VEN_xxxy&amp;DEV_yyyy&amp;CC_ccssii
                  PCI\VEN_xxxy&amp;DEV_yyyy&amp;CC_ccss
                  PCI\VEN_xxxy
             </para>
            
             <para>
             WDM "compatible IDs":
                  PCI\VEN_xxxy&amp;DEV_yyyy&amp;REV_rr
                  PCI\VEN_xxxy&amp;DEV_yyyy
                  PCI\VEN_xxxx&amp;CC_ccssii
                  PCI\VEN_xxxx&amp;CC_ccss
                  PCI\CC_ccssii
                  PCI\CC_ccss
             </para>
             </summary>
             <returns>
             An array containing the device IDs.  The list is ordered from most specific
             to least specific.
             </returns>
        </member>
        <member name="T:Microsoft.Singularity.Configuration.StringParameterAttribute">
            
             Parameter Attributes
            
        </member>
        <member name="M:Microsoft.Singularity.Memory.MemoryManager.SetRange(System.UIntPtr,System.UIntPtr,System.UInt32)">
            <summary>
            SetRange - provide access to the GC PageTable
            </summary>
            <param name="start">Beginning address</param>
            <param name="bytes">Number of bytes</param>
            <param name="tag">PageType with which to mark</param>
        </member>
        <member name="M:Microsoft.Singularity.Memory.SharedHeap.DereferenceRegion(System.UIntPtr,System.UIntPtr)">
            <summary>
            Decrement the reference count(s) on the page(s) or small region.
            </summary>
            <returns>true if last reference to this region was freed.</returns>
        </member>
        <member name="M:Microsoft.Singularity.Memory.SharedHeap.Free(Microsoft.Singularity.Memory.SharedHeap.Allocation*,Microsoft.Singularity.Memory.SharedHeap.AllocationOwnerId)">
             <summary>
             Free a previously-allocated region of memory.
            </summary>
            <returns>true if Free releases last reference to underlying memory</returns>
        </member>
        <member name="T:Microsoft.Singularity.Memory.SharedHeap.AllocationVisitor">
            <summary>
            Call back for iterating over all elements of an allocation list.
            </summary>
        </member>
        <member name="T:Microsoft.Singularity.Memory.SharedHeap.AllocationMatches">
            <summary>
            Call back for filtering elements of an allocation list.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Memory.SharedHeap.AllocationOwner.Iterate(Microsoft.Singularity.Memory.SharedHeap.AllocationOwner*,Microsoft.Singularity.Memory.SharedHeap.AllocationVisitor)">
            <summary>
            Calls the visitor with each allocation on the list.
            Important: the visitor is not allowed to keep the element!
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Memory.SharedHeap.AllocationOwner.IterateMatchingForModify(Microsoft.Singularity.Memory.SharedHeap.AllocationOwnerId,Microsoft.Singularity.Memory.SharedHeap.AllocationMatches,Microsoft.Singularity.Memory.SharedHeap.AllocationVisitor)">
             <summary>
             Calls the visitor with each matching allocation on the list.
             The matcher is not allowed to modify the list.
             The visitor is allowed to modify the list (e.g. to delete
             the visited element from the list), and the visitor
             is called with the owner lock unacquired.  Furthermore,
             the iteration releases the owner lock periodically (even
             if visitor is never called) so that it doesn't monopolize
             the lock.  The matcher should only return true if no other
             thread can deallocate the matched element while the lock
             is unheld; otherwise, the visitor will be in a race.
            
             To ensure that iteration is still meaningful in the face
             of concurrent mutation, the iterator adds a "rover"
             node to the beginning of the list, then steps the rover
             one node at a time through the list until it arrives at the
             end.
             </summary>
        </member>
        <member name="P:Microsoft.Singularity.Memory.SharedHeap.AllocationOwner.OutstandingBlocks">
            
              Diagnostic methods
            
        </member>
        <member name="M:Microsoft.Singularity.Memory.SharedHeap.Allocation.GetDataUnchecked(Microsoft.Singularity.Memory.SharedHeap.Allocation*)">
             <summary>
             Only to be used from
              - TransferToProcess
              - Freeing the Sentinel on FreeAll
              - SharedHeap walker
            
             All other uses should be checked.
             </summary>
        </member>
        <member name="T:Microsoft.Singularity.Isal.IX.PE">
            
             <remarks> PAE Paging Constants. </remarks>
            
        </member>
        <member name="T:Microsoft.Singularity.Isal.IX.PTE">
            
             <remarks> IX PAE Page table entry. </remarks>
            
        </member>
        <member name="T:Microsoft.Singularity.Isal.IX.PT">
            
             <remarks> IX PAE Page table. </remarks>
            
        </member>
        <member name="T:Microsoft.Singularity.Isal.IX.PDE">
            
             <remarks> IX PAE Page directory entry. </remarks>
            
        </member>
        <member name="T:Microsoft.Singularity.Isal.IX.PDE_2MB">
            
             <remarks> IX PAE 2MB Page directory entry </remarks>
            
        </member>
        <member name="T:Microsoft.Singularity.Isal.IX.PDT">
            
             <remarks> IX PAE Page directory table. </remarks>
            
        </member>
        <member name="T:Microsoft.Singularity.Isal.IX.PDPE">
            
             <remarks> IX PAE Page directory pointer entry. </remarks>
            
        </member>
        <member name="T:Microsoft.Singularity.Isal.IX.PDPT">
            
             <remarks> IX PAE Page directory pointer table. </remarks>
            
        </member>
        <member name="T:Microsoft.Singularity.KernelDebugger.Kd">
            <summary>
            This class exposes some of the unmanaged kernel debugger functions, mainly
            KdSendPacket and KdReceivePacket.  Eventually, more of the kernel debugger
            support should be moved out of halkd.cpp and into this class.
            
            The main consumer of this class is the KdFiles class.
            </summary>
        </member>
        <member name="T:Microsoft.Singularity.KernelDebugger.KdPacketType">
            <summary>
            Compatible with PACKET_TYPE_XXX defines in halkd.h.
            </summary>
        </member>
        <member name="T:Microsoft.Singularity.KernelDebugger.KdApi">
            <summary>
            These values identify the structure of messages / requests sent between 
            the kernel and KD.  Compatible with DbgKdXxxApi values.
            </summary>
        </member>
        <member name="T:Microsoft.Singularity.KernelDebugger.KdStatus">
            <summary>
            Declares error codes for Kd.ReceivePacket.  Values are compatible
            with unmanaged defines KDP_PACKET_RECEIVED, etc.
            </summary>
        </member>
        <member name="T:Microsoft.Singularity.Xml.XmlReader">
            <summary>
            This is a simple XML Parser that does no validation.
            All it does it parse the syntax of XML
            Note - since IoMemory is not CLSCompliant, neither is this!
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Xml.XmlReader.ExpandEntityReferences(System.String)">
            <summary>
            This method expands XML entity references found in an input string.
            If an invalid entity reference is encountered, this method will throw
            XmlException.
            </summary>
            <param name="input">The string to search for entity references.</param>
            <returns>The expanded string.</returns>
        </member>
        <member name="T:Microsoft.Singularity.Xml.KernelIoMemoryStream">
            <summary>
            This is a wholly unsafe manner of making a byte array look like
            a stream to the KernelXmlReader by giving it Read(), Peek(), and
            Close() methods.
            </summary>
        </member>
        <member name="T:Microsoft.Singularity.Xml.XmlNode">
            <summary>
            Summary description for XmlNode.
            </summary>
        </member>
        <member name="T:Microsoft.Singularity.Xml.XmlException">
            <summary>
            Summary description for XmlException.
            </summary>
        </member>
        <member name="T:Microsoft.Singularity.MpBootStatus">
            <summary> Constants used in MP systems to describe the
            progress of an initializing application processor
            (AP). </summary>
        </member>
        <member name="T:System.GCs.SegregatedFreeList">
             <summary>
             This class supports Allocate/Free operations using memory obtained
             from the PageManager.
            
             Objects that are small enough that multiple instances of them can fit
             on a page are allocated from pages of identically sized memory cells.
            
             Large objects are allocated on separate pages.
            
             This class is designed to be thread safe on both allocation and free
             operations. At this stage it is required that RecycleGlobalPages is
             called periodically to reconsider previously full pages for inclusion
             in allocation lists.
            
             The free operation is currently more expensive than required due to
             space accounting.
            
             This class also keeps up to date memory accounting information. Note
             that modifications to this data is not synchronized so it is possible
             that the counts drift from actual figures over time.
             </summary>
        </member>
        <member name="F:System.GCs.SegregatedFreeList.INIT_PAGE">
            <summary>
            Pages that are the process of being initialized, either as
            a page of small chunks or for a large object.
            </summary>
        </member>
        <member name="F:System.GCs.SegregatedFreeList.SMALL_OBJ_PAGE">
            <summary>
            PageType for pages containing small objects.
            </summary>
        </member>
        <member name="F:System.GCs.SegregatedFreeList.LARGE_OBJ_START">
            <summary>
            For any large object, the first page is marked
            LARGE_OBJ_START, and subsequent pages marked
            LARGE_OBJ_TAIL.
            </summary>
        </member>
        <member name="F:System.GCs.SegregatedFreeList.LOG_PAGE_SIZE">
            <summary>
            BUGBUG: Duplicated constant.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.GetSizeClass(System.UIntPtr)">
             <summary>
             Returns the size class index for an object of the specified size.
            
             BUGBUG: We hope that from an inlined allocation site this is
             resolved as a constant. That is why this was changed to remove
             indirection through an index lookup table.
             </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.GetCellSize(System.UInt32)">
            <summary>
            Returns the cell size for a given size class.
            </summary>
        </member>
        <member name="F:System.GCs.SegregatedFreeList.SmallBytes">
            <summary>
            A count of the bytes allocated for small objects.
            </summary>
        </member>
        <member name="F:System.GCs.SegregatedFreeList.SmallFreedBytes">
            <summary>
            A count of the bytes for objects the process of being freed.
            </summary>
        </member>
        <member name="F:System.GCs.SegregatedFreeList.SmallFreedPages">
            <summary>
            A count of the small pages in the process of being freed.
            </summary>
        </member>
        <member name="F:System.GCs.SegregatedFreeList.LargeFreedPages">
            <summary>
            A count of the large pages in the process of being freed.
            </summary>
        </member>
        <member name="F:System.GCs.SegregatedFreeList.LargePages">
            <summary>
            The number of pages reserved for large objects.
            </summary>
        </member>
        <member name="F:System.GCs.SegregatedFreeList.SmallPages">
            <summary>
            The number of pages reserved for small objects.
            </summary>
        </member>
        <member name="F:System.GCs.SegregatedFreeList.nullPartialFreePageVisitor">
            <summary>
            A partial free page visitor that does nothing.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.AddSmallBytes(System.UIntPtr)">
            <summary>
            Increment the counter of the number of small bytes allocated.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.AddLargePages(System.UIntPtr)">
            <summary>
            Increment the counter of the number of large bytes allocated.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.SubSmallBytes(System.UIntPtr)">
            <summary>
            Decrement the counter of the number of small bytes allocated.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.SubLargePages(System.UIntPtr)">
            <summary>
            Decrement the counter of the number of large pages allocated.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.AddSmallPage(System.GCs.SegregatedFreeList.PageHeader*)">
            <summary>
            Increment the counter of the number of small pages allocated.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.SubSmallPage(System.GCs.SegregatedFreeList.PageHeader*)">
            <summary>
            Decrement the counter of the number of small pages allocated.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.CommitFreedData">
            <summary>
            Subtract and zero the freed data counts.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.NewThreadNotification(System.Threading.Thread,System.Boolean)">
            <summary>
            When notified of the creation of a new thread we initialize the
            alloc heap in that thread.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.DeadThreadNotification(System.Threading.Thread)">
            <summary>
            A thread has finished, so we release any local pages.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.AllocateLarge(System.UInt32,System.UIntPtr,System.Threading.Thread)">
            <summary>
            Allocate a large object. Large objects don't share pages with
            any other objects. Get memory for the object directly from the
            PageManager.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.Free(System.Object)">
            <summary>
            Free the specified object. For large objects the page becomes
            immediately available. For small objects it may require a call
            to RecycleGlobalPages.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.FreeSmall(System.UIntPtr,System.UInt32)">
            <summary>
            Free a small object.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.FreeLarge(System.Object)">
            <summary>
            Free a large object.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.IsGcPtr(System.UIntPtr)">
            <summary>
            Determines whether a given address could be an interior pointer
            into an object.  If the function returns true, FindObjectAddr
            must be able to find the object containing the given address if
            such an object exists.  If the given address is outside the
            memory area for any object, it is possible for the function to
            return true, in which case FindObjectAddr is expected to
            be able to find a nearby object.
            Note: this method assumes that a pointer to the tail of one
            object and the head of another is really a pointer to the tail
            of the former.  In order to use method for pointers into the
            PreHeader, add PreHeader.Size to the argument.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.Find(System.UIntPtr)">
            <summary>
            Given a possibly interior pointer to an object, return the
            real address of the object.  Note that this assumes that
            a pointer to the tail of one object and the head of another
            is really a pointer to the tail of the former.  In order
            to use this for identifying pointers to PreHeader fields,
            add PreHeader.Size to the argument.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.FindSmall(System.UIntPtr)">
            <summary>
            Find a small object (after determining it is on a small page)
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.FindSmallCell(System.UIntPtr)">
            <summary>
            Find the cell for a given object address
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.FindLarge(System.UIntPtr)">
            <summary>
            Find a large object (after determining it is on a large page)
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.VisitAllObjects(System.GCs.SegregatedFreeList.ObjectVisitor)">
            <summary>
            Visit each object in the heap across all pages.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.VisitObjects(System.UIntPtr,System.UIntPtr,System.GCs.SegregatedFreeList.ObjectVisitor)">
             <summary>
             Visit each object in the heap across a range of pages.
            
             This can be run concurrent to allocations, but not frees.
             </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.VisitSmallObjects(System.UIntPtr,System.GCs.SegregatedFreeList.ObjectVisitor)">
            <summary>
            Visit small objects in a single page.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.VisitLargeObject(System.UIntPtr,System.GCs.SegregatedFreeList.ObjectVisitor)">
            <summary>
            Visit a large object on the specified page.
            </summary>
        </member>
        <member name="F:System.GCs.SegregatedFreeList.globalFreePages">
            <summary>
            This is the the free list of pages to allocate from.
            </summary>
        </member>
        <member name="F:System.GCs.SegregatedFreeList.globalPages">
            <summary>
            This is the list of pages released by threads. These pages must
            be periodically processes to release them back for allocation if
            necessary.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.Initialize">
            <summary>
            Initialize the alloc heap by setting up the heads for all the
            linked lists.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.RecycleGlobalPages">
            <summary>
            Take all global pages that have had elements freed and put them in
            the allocation queues.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.AtomicAdd(System.Int32@,System.Int32)">
            <summary>
            Atomically add a value to a field.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.AtomicPush(System.UIntPtr@,System.GCs.SegregatedFreeList.PageHeader*)">
            <summary>
            Atomically push a value onto a linked list.  The linked list
            may be concurrently added to, but may not be concurrently
            removed from.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.AtomicPop(System.UIntPtr@)">
            <summary>
            Atomically remove a value from the linked list. Returns null
            if the list is empty.  The list may be concurrently removed
            from by means of AtomicPop and concurrently added to by means
            of AtomicPushDecrementList.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.AtomicPopChain(System.UIntPtr@)">
            <summary>
            Steal an entire list.  Atomic PopChain can be done concurrently
            with any other atomic operation.  The removal of an entire chain
            does not by itself invite the ABA problem of lock-free algorithms.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.AtomicPushIncrementList(System.UIntPtr@,System.GCs.SegregatedFreeList.PageHeaderList)">
            <summary>
            Push a whole chain onto a list.
            The list may be concurrently added to by means to AtomicPush.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.AtomicPushDecrementList(System.UIntPtr@,System.GCs.SegregatedFreeList.PageHeaderList)">
            <summary>
            Push a whole chain onto a list.
            The list may be concurrently removed from by AtomicPop.
            The removal is done along with removal of the first element of
            the list, and the removed node is returned.  The removal of
            the first element of the list ensures the absence of an ABA
            problem.  AtomicPop and AtomicPushDecrementList are both
            tolerant of the particular kind of ABA change that could occur
            without removal of the first element of the list, but the
            defensive mechanism is used anyway to ensure that potential
            future problems are avoided.
            </summary>
        </member>
        <member name="F:System.GCs.SegregatedFreeList.freeList">
            <summary>
            This is a thread's local free list for each size class.
            </summary>
        </member>
        <member name="F:System.GCs.SegregatedFreeList.localPages">
            <summary>
            This is a thread's local set of pages for each size class.
            </summary>
        </member>
        <member name="F:System.GCs.SegregatedFreeList.largeOffset">
            <summary>
            Used to attempt to spread large objects across pages to avoid
            higher cache conflicts on low page addresses.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.AllocateSmall(System.UInt32,System.Threading.Thread)">
            <summary>
            Allocate an object of a specified size class from the
            thread's local block.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.AllocateSmallSlow(System.UInt32,System.Threading.Thread)">
            <summary>
            Get a new thread-local page and allocate from it.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.ReleaseLocalPage(System.UInt32)">
            <summary>
            Release a local allocation page into the pool of consumed pages.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.GetLocalPage(System.UInt32,System.Threading.Thread)">
            <summary>
            Either reuse an existing page or acquire a completely new page
            to allocate from.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.NewLocalPage(System.UInt32,System.Threading.Thread)">
            <summary>
            Create a new page to allocate from.
            </summary>
        </member>
        <member name="P:System.GCs.SegregatedFreeList.BLOCK_SIZE">
            <summary>
            The size of each block (which contains a single object size)
            </summary>
        </member>
        <member name="P:System.GCs.SegregatedFreeList.LARGE_OBJECT_THRESHOLD">
            <summary>
            The threshold where objects become large objects.
            </summary>
        </member>
        <member name="P:System.GCs.SegregatedFreeList.SIZE_CLASSES">
            <summary>
            The largest possible size class.
            </summary>
        </member>
        <member name="P:System.GCs.SegregatedFreeList.LargeBytes">
            <summary>
            A count of the bytes allocated for large objects.
            </summary>
        </member>
        <member name="P:System.GCs.SegregatedFreeList.TotalBytes">
            <summary>
            This is the total size of data (including object headers)
            </summary>
        </member>
        <member name="P:System.GCs.SegregatedFreeList.ReservedBytes">
            <summary>
            The number of pages managed by the alloc heap, including space
            occupied by empty cells.
            </summary>
        </member>
        <member name="M:System.GCs.SegregatedFreeList.PageHeaderList.Append(System.GCs.SegregatedFreeList.PageHeader*)">
            <summary>
            Add a page onto a local linked list (possibly the first page)
            </summary>
        </member>
        <member name="T:System.GCs.SegregatedFreeList.PageHeader">
             <summary>
             This struct represents the header data stored in each
             small object page.
            
             BUGBUG: Not space efficient.
             </summary>
        </member>
        <member name="F:System.GCs.SegregatedFreeList.PageHeader.nextPage">
            <summary>
            The next page in the linked list.
            </summary>
        </member>
        <member name="F:System.GCs.SegregatedFreeList.PageHeader.freeList">
            <summary>
            The head of the free list for this page. This is not
            used when a page is assigned to a thread.
            </summary>
        </member>
        <member name="F:System.GCs.SegregatedFreeList.PageHeader.cellSize">
            <summary>
            The cell size for objects in this page.
            </summary>
        </member>
        <member name="F:System.GCs.SegregatedFreeList.PageHeader.userValue">
            <summary>
            User value.
            </summary>
        </member>
        <member name="F:System.GCs.SegregatedFreeList.PageHeader.freeCount">
            <summary>
            The number of cells that have been freed. This is used
            for accounting purposes.
            </summary>
        </member>
        <member name="F:Microsoft.Singularity.Kernel.hasBooted">
            <summary> Flag indicating if kernel has succesfully booted </summary>
        </member>
        <member name="P:Microsoft.Singularity.Kernel.HasBooted">
            
             <summary>
                 Property to find out if kernel finished booting
             </summary>
            
        </member>
        <member name="P:Microsoft.Singularity.Kernel.TheScheduler">
            <summary>
                Get a default kernel scheduler
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.Process.GetPrivileges">
            <summary>
            Get the process's current privileges
            </summary>
        </member>
        <member name="P:Microsoft.Singularity.Process.Parent">
            <summary>
            Get the parent process
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.ServiceRequestQueue.#ctor">
            
             <summary>
                 Constructor
             </summary>
            
        </member>
        <member name="T:Microsoft.Singularity.ServiceThread">
            
             <summary>
                 Class processing asynchronous requeusts
             </summary>
            
        </member>
        <member name="M:Microsoft.Singularity.ServiceThread.Request(Microsoft.Singularity.ServiceRequest)">
            
             <summary>
                 Enqueue a request into the service queue
             </summary>
            
             <param name="req">Requeuest to enqueu</param>
            
        </member>
        <member name="M:Microsoft.Singularity.ServiceThread.ServiceLoop">
            
             <summary>
                 Service thread loop processing requests
             </summary>
            
        </member>
        <member name="F:Microsoft.Singularity.ServiceThread.queue">
            <summary> Service queue </summary>
        </member>
        <member name="T:Microsoft.Singularity.SystemClock">
            <remarks>
            The system clock provides an interface to the clock device that
            caters for the difference between the Clock and UTC.  The Clock time
            is typically held in persistent storage and set by the user.  The
            clock time is typically stored local time rather than UTC.
            </remarks>
        </member>
        <member name="M:Microsoft.Singularity.SystemClock.Initialize(Microsoft.Singularity.Hal.HalClock,System.Int64)">
            <summary>
            Constructor.
            <param name="device">Underlying clock device to use.</param>
            <param name="rtcUtcDelta">The UTC offset of the Real-Time Clock
            associated with the clock device. </param>
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.SystemClock.GetRtcUtcOffset(System.Int64)">
            <summary>
            Get the offset applied to the Real-Time Clock device.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.SystemClock.SetRtcUtcOffset(System.Int64)">
            <summary>
            Set the offset applied to the Real-Time Clock device.
            <param name="ticks">Offset in units of 100ns.</param>
            <returns>true on success, false if offset is greater than 12 hours.
            </returns>
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.SystemClock.UtcOffsetValid(System.Int64)">
            <summary> Get the time since booting in kernel ticks of 100ns.
            </summary>
        </member>
        <member name="P:Microsoft.Singularity.SystemClock.KernelUpTime">
            <summary> Get the time elapsed since booting.  All
            kernel timers and timing calculations should be
            based on the time returned by this method to avoid
            problems following <c>TimeZone</c> changes or time updates.
            <returns>Time in units of 100ns. </returns>
            </summary>
        </member>
        <member name="T:Microsoft.Singularity.KernelDebugger.KernelDebuggerFiles">
            <summary>
            This class allows the kernel to send/receive files to/from the attached kernel debugger,
            if any.  Currently, the only use for this is to support the ".kdfiles" command in KD.
            (Refer to the Windows Debugging Tools documentation (debugger.chm) for info on .kdfiles.)
            This allows developers to transfer program binaries (and other files) over the debugger
            port, rather than a filesystem, in order to speed up development.
            
            In the comments in this file, 'host' refers to the machine running the kernel debugger.
            </summary>
        </member>
        <member name="M:Microsoft.Singularity.KernelDebugger.KernelDebuggerFiles.CreateHostFile(System.Int64@,System.Int64@,System.String,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            This method opens a file on the host.  This file handle can be used in calls to ReadHostFile,
            WriteHostFile (depending on access requested), and CloseHostFile.
            </summary>
            <param name="FileHandle">Returns the file handle.  This handle has meaning only to the host.</param>
            <param name="FileLength">Returns the length of the file.</param>
            
            <param name="FileName">
            The file to open.  Note that KD will not allow the debug target to open arbitrary files; this method 
            can only be used to open files that have been added to the .kdfiles set by the developer controlling KD.
            For example, a .kdfiles file (say, kdfiles.txt) contains map entries, in this form:
            
            map [from] [to]
            
            This string identifies the "from" part.  The "to" part identifies some file in the namespace of
            the machine running KD.  If the file is opened successfully, then the debug target can read/write
            the file.
            </param>
            
            <param name="DesiredAccess">
            The access mask requested, using standard Windows access masks.
            However, note that KD will only look for the FILE_READ_DATA and FILE_WRITE_DATA bits, which it
            maps to GENERIC_READ and GENERIC_WRITE.  So don't bother specifying any bits outside of those;
            they will be ignored.
            </param>
            
            <param name="FileAttributes">Initial file attributes, if creating a file.  Most callers should pass 0.</param>
            
            <param name="ShareAccess">
            The shared access mask, if any.  If opening a file for read access, then pass FILE_SHARE_READ.
            </param>
            
            <param name="CreateDisposition">Specifies what to do if the file already exists, or doesn't.
            Use FILE_OPEN, FILE_CREATE, etc.
            </param>
            
            <returns>True if the file was successfully opened.</returns>
        </member>
        <member name="M:Microsoft.Singularity.KernelDebugger.KernelDebuggerFiles.ReadHostFile(System.Int64,System.Int64,System.Void*,System.Int32,System.Int32@)">
            <summary>
            Reads data from a host file that has already been opened using CreateHostFile.
            </summary>
            <param name="RemoteHandle">The file handle.</param>
            <param name="FileOffset">Offset within the file of the chunk to read.</param>
            <param name="Buffer">The buffer to store data into.</param>
            <param name="Length">The number of bytes to transfer.</param>
            <param name="BytesTransferred">On return, the number of bytes actually transferred.</param>
            <returns>True if the transfer succeeded.</returns>
        </member>
        <member name="M:Microsoft.Singularity.KernelDebugger.KernelDebuggerFiles.SendFileIoRequestWaitResponse(Microsoft.Singularity.KernelDebugger.HostFileIoRequest,System.Byte*,System.Int32,Microsoft.Singularity.KernelDebugger.HostFileIoResponse@,System.Byte*,System.Int32,System.Int32@)">
            <summary>
            This internal method handles executing a host file I/O request.  All requests use the
            DBGKD_FILEIO structure; using a structure with a different length will greatly confuse
            the kernel debugger, the kernel, or both.
            </summary>
            
            <param name="Request">The request to send to the debugger.</param>
            <param name="RequestDataBuffer">A buffer containing additional data, if any, to send with the request.</param>
            <param name="RequestDataLength">The length of the additional data to send, or zero if there is none.</param>
            <param name="Response">On return, contains the response message.</param>
            <param name="ResponseDataBuffer">A buffer which receives any returned with the response.</param>
            <param name="ResponseDataMaximumLength">The maximum length of the data to store in the response buffer.</param>
            <param name="ResponseDataActualLength">The actual length of the data to store in the response buffer.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Singularity.KernelDebugger.KernelDebuggerFiles.WriteHostFile(System.Int64,System.Int64,System.Void*,System.Int32,System.Int32@)">
            <summary>
            Writes data to a file open on the host.
            </summary>
            
            <param name="FileHandle">The host file handle, acquired using CreateHostFile.</param>
            <param name="FileOffset">
            The offset within the file to begin writing.
            (TODO: Does this support NT-style always-append semantics?  Probably.)
            </param>
            <param name="Buffer">The buffer containing the data to write.</param>
            <param name="Length">The number of bytes to write.</param>
            <param name="BytesTransferred">The actual number of bytes transferred.</param>
            <returns>True if the transfer succeeded.</returns>
        </member>
        <member name="M:Microsoft.Singularity.KernelDebugger.KernelDebuggerFiles.CloseHostFile(System.Int64)">
            <summary>
            Closes a file handle that was opened using CreateHostFile.
            </summary>
            <param name="FileHandle">The file handle to close.</param>
        </member>
        <member name="M:Microsoft.Singularity.KernelDebugger.KernelDebuggerFiles.DownloadHostFile(System.String,System.Byte[]@)">
            <summary>
            Transfers a file from the debugger to local memory.  See CreateHostFile for more info.
            </summary>
            <param name="filename">
            The file to download; this filename has meaning only to the host debugger.
            </param>
            <param name="FileData"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Singularity.KernelDebugger.CreateHostFileRequest">
            <summary>
            Encodes the "Create Host File" request, which allows this OS instance to open a file that
            resides on the debugger's machine, with the cooperation of the host debugger.
            
            This structure is bit-compatible with the Windows DBGKD_CREATE_FILE structure, defined in ntdbg.h,
            at least when that structure is used as a request.
            
            The name of the file to open is carried in the "additional data", and is encoded in UTF-16 (LE),
            with a Unicode NUL terminator.  The name provided has meaning only to KD; KD uses a look-up table,
            whose contents are set up by the .kdfiles debugger command, to translate these filenames into
            actual host filenames.
            </summary>
        </member>
        <member name="T:Microsoft.Singularity.KernelDebugger.CreateHostFileResponse">
            <summary>
            This structure defines the response to the "Create Host File" request.  This structure is bit-
            compatible with the Windows DBGKD_CREATE_FILE structure, at least with the fields relevant when
            that structure is used as a response.
            
            The field offsets may look strange -- why don't the fields start at 0?  The reason is that
            KD uses the same structure for both the request and (matching) response.  So the fields in
            this structure were originally part of DBGKD_CREATE_FILE / CreateHostFileRequest.  Even then,
            you need to take into account the 8-byte alignment for FileHandle; the compiler inserts 4
            byte of padding alignment between CreateOptions and FileHandle.
            
            </summary>
        </member>
        <member name="T:Microsoft.Singularity.KernelDebugger.ReadHostFileRequest">
            <summary>
            Encodes the "Read Host File" request.  This structure is bit-compatible with the Windows
            DBGKD_READ_FILE structure, defined in ntdbg.h, when used as a request.
            
            Data is returned as additional data in the response.
            
            This structure is used for both the request and response.
            </summary>
        </member>
        <member name="T:Microsoft.Singularity.KernelDebugger.ReadHostFileResponse">
            <summary>
            Encodes the "Read Host File" response.  This structure is bit-compatible with the Windows
            DBGKD_READ_FILE structure, defined in ntdbg.h, when used as a response.
            </summary>
        </member>
        <member name="T:Microsoft.Singularity.KernelDebugger.WriteHostFileRequest">
            <summary>
            Encodes the "Write Host File" request.  This structure is bit-compatible with the Windows
            DBGKD_WRITE_FILE structure, if you exclude the header.
            
            The data to write is carried in the "additional data" field.
            
            This structure is used for both the request and response.
            </summary>
        </member>
        <member name="T:Microsoft.Singularity.KernelDebugger.WriteHostFileResponse">
            <summary>
            Encodes the "Write Host File" response.  This structure is bit-compatible with the Windows
            DBGKD_WRITE_FILE_STRUCTURE, when used as a response.
            </summary>
        </member>
        <member name="T:Microsoft.Singularity.KernelDebugger.CloseHostFileRequest">
            <summary>
            Encodes the "Close Host File" request.  This structure is bit-compatible with the Windows
            DBGKD_CLOSE_FILE structure.  There is no matching CloseHostFileResponse structure, because
            there are no request-specific return fields.
            </summary>
        </member>
        <member name="T:Microsoft.Singularity.KernelDebugger.HostFileIoRequest">
            <summary>
            All reqests transmitted from the kernel to the debugger (KD) use this message format.
            The length is always 64 bytes.
            
            This structure is bit-compatible with the Windows DBGKD_FILE_IO structure.
            </summary>
        </member>
        <member name="T:Microsoft.Singularity.KernelDebugger.HostFileIoResponse">
            <summary>
            All responses transmitted from the debugger (KD) to the kernel use this message format.
            The length is always 64 bytes.
            
            This structure is bit-compatible with the Windows DBGKD_FILE_IO structure.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.OverrideCctorAttribute">
            <summary>
            This attribute must be placed on override types that override the class
            constructor.  It is a compile-time error if the attribute is missing
            during an override.  It is also a compile-time error if it exists and
            either the original or the override type does not have a class
            constructor.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.OverrideExtendsAttribute">
            <summary>
            This attribute must be placed on override types that mean to override the
            base class.  If a base class is overridden, then either this attribute or
            IgnoreOverrideExtendsAttribute must be present.  It is also a compile-time
            error if this attribute exists and the override base class is the same as
            the original base class.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.IgnoreOverrideExtendsAttribute">
            <summary>
            This attribute must be placed on override types that override the base
            class in the override assembly but do not mean to override the base class
            in the actual type.  If a base class is overridden, then either this
            attribute or OverrideExtendsAttribute must be present.  It is also a
            compile-time error if this attribute exists and the override base class is
            the same as the original base class.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.DeleteCctorAttribute">
            <summary>
            This attribute is placed on override types to delete the built-in class
            constructor.  Using this is better than overriding with an empty method.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.DeleteAttribute">
            <summary>
            This attribute is placed on methods in override assemblies to delete the
            original method.  This shouldn't be used for optimization.  For example,
            this was introduced to temporarily remove a complex interface
            implementation that could not be handled by MethodHierarchy.
            </summary>
        </member>
        <member name="T:System.Threading.SpinLockBase">
            
             <summary>
                 Spinlock Base - actual implementation of spinlock mechanism
             </summary>
            
        </member>
        <member name="F:System.Threading.SpinLockBase.MaxSpinLimit">
            <summary> A timer for short back off in ms </summary>
        </member>
        <member name="F:System.Threading.SpinLockBase.ShortBackOffLimit">
            <summary> A counter for short back off in ms </summary>
        </member>
        <member name="F:System.Threading.SpinLockBase.LongBackOffLimit">
            <summary> A counter for short back off in ms </summary>
        </member>
        <member name="F:System.Threading.SpinLockBase.ShortBackOff">
            <summary> A timer for short back off in ms </summary>
        </member>
        <member name="F:System.Threading.SpinLockBase.LongBackOff">
            <summary> A timer for long back off in ms </summary>
        </member>
        <member name="M:System.Threading.SpinLockBase.#ctor(System.Int32)">
            
             <summary>
                 Construct a SpinLockBase and initialize its type
             </summary>
            
             <param name="type">Type of the spin lock. See KernelSpinLock.cs for details</param>
            
        </member>
        <member name="M:System.Threading.SpinLockBase.AssertHeldBy(System.Int32)">
            
             <summary>
                Assert if the specified thread actual owner of the spinlock
             </summary>
            
             <param name="ownerId">Owner Id that request is using to get spinlock</param>
            
        </member>
        <member name="M:System.Threading.SpinLockBase.IsHeld">
            
             <summary>
                 Internal method to find out if spinlock is held by any thread
             </summary>
             <returns> true if the spin lock is acquired. </returns>
            
        </member>
        <member name="M:System.Threading.SpinLockBase.IsHeldBy(System.Int32)">
            
             <summary>
                 Method to find out if spinlock is held by specific thread
             </summary>
             <returns> true if the spin lock is acquired by specific thread. </returns>
            
             <param name="ownerId">Owner Id that request is using to check for spinlock ownership</param>
            
        </member>
        <member name="M:System.Threading.SpinLockBase.TryAcquire(System.Int32)">
            
             <summary>
                 Try to acquire the spin lock. Always return immediately.
             </summary>
             <returns> true if the spin lock is acquired. </returns>
            
        </member>
        <member name="M:System.Threading.SpinLockBase.Acquire(System.Int32)">
            
             <summary>
                Acquire a lock
             </summary>
            
             <param name="ownerId">Owner Id that request is using to acquire spinlock</param>
            
        </member>
        <member name="M:System.Threading.SpinLockBase.Release(System.Int32)">
            
             <summary>
                Release a lock
             </summary>
            
             <param name="ownerId">Spinlock owner</param>
            
        </member>
        <member name="M:System.Threading.SpinLockBase.SpinToAcquire(System.Int32)">
            
             <summary>
                Spin until we can actually acquire spinlock
             </summary>
            
             <param name="ownerId">Owner Id that request is using to acquire spinlock</param>
            
        </member>
        <member name="F:System.Threading.SpinLockBase.ownerId">
            <summary> Thread owner </summary>
        </member>
        <member name="F:System.Threading.SpinLockBase.type">
            <summary>Type of a spinlock</summary>
        </member>
        <member name="P:System.Threading.SpinLockBase.Type">
            
             <summary>
                 Type of a spinlock
            </summary>
            
        </member>
        <member name="T:System.Threading.SpinLock">
            
             <summary>
                 Implementation of Kernel Spinlocks
             </summary>
            
        </member>
        <member name="F:System.Threading.SpinLock.RankShift">
            <summary> Constant defines shift of the rank</summary>
        </member>
        <member name="F:System.Threading.SpinLock.TypeMask">
            <summary> Constant defines mask for getting type of gompound spinlock type </summary>
        </member>
        <member name="F:System.Threading.SpinLock.InitialThreadId">
            <summary> Id of a initial thread </summary>
        </member>
        <member name="M:System.Threading.SpinLock.StaticInitialize">
            
             <summary>
                Static initializer
             </summary>
            
        </member>
        <member name="M:System.Threading.SpinLock.#ctor(System.Threading.SpinLock.Types)">
            
             <summary>
                 Init spinlock
             </summary>
             <param name="type">Type of SpinLock</param>
            
        </member>
        <member name="M:System.Threading.SpinLock.Acquire">
            
             <summary>
                 Acquire spinlock
             </summary>
            
        </member>
        <member name="M:System.Threading.SpinLock.Acquire(System.Int32)">
            
             <summary>
                 Acquire spinlock
             </summary>
            
             <param name="threadId">Thread's Id acquiring spinlock</param>
            
        </member>
        <member name="M:System.Threading.SpinLock.Acquire(System.Threading.Thread)">
            
             <summary>
                 Acquire spinlock
             </summary>
            
             <param name="thread">Thread acquiring spinlock</param>
            
        </member>
        <member name="M:System.Threading.SpinLock.Release">
            
             <summary>
                 Release spinlock
             </summary>
            
        </member>
        <member name="M:System.Threading.SpinLock.Release(System.Int32)">
            
             <summary>
                 Release spinlock
             </summary>
            
             <param name="threadId">Thread's Id releasing spinlock</param>
            
        </member>
        <member name="M:System.Threading.SpinLock.Release(System.Threading.Thread)">
            
             <summary>
                 Release spinlock
             </summary>
            
             <param name="thread">Thread releasing spinlock</param>
            
        </member>
        <member name="M:System.Threading.SpinLock.TryAcquire">
            
             <summary>
                 Try to acquire the spin lock. Always return immediately.
             </summary>
             <returns> true if the spin lock is acquired. </returns>
            
        </member>
        <member name="M:System.Threading.SpinLock.TryAcquire(System.Threading.Thread)">
            
             <summary>
                 Try to acquire the spin lock. Always return immediately.
             </summary>
            
             <returns> true if the spin lock is acquired. </returns>
            
             <param name="thread">Thread acquiring spinlock</param>
            
        </member>
        <member name="M:System.Threading.SpinLock.IsHeldBy(System.Threading.Thread)">
            
             <summary>
                 Method to find out if spinlock is held by specified thread
             </summary>
             <returns> true if the spin lock is acquired. </returns>
            
             <param name="thread">Thread to verify possible spinlock's ownership</param>
            
        </member>
        <member name="M:System.Threading.SpinLock.IsHeldBy(System.Int32)">
            
             <summary>
                 Method to find out if spinlock is held by specified thread
             </summary>
             <returns> true if the spin lock is acquired. </returns>
            
             <param name="threadId">Thread's Id to verify possible spinlock's ownership</param>
            
        </member>
        <member name="M:System.Threading.SpinLock.AssertHeldBy(System.Threading.Thread)">
            
             <summary>
                 Assert thatf spinlock is held by specified thread
             </summary>
            
             <param name="thread">Thread to verify possible spinlock's ownership</param>
            
        </member>
        <member name="M:System.Threading.SpinLock.AssertHeldBy(System.Int32)">
            
             <summary>
                 Assert thatf spinlock is held by specified thread
             </summary>
            
             <param name="threadId">Thread's Id to verify possible spinlock's ownership</param>
            
        </member>
        <member name="M:System.Threading.SpinLock.DeriveType(System.Int32)">
            
             <summary>
                 Given integer : derive type of a lock
             </summary>
            
             <param name="type">Parameter from which we can derive actual type of spinlock</param>
            
        </member>
        <member name="M:System.Threading.SpinLock.DeriveRank(System.Int32)">
            
             <summary>
                 Given integer : derive type of a lock
             </summary>
            
             <param name="type">Parameter from which we can derive actual rank of spinlock</param>
            
        </member>
        <member name="M:System.Threading.SpinLock.TryAcquireInternal(System.Threading.Thread,System.Int32)">
            
             <summary>
                 Try to acquire the spin lock. Always return immediately.
             </summary>
             <returns> true if the spin lock is acquired. </returns>
            
             <param name="thread">Thread acquiring spinlock</param>
             <param name="threadId">Thread's Id acquiring spinlock</param>
            
        </member>
        <member name="M:System.Threading.SpinLock.AcquireInternal(System.Threading.Thread,System.Int32)">
            
             <summary>
                 Acquire the spin lock.
             </summary>
            
             <param name="thread">Thread acquiring spinlock</param>
             <param name="threadId">Thread's Id acquiring spinlock</param>
            
        </member>
        <member name="M:System.Threading.SpinLock.ReleaseInternal(System.Threading.Thread,System.Int32)">
            
             <summary>
                 Release the spin lock.
             </summary>
            
             <param name="thread">Thread releasing spinlock</param>
             <param name="threadId">Thread's Id releasing spinlock</param>
            
        </member>
        <member name="F:System.Threading.SpinLock.baseLock">
            <summary> Actual mechanism implementing spinlock</summary>
        </member>
        <member name="P:System.Threading.SpinLock.Rank">
            
             <summary>
                 SpinLock Rank
             </summary>
            
        </member>
        <member name="P:System.Threading.SpinLock.Type">
            
             <summary>
                 SpinLock Type
             </summary>
            
        </member>
        <member name="T:System.Threading.SpinLock.Ranks">
            
             <summary>
                 Spinlock Rank is enumerator used to enumerate spinlock  ranks. The rule is:
                 holders of lower rank spinlocks can't acquire spinlocks with higher ranks.
                 Note this needs to be a bitmask enum because of the validation logic in Thread.cs
             </summary>
            
        </member>
        <member name="F:System.Threading.SpinLock.Ranks.NoRank">
            <summary> Placeholder. eventually all spinlocks should be ranked </summary>
        </member>
        <member name="F:System.Threading.SpinLock.Ranks.FlatPages">
            <summary>
                Used by flag pages (low level memory management). This is nested
                within several spin locks with Dispatcher rank, including
                PageManager (GC) and linked stack.
            </summary>
        </member>
        <member name="F:System.Threading.SpinLock.Ranks.Hal">
            <summary>
                Use by Hal. This can be nested within other
                spin locks with Dispatcher rank.
            </summary>
        </member>
        <member name="F:System.Threading.SpinLock.Ranks.Dispatcher">
            <summary>
                Used by scheduler and dispatcher code, and other code run with
                interrupt disabled.
            </summary>
        </member>
        <member name="F:System.Threading.SpinLock.Ranks.Passive">
             <summary>
                 The lowest rank above Dispatcher. A thread holding a lock with this rank
                 cannot acquire another spinlock, unless it enters scheduling code through
                 Yield or blocking. Most code above dispatcher level should use this rank.
            
                 Add higher ranks only if the code needs to acquire multiple spinlocks,
                 which should be avoided unless absolutely necessary.
             </summary>
        </member>
        <member name="F:System.Threading.SpinLock.Ranks.Service">
            <summary>
                Used by services implemented in kernel
            </summary>
        </member>
        <member name="T:System.Threading.SpinLock.Types">
            
             <summary>
                 Spinlock Type is enumerator used to enumerate spinlock types so that we can keep
             proper statistic for each spinlock. Statistic will allow us to identify spinlock problems
             </summary>
            
        </member>
        <member name="T:System.Threading.IgnoreLockRankAttribute">
            <summary> Attribute to mark methods that stop lock rank verification </summary>
        </member>
        <member name="T:System.Threading.FlatPagesLockAttribute">
            <summary> Attribute to mark classes / methods that hold FlatPages locks </summary>
        </member>
        <member name="T:System.Threading.HalLockAttribute">
            <summary> Attribute to mark classes / methods that hold Hal locks </summary>
        </member>
        <member name="T:System.Threading.DispatcherLockAttribute">
            <summary> Attribute to mark classes / methods that hold Dispatcher locks </summary>
        </member>
        <member name="T:System.Threading.PassiveLockAttribute">
            <summary> Attribute to mark classes / methods that hold Passive locks </summary>
        </member>
        <member name="T:System.Threading.ServiceLockAttribute">
            <summary> Attribute to mark classes / methods that hold Service locks </summary>
        </member>
        <member name="T:System.Threading.PreemptionLock">
            
        </member>
        <member name="T:System.Finalizer">
             <summary>
             Finalizers are allocated for allocated objects that are finalizable.
            
             BUGBUG: During a garbage collection it should be possible to coalesce
             several FinalizerTable entries into a single entry. In order to
             facilitate this all indexes are currently allocated with reference to
             the first table. It should also be possible to compact the tables.
             </summary>
        </member>
        <member name="M:System.Finalizer.RegisterCandidate(System.Object)">
            <summary>
            Allocate a Finalizer entry for this object.
            </summary>
        </member>
        <member name="M:System.Finalizer.SuppressCandidate(System.Object)">
            <summary>
            Loop through the candidate structure and zero a reference to
            this object.
            </summary>
        </member>
        <member name="M:System.Finalizer.Shutdown">
            <summary>
            Moves all candidates to the run queue.
            </summary>
        </member>
        <member name="M:System.Finalizer.WaitForPending">
            <summary>
            Wait until the finalization queue has been emptied.
            </summary>
        </member>
        <member name="M:System.Finalizer.CompactTables">
            <summary>
            BUGBUG: TODO
            </summary>
        </member>
        <member name="M:System.Finalizer.StartFinalizerThread">
            <summary>
            Start the finalization thread.
            </summary>
        </member>
        <member name="M:System.Finalizer.ThreadLoop">
            <summary>
            The thread loops doing this work forever.
            </summary>
        </member>
        <member name="M:System.Finalizer.PrepareCollectFinalizers">
            <summary>
            This method must be called to prepare the Finalizer data
            structures for a collection.
            </summary>
        </member>
        <member name="M:System.Finalizer.ReleaseCollectFinalizers">
            <summary>
            Finish up after a collection.
            </summary>
        </member>
        <member name="M:System.Finalizer.VisitBootstrapData(System.GCs.DirectReferenceVisitor)">
            <summary>
            Ensure that any references from the Bootstrap space into the
            managed heap are traced during a collection avoiding dangling
            pointers.
            </summary>
        </member>
        <member name="M:System.Finalizer.VisitAllRunFinalizer(System.GCs.DirectReferenceVisitor,System.Boolean,System.Boolean)">
            <summary>
            This method visits all the objects in the RunFinalizer structures.
            </summary>
        </member>
        <member name="M:System.Finalizer.ResurrectCandidates(System.GCs.DirectReferenceVisitor,System.GCs.DirectReferenceVisitor,System.Boolean)">
            <summary>
            Find all candidates that have become unreachable.
            </summary>
        </member>
        <member name="M:System.Finalizer.GetObjectFromRun">
            <summary>
            Find and remove an object from the to be run list.  Remembers where
            the last object was found as a starting point for finding the next
            object.
            </summary>
        </member>
        <member name="F:System.Finalizer.finalizerThread">
            <summary>
            The thread that runs finalizers.
            </summary>
        </member>
        <member name="F:System.Finalizer.madeRunnable">
            <summary>
            Did the current collection make any finalizers runnable?
            </summary>
        </member>
        <member name="F:System.Finalizer.running">
            <summary>
            Is the finalization thread running?
            </summary>
        </member>
        <member name="F:System.Finalizer.CandidateTable">
            <summary>
            The table of Finalization Candidates.
            </summary>
        </member>
        <member name="F:System.Finalizer.CandidateTableShadow">
            <summary>
            A shadow of the candidates table (hidden from GC).
            </summary>
        </member>
        <member name="F:System.Finalizer.RunFinalizerTable">
            <summary>
            The table of objects to have finalizers run Candidates.
            </summary>
        </member>
        <member name="F:System.Finalizer.WorkExistsForFinalizerThread">
            <summary>
            Controls sleeping on the finalizer thread.  The GC signals the
            finalizer thread when there is work to do.  The finalizer thread
            sleeps when there is no work remaining.  The use of an event prevents
            the GC from being blocked.
            </summary>
        </member>
        <member name="F:System.Finalizer.WaitForPendingShouldReturn">
            <summary>
            Controls sleeping in calls to WaitForPendingFinalizers.  The
            finalizer thread signals when work is complete.  The GC resets the
            signal when there is more work.  The use of an event should prevent
            deadlocks.
            </summary>
        </member>
        <member name="F:System.Finalizer.RunFinalizerTableShadow">
            <summary>
            A shadow of the run finalizer table (hidden from GC).
            </summary>
        </member>
        <member name="F:System.Finalizer.lastCandidateIndex">
            <summary>
            This is one more than the highest index in use.
            </summary>
        </member>
        <member name="F:System.Finalizer.freeCandidateLink">
            <summary>
            This is a link into the free list of entries in the CandidateTable.
            </summary>
        </member>
        <member name="F:System.Finalizer.spinLock">
            <summary>
            SpinLock to serialize modifications to the CandidateTable.
            </summary>
        </member>
        <member name="F:System.Finalizer.LastTableRun">
            <summary>
            This is the index of the table from which the last finalizer was run.
            Used as an optimization in finding the next finalizer to run.
            </summary>
        </member>
        <member name="F:System.Finalizer.LastEntryRun">
            <summary>
            This is the index of the finalizer (in LastTableRun) that was last
            run.  Used as an optimization in finding the next finalizer to run.
            </summary>
        </member>
        <member name="F:System.Finalizer.WaitingToRun">
            <summary>
            The number of finalizers waiting to run
            </summary>
        </member>
        <member name="T:System.StackHeight">
             <summary>
             Abstraction for information about the stack height.  This is currently
             only used by the logging undo code for determining if a pointer write
             occurred in stack space allocated after the tryall section began.
            
             StackHeight does not record information about the call stack.
            
             The current implementation is hardwired to a stack model where the stack
             is a single contiguous piece of memory that grows by putting smaller
             values into the stack pointer.
             </summary>
        </member>
        <member name="M:System.StackHeight.#ctor(System.UIntPtr)">
            <summary>
            Interpret the pointer as a stack pointer to determine the stack
            height.
            </summary>
            <param name="stackPointer">Pointer into the stack.</param>
            <returns>The stack height of the location pointed to by the
            argument.</returns>
        </member>
        <member name="M:System.StackHeight.op_Explicit(System.UIntPtr)~System.StackHeight">
            <summary>
            Interpret the pointer as a stack pointer to determine the stack
            height.
            </summary>
            <param name="stackPointer">Pointer into the stack.</param>
            <returns>The stack height of the location pointed to by the
            argument.</returns>
        </member>
        <member name="M:System.StackHeight.GetStackHeight">
            <summary>
            Get the current stack height.
            </summary>
            <returns>The current stack height.</returns>
        </member>
        <member name="M:System.StackHeight.Deeper(System.StackHeight,System.StackHeight)">
            <summary>
            Check if the first stack height represents a deeper location on the
            stack.
            </summary>
            <param name="first">The first stack height to compare.</param>
            <param name="second">The second stack height to compare.</param>
            <returns>True iff the first height is deeper in the stack than the
            second height.</returns>
        </member>
        <member name="F:System.StackHeight.stackPointer">
            <summary>
            The value of the stack pointer when the stack height was taken.
            </summary>
        </member>
        <member name="T:System.WeakReference">
            <summary>
            This class implements weak references.
            
            When a new weak references is allocated it is atomically linked 
            onto a singly linked list of weak references.
            
            During a garbage collection this chain is traversed and references 
            are updated or cleared.
            
            There are two modes of processing weak references.
            
                1. Ignoring 'Long' References that track resurrection and
                   only updating references that should be cleared when the
                   object is finalized.
                2. Updating all reference types.
               
            In any collection at least the second method must be called to 
            ensure no dangling pointers are created.
            
            BUGBUG: At the moment it is possible to have a weak reference that
            is unlinked from the chain and then resurrected as reachable from 
            a finalizable object!
            </summary>
        </member>
        <member name="F:System.WeakReference.headRef">
            <summary>
            The dummy head reference to simplify traversal logic.
            </summary>
        </member>
        <member name="F:System.WeakReference.objPtr">
            <summary>
            The weak reference to the object
            </summary>
        </member>
        <member name="F:System.WeakReference.nextRef">
            <summary>
            The next reference on the chain.
            </summary>
        </member>
        <member name="F:System.WeakReference.trackResurrection">
            <summary>
            Does this reference stay alive during finalization of the target?
            </summary>
        </member>
        <member name="M:System.WeakReference.#ctor(System.Object)">
            <summary>
            Construct a 'Short' weak reference.
            </summary>
        </member>
        <member name="M:System.WeakReference.#ctor(System.Object,System.Boolean)">
            <summary>
            Construct a weak reference and link it onto the chain, 
            specifying if it is to track an object through finalization.
            </summary>
        </member>
        <member name="M:System.WeakReference.Process(System.GCs.DirectReferenceVisitor,System.Boolean,System.Boolean)">
            <summary>
            This method performs the processing of weak references for GC.
            
            It essentially walks a list unlinking weak reference objects 
            that are not live and updating references as necessary.
            </summary>
        </member>
        <member name="M:System.WeakReference.#cctor">
            <summary>
            Class constructor, set up dummy head.
            </summary>
        </member>
        <member name="P:System.WeakReference.IsAlive">
            <summary>
            Is the object alive?
            </summary>
        </member>
        <member name="P:System.WeakReference.Target">
            <summary>
            Get or set target of the object. Null if the object has been
            collected.
            </summary>
        </member>
        <member name="P:System.WeakReference.TrackResurrection">
            <summary>
            Should this reference track objects through finalization?
            </summary>
        </member>
        <member name="T:System.GCs.GCEvent">
            <summary>
            Enumeration of Event Types.
            </summary>
        </member>
        <member name="T:System.GCs.CollectorStatistics">
            <summary>
            Manages statistics from the collector. Intended for communication
            with the scheduler.
            </summary>
        </member>
        <member name="F:System.GCs.CollectorStatistics.CounterFrequency">
            <summary>
            The number of counter values per microsecond.
            </summary>
        </member>
        <member name="F:System.GCs.CollectorStatistics.StartCount">
            <summary>
            The counter value at the initialization of statistics.
            </summary>
        </member>
        <member name="M:System.GCs.CollectorStatistics.Initialize">
            <summary>
            Initialize the statistics information
            </summary>
        </member>
        <member name="M:System.GCs.CollectorStatistics.Summary">
            <summary>
            Print out a summary
            </summary>
        </member>
        <member name="M:System.GCs.CollectorStatistics.Event(System.GCs.GCEvent)">
            <summary>
            A GC event.
            </summary>
        </member>
        <member name="M:System.GCs.CollectorStatistics.Event(System.GCs.GCEvent,System.Int64)">
            <summary>
            A GC event.
            </summary>
        </member>
        <member name="P:System.GCs.CollectorStatistics.PerformanceCounter">
            <summary>
            The current value of the counter.
            </summary>
        </member>
        <member name="M:System.GCs.CMSMarking.ReferenceCheck(System.UIntPtr*,System.Object,System.Int32)">
            <summary>
            In the sliding views phase, where some threads may have
            scanned their roots and others have not, we need to ensure
            that both old and new values will be marked and scanned.
            In the tracing phase we only need to ensure that the old
            values are traced and marked, as the old values may be the
            only references to a part of the snapshot reachable object
            graph from the untraced part of the object graph.
            </summary>
            <param name="addr">The memory location being modified</param>
            <param name="value">The reference value to be written into
            the "addr" location</param>
            <param name="mask">The barrier mode mask generated by the
            compiler</param>
        </member>
        <member name="M:System.GCs.CMSMarking.ReferenceCheck(System.Object@,System.Object,System.Int32)">
            <summary>
            In the sliding views phase, where some threads may have
            scanned their roots and others have not, we need to ensure
            that both old and new values will be marked and scanned.
            In the tracing phase we only need to ensure that the old
            values are traced and marked, as the old values may be the
            only references to a part of the snapshot reachable object
            graph from the untraced part of the object graph.
            </summary>
            <param name="reference">The memory location being modified</param>
            <param name="value">The reference value to be written into
            the "addr" location</param>
            <param name="mask">The barrier mode mask generated by the
            compiler</param>
        </member>
        <member name="M:System.GCs.CMSMarking.MarkIfNecessary(System.UIntPtr)">
            <summary>
            Ensures that a reference value is going to be marked and
            scanned.
            </summary>
            <param name="value">The reference value that may need to
            be marked</param>
        </member>
        <member name="M:System.GCs.CMSMarking.MarkObject(System.UIntPtr,System.Threading.Thread)">
            <summary>
            Ensures that an object is going to be marked and scanned.
            </summary>
        </member>
        <member name="T:System.GCs.ConcurrentMSCollector">
             <summary>
             This class implements a semi-concurrent version of MarkSweep.
            
             The goal for this collector is to perform as much of the processing
             as possible during mutator time, and also have a fixed upper bound
             on pause times.
            
             Additionally, the collector will be required in the future to
             communicate with the scheduler to prevent real time applications
             from competing with the GC.
            
            
             TODO: BUGBUG: NEED TO REPLICATE THE ALLOCATION COLOR LOGIC TO THE
                     INLINED ALLOCATION SEQUENCE.
             </summary>
        </member>
        <member name="F:System.GCs.ConcurrentMSCollector.collectionTrigger">
            <summary>
            Amount of memory to allocate between collections.
            BUGBUG: This heuristic is not very good for CMS.
            </summary>
        </member>
        <member name="M:System.GCs.ConcurrentMSCollector.Initialize">
            <summary>
            Initialise the collector and allow allocations to commence.
            </summary>
        </member>
        <member name="M:System.GCs.ConcurrentMSCollector.CollectStoppable(System.Int32,System.Int32)">
             <summary>
             Perform a collection. Depending on the current phase of collection
             this method will either:
            
                 1. Start a new collection and schedule the mark thread
                 2. Notice that a collection is underway and exit
                 3. Clean up after a collection
            
             BUGBUG: The interaction between the collector needs work!
             </summary>
        </member>
        <member name="M:System.GCs.ConcurrentMSCollector.CollectionTask">
            <summary>
            This method is run by the collector threads.
            </summary>
        </member>
        <member name="M:System.GCs.ConcurrentMSCollector.AllocateObjectMemory(System.UIntPtr,System.UInt32,System.Threading.Thread)">
            <summary>
            Allocate memory for a new object, potentially triggering a
            collection.
            </summary>
        </member>
        <member name="M:System.GCs.ConcurrentMSCollector.GetGeneration(System.Object)">
            <summary>
            Return the generation for an object. We only have one
            generation, so we always return generation zero.
            </summary>
        </member>
        <member name="M:System.GCs.ConcurrentMSCollector.DestructHeap">
            <summary>
            Destroy the heap. Nothing to do here.
            </summary>
        </member>
        <member name="M:System.GCs.ConcurrentMSCollector.VerifyHeap(System.Boolean)">
            <summary>
            Verify the heap.
            </summary>
        </member>
        <member name="F:System.GCs.ConcurrentMSCollector.collectorStack">
            Routines to keep track of requests for collection work
        </member>
        <member name="M:System.GCs.ConcurrentMSCollector.AddThreadToWaitList(System.Int32)">
            Routines to keep track of threads that must be notified when
            a collection has been completed.
        </member>
        <member name="M:System.GCs.ConcurrentMSCollector.MakeTraceRequest">
            Routines to control the commencement of the tracing phase
        </member>
        <member name="M:System.GCs.ConcurrentMSCollector.Sweep">
            <summary>
            Walk the allocation structures and reclaim any free cells.
            </summary>
        </member>
        <member name="M:System.GCs.ConcurrentMSCollector.CommitSweep">
            <summary>
            Update alloc heap to account for data just freed.
            </summary>
        </member>
        <member name="M:System.GCs.ConcurrentMSCollector.CollectionGeneration(System.Int32)">
            <summary>
            Select the generation to collect (always generation 0)
            </summary>
        </member>
        <member name="M:System.GCs.ConcurrentMSCollector.FindObjectAddr(System.UIntPtr)">
            <summary>
            Find the object address for a given interior pointer.
            </summary>
        </member>
        <member name="M:System.GCs.ConcurrentMSCollector.VisitObjects(System.GCs.ObjectLayout.ObjectVisitor,System.UIntPtr,System.UIntPtr)">
            <summary>
            Visit all objects in the heap with a specified visitor.
            </summary>
        </member>
        <member name="M:System.GCs.ConcurrentMSCollector.NewThreadNotification(System.Threading.Thread,System.Boolean)">
            <summary>
            A new thread has been created, set any allocator/collector state.
            </summary>
        </member>
        <member name="M:System.GCs.ConcurrentMSCollector.VerifyEmptyQueues">
            <summary>
            This method loops through all non-null threads and asserts that
            no thread has any work on its marking queue.
            </summary>
        </member>
        <member name="M:System.GCs.ConcurrentMSCollector.VerifyQueueHeaders">
            <summary>
            This method walks through all objects in the heap to ensure
            that no objects have values in their queue header field
            </summary>
        </member>
        <member name="P:System.GCs.ConcurrentMSCollector.markedColor">
            <summary>
            Current mark state. This is flipped between collections.
            </summary>
        </member>
        <member name="P:System.GCs.ConcurrentMSCollector.IsOnTheFlyCollector">
            <summary>
            Does this collector compute a root set with threads running?
            </summary>
        </member>
        <member name="P:System.GCs.ConcurrentMSCollector.MaxGeneration">
            <summary>
            The maximum generation. For MarkSweep this is generation zero.
            </summary>
        </member>
        <member name="P:System.GCs.ConcurrentMSCollector.MinGeneration">
            <summary>
            The minimum generation. For MarkSweep this is generation zero.
            </summary>
        </member>
        <member name="P:System.GCs.ConcurrentMSCollector.TotalMemory">
            <summary>
            This returns the total amount of memory that is allocated within
            the collected heap.
            </summary>
        </member>
        <member name="T:System.GCs.ConcurrentMSCollector.UpdateReferenceVisitor">
            <summary>
            Routines for updating pointers to new locations of marked objects
            No objects are resurrected using this mechanism.
            As this is mark sweep the value does not need to be updated.
            </summary>
        </member>
        <member name="T:System.GCs.ConcurrentMSCollector.MarkReferenceVisitor">
            <summary>
            This visitor is the core of the tracing functionality.
            It builds up a buffer of references (the root set), and
            then at a later point the tracing thread processes these
            buffers.
            </summary>
        </member>
        <member name="M:System.GCs.ConcurrentMSCollector.MarkReferenceVisitor.ProcessGrayObjects">
            <summary>
            Process all marked objects from queues stored in
            thread objects.
            </summary>
        </member>
        <member name="M:System.GCs.ConcurrentMSCollector.MarkReferenceVisitor.AcquireWork(System.GCs.ThreadHeaderQueue.LocalList@)">
            <summary>
            Look through other threads and see if any have some values on
            their queues that we can acquire.
            </summary>
        </member>
        <member name="M:System.GCs.ConcurrentMSCollector.MarkReferenceVisitor.Cleanup">
            <summary>
            Clean up after processing all queues. This involves calling
            reset on each thread's queue.
            </summary>
        </member>
        <member name="T:System.GCs.ConcurrentMSCollector.StackMarkReferenceVisitor">
            <summary>
            This class maps an interior pointer back to the containing object
            pointer and then passes it on to the object marking visitor.
            </summary>
        </member>
        <member name="M:System.GCs.ConcurrentMSCollector.StackMarkReferenceVisitor.Visit(System.UIntPtr*)">
            <summary>
            Visit an interior pointer stored in loc.
            </summary>
        </member>
        <member name="T:System.GCs.ConcurrentMSCollector.UnmarkVisitor">
            <summary>
            This class is used to visit every object in the heap
            replacing markedColor with unmarkedColor.  It is used
            only in the StopTheWorld phase of the collector.
            </summary>
        </member>
        <member name="T:System.GCs.ConcurrentMSCollector.SweepVisitor">
            <summary>
            This class is used to visit every object, determine if it
            is marked and free it if not.
            </summary>
        </member>
        <member name="T:System.GCs.ConcurrentMSCollector.VerifyVisitor">
            <summary>
            This class is used to verify that there are no dangling pointers.
            </summary>
        </member>
        <member name="T:System.GCs.ConcurrentMSCollector.VerifyMarkVisitor">
            <summary>
            This class is used to check that all the pointers within a marked
            object point into other marked objects.
            </summary>
        </member>
        <member name="T:System.GCs.ConcurrentMSCollector.VerifyHeaderVisitor">
            <summary>
            This visitor trivially asserts that the objects queue header
            field is zero.
            </summary>
        </member>
        <member name="M:System.GCs.ConcurrentMSCollector.VerifyHeaderVisitor.VisitSmall(System.Object,System.UIntPtr)">
            <summary>
            Visit small objects, checking queue header.
            </summary>
        </member>
        <member name="T:System.GCs.ThreadHeaderQueue">
             <summary>
             This class defines a queue that is created as a linked list from
             each thread object through pointers stored in object headers.
            
             This queue is used for the concurrent mark sweep collector to allow
             it to trace through the heap without ever requiring allocation
             or locking.
            
             Within a thread this is a FIFO queue; all mutations are made at the
             head.
             </summary>
        </member>
        <member name="F:System.GCs.ThreadHeaderQueue.ongoingUpdates">
            <summary>
            A counter of ongoing attempts to update the queue.  If the
            push operations are non-interruptable, the possible values
            are 0 and 1.  In the Singularity kernel, the push operation
            may be interrupted and code run in the interrupt handlers
            may cause overlapping attempts to update the queue, so the
            possible values range between 0 and the number of threads.
            </summary>
        </member>
        <member name="F:System.GCs.ThreadHeaderQueue.head">
             <summary>
             Contains the pointer to the first object in the queue, or
             the TAIL_MARKER value if the queue is empty.
            
             This field really should be declared volatile, but since C#
             does not support atomic operations on volatile variables,
             we have to use atomic operations on every read and write of
             this variable to ensure is appears to be a volatile variable.
             </summary>
        </member>
        <member name="F:System.GCs.ThreadHeaderQueue.stolenHead">
             <summary>
             Contains a pointer to the object that was at the head of the
             queue the last time it was 'stolen' by a consuming thread.
            
             If this.stolenHead is equal to this.head, then there is nothing
             on the queue that has not been stolen.  If they are different,
             then the queue contains the list of nodes that starts at
             this.head and ends at this.stolenHead, but does not include
             the node at this.stolenHead.
            
             This field really should be declared volatile, but since C#
             does not support atomic operations on volatile variables,
             we have to use atomic operations on every read and write of
             this variable to ensure is appears to be a volatile variable.
             </summary>
        </member>
        <member name="F:System.GCs.ThreadHeaderQueue.transferAttempt">
            <summary>
            This flag indicates that there has been an attempt to transfer
            the contents of a dead thread's ThreadHeaderQueue
            to another thread's ThreadHeaderQueue.  The flag is used when
            trying to establish that all threads' ThreadHeaderQueues are
            empty.  The usage pattern is to first clear this flag, then
            iterate through all the threads checking that the
            ThreadHeaderQueues are empty, and finally checking that the
            flag has not been set during the iteration through the threads.
            Doing so prevents an unnoticed transfer of work from an unvisited
            dying/dead thread to an already visited thread followed by the
            disappearance of the dead thread.
            </summary>
        </member>
        <member name="M:System.GCs.ThreadHeaderQueue.CompareAndSwap(System.UIntPtr@,System.UIntPtr,System.UIntPtr)">
            <summary>
            Atomically compare-and-swap (CAS) one value for another.
            Return true if the CAS operation succeeds, false otherwise.
            </summary>
        </member>
        <member name="M:System.GCs.ThreadHeaderQueue.Reset(System.Threading.Thread)">
            <summary>
            Reset the queue of a thread.
            </summary>
        </member>
        <member name="M:System.GCs.ThreadHeaderQueue.Reset">
            <summary>
            Reset the queue.
            </summary>
        </member>
        <member name="M:System.GCs.ThreadHeaderQueue.IsEmpty(System.Threading.Thread)">
            <summary>
            Is the queue empty?
            </summary>
        </member>
        <member name="M:System.GCs.ThreadHeaderQueue.QueueField(System.Object)">
            <summary>
            Return the value of an object's link field.
            </summary>
        </member>
        <member name="M:System.GCs.ThreadHeaderQueue.SetQueueField(System.Object,System.UIntPtr)">
            <summary>
            Set  an object's link field to a given value.
            </summary>
        </member>
        <member name="M:System.GCs.ThreadHeaderQueue.ExchangeQueueField(System.Object,System.UIntPtr,System.UIntPtr)">
            <summary>
            Perform a CAS operation on an object's link field.
            </summary>
        </member>
        <member name="M:System.GCs.ThreadHeaderQueue.QueueLink(System.Object)">
            <summary>
            An object's link field can contain both a link to another
            object and two mark bits.  This function returns the link
            part of the link field.
            </summary>
        </member>
        <member name="M:System.GCs.ThreadHeaderQueue.GcMark(System.Object)">
            <summary>
            An object's link field can contain both a link to another
            object and two mark bits.  This function returns the mark
            part of the link field.
            </summary>
        </member>
        <member name="M:System.GCs.ThreadHeaderQueue.SetGcMark(System.UIntPtr,System.UIntPtr)">
            <summary>
            Sets the mark value in the header word of the object.
            </summary>
        </member>
        <member name="M:System.GCs.ThreadHeaderQueue.Push(System.Threading.Thread,System.UIntPtr,System.UIntPtr,System.UIntPtr)">
            <summary>
            Link a new value at the head of the queue.  It is assumed that
            if the object is unmarked, the value in the header word will
            simply be 'unmarkedColor'.  The function returns true if the
            object was marked and linked into the queue.  The function
            returns false if the object has already linked into an(other)
            queue.
            </summary>
        </member>
        <member name="M:System.GCs.ThreadHeaderQueue.PushPrivateObject(System.Threading.Thread,System.Object,System.UIntPtr)">
            <summary>
            Link a new value at the head of the queue, knowing that the
            object is a thread local object.  Since the object is
            thread local, we don't need to use a CAS operation to set
            the link field of the object.
            </summary>
        </member>
        <member name="M:System.GCs.ThreadHeaderQueue.StealDead(System.Threading.Thread,System.Threading.Thread,System.UIntPtr)">
             <summary>
             This method attempts to take values from the passed-in queue
             and place it in the 'this' queue.  The method is tolerant
             of concurrent attempts to steal from the fromQueue.  The
             'fromThread' is assumed to be dead, which means that no
             additions to its queue is possible.
            
             Rather than reading the old mark value from the header word
             of the tail object in the 'fromQueue', the new mark value in
             said object is going to be 'markedColor'
             </summary>
        </member>
        <member name="P:System.GCs.ThreadHeaderQueue.TAIL_MARKER">
            <summary>
            Every object that is in a ThreadHeaderQueue list must have a
            non-zero link field.  To ensure this invariant for the last
            element in the list, a non-zero value is used to mark the
            end of the list.  TAIL_MARKER is that value.
            </summary>
        </member>
        <member name="M:System.GCs.ThreadHeaderQueue.LocalList.IsEmpty">
            <summary>
            Is the queue empty?
            </summary>
        </member>
        <member name="M:System.GCs.ThreadHeaderQueue.LocalList.StealFrom(System.Threading.Thread,System.UIntPtr)">
             <summary>
             This method attempts to take values from the passed-in queue
             and place it in the 'this' local queue.  It assumes that the
             'this' local queue is not concurrently added to.  However,
             the method is tolerant of concurrent attempts to steal from
             the fromQueue.
            
             If any values are stolen the method returns true.
             </summary>
        </member>
        <member name="M:System.GCs.ThreadHeaderQueue.LocalList.Pop(System.UIntPtr)">
            <summary>
            Unlink a value from the head of the queue. This
            method is NOT thread safe.  The method is supposed to be
            called only by the thread that populates the queue.
            </summary>
        </member>
    </members>
</doc>
