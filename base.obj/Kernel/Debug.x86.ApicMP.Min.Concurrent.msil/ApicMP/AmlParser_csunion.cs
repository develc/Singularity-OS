///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  Microsoft Research Singularity
//
//  This file is automatically generated by mkunion. Do not check it in or edit it.
//


using System.Diagnostics;


using Microsoft.Singularity.Hal.Acpi;
using ByteData  = System.Byte;
using WordData  = System.UInt16;
using DWordData = System.UInt32;
using QWordData = System.UInt64;

namespace Microsoft.Singularity.Hal.Acpi.AmlParserUnions
{

    public class SimpleName : AmlParserNode
    {
        public enum TagValue
        {
            NameString,
            ArgObj,
            LocalObj,
        }

        private TagValue tag;

        public TagValue Tag
        {
            get {
                return tag;
            }
        }

        private object value;

        private SimpleName(TagValue tag, object value) {
            this.tag = tag;
            this.value = value;
        }

        public static SimpleName CreateNameString(AmlParser.NameString nameString)
        {
            return new SimpleName(TagValue.NameString, nameString);
        }

        public static SimpleName CreateArgObj(AmlParser.ArgObj argObj)
        {
            return new SimpleName(TagValue.ArgObj, argObj);
        }

        public static SimpleName CreateLocalObj(AmlParser.LocalObj localObj)
        {
            return new SimpleName(TagValue.LocalObj, localObj);
        }

        public AmlParser.NameString GetAsNameString()
        {
            Debug.Assert(Tag == TagValue.NameString, "Type error: tried to access disjoint union as 'NameString' but tag does not match");
            return (AmlParser.NameString)value;
        }

        public AmlParser.ArgObj GetAsArgObj()
        {
            Debug.Assert(Tag == TagValue.ArgObj, "Type error: tried to access disjoint union as 'ArgObj' but tag does not match");
            return (AmlParser.ArgObj)value;
        }

        public AmlParser.LocalObj GetAsLocalObj()
        {
            Debug.Assert(Tag == TagValue.LocalObj, "Type error: tried to access disjoint union as 'LocalObj' but tag does not match");
            return (AmlParser.LocalObj)value;
        }

#if false
        // Example usage template for this disjoint union type
        public static void ExampleUsage(SimpleName simpleName)
        {
            switch (simpleName.Tag) {
                case SimpleName.TagValue.NameString:
                    AmlParser.NameString nameString = simpleName.GetAsNameString();
                    break;
                case SimpleName.TagValue.ArgObj:
                    AmlParser.ArgObj argObj = simpleName.GetAsArgObj();
                    break;
                case SimpleName.TagValue.LocalObj:
                    AmlParser.LocalObj localObj = simpleName.GetAsLocalObj();
                    break;
                default:
                    Debug.Assert(false, "Unhandled alternative in switch over 'SimpleName'");
                    break;
            }
        }
#endif
    public override void Accept(AmlParserNodeVisitor v) {        v.Visit(this);    }        public void AcceptAlternative(AmlParserNodeVisitor v) {        ((AmlParserNode)value).Accept(v);    }    
    }

    public class SuperName : AmlParserNode
    {
        public enum TagValue
        {
            SimpleName,
            DebugObj,
            Type6Opcode,
        }

        private TagValue tag;

        public TagValue Tag
        {
            get {
                return tag;
            }
        }

        private object value;

        private SuperName(TagValue tag, object value) {
            this.tag = tag;
            this.value = value;
        }

        public static SuperName CreateSimpleName(SimpleName simpleName)
        {
            return new SuperName(TagValue.SimpleName, simpleName);
        }

        public static SuperName CreateDebugObj(AmlParser.DebugObj debugObj)
        {
            return new SuperName(TagValue.DebugObj, debugObj);
        }

        public static SuperName CreateType6Opcode(Type6Opcode type6Opcode)
        {
            return new SuperName(TagValue.Type6Opcode, type6Opcode);
        }

        public SimpleName GetAsSimpleName()
        {
            Debug.Assert(Tag == TagValue.SimpleName, "Type error: tried to access disjoint union as 'SimpleName' but tag does not match");
            return (SimpleName)value;
        }

        public AmlParser.DebugObj GetAsDebugObj()
        {
            Debug.Assert(Tag == TagValue.DebugObj, "Type error: tried to access disjoint union as 'DebugObj' but tag does not match");
            return (AmlParser.DebugObj)value;
        }

        public Type6Opcode GetAsType6Opcode()
        {
            Debug.Assert(Tag == TagValue.Type6Opcode, "Type error: tried to access disjoint union as 'Type6Opcode' but tag does not match");
            return (Type6Opcode)value;
        }

#if false
        // Example usage template for this disjoint union type
        public static void ExampleUsage(SuperName superName)
        {
            switch (superName.Tag) {
                case SuperName.TagValue.SimpleName:
                    SimpleName simpleName = superName.GetAsSimpleName();
                    break;
                case SuperName.TagValue.DebugObj:
                    AmlParser.DebugObj debugObj = superName.GetAsDebugObj();
                    break;
                case SuperName.TagValue.Type6Opcode:
                    Type6Opcode type6Opcode = superName.GetAsType6Opcode();
                    break;
                default:
                    Debug.Assert(false, "Unhandled alternative in switch over 'SuperName'");
                    break;
            }
        }
#endif
    public override void Accept(AmlParserNodeVisitor v) {        v.Visit(this);    }        public void AcceptAlternative(AmlParserNodeVisitor v) {        ((AmlParserNode)value).Accept(v);    }    
    }

    public class ComputationalData : AmlParserNode
    {
        public enum TagValue
        {
            ByteConst,
            WordConst,
            DWordConst,
            QWordConst,
            StringConst,
            ConstObj,
            RevisionOp,
            DefBuffer,
        }

        private TagValue tag;

        public TagValue Tag
        {
            get {
                return tag;
            }
        }

        private object value;

        private ComputationalData(TagValue tag, object value) {
            this.tag = tag;
            this.value = value;
        }

        public static ComputationalData CreateByteConst(ByteData byteConst)
        {
            return new ComputationalData(TagValue.ByteConst, byteConst);
        }

        public static ComputationalData CreateWordConst(WordData wordConst)
        {
            return new ComputationalData(TagValue.WordConst, wordConst);
        }

        public static ComputationalData CreateDWordConst(DWordData dWordConst)
        {
            return new ComputationalData(TagValue.DWordConst, dWordConst);
        }

        public static ComputationalData CreateQWordConst(QWordData qWordConst)
        {
            return new ComputationalData(TagValue.QWordConst, qWordConst);
        }

        public static ComputationalData CreateStringConst(string stringConst)
        {
            return new ComputationalData(TagValue.StringConst, stringConst);
        }

        public static ComputationalData CreateConstObj(AmlParser.ConstObj constObj)
        {
            return new ComputationalData(TagValue.ConstObj, constObj);
        }

        public static ComputationalData CreateRevisionOp()
        {
            return new ComputationalData(TagValue.RevisionOp, null);
        }

        public static ComputationalData CreateDefBuffer(AmlParser.DefBuffer defBuffer)
        {
            return new ComputationalData(TagValue.DefBuffer, defBuffer);
        }

        public ByteData GetAsByteConst()
        {
            Debug.Assert(Tag == TagValue.ByteConst, "Type error: tried to access disjoint union as 'ByteConst' but tag does not match");
            return (ByteData)value;
        }

        public WordData GetAsWordConst()
        {
            Debug.Assert(Tag == TagValue.WordConst, "Type error: tried to access disjoint union as 'WordConst' but tag does not match");
            return (WordData)value;
        }

        public DWordData GetAsDWordConst()
        {
            Debug.Assert(Tag == TagValue.DWordConst, "Type error: tried to access disjoint union as 'DWordConst' but tag does not match");
            return (DWordData)value;
        }

        public QWordData GetAsQWordConst()
        {
            Debug.Assert(Tag == TagValue.QWordConst, "Type error: tried to access disjoint union as 'QWordConst' but tag does not match");
            return (QWordData)value;
        }

        public string GetAsStringConst()
        {
            Debug.Assert(Tag == TagValue.StringConst, "Type error: tried to access disjoint union as 'StringConst' but tag does not match");
            return (string)value;
        }

        public AmlParser.ConstObj GetAsConstObj()
        {
            Debug.Assert(Tag == TagValue.ConstObj, "Type error: tried to access disjoint union as 'ConstObj' but tag does not match");
            return (AmlParser.ConstObj)value;
        }

        public AmlParser.DefBuffer GetAsDefBuffer()
        {
            Debug.Assert(Tag == TagValue.DefBuffer, "Type error: tried to access disjoint union as 'DefBuffer' but tag does not match");
            return (AmlParser.DefBuffer)value;
        }

#if false
        // Example usage template for this disjoint union type
        public static void ExampleUsage(ComputationalData computationalData)
        {
            switch (computationalData.Tag) {
                case ComputationalData.TagValue.ByteConst:
                    ByteData byteConst = computationalData.GetAsByteConst();
                    break;
                case ComputationalData.TagValue.WordConst:
                    WordData wordConst = computationalData.GetAsWordConst();
                    break;
                case ComputationalData.TagValue.DWordConst:
                    DWordData dWordConst = computationalData.GetAsDWordConst();
                    break;
                case ComputationalData.TagValue.QWordConst:
                    QWordData qWordConst = computationalData.GetAsQWordConst();
                    break;
                case ComputationalData.TagValue.StringConst:
                    string stringConst = computationalData.GetAsStringConst();
                    break;
                case ComputationalData.TagValue.ConstObj:
                    AmlParser.ConstObj constObj = computationalData.GetAsConstObj();
                    break;
                case ComputationalData.TagValue.RevisionOp:
                    break;
                case ComputationalData.TagValue.DefBuffer:
                    AmlParser.DefBuffer defBuffer = computationalData.GetAsDefBuffer();
                    break;
                default:
                    Debug.Assert(false, "Unhandled alternative in switch over 'ComputationalData'");
                    break;
            }
        }
#endif
    public override void Accept(AmlParserNodeVisitor v) {        v.Visit(this);    }        public void AcceptAlternative(AmlParserNodeVisitor v) {        ((AmlParserNode)value).Accept(v);    }    
    }

    public class DataObject : AmlParserNode
    {
        public enum TagValue
        {
            ComputationalData,
            DefPackage,
            DefVarPackage,
        }

        private TagValue tag;

        public TagValue Tag
        {
            get {
                return tag;
            }
        }

        private object value;

        private DataObject(TagValue tag, object value) {
            this.tag = tag;
            this.value = value;
        }

        public static DataObject CreateComputationalData(ComputationalData computationalData)
        {
            return new DataObject(TagValue.ComputationalData, computationalData);
        }

        public static DataObject CreateDefPackage(AmlParser.DefPackage defPackage)
        {
            return new DataObject(TagValue.DefPackage, defPackage);
        }

        public static DataObject CreateDefVarPackage(AmlParser.DefVarPackage defVarPackage)
        {
            return new DataObject(TagValue.DefVarPackage, defVarPackage);
        }

        public ComputationalData GetAsComputationalData()
        {
            Debug.Assert(Tag == TagValue.ComputationalData, "Type error: tried to access disjoint union as 'ComputationalData' but tag does not match");
            return (ComputationalData)value;
        }

        public AmlParser.DefPackage GetAsDefPackage()
        {
            Debug.Assert(Tag == TagValue.DefPackage, "Type error: tried to access disjoint union as 'DefPackage' but tag does not match");
            return (AmlParser.DefPackage)value;
        }

        public AmlParser.DefVarPackage GetAsDefVarPackage()
        {
            Debug.Assert(Tag == TagValue.DefVarPackage, "Type error: tried to access disjoint union as 'DefVarPackage' but tag does not match");
            return (AmlParser.DefVarPackage)value;
        }

#if false
        // Example usage template for this disjoint union type
        public static void ExampleUsage(DataObject dataObject)
        {
            switch (dataObject.Tag) {
                case DataObject.TagValue.ComputationalData:
                    ComputationalData computationalData = dataObject.GetAsComputationalData();
                    break;
                case DataObject.TagValue.DefPackage:
                    AmlParser.DefPackage defPackage = dataObject.GetAsDefPackage();
                    break;
                case DataObject.TagValue.DefVarPackage:
                    AmlParser.DefVarPackage defVarPackage = dataObject.GetAsDefVarPackage();
                    break;
                default:
                    Debug.Assert(false, "Unhandled alternative in switch over 'DataObject'");
                    break;
            }
        }
#endif
    public override void Accept(AmlParserNodeVisitor v) {        v.Visit(this);    }        public void AcceptAlternative(AmlParserNodeVisitor v) {        ((AmlParserNode)value).Accept(v);    }    
    }

    public class DataRefObject : AmlParserNode
    {
        public enum TagValue
        {
            DataObject,
            ObjectReference,
            DDBHandle,
        }

        private TagValue tag;

        public TagValue Tag
        {
            get {
                return tag;
            }
        }

        private object value;

        private DataRefObject(TagValue tag, object value) {
            this.tag = tag;
            this.value = value;
        }

        public static DataRefObject CreateDataObject(DataObject dataObject)
        {
            return new DataRefObject(TagValue.DataObject, dataObject);
        }

        public static DataRefObject CreateObjectReference(TermArg objectReference)
        {
            return new DataRefObject(TagValue.ObjectReference, objectReference);
        }

        public static DataRefObject CreateDDBHandle(AmlParser.DDBHandleObject ddbHandle)
        {
            return new DataRefObject(TagValue.DDBHandle, ddbHandle);
        }

        public DataObject GetAsDataObject()
        {
            Debug.Assert(Tag == TagValue.DataObject, "Type error: tried to access disjoint union as 'DataObject' but tag does not match");
            return (DataObject)value;
        }

        public TermArg GetAsObjectReference()
        {
            Debug.Assert(Tag == TagValue.ObjectReference, "Type error: tried to access disjoint union as 'ObjectReference' but tag does not match");
            return (TermArg)value;
        }

        public AmlParser.DDBHandleObject GetAsDDBHandle()
        {
            Debug.Assert(Tag == TagValue.DDBHandle, "Type error: tried to access disjoint union as 'DDBHandle' but tag does not match");
            return (AmlParser.DDBHandleObject)value;
        }

#if false
        // Example usage template for this disjoint union type
        public static void ExampleUsage(DataRefObject dataRefObject)
        {
            switch (dataRefObject.Tag) {
                case DataRefObject.TagValue.DataObject:
                    DataObject dataObject = dataRefObject.GetAsDataObject();
                    break;
                case DataRefObject.TagValue.ObjectReference:
                    TermArg objectReference = dataRefObject.GetAsObjectReference();
                    break;
                case DataRefObject.TagValue.DDBHandle:
                    AmlParser.DDBHandleObject dDBHandle = dataRefObject.GetAsDDBHandle();
                    break;
                default:
                    Debug.Assert(false, "Unhandled alternative in switch over 'DataRefObject'");
                    break;
            }
        }
#endif
    public override void Accept(AmlParserNodeVisitor v) {        v.Visit(this);    }        public void AcceptAlternative(AmlParserNodeVisitor v) {        ((AmlParserNode)value).Accept(v);    }    
    }

    public class TermObj : AmlParserNode
    {
        public enum TagValue
        {
            NameSpaceModifierObj,
            NamedObj,
            Type1Opcode,
            Type2Opcode,
        }

        private TagValue tag;

        public TagValue Tag
        {
            get {
                return tag;
            }
        }

        private object value;

        private TermObj(TagValue tag, object value) {
            this.tag = tag;
            this.value = value;
        }

        public static TermObj CreateNameSpaceModifierObj(NameSpaceModifierObj nameSpaceModifierObj)
        {
            return new TermObj(TagValue.NameSpaceModifierObj, nameSpaceModifierObj);
        }

        public static TermObj CreateNamedObj(NamedObj namedObj)
        {
            return new TermObj(TagValue.NamedObj, namedObj);
        }

        public static TermObj CreateType1Opcode(Type1Opcode type1Opcode)
        {
            return new TermObj(TagValue.Type1Opcode, type1Opcode);
        }

        public static TermObj CreateType2Opcode(Type2Opcode type2Opcode)
        {
            return new TermObj(TagValue.Type2Opcode, type2Opcode);
        }

        public NameSpaceModifierObj GetAsNameSpaceModifierObj()
        {
            Debug.Assert(Tag == TagValue.NameSpaceModifierObj, "Type error: tried to access disjoint union as 'NameSpaceModifierObj' but tag does not match");
            return (NameSpaceModifierObj)value;
        }

        public NamedObj GetAsNamedObj()
        {
            Debug.Assert(Tag == TagValue.NamedObj, "Type error: tried to access disjoint union as 'NamedObj' but tag does not match");
            return (NamedObj)value;
        }

        public Type1Opcode GetAsType1Opcode()
        {
            Debug.Assert(Tag == TagValue.Type1Opcode, "Type error: tried to access disjoint union as 'Type1Opcode' but tag does not match");
            return (Type1Opcode)value;
        }

        public Type2Opcode GetAsType2Opcode()
        {
            Debug.Assert(Tag == TagValue.Type2Opcode, "Type error: tried to access disjoint union as 'Type2Opcode' but tag does not match");
            return (Type2Opcode)value;
        }

#if false
        // Example usage template for this disjoint union type
        public static void ExampleUsage(TermObj termObj)
        {
            switch (termObj.Tag) {
                case TermObj.TagValue.NameSpaceModifierObj:
                    NameSpaceModifierObj nameSpaceModifierObj = termObj.GetAsNameSpaceModifierObj();
                    break;
                case TermObj.TagValue.NamedObj:
                    NamedObj namedObj = termObj.GetAsNamedObj();
                    break;
                case TermObj.TagValue.Type1Opcode:
                    Type1Opcode type1Opcode = termObj.GetAsType1Opcode();
                    break;
                case TermObj.TagValue.Type2Opcode:
                    Type2Opcode type2Opcode = termObj.GetAsType2Opcode();
                    break;
                default:
                    Debug.Assert(false, "Unhandled alternative in switch over 'TermObj'");
                    break;
            }
        }
#endif
    public override void Accept(AmlParserNodeVisitor v) {        v.Visit(this);    }        public void AcceptAlternative(AmlParserNodeVisitor v) {        ((AmlParserNode)value).Accept(v);    }    
    }

    public class TermArg : AmlParserNode
    {
        public enum TagValue
        {
            Type2Opcode,
            DataObject,
            ArgObj,
            LocalObj,
        }

        private TagValue tag;

        public TagValue Tag
        {
            get {
                return tag;
            }
        }

        private object value;

        private TermArg(TagValue tag, object value) {
            this.tag = tag;
            this.value = value;
        }

        public static TermArg CreateType2Opcode(Type2Opcode type2Opcode)
        {
            return new TermArg(TagValue.Type2Opcode, type2Opcode);
        }

        public static TermArg CreateDataObject(DataObject dataObject)
        {
            return new TermArg(TagValue.DataObject, dataObject);
        }

        public static TermArg CreateArgObj(AmlParser.ArgObj argObj)
        {
            return new TermArg(TagValue.ArgObj, argObj);
        }

        public static TermArg CreateLocalObj(AmlParser.LocalObj localObj)
        {
            return new TermArg(TagValue.LocalObj, localObj);
        }

        public Type2Opcode GetAsType2Opcode()
        {
            Debug.Assert(Tag == TagValue.Type2Opcode, "Type error: tried to access disjoint union as 'Type2Opcode' but tag does not match");
            return (Type2Opcode)value;
        }

        public DataObject GetAsDataObject()
        {
            Debug.Assert(Tag == TagValue.DataObject, "Type error: tried to access disjoint union as 'DataObject' but tag does not match");
            return (DataObject)value;
        }

        public AmlParser.ArgObj GetAsArgObj()
        {
            Debug.Assert(Tag == TagValue.ArgObj, "Type error: tried to access disjoint union as 'ArgObj' but tag does not match");
            return (AmlParser.ArgObj)value;
        }

        public AmlParser.LocalObj GetAsLocalObj()
        {
            Debug.Assert(Tag == TagValue.LocalObj, "Type error: tried to access disjoint union as 'LocalObj' but tag does not match");
            return (AmlParser.LocalObj)value;
        }

#if false
        // Example usage template for this disjoint union type
        public static void ExampleUsage(TermArg termArg)
        {
            switch (termArg.Tag) {
                case TermArg.TagValue.Type2Opcode:
                    Type2Opcode type2Opcode = termArg.GetAsType2Opcode();
                    break;
                case TermArg.TagValue.DataObject:
                    DataObject dataObject = termArg.GetAsDataObject();
                    break;
                case TermArg.TagValue.ArgObj:
                    AmlParser.ArgObj argObj = termArg.GetAsArgObj();
                    break;
                case TermArg.TagValue.LocalObj:
                    AmlParser.LocalObj localObj = termArg.GetAsLocalObj();
                    break;
                default:
                    Debug.Assert(false, "Unhandled alternative in switch over 'TermArg'");
                    break;
            }
        }
#endif
    public override void Accept(AmlParserNodeVisitor v) {        v.Visit(this);    }        public void AcceptAlternative(AmlParserNodeVisitor v) {        ((AmlParserNode)value).Accept(v);    }    
    }

    public class AmlObject : AmlParserNode
    {
        public enum TagValue
        {
            NameSpaceModifierObj,
            NamedObj,
        }

        private TagValue tag;

        public TagValue Tag
        {
            get {
                return tag;
            }
        }

        private object value;

        private AmlObject(TagValue tag, object value) {
            this.tag = tag;
            this.value = value;
        }

        public static AmlObject CreateNameSpaceModifierObj(NameSpaceModifierObj nameSpaceModifierObj)
        {
            return new AmlObject(TagValue.NameSpaceModifierObj, nameSpaceModifierObj);
        }

        public static AmlObject CreateNamedObj(NamedObj namedObj)
        {
            return new AmlObject(TagValue.NamedObj, namedObj);
        }

        public NameSpaceModifierObj GetAsNameSpaceModifierObj()
        {
            Debug.Assert(Tag == TagValue.NameSpaceModifierObj, "Type error: tried to access disjoint union as 'NameSpaceModifierObj' but tag does not match");
            return (NameSpaceModifierObj)value;
        }

        public NamedObj GetAsNamedObj()
        {
            Debug.Assert(Tag == TagValue.NamedObj, "Type error: tried to access disjoint union as 'NamedObj' but tag does not match");
            return (NamedObj)value;
        }

#if false
        // Example usage template for this disjoint union type
        public static void ExampleUsage(AmlObject amlObject)
        {
            switch (amlObject.Tag) {
                case AmlObject.TagValue.NameSpaceModifierObj:
                    NameSpaceModifierObj nameSpaceModifierObj = amlObject.GetAsNameSpaceModifierObj();
                    break;
                case AmlObject.TagValue.NamedObj:
                    NamedObj namedObj = amlObject.GetAsNamedObj();
                    break;
                default:
                    Debug.Assert(false, "Unhandled alternative in switch over 'AmlObject'");
                    break;
            }
        }
#endif
    public override void Accept(AmlParserNodeVisitor v) {        v.Visit(this);    }        public void AcceptAlternative(AmlParserNodeVisitor v) {        ((AmlParserNode)value).Accept(v);    }    
    }

    public class NameSpaceModifierObj : AmlParserNode
    {
        public enum TagValue
        {
            DefAlias,
            DefName,
            DefScope,
        }

        private TagValue tag;

        public TagValue Tag
        {
            get {
                return tag;
            }
        }

        private object value;

        private NameSpaceModifierObj(TagValue tag, object value) {
            this.tag = tag;
            this.value = value;
        }

        public static NameSpaceModifierObj CreateDefAlias(AmlParser.DefAlias defAlias)
        {
            return new NameSpaceModifierObj(TagValue.DefAlias, defAlias);
        }

        public static NameSpaceModifierObj CreateDefName(AmlParser.DefName defName)
        {
            return new NameSpaceModifierObj(TagValue.DefName, defName);
        }

        public static NameSpaceModifierObj CreateDefScope(AmlParser.DefScope defScope)
        {
            return new NameSpaceModifierObj(TagValue.DefScope, defScope);
        }

        public AmlParser.DefAlias GetAsDefAlias()
        {
            Debug.Assert(Tag == TagValue.DefAlias, "Type error: tried to access disjoint union as 'DefAlias' but tag does not match");
            return (AmlParser.DefAlias)value;
        }

        public AmlParser.DefName GetAsDefName()
        {
            Debug.Assert(Tag == TagValue.DefName, "Type error: tried to access disjoint union as 'DefName' but tag does not match");
            return (AmlParser.DefName)value;
        }

        public AmlParser.DefScope GetAsDefScope()
        {
            Debug.Assert(Tag == TagValue.DefScope, "Type error: tried to access disjoint union as 'DefScope' but tag does not match");
            return (AmlParser.DefScope)value;
        }

#if false
        // Example usage template for this disjoint union type
        public static void ExampleUsage(NameSpaceModifierObj nameSpaceModifierObj)
        {
            switch (nameSpaceModifierObj.Tag) {
                case NameSpaceModifierObj.TagValue.DefAlias:
                    AmlParser.DefAlias defAlias = nameSpaceModifierObj.GetAsDefAlias();
                    break;
                case NameSpaceModifierObj.TagValue.DefName:
                    AmlParser.DefName defName = nameSpaceModifierObj.GetAsDefName();
                    break;
                case NameSpaceModifierObj.TagValue.DefScope:
                    AmlParser.DefScope defScope = nameSpaceModifierObj.GetAsDefScope();
                    break;
                default:
                    Debug.Assert(false, "Unhandled alternative in switch over 'NameSpaceModifierObj'");
                    break;
            }
        }
#endif
    public override void Accept(AmlParserNodeVisitor v) {        v.Visit(this);    }        public void AcceptAlternative(AmlParserNodeVisitor v) {        ((AmlParserNode)value).Accept(v);    }    
    }

    public class NamedObj : AmlParserNode
    {
        public enum TagValue
        {
            DefBankField,
            DefCreateBitField,
            DefCreateByteField,
            DefCreateDWordField,
            DefCreateField,
            DefCreateQWordField,
            DefCreateWordField,
            DefDataRegion,
            DefDevice,
            DefEvent,
            DefField,
            DefIndexField,
            DefMethod,
            DefMutex,
            DefOpRegion,
            DefPowerRes,
            DefProcessor,
            DefThermalZone,
        }

        private TagValue tag;

        public TagValue Tag
        {
            get {
                return tag;
            }
        }

        private object value;

        private NamedObj(TagValue tag, object value) {
            this.tag = tag;
            this.value = value;
        }

        public static NamedObj CreateDefBankField(AmlParser.DefBankField defBankField)
        {
            return new NamedObj(TagValue.DefBankField, defBankField);
        }

        public static NamedObj CreateDefCreateBitField(AmlParser.DefCreateBitField defCreateBitField)
        {
            return new NamedObj(TagValue.DefCreateBitField, defCreateBitField);
        }

        public static NamedObj CreateDefCreateByteField(AmlParser.DefCreateByteField defCreateByteField)
        {
            return new NamedObj(TagValue.DefCreateByteField, defCreateByteField);
        }

        public static NamedObj CreateDefCreateDWordField(AmlParser.DefCreateDWordField defCreateDWordField)
        {
            return new NamedObj(TagValue.DefCreateDWordField, defCreateDWordField);
        }

        public static NamedObj CreateDefCreateField(AmlParser.DefCreateField defCreateField)
        {
            return new NamedObj(TagValue.DefCreateField, defCreateField);
        }

        public static NamedObj CreateDefCreateQWordField(AmlParser.DefCreateQWordField defCreateQWordField)
        {
            return new NamedObj(TagValue.DefCreateQWordField, defCreateQWordField);
        }

        public static NamedObj CreateDefCreateWordField(AmlParser.DefCreateWordField defCreateWordField)
        {
            return new NamedObj(TagValue.DefCreateWordField, defCreateWordField);
        }

        public static NamedObj CreateDefDataRegion(AmlParser.DefDataRegion defDataRegion)
        {
            return new NamedObj(TagValue.DefDataRegion, defDataRegion);
        }

        public static NamedObj CreateDefDevice(AmlParser.DefDevice defDevice)
        {
            return new NamedObj(TagValue.DefDevice, defDevice);
        }

        public static NamedObj CreateDefEvent(AmlParser.DefEvent defEvent)
        {
            return new NamedObj(TagValue.DefEvent, defEvent);
        }

        public static NamedObj CreateDefField(AmlParser.DefField defField)
        {
            return new NamedObj(TagValue.DefField, defField);
        }

        public static NamedObj CreateDefIndexField(AmlParser.DefIndexField defIndexField)
        {
            return new NamedObj(TagValue.DefIndexField, defIndexField);
        }

        public static NamedObj CreateDefMethod(AmlParser.DefMethod defMethod)
        {
            return new NamedObj(TagValue.DefMethod, defMethod);
        }

        public static NamedObj CreateDefMutex(AmlParser.DefMutex defMutex)
        {
            return new NamedObj(TagValue.DefMutex, defMutex);
        }

        public static NamedObj CreateDefOpRegion(AmlParser.DefOpRegion defOpRegion)
        {
            return new NamedObj(TagValue.DefOpRegion, defOpRegion);
        }

        public static NamedObj CreateDefPowerRes(AmlParser.DefPowerRes defPowerRes)
        {
            return new NamedObj(TagValue.DefPowerRes, defPowerRes);
        }

        public static NamedObj CreateDefProcessor(AmlParser.DefProcessor defProcessor)
        {
            return new NamedObj(TagValue.DefProcessor, defProcessor);
        }

        public static NamedObj CreateDefThermalZone(AmlParser.DefThermalZone defThermalZone)
        {
            return new NamedObj(TagValue.DefThermalZone, defThermalZone);
        }

        public AmlParser.DefBankField GetAsDefBankField()
        {
            Debug.Assert(Tag == TagValue.DefBankField, "Type error: tried to access disjoint union as 'DefBankField' but tag does not match");
            return (AmlParser.DefBankField)value;
        }

        public AmlParser.DefCreateBitField GetAsDefCreateBitField()
        {
            Debug.Assert(Tag == TagValue.DefCreateBitField, "Type error: tried to access disjoint union as 'DefCreateBitField' but tag does not match");
            return (AmlParser.DefCreateBitField)value;
        }

        public AmlParser.DefCreateByteField GetAsDefCreateByteField()
        {
            Debug.Assert(Tag == TagValue.DefCreateByteField, "Type error: tried to access disjoint union as 'DefCreateByteField' but tag does not match");
            return (AmlParser.DefCreateByteField)value;
        }

        public AmlParser.DefCreateDWordField GetAsDefCreateDWordField()
        {
            Debug.Assert(Tag == TagValue.DefCreateDWordField, "Type error: tried to access disjoint union as 'DefCreateDWordField' but tag does not match");
            return (AmlParser.DefCreateDWordField)value;
        }

        public AmlParser.DefCreateField GetAsDefCreateField()
        {
            Debug.Assert(Tag == TagValue.DefCreateField, "Type error: tried to access disjoint union as 'DefCreateField' but tag does not match");
            return (AmlParser.DefCreateField)value;
        }

        public AmlParser.DefCreateQWordField GetAsDefCreateQWordField()
        {
            Debug.Assert(Tag == TagValue.DefCreateQWordField, "Type error: tried to access disjoint union as 'DefCreateQWordField' but tag does not match");
            return (AmlParser.DefCreateQWordField)value;
        }

        public AmlParser.DefCreateWordField GetAsDefCreateWordField()
        {
            Debug.Assert(Tag == TagValue.DefCreateWordField, "Type error: tried to access disjoint union as 'DefCreateWordField' but tag does not match");
            return (AmlParser.DefCreateWordField)value;
        }

        public AmlParser.DefDataRegion GetAsDefDataRegion()
        {
            Debug.Assert(Tag == TagValue.DefDataRegion, "Type error: tried to access disjoint union as 'DefDataRegion' but tag does not match");
            return (AmlParser.DefDataRegion)value;
        }

        public AmlParser.DefDevice GetAsDefDevice()
        {
            Debug.Assert(Tag == TagValue.DefDevice, "Type error: tried to access disjoint union as 'DefDevice' but tag does not match");
            return (AmlParser.DefDevice)value;
        }

        public AmlParser.DefEvent GetAsDefEvent()
        {
            Debug.Assert(Tag == TagValue.DefEvent, "Type error: tried to access disjoint union as 'DefEvent' but tag does not match");
            return (AmlParser.DefEvent)value;
        }

        public AmlParser.DefField GetAsDefField()
        {
            Debug.Assert(Tag == TagValue.DefField, "Type error: tried to access disjoint union as 'DefField' but tag does not match");
            return (AmlParser.DefField)value;
        }

        public AmlParser.DefIndexField GetAsDefIndexField()
        {
            Debug.Assert(Tag == TagValue.DefIndexField, "Type error: tried to access disjoint union as 'DefIndexField' but tag does not match");
            return (AmlParser.DefIndexField)value;
        }

        public AmlParser.DefMethod GetAsDefMethod()
        {
            Debug.Assert(Tag == TagValue.DefMethod, "Type error: tried to access disjoint union as 'DefMethod' but tag does not match");
            return (AmlParser.DefMethod)value;
        }

        public AmlParser.DefMutex GetAsDefMutex()
        {
            Debug.Assert(Tag == TagValue.DefMutex, "Type error: tried to access disjoint union as 'DefMutex' but tag does not match");
            return (AmlParser.DefMutex)value;
        }

        public AmlParser.DefOpRegion GetAsDefOpRegion()
        {
            Debug.Assert(Tag == TagValue.DefOpRegion, "Type error: tried to access disjoint union as 'DefOpRegion' but tag does not match");
            return (AmlParser.DefOpRegion)value;
        }

        public AmlParser.DefPowerRes GetAsDefPowerRes()
        {
            Debug.Assert(Tag == TagValue.DefPowerRes, "Type error: tried to access disjoint union as 'DefPowerRes' but tag does not match");
            return (AmlParser.DefPowerRes)value;
        }

        public AmlParser.DefProcessor GetAsDefProcessor()
        {
            Debug.Assert(Tag == TagValue.DefProcessor, "Type error: tried to access disjoint union as 'DefProcessor' but tag does not match");
            return (AmlParser.DefProcessor)value;
        }

        public AmlParser.DefThermalZone GetAsDefThermalZone()
        {
            Debug.Assert(Tag == TagValue.DefThermalZone, "Type error: tried to access disjoint union as 'DefThermalZone' but tag does not match");
            return (AmlParser.DefThermalZone)value;
        }

#if false
        // Example usage template for this disjoint union type
        public static void ExampleUsage(NamedObj namedObj)
        {
            switch (namedObj.Tag) {
                case NamedObj.TagValue.DefBankField:
                    AmlParser.DefBankField defBankField = namedObj.GetAsDefBankField();
                    break;
                case NamedObj.TagValue.DefCreateBitField:
                    AmlParser.DefCreateBitField defCreateBitField = namedObj.GetAsDefCreateBitField();
                    break;
                case NamedObj.TagValue.DefCreateByteField:
                    AmlParser.DefCreateByteField defCreateByteField = namedObj.GetAsDefCreateByteField();
                    break;
                case NamedObj.TagValue.DefCreateDWordField:
                    AmlParser.DefCreateDWordField defCreateDWordField = namedObj.GetAsDefCreateDWordField();
                    break;
                case NamedObj.TagValue.DefCreateField:
                    AmlParser.DefCreateField defCreateField = namedObj.GetAsDefCreateField();
                    break;
                case NamedObj.TagValue.DefCreateQWordField:
                    AmlParser.DefCreateQWordField defCreateQWordField = namedObj.GetAsDefCreateQWordField();
                    break;
                case NamedObj.TagValue.DefCreateWordField:
                    AmlParser.DefCreateWordField defCreateWordField = namedObj.GetAsDefCreateWordField();
                    break;
                case NamedObj.TagValue.DefDataRegion:
                    AmlParser.DefDataRegion defDataRegion = namedObj.GetAsDefDataRegion();
                    break;
                case NamedObj.TagValue.DefDevice:
                    AmlParser.DefDevice defDevice = namedObj.GetAsDefDevice();
                    break;
                case NamedObj.TagValue.DefEvent:
                    AmlParser.DefEvent defEvent = namedObj.GetAsDefEvent();
                    break;
                case NamedObj.TagValue.DefField:
                    AmlParser.DefField defField = namedObj.GetAsDefField();
                    break;
                case NamedObj.TagValue.DefIndexField:
                    AmlParser.DefIndexField defIndexField = namedObj.GetAsDefIndexField();
                    break;
                case NamedObj.TagValue.DefMethod:
                    AmlParser.DefMethod defMethod = namedObj.GetAsDefMethod();
                    break;
                case NamedObj.TagValue.DefMutex:
                    AmlParser.DefMutex defMutex = namedObj.GetAsDefMutex();
                    break;
                case NamedObj.TagValue.DefOpRegion:
                    AmlParser.DefOpRegion defOpRegion = namedObj.GetAsDefOpRegion();
                    break;
                case NamedObj.TagValue.DefPowerRes:
                    AmlParser.DefPowerRes defPowerRes = namedObj.GetAsDefPowerRes();
                    break;
                case NamedObj.TagValue.DefProcessor:
                    AmlParser.DefProcessor defProcessor = namedObj.GetAsDefProcessor();
                    break;
                case NamedObj.TagValue.DefThermalZone:
                    AmlParser.DefThermalZone defThermalZone = namedObj.GetAsDefThermalZone();
                    break;
                default:
                    Debug.Assert(false, "Unhandled alternative in switch over 'NamedObj'");
                    break;
            }
        }
#endif
    public override void Accept(AmlParserNodeVisitor v) {        v.Visit(this);    }        public void AcceptAlternative(AmlParserNodeVisitor v) {        ((AmlParserNode)value).Accept(v);    }    
    }

    public class FieldElement : AmlParserNode
    {
        public enum TagValue
        {
            NamedField,
            ReservedField,
            AccessField,
        }

        private TagValue tag;

        public TagValue Tag
        {
            get {
                return tag;
            }
        }

        private object value;

        private FieldElement(TagValue tag, object value) {
            this.tag = tag;
            this.value = value;
        }

        public static FieldElement CreateNamedField(AmlParser.NamedField namedField)
        {
            return new FieldElement(TagValue.NamedField, namedField);
        }

        public static FieldElement CreateReservedField(AmlParser.ReservedField reservedField)
        {
            return new FieldElement(TagValue.ReservedField, reservedField);
        }

        public static FieldElement CreateAccessField(AmlParser.AccessField accessField)
        {
            return new FieldElement(TagValue.AccessField, accessField);
        }

        public AmlParser.NamedField GetAsNamedField()
        {
            Debug.Assert(Tag == TagValue.NamedField, "Type error: tried to access disjoint union as 'NamedField' but tag does not match");
            return (AmlParser.NamedField)value;
        }

        public AmlParser.ReservedField GetAsReservedField()
        {
            Debug.Assert(Tag == TagValue.ReservedField, "Type error: tried to access disjoint union as 'ReservedField' but tag does not match");
            return (AmlParser.ReservedField)value;
        }

        public AmlParser.AccessField GetAsAccessField()
        {
            Debug.Assert(Tag == TagValue.AccessField, "Type error: tried to access disjoint union as 'AccessField' but tag does not match");
            return (AmlParser.AccessField)value;
        }

#if false
        // Example usage template for this disjoint union type
        public static void ExampleUsage(FieldElement fieldElement)
        {
            switch (fieldElement.Tag) {
                case FieldElement.TagValue.NamedField:
                    AmlParser.NamedField namedField = fieldElement.GetAsNamedField();
                    break;
                case FieldElement.TagValue.ReservedField:
                    AmlParser.ReservedField reservedField = fieldElement.GetAsReservedField();
                    break;
                case FieldElement.TagValue.AccessField:
                    AmlParser.AccessField accessField = fieldElement.GetAsAccessField();
                    break;
                default:
                    Debug.Assert(false, "Unhandled alternative in switch over 'FieldElement'");
                    break;
            }
        }
#endif
    public override void Accept(AmlParserNodeVisitor v) {        v.Visit(this);    }        public void AcceptAlternative(AmlParserNodeVisitor v) {        ((AmlParserNode)value).Accept(v);    }    
    }

    public class Type1Opcode : AmlParserNode
    {
        public enum TagValue
        {
            DefBreak,
            DefBreakPoint,
            DefContinue,
            DefFatal,
            DefIfElse,
            DefLoad,
            DefNoop,
            DefNotify,
            DefRelease,
            DefReset,
            DefReturn,
            DefSignal,
            DefSleep,
            DefStall,
            DefUnload,
            DefWhile,
        }

        private TagValue tag;

        public TagValue Tag
        {
            get {
                return tag;
            }
        }

        private object value;

        private Type1Opcode(TagValue tag, object value) {
            this.tag = tag;
            this.value = value;
        }

        public static Type1Opcode CreateDefBreak(AmlParser.DefBreak defBreak)
        {
            return new Type1Opcode(TagValue.DefBreak, defBreak);
        }

        public static Type1Opcode CreateDefBreakPoint(AmlParser.DefBreakPoint defBreakPoint)
        {
            return new Type1Opcode(TagValue.DefBreakPoint, defBreakPoint);
        }

        public static Type1Opcode CreateDefContinue(AmlParser.DefContinue defContinue)
        {
            return new Type1Opcode(TagValue.DefContinue, defContinue);
        }

        public static Type1Opcode CreateDefFatal(AmlParser.DefFatal defFatal)
        {
            return new Type1Opcode(TagValue.DefFatal, defFatal);
        }

        public static Type1Opcode CreateDefIfElse(AmlParser.DefIfElse defIfElse)
        {
            return new Type1Opcode(TagValue.DefIfElse, defIfElse);
        }

        public static Type1Opcode CreateDefLoad(AmlParser.DefLoad defLoad)
        {
            return new Type1Opcode(TagValue.DefLoad, defLoad);
        }

        public static Type1Opcode CreateDefNoop(AmlParser.DefNoop defNoop)
        {
            return new Type1Opcode(TagValue.DefNoop, defNoop);
        }

        public static Type1Opcode CreateDefNotify(AmlParser.DefNotify defNotify)
        {
            return new Type1Opcode(TagValue.DefNotify, defNotify);
        }

        public static Type1Opcode CreateDefRelease(AmlParser.DefRelease defRelease)
        {
            return new Type1Opcode(TagValue.DefRelease, defRelease);
        }

        public static Type1Opcode CreateDefReset(AmlParser.DefReset defReset)
        {
            return new Type1Opcode(TagValue.DefReset, defReset);
        }

        public static Type1Opcode CreateDefReturn(AmlParser.DefReturn defReturn)
        {
            return new Type1Opcode(TagValue.DefReturn, defReturn);
        }

        public static Type1Opcode CreateDefSignal(AmlParser.DefSignal defSignal)
        {
            return new Type1Opcode(TagValue.DefSignal, defSignal);
        }

        public static Type1Opcode CreateDefSleep(AmlParser.DefSleep defSleep)
        {
            return new Type1Opcode(TagValue.DefSleep, defSleep);
        }

        public static Type1Opcode CreateDefStall(AmlParser.DefStall defStall)
        {
            return new Type1Opcode(TagValue.DefStall, defStall);
        }

        public static Type1Opcode CreateDefUnload(AmlParser.DefUnload defUnload)
        {
            return new Type1Opcode(TagValue.DefUnload, defUnload);
        }

        public static Type1Opcode CreateDefWhile(AmlParser.DefWhile defWhile)
        {
            return new Type1Opcode(TagValue.DefWhile, defWhile);
        }

        public AmlParser.DefBreak GetAsDefBreak()
        {
            Debug.Assert(Tag == TagValue.DefBreak, "Type error: tried to access disjoint union as 'DefBreak' but tag does not match");
            return (AmlParser.DefBreak)value;
        }

        public AmlParser.DefBreakPoint GetAsDefBreakPoint()
        {
            Debug.Assert(Tag == TagValue.DefBreakPoint, "Type error: tried to access disjoint union as 'DefBreakPoint' but tag does not match");
            return (AmlParser.DefBreakPoint)value;
        }

        public AmlParser.DefContinue GetAsDefContinue()
        {
            Debug.Assert(Tag == TagValue.DefContinue, "Type error: tried to access disjoint union as 'DefContinue' but tag does not match");
            return (AmlParser.DefContinue)value;
        }

        public AmlParser.DefFatal GetAsDefFatal()
        {
            Debug.Assert(Tag == TagValue.DefFatal, "Type error: tried to access disjoint union as 'DefFatal' but tag does not match");
            return (AmlParser.DefFatal)value;
        }

        public AmlParser.DefIfElse GetAsDefIfElse()
        {
            Debug.Assert(Tag == TagValue.DefIfElse, "Type error: tried to access disjoint union as 'DefIfElse' but tag does not match");
            return (AmlParser.DefIfElse)value;
        }

        public AmlParser.DefLoad GetAsDefLoad()
        {
            Debug.Assert(Tag == TagValue.DefLoad, "Type error: tried to access disjoint union as 'DefLoad' but tag does not match");
            return (AmlParser.DefLoad)value;
        }

        public AmlParser.DefNoop GetAsDefNoop()
        {
            Debug.Assert(Tag == TagValue.DefNoop, "Type error: tried to access disjoint union as 'DefNoop' but tag does not match");
            return (AmlParser.DefNoop)value;
        }

        public AmlParser.DefNotify GetAsDefNotify()
        {
            Debug.Assert(Tag == TagValue.DefNotify, "Type error: tried to access disjoint union as 'DefNotify' but tag does not match");
            return (AmlParser.DefNotify)value;
        }

        public AmlParser.DefRelease GetAsDefRelease()
        {
            Debug.Assert(Tag == TagValue.DefRelease, "Type error: tried to access disjoint union as 'DefRelease' but tag does not match");
            return (AmlParser.DefRelease)value;
        }

        public AmlParser.DefReset GetAsDefReset()
        {
            Debug.Assert(Tag == TagValue.DefReset, "Type error: tried to access disjoint union as 'DefReset' but tag does not match");
            return (AmlParser.DefReset)value;
        }

        public AmlParser.DefReturn GetAsDefReturn()
        {
            Debug.Assert(Tag == TagValue.DefReturn, "Type error: tried to access disjoint union as 'DefReturn' but tag does not match");
            return (AmlParser.DefReturn)value;
        }

        public AmlParser.DefSignal GetAsDefSignal()
        {
            Debug.Assert(Tag == TagValue.DefSignal, "Type error: tried to access disjoint union as 'DefSignal' but tag does not match");
            return (AmlParser.DefSignal)value;
        }

        public AmlParser.DefSleep GetAsDefSleep()
        {
            Debug.Assert(Tag == TagValue.DefSleep, "Type error: tried to access disjoint union as 'DefSleep' but tag does not match");
            return (AmlParser.DefSleep)value;
        }

        public AmlParser.DefStall GetAsDefStall()
        {
            Debug.Assert(Tag == TagValue.DefStall, "Type error: tried to access disjoint union as 'DefStall' but tag does not match");
            return (AmlParser.DefStall)value;
        }

        public AmlParser.DefUnload GetAsDefUnload()
        {
            Debug.Assert(Tag == TagValue.DefUnload, "Type error: tried to access disjoint union as 'DefUnload' but tag does not match");
            return (AmlParser.DefUnload)value;
        }

        public AmlParser.DefWhile GetAsDefWhile()
        {
            Debug.Assert(Tag == TagValue.DefWhile, "Type error: tried to access disjoint union as 'DefWhile' but tag does not match");
            return (AmlParser.DefWhile)value;
        }

#if false
        // Example usage template for this disjoint union type
        public static void ExampleUsage(Type1Opcode type1Opcode)
        {
            switch (type1Opcode.Tag) {
                case Type1Opcode.TagValue.DefBreak:
                    AmlParser.DefBreak defBreak = type1Opcode.GetAsDefBreak();
                    break;
                case Type1Opcode.TagValue.DefBreakPoint:
                    AmlParser.DefBreakPoint defBreakPoint = type1Opcode.GetAsDefBreakPoint();
                    break;
                case Type1Opcode.TagValue.DefContinue:
                    AmlParser.DefContinue defContinue = type1Opcode.GetAsDefContinue();
                    break;
                case Type1Opcode.TagValue.DefFatal:
                    AmlParser.DefFatal defFatal = type1Opcode.GetAsDefFatal();
                    break;
                case Type1Opcode.TagValue.DefIfElse:
                    AmlParser.DefIfElse defIfElse = type1Opcode.GetAsDefIfElse();
                    break;
                case Type1Opcode.TagValue.DefLoad:
                    AmlParser.DefLoad defLoad = type1Opcode.GetAsDefLoad();
                    break;
                case Type1Opcode.TagValue.DefNoop:
                    AmlParser.DefNoop defNoop = type1Opcode.GetAsDefNoop();
                    break;
                case Type1Opcode.TagValue.DefNotify:
                    AmlParser.DefNotify defNotify = type1Opcode.GetAsDefNotify();
                    break;
                case Type1Opcode.TagValue.DefRelease:
                    AmlParser.DefRelease defRelease = type1Opcode.GetAsDefRelease();
                    break;
                case Type1Opcode.TagValue.DefReset:
                    AmlParser.DefReset defReset = type1Opcode.GetAsDefReset();
                    break;
                case Type1Opcode.TagValue.DefReturn:
                    AmlParser.DefReturn defReturn = type1Opcode.GetAsDefReturn();
                    break;
                case Type1Opcode.TagValue.DefSignal:
                    AmlParser.DefSignal defSignal = type1Opcode.GetAsDefSignal();
                    break;
                case Type1Opcode.TagValue.DefSleep:
                    AmlParser.DefSleep defSleep = type1Opcode.GetAsDefSleep();
                    break;
                case Type1Opcode.TagValue.DefStall:
                    AmlParser.DefStall defStall = type1Opcode.GetAsDefStall();
                    break;
                case Type1Opcode.TagValue.DefUnload:
                    AmlParser.DefUnload defUnload = type1Opcode.GetAsDefUnload();
                    break;
                case Type1Opcode.TagValue.DefWhile:
                    AmlParser.DefWhile defWhile = type1Opcode.GetAsDefWhile();
                    break;
                default:
                    Debug.Assert(false, "Unhandled alternative in switch over 'Type1Opcode'");
                    break;
            }
        }
#endif
    public override void Accept(AmlParserNodeVisitor v) {        v.VisitType1Opcode(this);    }        public void AcceptAlternative(AmlParserNodeVisitor v) {        ((AmlParserNode)value).Accept(v);    }    
    }

    public class Type2Opcode : AmlParserNode
    {
        public enum TagValue
        {
            DefAcquire,
            DefAdd,
            DefAnd,
            DefBuffer,
            DefConcat,
            DefConcatRes,
            DefCondRefOf,
            DefCopyObject,
            DefDecrement,
            DefDerefOf,
            DefDivide,
            DefFindSetLeftBit,
            DefFindSetRightBit,
            DefFromBCD,
            DefIncrement,
            DefIndex,
            DefLAnd,
            DefLEqual,
            DefLGreater,
            DefLGreaterEqual,
            DefLLess,
            DefLLessEqual,
            DefMid,
            DefLNot,
            DefLNotEqual,
            DefLoadTable,
            DefLOr,
            DefMatch,
            DefMod,
            DefMultiply,
            DefNAnd,
            DefNOr,
            DefNot,
            DefObjectType,
            DefOr,
            DefPackage,
            DefVarPackage,
            DefRefOf,
            DefShiftLeft,
            DefShiftRight,
            DefSizeOf,
            DefStore,
            DefSubtract,
            DefTimer,
            DefToBCD,
            DefToBuffer,
            DefToDecimalString,
            DefToHexString,
            DefToInteger,
            DefToString,
            DefWait,
            DefXOr,
            UserTermObj,
        }

        private TagValue tag;

        public TagValue Tag
        {
            get {
                return tag;
            }
        }

        private object value;

        private Type2Opcode(TagValue tag, object value) {
            this.tag = tag;
            this.value = value;
        }

        public static Type2Opcode CreateDefAcquire(AmlParser.DefAcquire defAcquire)
        {
            return new Type2Opcode(TagValue.DefAcquire, defAcquire);
        }

        public static Type2Opcode CreateDefAdd(AmlParser.DefAdd defAdd)
        {
            return new Type2Opcode(TagValue.DefAdd, defAdd);
        }

        public static Type2Opcode CreateDefAnd(AmlParser.DefAnd defAnd)
        {
            return new Type2Opcode(TagValue.DefAnd, defAnd);
        }

        public static Type2Opcode CreateDefBuffer(AmlParser.DefBuffer defBuffer)
        {
            return new Type2Opcode(TagValue.DefBuffer, defBuffer);
        }

        public static Type2Opcode CreateDefConcat(AmlParser.DefConcat defConcat)
        {
            return new Type2Opcode(TagValue.DefConcat, defConcat);
        }

        public static Type2Opcode CreateDefConcatRes(AmlParser.DefConcatRes defConcatRes)
        {
            return new Type2Opcode(TagValue.DefConcatRes, defConcatRes);
        }

        public static Type2Opcode CreateDefCondRefOf(AmlParser.DefCondRefOf defCondRefOf)
        {
            return new Type2Opcode(TagValue.DefCondRefOf, defCondRefOf);
        }

        public static Type2Opcode CreateDefCopyObject(AmlParser.DefCopyObject defCopyObject)
        {
            return new Type2Opcode(TagValue.DefCopyObject, defCopyObject);
        }

        public static Type2Opcode CreateDefDecrement(AmlParser.DefDecrement defDecrement)
        {
            return new Type2Opcode(TagValue.DefDecrement, defDecrement);
        }

        public static Type2Opcode CreateDefDerefOf(AmlParser.DefDerefOf defDerefOf)
        {
            return new Type2Opcode(TagValue.DefDerefOf, defDerefOf);
        }

        public static Type2Opcode CreateDefDivide(AmlParser.DefDivide defDivide)
        {
            return new Type2Opcode(TagValue.DefDivide, defDivide);
        }

        public static Type2Opcode CreateDefFindSetLeftBit(AmlParser.DefFindSetLeftBit defFindSetLeftBit)
        {
            return new Type2Opcode(TagValue.DefFindSetLeftBit, defFindSetLeftBit);
        }

        public static Type2Opcode CreateDefFindSetRightBit(AmlParser.DefFindSetRightBit defFindSetRightBit)
        {
            return new Type2Opcode(TagValue.DefFindSetRightBit, defFindSetRightBit);
        }

        public static Type2Opcode CreateDefFromBCD(AmlParser.DefFromBCD defFromBCD)
        {
            return new Type2Opcode(TagValue.DefFromBCD, defFromBCD);
        }

        public static Type2Opcode CreateDefIncrement(AmlParser.DefIncrement defIncrement)
        {
            return new Type2Opcode(TagValue.DefIncrement, defIncrement);
        }

        public static Type2Opcode CreateDefIndex(AmlParser.DefIndex defIndex)
        {
            return new Type2Opcode(TagValue.DefIndex, defIndex);
        }

        public static Type2Opcode CreateDefLAnd(AmlParser.DefLAnd defLAnd)
        {
            return new Type2Opcode(TagValue.DefLAnd, defLAnd);
        }

        public static Type2Opcode CreateDefLEqual(AmlParser.DefLEqual defLEqual)
        {
            return new Type2Opcode(TagValue.DefLEqual, defLEqual);
        }

        public static Type2Opcode CreateDefLGreater(AmlParser.DefLGreater defLGreater)
        {
            return new Type2Opcode(TagValue.DefLGreater, defLGreater);
        }

        public static Type2Opcode CreateDefLGreaterEqual(AmlParser.DefLGreaterEqual defLGreaterEqual)
        {
            return new Type2Opcode(TagValue.DefLGreaterEqual, defLGreaterEqual);
        }

        public static Type2Opcode CreateDefLLess(AmlParser.DefLLess defLLess)
        {
            return new Type2Opcode(TagValue.DefLLess, defLLess);
        }

        public static Type2Opcode CreateDefLLessEqual(AmlParser.DefLLessEqual defLLessEqual)
        {
            return new Type2Opcode(TagValue.DefLLessEqual, defLLessEqual);
        }

        public static Type2Opcode CreateDefMid(AmlParser.DefMid defMid)
        {
            return new Type2Opcode(TagValue.DefMid, defMid);
        }

        public static Type2Opcode CreateDefLNot(AmlParser.DefLNot defLNot)
        {
            return new Type2Opcode(TagValue.DefLNot, defLNot);
        }

        public static Type2Opcode CreateDefLNotEqual(AmlParser.DefLNotEqual defLNotEqual)
        {
            return new Type2Opcode(TagValue.DefLNotEqual, defLNotEqual);
        }

        public static Type2Opcode CreateDefLoadTable(AmlParser.DefLoadTable defLoadTable)
        {
            return new Type2Opcode(TagValue.DefLoadTable, defLoadTable);
        }

        public static Type2Opcode CreateDefLOr(AmlParser.DefLOr defLOr)
        {
            return new Type2Opcode(TagValue.DefLOr, defLOr);
        }

        public static Type2Opcode CreateDefMatch(AmlParser.DefMatch defMatch)
        {
            return new Type2Opcode(TagValue.DefMatch, defMatch);
        }

        public static Type2Opcode CreateDefMod(AmlParser.DefMod defMod)
        {
            return new Type2Opcode(TagValue.DefMod, defMod);
        }

        public static Type2Opcode CreateDefMultiply(AmlParser.DefMultiply defMultiply)
        {
            return new Type2Opcode(TagValue.DefMultiply, defMultiply);
        }

        public static Type2Opcode CreateDefNAnd(AmlParser.DefNAnd defNAnd)
        {
            return new Type2Opcode(TagValue.DefNAnd, defNAnd);
        }

        public static Type2Opcode CreateDefNOr(AmlParser.DefNOr defNOr)
        {
            return new Type2Opcode(TagValue.DefNOr, defNOr);
        }

        public static Type2Opcode CreateDefNot(AmlParser.DefNot defNot)
        {
            return new Type2Opcode(TagValue.DefNot, defNot);
        }

        public static Type2Opcode CreateDefObjectType(AmlParser.DefObjectType defObjectType)
        {
            return new Type2Opcode(TagValue.DefObjectType, defObjectType);
        }

        public static Type2Opcode CreateDefOr(AmlParser.DefOr defOr)
        {
            return new Type2Opcode(TagValue.DefOr, defOr);
        }

        public static Type2Opcode CreateDefPackage(AmlParser.DefPackage defPackage)
        {
            return new Type2Opcode(TagValue.DefPackage, defPackage);
        }

        public static Type2Opcode CreateDefVarPackage(AmlParser.DefVarPackage defVarPackage)
        {
            return new Type2Opcode(TagValue.DefVarPackage, defVarPackage);
        }

        public static Type2Opcode CreateDefRefOf(AmlParser.DefRefOf defRefOf)
        {
            return new Type2Opcode(TagValue.DefRefOf, defRefOf);
        }

        public static Type2Opcode CreateDefShiftLeft(AmlParser.DefShiftLeft defShiftLeft)
        {
            return new Type2Opcode(TagValue.DefShiftLeft, defShiftLeft);
        }

        public static Type2Opcode CreateDefShiftRight(AmlParser.DefShiftRight defShiftRight)
        {
            return new Type2Opcode(TagValue.DefShiftRight, defShiftRight);
        }

        public static Type2Opcode CreateDefSizeOf(AmlParser.DefSizeOf defSizeOf)
        {
            return new Type2Opcode(TagValue.DefSizeOf, defSizeOf);
        }

        public static Type2Opcode CreateDefStore(AmlParser.DefStore defStore)
        {
            return new Type2Opcode(TagValue.DefStore, defStore);
        }

        public static Type2Opcode CreateDefSubtract(AmlParser.DefSubtract defSubtract)
        {
            return new Type2Opcode(TagValue.DefSubtract, defSubtract);
        }

        public static Type2Opcode CreateDefTimer(AmlParser.DefTimer defTimer)
        {
            return new Type2Opcode(TagValue.DefTimer, defTimer);
        }

        public static Type2Opcode CreateDefToBCD(AmlParser.DefToBCD defToBCD)
        {
            return new Type2Opcode(TagValue.DefToBCD, defToBCD);
        }

        public static Type2Opcode CreateDefToBuffer(AmlParser.DefToBuffer defToBuffer)
        {
            return new Type2Opcode(TagValue.DefToBuffer, defToBuffer);
        }

        public static Type2Opcode CreateDefToDecimalString(AmlParser.DefToDecimalString defToDecimalString)
        {
            return new Type2Opcode(TagValue.DefToDecimalString, defToDecimalString);
        }

        public static Type2Opcode CreateDefToHexString(AmlParser.DefToHexString defToHexString)
        {
            return new Type2Opcode(TagValue.DefToHexString, defToHexString);
        }

        public static Type2Opcode CreateDefToInteger(AmlParser.DefToInteger defToInteger)
        {
            return new Type2Opcode(TagValue.DefToInteger, defToInteger);
        }

        public static Type2Opcode CreateDefToString(AmlParser.DefToString defToString)
        {
            return new Type2Opcode(TagValue.DefToString, defToString);
        }

        public static Type2Opcode CreateDefWait(AmlParser.DefWait defWait)
        {
            return new Type2Opcode(TagValue.DefWait, defWait);
        }

        public static Type2Opcode CreateDefXOr(AmlParser.DefXOr defXOr)
        {
            return new Type2Opcode(TagValue.DefXOr, defXOr);
        }

        public static Type2Opcode CreateUserTermObj(AmlParser.UserTermObj userTermObj)
        {
            return new Type2Opcode(TagValue.UserTermObj, userTermObj);
        }

        public AmlParser.DefAcquire GetAsDefAcquire()
        {
            Debug.Assert(Tag == TagValue.DefAcquire, "Type error: tried to access disjoint union as 'DefAcquire' but tag does not match");
            return (AmlParser.DefAcquire)value;
        }

        public AmlParser.DefAdd GetAsDefAdd()
        {
            Debug.Assert(Tag == TagValue.DefAdd, "Type error: tried to access disjoint union as 'DefAdd' but tag does not match");
            return (AmlParser.DefAdd)value;
        }

        public AmlParser.DefAnd GetAsDefAnd()
        {
            Debug.Assert(Tag == TagValue.DefAnd, "Type error: tried to access disjoint union as 'DefAnd' but tag does not match");
            return (AmlParser.DefAnd)value;
        }

        public AmlParser.DefBuffer GetAsDefBuffer()
        {
            Debug.Assert(Tag == TagValue.DefBuffer, "Type error: tried to access disjoint union as 'DefBuffer' but tag does not match");
            return (AmlParser.DefBuffer)value;
        }

        public AmlParser.DefConcat GetAsDefConcat()
        {
            Debug.Assert(Tag == TagValue.DefConcat, "Type error: tried to access disjoint union as 'DefConcat' but tag does not match");
            return (AmlParser.DefConcat)value;
        }

        public AmlParser.DefConcatRes GetAsDefConcatRes()
        {
            Debug.Assert(Tag == TagValue.DefConcatRes, "Type error: tried to access disjoint union as 'DefConcatRes' but tag does not match");
            return (AmlParser.DefConcatRes)value;
        }

        public AmlParser.DefCondRefOf GetAsDefCondRefOf()
        {
            Debug.Assert(Tag == TagValue.DefCondRefOf, "Type error: tried to access disjoint union as 'DefCondRefOf' but tag does not match");
            return (AmlParser.DefCondRefOf)value;
        }

        public AmlParser.DefCopyObject GetAsDefCopyObject()
        {
            Debug.Assert(Tag == TagValue.DefCopyObject, "Type error: tried to access disjoint union as 'DefCopyObject' but tag does not match");
            return (AmlParser.DefCopyObject)value;
        }

        public AmlParser.DefDecrement GetAsDefDecrement()
        {
            Debug.Assert(Tag == TagValue.DefDecrement, "Type error: tried to access disjoint union as 'DefDecrement' but tag does not match");
            return (AmlParser.DefDecrement)value;
        }

        public AmlParser.DefDerefOf GetAsDefDerefOf()
        {
            Debug.Assert(Tag == TagValue.DefDerefOf, "Type error: tried to access disjoint union as 'DefDerefOf' but tag does not match");
            return (AmlParser.DefDerefOf)value;
        }

        public AmlParser.DefDivide GetAsDefDivide()
        {
            Debug.Assert(Tag == TagValue.DefDivide, "Type error: tried to access disjoint union as 'DefDivide' but tag does not match");
            return (AmlParser.DefDivide)value;
        }

        public AmlParser.DefFindSetLeftBit GetAsDefFindSetLeftBit()
        {
            Debug.Assert(Tag == TagValue.DefFindSetLeftBit, "Type error: tried to access disjoint union as 'DefFindSetLeftBit' but tag does not match");
            return (AmlParser.DefFindSetLeftBit)value;
        }

        public AmlParser.DefFindSetRightBit GetAsDefFindSetRightBit()
        {
            Debug.Assert(Tag == TagValue.DefFindSetRightBit, "Type error: tried to access disjoint union as 'DefFindSetRightBit' but tag does not match");
            return (AmlParser.DefFindSetRightBit)value;
        }

        public AmlParser.DefFromBCD GetAsDefFromBCD()
        {
            Debug.Assert(Tag == TagValue.DefFromBCD, "Type error: tried to access disjoint union as 'DefFromBCD' but tag does not match");
            return (AmlParser.DefFromBCD)value;
        }

        public AmlParser.DefIncrement GetAsDefIncrement()
        {
            Debug.Assert(Tag == TagValue.DefIncrement, "Type error: tried to access disjoint union as 'DefIncrement' but tag does not match");
            return (AmlParser.DefIncrement)value;
        }

        public AmlParser.DefIndex GetAsDefIndex()
        {
            Debug.Assert(Tag == TagValue.DefIndex, "Type error: tried to access disjoint union as 'DefIndex' but tag does not match");
            return (AmlParser.DefIndex)value;
        }

        public AmlParser.DefLAnd GetAsDefLAnd()
        {
            Debug.Assert(Tag == TagValue.DefLAnd, "Type error: tried to access disjoint union as 'DefLAnd' but tag does not match");
            return (AmlParser.DefLAnd)value;
        }

        public AmlParser.DefLEqual GetAsDefLEqual()
        {
            Debug.Assert(Tag == TagValue.DefLEqual, "Type error: tried to access disjoint union as 'DefLEqual' but tag does not match");
            return (AmlParser.DefLEqual)value;
        }

        public AmlParser.DefLGreater GetAsDefLGreater()
        {
            Debug.Assert(Tag == TagValue.DefLGreater, "Type error: tried to access disjoint union as 'DefLGreater' but tag does not match");
            return (AmlParser.DefLGreater)value;
        }

        public AmlParser.DefLGreaterEqual GetAsDefLGreaterEqual()
        {
            Debug.Assert(Tag == TagValue.DefLGreaterEqual, "Type error: tried to access disjoint union as 'DefLGreaterEqual' but tag does not match");
            return (AmlParser.DefLGreaterEqual)value;
        }

        public AmlParser.DefLLess GetAsDefLLess()
        {
            Debug.Assert(Tag == TagValue.DefLLess, "Type error: tried to access disjoint union as 'DefLLess' but tag does not match");
            return (AmlParser.DefLLess)value;
        }

        public AmlParser.DefLLessEqual GetAsDefLLessEqual()
        {
            Debug.Assert(Tag == TagValue.DefLLessEqual, "Type error: tried to access disjoint union as 'DefLLessEqual' but tag does not match");
            return (AmlParser.DefLLessEqual)value;
        }

        public AmlParser.DefMid GetAsDefMid()
        {
            Debug.Assert(Tag == TagValue.DefMid, "Type error: tried to access disjoint union as 'DefMid' but tag does not match");
            return (AmlParser.DefMid)value;
        }

        public AmlParser.DefLNot GetAsDefLNot()
        {
            Debug.Assert(Tag == TagValue.DefLNot, "Type error: tried to access disjoint union as 'DefLNot' but tag does not match");
            return (AmlParser.DefLNot)value;
        }

        public AmlParser.DefLNotEqual GetAsDefLNotEqual()
        {
            Debug.Assert(Tag == TagValue.DefLNotEqual, "Type error: tried to access disjoint union as 'DefLNotEqual' but tag does not match");
            return (AmlParser.DefLNotEqual)value;
        }

        public AmlParser.DefLoadTable GetAsDefLoadTable()
        {
            Debug.Assert(Tag == TagValue.DefLoadTable, "Type error: tried to access disjoint union as 'DefLoadTable' but tag does not match");
            return (AmlParser.DefLoadTable)value;
        }

        public AmlParser.DefLOr GetAsDefLOr()
        {
            Debug.Assert(Tag == TagValue.DefLOr, "Type error: tried to access disjoint union as 'DefLOr' but tag does not match");
            return (AmlParser.DefLOr)value;
        }

        public AmlParser.DefMatch GetAsDefMatch()
        {
            Debug.Assert(Tag == TagValue.DefMatch, "Type error: tried to access disjoint union as 'DefMatch' but tag does not match");
            return (AmlParser.DefMatch)value;
        }

        public AmlParser.DefMod GetAsDefMod()
        {
            Debug.Assert(Tag == TagValue.DefMod, "Type error: tried to access disjoint union as 'DefMod' but tag does not match");
            return (AmlParser.DefMod)value;
        }

        public AmlParser.DefMultiply GetAsDefMultiply()
        {
            Debug.Assert(Tag == TagValue.DefMultiply, "Type error: tried to access disjoint union as 'DefMultiply' but tag does not match");
            return (AmlParser.DefMultiply)value;
        }

        public AmlParser.DefNAnd GetAsDefNAnd()
        {
            Debug.Assert(Tag == TagValue.DefNAnd, "Type error: tried to access disjoint union as 'DefNAnd' but tag does not match");
            return (AmlParser.DefNAnd)value;
        }

        public AmlParser.DefNOr GetAsDefNOr()
        {
            Debug.Assert(Tag == TagValue.DefNOr, "Type error: tried to access disjoint union as 'DefNOr' but tag does not match");
            return (AmlParser.DefNOr)value;
        }

        public AmlParser.DefNot GetAsDefNot()
        {
            Debug.Assert(Tag == TagValue.DefNot, "Type error: tried to access disjoint union as 'DefNot' but tag does not match");
            return (AmlParser.DefNot)value;
        }

        public AmlParser.DefObjectType GetAsDefObjectType()
        {
            Debug.Assert(Tag == TagValue.DefObjectType, "Type error: tried to access disjoint union as 'DefObjectType' but tag does not match");
            return (AmlParser.DefObjectType)value;
        }

        public AmlParser.DefOr GetAsDefOr()
        {
            Debug.Assert(Tag == TagValue.DefOr, "Type error: tried to access disjoint union as 'DefOr' but tag does not match");
            return (AmlParser.DefOr)value;
        }

        public AmlParser.DefPackage GetAsDefPackage()
        {
            Debug.Assert(Tag == TagValue.DefPackage, "Type error: tried to access disjoint union as 'DefPackage' but tag does not match");
            return (AmlParser.DefPackage)value;
        }

        public AmlParser.DefVarPackage GetAsDefVarPackage()
        {
            Debug.Assert(Tag == TagValue.DefVarPackage, "Type error: tried to access disjoint union as 'DefVarPackage' but tag does not match");
            return (AmlParser.DefVarPackage)value;
        }

        public AmlParser.DefRefOf GetAsDefRefOf()
        {
            Debug.Assert(Tag == TagValue.DefRefOf, "Type error: tried to access disjoint union as 'DefRefOf' but tag does not match");
            return (AmlParser.DefRefOf)value;
        }

        public AmlParser.DefShiftLeft GetAsDefShiftLeft()
        {
            Debug.Assert(Tag == TagValue.DefShiftLeft, "Type error: tried to access disjoint union as 'DefShiftLeft' but tag does not match");
            return (AmlParser.DefShiftLeft)value;
        }

        public AmlParser.DefShiftRight GetAsDefShiftRight()
        {
            Debug.Assert(Tag == TagValue.DefShiftRight, "Type error: tried to access disjoint union as 'DefShiftRight' but tag does not match");
            return (AmlParser.DefShiftRight)value;
        }

        public AmlParser.DefSizeOf GetAsDefSizeOf()
        {
            Debug.Assert(Tag == TagValue.DefSizeOf, "Type error: tried to access disjoint union as 'DefSizeOf' but tag does not match");
            return (AmlParser.DefSizeOf)value;
        }

        public AmlParser.DefStore GetAsDefStore()
        {
            Debug.Assert(Tag == TagValue.DefStore, "Type error: tried to access disjoint union as 'DefStore' but tag does not match");
            return (AmlParser.DefStore)value;
        }

        public AmlParser.DefSubtract GetAsDefSubtract()
        {
            Debug.Assert(Tag == TagValue.DefSubtract, "Type error: tried to access disjoint union as 'DefSubtract' but tag does not match");
            return (AmlParser.DefSubtract)value;
        }

        public AmlParser.DefTimer GetAsDefTimer()
        {
            Debug.Assert(Tag == TagValue.DefTimer, "Type error: tried to access disjoint union as 'DefTimer' but tag does not match");
            return (AmlParser.DefTimer)value;
        }

        public AmlParser.DefToBCD GetAsDefToBCD()
        {
            Debug.Assert(Tag == TagValue.DefToBCD, "Type error: tried to access disjoint union as 'DefToBCD' but tag does not match");
            return (AmlParser.DefToBCD)value;
        }

        public AmlParser.DefToBuffer GetAsDefToBuffer()
        {
            Debug.Assert(Tag == TagValue.DefToBuffer, "Type error: tried to access disjoint union as 'DefToBuffer' but tag does not match");
            return (AmlParser.DefToBuffer)value;
        }

        public AmlParser.DefToDecimalString GetAsDefToDecimalString()
        {
            Debug.Assert(Tag == TagValue.DefToDecimalString, "Type error: tried to access disjoint union as 'DefToDecimalString' but tag does not match");
            return (AmlParser.DefToDecimalString)value;
        }

        public AmlParser.DefToHexString GetAsDefToHexString()
        {
            Debug.Assert(Tag == TagValue.DefToHexString, "Type error: tried to access disjoint union as 'DefToHexString' but tag does not match");
            return (AmlParser.DefToHexString)value;
        }

        public AmlParser.DefToInteger GetAsDefToInteger()
        {
            Debug.Assert(Tag == TagValue.DefToInteger, "Type error: tried to access disjoint union as 'DefToInteger' but tag does not match");
            return (AmlParser.DefToInteger)value;
        }

        public AmlParser.DefToString GetAsDefToString()
        {
            Debug.Assert(Tag == TagValue.DefToString, "Type error: tried to access disjoint union as 'DefToString' but tag does not match");
            return (AmlParser.DefToString)value;
        }

        public AmlParser.DefWait GetAsDefWait()
        {
            Debug.Assert(Tag == TagValue.DefWait, "Type error: tried to access disjoint union as 'DefWait' but tag does not match");
            return (AmlParser.DefWait)value;
        }

        public AmlParser.DefXOr GetAsDefXOr()
        {
            Debug.Assert(Tag == TagValue.DefXOr, "Type error: tried to access disjoint union as 'DefXOr' but tag does not match");
            return (AmlParser.DefXOr)value;
        }

        public AmlParser.UserTermObj GetAsUserTermObj()
        {
            Debug.Assert(Tag == TagValue.UserTermObj, "Type error: tried to access disjoint union as 'UserTermObj' but tag does not match");
            return (AmlParser.UserTermObj)value;
        }

#if false
        // Example usage template for this disjoint union type
        public static void ExampleUsage(Type2Opcode type2Opcode)
        {
            switch (type2Opcode.Tag) {
                case Type2Opcode.TagValue.DefAcquire:
                    AmlParser.DefAcquire defAcquire = type2Opcode.GetAsDefAcquire();
                    break;
                case Type2Opcode.TagValue.DefAdd:
                    AmlParser.DefAdd defAdd = type2Opcode.GetAsDefAdd();
                    break;
                case Type2Opcode.TagValue.DefAnd:
                    AmlParser.DefAnd defAnd = type2Opcode.GetAsDefAnd();
                    break;
                case Type2Opcode.TagValue.DefBuffer:
                    AmlParser.DefBuffer defBuffer = type2Opcode.GetAsDefBuffer();
                    break;
                case Type2Opcode.TagValue.DefConcat:
                    AmlParser.DefConcat defConcat = type2Opcode.GetAsDefConcat();
                    break;
                case Type2Opcode.TagValue.DefConcatRes:
                    AmlParser.DefConcatRes defConcatRes = type2Opcode.GetAsDefConcatRes();
                    break;
                case Type2Opcode.TagValue.DefCondRefOf:
                    AmlParser.DefCondRefOf defCondRefOf = type2Opcode.GetAsDefCondRefOf();
                    break;
                case Type2Opcode.TagValue.DefCopyObject:
                    AmlParser.DefCopyObject defCopyObject = type2Opcode.GetAsDefCopyObject();
                    break;
                case Type2Opcode.TagValue.DefDecrement:
                    AmlParser.DefDecrement defDecrement = type2Opcode.GetAsDefDecrement();
                    break;
                case Type2Opcode.TagValue.DefDerefOf:
                    AmlParser.DefDerefOf defDerefOf = type2Opcode.GetAsDefDerefOf();
                    break;
                case Type2Opcode.TagValue.DefDivide:
                    AmlParser.DefDivide defDivide = type2Opcode.GetAsDefDivide();
                    break;
                case Type2Opcode.TagValue.DefFindSetLeftBit:
                    AmlParser.DefFindSetLeftBit defFindSetLeftBit = type2Opcode.GetAsDefFindSetLeftBit();
                    break;
                case Type2Opcode.TagValue.DefFindSetRightBit:
                    AmlParser.DefFindSetRightBit defFindSetRightBit = type2Opcode.GetAsDefFindSetRightBit();
                    break;
                case Type2Opcode.TagValue.DefFromBCD:
                    AmlParser.DefFromBCD defFromBCD = type2Opcode.GetAsDefFromBCD();
                    break;
                case Type2Opcode.TagValue.DefIncrement:
                    AmlParser.DefIncrement defIncrement = type2Opcode.GetAsDefIncrement();
                    break;
                case Type2Opcode.TagValue.DefIndex:
                    AmlParser.DefIndex defIndex = type2Opcode.GetAsDefIndex();
                    break;
                case Type2Opcode.TagValue.DefLAnd:
                    AmlParser.DefLAnd defLAnd = type2Opcode.GetAsDefLAnd();
                    break;
                case Type2Opcode.TagValue.DefLEqual:
                    AmlParser.DefLEqual defLEqual = type2Opcode.GetAsDefLEqual();
                    break;
                case Type2Opcode.TagValue.DefLGreater:
                    AmlParser.DefLGreater defLGreater = type2Opcode.GetAsDefLGreater();
                    break;
                case Type2Opcode.TagValue.DefLGreaterEqual:
                    AmlParser.DefLGreaterEqual defLGreaterEqual = type2Opcode.GetAsDefLGreaterEqual();
                    break;
                case Type2Opcode.TagValue.DefLLess:
                    AmlParser.DefLLess defLLess = type2Opcode.GetAsDefLLess();
                    break;
                case Type2Opcode.TagValue.DefLLessEqual:
                    AmlParser.DefLLessEqual defLLessEqual = type2Opcode.GetAsDefLLessEqual();
                    break;
                case Type2Opcode.TagValue.DefMid:
                    AmlParser.DefMid defMid = type2Opcode.GetAsDefMid();
                    break;
                case Type2Opcode.TagValue.DefLNot:
                    AmlParser.DefLNot defLNot = type2Opcode.GetAsDefLNot();
                    break;
                case Type2Opcode.TagValue.DefLNotEqual:
                    AmlParser.DefLNotEqual defLNotEqual = type2Opcode.GetAsDefLNotEqual();
                    break;
                case Type2Opcode.TagValue.DefLoadTable:
                    AmlParser.DefLoadTable defLoadTable = type2Opcode.GetAsDefLoadTable();
                    break;
                case Type2Opcode.TagValue.DefLOr:
                    AmlParser.DefLOr defLOr = type2Opcode.GetAsDefLOr();
                    break;
                case Type2Opcode.TagValue.DefMatch:
                    AmlParser.DefMatch defMatch = type2Opcode.GetAsDefMatch();
                    break;
                case Type2Opcode.TagValue.DefMod:
                    AmlParser.DefMod defMod = type2Opcode.GetAsDefMod();
                    break;
                case Type2Opcode.TagValue.DefMultiply:
                    AmlParser.DefMultiply defMultiply = type2Opcode.GetAsDefMultiply();
                    break;
                case Type2Opcode.TagValue.DefNAnd:
                    AmlParser.DefNAnd defNAnd = type2Opcode.GetAsDefNAnd();
                    break;
                case Type2Opcode.TagValue.DefNOr:
                    AmlParser.DefNOr defNOr = type2Opcode.GetAsDefNOr();
                    break;
                case Type2Opcode.TagValue.DefNot:
                    AmlParser.DefNot defNot = type2Opcode.GetAsDefNot();
                    break;
                case Type2Opcode.TagValue.DefObjectType:
                    AmlParser.DefObjectType defObjectType = type2Opcode.GetAsDefObjectType();
                    break;
                case Type2Opcode.TagValue.DefOr:
                    AmlParser.DefOr defOr = type2Opcode.GetAsDefOr();
                    break;
                case Type2Opcode.TagValue.DefPackage:
                    AmlParser.DefPackage defPackage = type2Opcode.GetAsDefPackage();
                    break;
                case Type2Opcode.TagValue.DefVarPackage:
                    AmlParser.DefVarPackage defVarPackage = type2Opcode.GetAsDefVarPackage();
                    break;
                case Type2Opcode.TagValue.DefRefOf:
                    AmlParser.DefRefOf defRefOf = type2Opcode.GetAsDefRefOf();
                    break;
                case Type2Opcode.TagValue.DefShiftLeft:
                    AmlParser.DefShiftLeft defShiftLeft = type2Opcode.GetAsDefShiftLeft();
                    break;
                case Type2Opcode.TagValue.DefShiftRight:
                    AmlParser.DefShiftRight defShiftRight = type2Opcode.GetAsDefShiftRight();
                    break;
                case Type2Opcode.TagValue.DefSizeOf:
                    AmlParser.DefSizeOf defSizeOf = type2Opcode.GetAsDefSizeOf();
                    break;
                case Type2Opcode.TagValue.DefStore:
                    AmlParser.DefStore defStore = type2Opcode.GetAsDefStore();
                    break;
                case Type2Opcode.TagValue.DefSubtract:
                    AmlParser.DefSubtract defSubtract = type2Opcode.GetAsDefSubtract();
                    break;
                case Type2Opcode.TagValue.DefTimer:
                    AmlParser.DefTimer defTimer = type2Opcode.GetAsDefTimer();
                    break;
                case Type2Opcode.TagValue.DefToBCD:
                    AmlParser.DefToBCD defToBCD = type2Opcode.GetAsDefToBCD();
                    break;
                case Type2Opcode.TagValue.DefToBuffer:
                    AmlParser.DefToBuffer defToBuffer = type2Opcode.GetAsDefToBuffer();
                    break;
                case Type2Opcode.TagValue.DefToDecimalString:
                    AmlParser.DefToDecimalString defToDecimalString = type2Opcode.GetAsDefToDecimalString();
                    break;
                case Type2Opcode.TagValue.DefToHexString:
                    AmlParser.DefToHexString defToHexString = type2Opcode.GetAsDefToHexString();
                    break;
                case Type2Opcode.TagValue.DefToInteger:
                    AmlParser.DefToInteger defToInteger = type2Opcode.GetAsDefToInteger();
                    break;
                case Type2Opcode.TagValue.DefToString:
                    AmlParser.DefToString defToString = type2Opcode.GetAsDefToString();
                    break;
                case Type2Opcode.TagValue.DefWait:
                    AmlParser.DefWait defWait = type2Opcode.GetAsDefWait();
                    break;
                case Type2Opcode.TagValue.DefXOr:
                    AmlParser.DefXOr defXOr = type2Opcode.GetAsDefXOr();
                    break;
                case Type2Opcode.TagValue.UserTermObj:
                    AmlParser.UserTermObj userTermObj = type2Opcode.GetAsUserTermObj();
                    break;
                default:
                    Debug.Assert(false, "Unhandled alternative in switch over 'Type2Opcode'");
                    break;
            }
        }
#endif
    public override void Accept(AmlParserNodeVisitor v) {        v.VisitType2Opcode(this);    }        public void AcceptAlternative(AmlParserNodeVisitor v) {        ((AmlParserNode)value).Accept(v);    }    
    }

    public class Type6Opcode : AmlParserNode
    {
        public enum TagValue
        {
            DefRefOf,
            DefDerefOf,
            DefIndex,
            UserTermObj,
        }

        private TagValue tag;

        public TagValue Tag
        {
            get {
                return tag;
            }
        }

        private object value;

        private Type6Opcode(TagValue tag, object value) {
            this.tag = tag;
            this.value = value;
        }

        public static Type6Opcode CreateDefRefOf(AmlParser.DefRefOf defRefOf)
        {
            return new Type6Opcode(TagValue.DefRefOf, defRefOf);
        }

        public static Type6Opcode CreateDefDerefOf(AmlParser.DefDerefOf defDerefOf)
        {
            return new Type6Opcode(TagValue.DefDerefOf, defDerefOf);
        }

        public static Type6Opcode CreateDefIndex(AmlParser.DefIndex defIndex)
        {
            return new Type6Opcode(TagValue.DefIndex, defIndex);
        }

        public static Type6Opcode CreateUserTermObj(AmlParser.UserTermObj userTermObj)
        {
            return new Type6Opcode(TagValue.UserTermObj, userTermObj);
        }

        public AmlParser.DefRefOf GetAsDefRefOf()
        {
            Debug.Assert(Tag == TagValue.DefRefOf, "Type error: tried to access disjoint union as 'DefRefOf' but tag does not match");
            return (AmlParser.DefRefOf)value;
        }

        public AmlParser.DefDerefOf GetAsDefDerefOf()
        {
            Debug.Assert(Tag == TagValue.DefDerefOf, "Type error: tried to access disjoint union as 'DefDerefOf' but tag does not match");
            return (AmlParser.DefDerefOf)value;
        }

        public AmlParser.DefIndex GetAsDefIndex()
        {
            Debug.Assert(Tag == TagValue.DefIndex, "Type error: tried to access disjoint union as 'DefIndex' but tag does not match");
            return (AmlParser.DefIndex)value;
        }

        public AmlParser.UserTermObj GetAsUserTermObj()
        {
            Debug.Assert(Tag == TagValue.UserTermObj, "Type error: tried to access disjoint union as 'UserTermObj' but tag does not match");
            return (AmlParser.UserTermObj)value;
        }

#if false
        // Example usage template for this disjoint union type
        public static void ExampleUsage(Type6Opcode type6Opcode)
        {
            switch (type6Opcode.Tag) {
                case Type6Opcode.TagValue.DefRefOf:
                    AmlParser.DefRefOf defRefOf = type6Opcode.GetAsDefRefOf();
                    break;
                case Type6Opcode.TagValue.DefDerefOf:
                    AmlParser.DefDerefOf defDerefOf = type6Opcode.GetAsDefDerefOf();
                    break;
                case Type6Opcode.TagValue.DefIndex:
                    AmlParser.DefIndex defIndex = type6Opcode.GetAsDefIndex();
                    break;
                case Type6Opcode.TagValue.UserTermObj:
                    AmlParser.UserTermObj userTermObj = type6Opcode.GetAsUserTermObj();
                    break;
                default:
                    Debug.Assert(false, "Unhandled alternative in switch over 'Type6Opcode'");
                    break;
            }
        }
#endif
    public override void Accept(AmlParserNodeVisitor v) {        v.VisitType6Opcode(this);    }        public void AcceptAlternative(AmlParserNodeVisitor v) {        ((AmlParserNode)value).Accept(v);    }    
    }

    public class PackageElement : AmlParserNode
    {
        public enum TagValue
        {
            DataRefObject,
            NameString,
        }

        private TagValue tag;

        public TagValue Tag
        {
            get {
                return tag;
            }
        }

        private object value;

        private PackageElement(TagValue tag, object value) {
            this.tag = tag;
            this.value = value;
        }

        public static PackageElement CreateDataRefObject(DataRefObject dataRefObject)
        {
            return new PackageElement(TagValue.DataRefObject, dataRefObject);
        }

        public static PackageElement CreateNameString(AmlParser.NameString nameString)
        {
            return new PackageElement(TagValue.NameString, nameString);
        }

        public DataRefObject GetAsDataRefObject()
        {
            Debug.Assert(Tag == TagValue.DataRefObject, "Type error: tried to access disjoint union as 'DataRefObject' but tag does not match");
            return (DataRefObject)value;
        }

        public AmlParser.NameString GetAsNameString()
        {
            Debug.Assert(Tag == TagValue.NameString, "Type error: tried to access disjoint union as 'NameString' but tag does not match");
            return (AmlParser.NameString)value;
        }

#if false
        // Example usage template for this disjoint union type
        public static void ExampleUsage(PackageElement packageElement)
        {
            switch (packageElement.Tag) {
                case PackageElement.TagValue.DataRefObject:
                    DataRefObject dataRefObject = packageElement.GetAsDataRefObject();
                    break;
                case PackageElement.TagValue.NameString:
                    AmlParser.NameString nameString = packageElement.GetAsNameString();
                    break;
                default:
                    Debug.Assert(false, "Unhandled alternative in switch over 'PackageElement'");
                    break;
            }
        }
#endif
    public override void Accept(AmlParserNodeVisitor v) {        v.Visit(this);    }        public void AcceptAlternative(AmlParserNodeVisitor v) {        ((AmlParserNode)value).Accept(v);    }    
    }

}

