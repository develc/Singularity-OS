; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	C:\Users\cc\source\repos\Singularity-OS\base\Boot\SingLdrPc\blpool.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?BlPoolSegmentList@@3U_LIST_ENTRY@@A		; BlPoolSegmentList
_BSS	SEGMENT
?BlPoolSegmentList@@3U_LIST_ENTRY@@A DQ 01H DUP (?)	; BlPoolSegmentList
_BSS	ENDS
PUBLIC	?BlPoolInitialize@@YIXXZ			; BlPoolInitialize
EXTRN	?BlRtlInitializeListHead@@YIXPAU_LIST_ENTRY@@@Z:PROC ; BlRtlInitializeListHead
; Function compile flags: /Odsp
; File c:\users\cc\source\repos\singularity-os\base\boot\singldrpc\blpool.cpp
;	COMDAT ?BlPoolInitialize@@YIXXZ
_TEXT	SEGMENT
?BlPoolInitialize@@YIXXZ PROC				; BlPoolInitialize, COMDAT

; 93   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 94   :     BlRtlInitializeListHead(&BlPoolSegmentList);

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?BlPoolSegmentList@@3U_LIST_ENTRY@@A ; BlPoolSegmentList
  00008	e8 00 00 00 00	 call	 ?BlRtlInitializeListHead@@YIXPAU_LIST_ENTRY@@@Z ; BlRtlInitializeListHead

; 95   : 
; 96   : #if POOL_VERBOSE
; 97   : 
; 98   :     BlRtlPrintf("POOL: Segment list @ %p.\n", &BlPoolSegmentList);
; 99   : 
; 100  : #endif
; 101  : 
; 102  :     return;
; 103  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?BlPoolInitialize@@YIXXZ ENDP				; BlPoolInitialize
_TEXT	ENDS
PUBLIC	??_C@_0L@IABHNPNF@blpool?4cpp?$AA@		; `string'
PUBLIC	?BlPoolVerify@@YIXXZ				; BlPoolVerify
EXTRN	?BlRtlAssertFailedPtr@@YIXPBDKK@Z:PROC		; BlRtlAssertFailedPtr
EXTRN	?BlRtlAssertFailed@@YIXPBDK@Z:PROC		; BlRtlAssertFailed
;	COMDAT ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
CONST	SEGMENT
??_C@_0L@IABHNPNF@blpool?4cpp?$AA@ DB 'blpool.cpp', 00H	; `string'
; Function compile flags: /Odsp
CONST	ENDS
;	COMDAT ?BlPoolVerify@@YIXXZ
_TEXT	SEGMENT
_BlockEntry$ = -28					; size = 4
_Block$ = -24						; size = 4
_BlockHead$ = -20					; size = 4
_NextBlock$ = -16					; size = 4
_SegmentHead$ = -12					; size = 4
_SegmentEntry$ = -8					; size = 4
_Segment$ = -4						; size = 4
?BlPoolVerify@@YIXXZ PROC				; BlPoolVerify, COMDAT

; 175  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 176  :     PBL_POOL_BLOCK Block;
; 177  :     PLIST_ENTRY BlockEntry;
; 178  :     PLIST_ENTRY BlockHead;
; 179  :     PBL_POOL_BLOCK NextBlock;
; 180  :     PBL_POOL_SEGMENT Segment;
; 181  :     PLIST_ENTRY SegmentEntry;
; 182  :     PLIST_ENTRY SegmentHead;
; 183  : 
; 184  :     SegmentHead = &BlPoolSegmentList;

  00006	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _SegmentHead$[ebp], OFFSET ?BlPoolSegmentList@@3U_LIST_ENTRY@@A ; BlPoolSegmentList

; 185  : 
; 186  :     BLASSERT(SegmentHead->Flink->Blink == SegmentHead);

  0000d	8b 45 f4	 mov	 eax, DWORD PTR _SegmentHead$[ebp]
  00010	8b 00		 mov	 eax, DWORD PTR [eax]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	3b 45 f4	 cmp	 eax, DWORD PTR _SegmentHead$[ebp]
  00018	74 0f		 je	 SHORT $LN22@BlPoolVeri
  0001a	ba ba 00 00 00	 mov	 edx, 186		; 000000baH
  0001f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  00024	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN22@BlPoolVeri:

; 187  :     BLASSERT(SegmentHead->Blink->Flink == SegmentHead);

  00029	8b 45 f4	 mov	 eax, DWORD PTR _SegmentHead$[ebp]
  0002c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002f	8b 00		 mov	 eax, DWORD PTR [eax]
  00031	3b 45 f4	 cmp	 eax, DWORD PTR _SegmentHead$[ebp]
  00034	74 0f		 je	 SHORT $LN21@BlPoolVeri
  00036	ba bb 00 00 00	 mov	 edx, 187		; 000000bbH
  0003b	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  00040	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN21@BlPoolVeri:

; 188  : 
; 189  :     for (SegmentEntry = SegmentHead->Flink; SegmentEntry != SegmentHead; SegmentEntry = SegmentEntry->Flink) {

  00045	8b 45 f4	 mov	 eax, DWORD PTR _SegmentHead$[ebp]
  00048	8b 00		 mov	 eax, DWORD PTR [eax]
  0004a	89 45 f8	 mov	 DWORD PTR _SegmentEntry$[ebp], eax
  0004d	eb 08		 jmp	 SHORT $LN20@BlPoolVeri
$LN19@BlPoolVeri:
  0004f	8b 45 f8	 mov	 eax, DWORD PTR _SegmentEntry$[ebp]
  00052	8b 00		 mov	 eax, DWORD PTR [eax]
  00054	89 45 f8	 mov	 DWORD PTR _SegmentEntry$[ebp], eax
$LN20@BlPoolVeri:
  00057	8b 45 f8	 mov	 eax, DWORD PTR _SegmentEntry$[ebp]
  0005a	3b 45 f4	 cmp	 eax, DWORD PTR _SegmentHead$[ebp]
  0005d	0f 84 00 02 00
	00		 je	 $LN23@BlPoolVeri

; 190  : 
; 191  :         Segment = CONTAINING_RECORD(SegmentEntry,
; 192  :                                     BL_POOL_SEGMENT,
; 193  :                                     Entry);

  00063	8b 45 f8	 mov	 eax, DWORD PTR _SegmentEntry$[ebp]
  00066	83 e8 04	 sub	 eax, 4
  00069	89 45 fc	 mov	 DWORD PTR _Segment$[ebp], eax

; 194  : 
; 195  :         BLASSERT_PTR(Segment->Magic1 == BL_POOL_SEGMENT_MAGIC1, Segment);

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _Segment$[ebp]
  0006f	81 38 fc fd fe
	ff		 cmp	 DWORD PTR [eax], -66052	; fffefdfcH
  00075	74 12		 je	 SHORT $LN17@BlPoolVeri
  00077	ff 75 fc	 push	 DWORD PTR _Segment$[ebp]
  0007a	ba c3 00 00 00	 mov	 edx, 195		; 000000c3H
  0007f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  00084	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN17@BlPoolVeri:

; 196  :         BLASSERT_PTR(Segment->Magic2 == BL_POOL_SEGMENT_MAGIC2, Segment);

  00089	8b 45 fc	 mov	 eax, DWORD PTR _Segment$[ebp]
  0008c	81 78 20 f8 f9
	fa fb		 cmp	 DWORD PTR [eax+32], -67438088 ; fbfaf9f8H
  00093	74 12		 je	 SHORT $LN16@BlPoolVeri
  00095	ff 75 fc	 push	 DWORD PTR _Segment$[ebp]
  00098	ba c4 00 00 00	 mov	 edx, 196		; 000000c4H
  0009d	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  000a2	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN16@BlPoolVeri:

; 197  : 
; 198  :         BLASSERT_PTR(Segment->Entry.Flink->Blink == &Segment->Entry, Segment);

  000a7	8b 45 fc	 mov	 eax, DWORD PTR _Segment$[ebp]
  000aa	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000ad	8b 4d fc	 mov	 ecx, DWORD PTR _Segment$[ebp]
  000b0	83 c1 04	 add	 ecx, 4
  000b3	39 48 04	 cmp	 DWORD PTR [eax+4], ecx
  000b6	74 12		 je	 SHORT $LN15@BlPoolVeri
  000b8	ff 75 fc	 push	 DWORD PTR _Segment$[ebp]
  000bb	ba c6 00 00 00	 mov	 edx, 198		; 000000c6H
  000c0	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  000c5	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN15@BlPoolVeri:

; 199  :         BLASSERT_PTR(Segment->Entry.Blink->Flink == &Segment->Entry, Segment);

  000ca	8b 45 fc	 mov	 eax, DWORD PTR _Segment$[ebp]
  000cd	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000d0	8b 4d fc	 mov	 ecx, DWORD PTR _Segment$[ebp]
  000d3	83 c1 04	 add	 ecx, 4
  000d6	39 08		 cmp	 DWORD PTR [eax], ecx
  000d8	74 12		 je	 SHORT $LN14@BlPoolVeri
  000da	ff 75 fc	 push	 DWORD PTR _Segment$[ebp]
  000dd	ba c7 00 00 00	 mov	 edx, 199		; 000000c7H
  000e2	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  000e7	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN14@BlPoolVeri:

; 200  : 
; 201  : 
; 202  :         BlockHead = &Segment->BlockList;

  000ec	8b 45 fc	 mov	 eax, DWORD PTR _Segment$[ebp]
  000ef	83 c0 18	 add	 eax, 24			; 00000018H
  000f2	89 45 ec	 mov	 DWORD PTR _BlockHead$[ebp], eax

; 203  : 
; 204  :         for (BlockEntry = BlockHead->Flink; BlockEntry != BlockHead; BlockEntry = BlockEntry->Flink) {

  000f5	8b 45 ec	 mov	 eax, DWORD PTR _BlockHead$[ebp]
  000f8	8b 00		 mov	 eax, DWORD PTR [eax]
  000fa	89 45 e4	 mov	 DWORD PTR _BlockEntry$[ebp], eax
  000fd	eb 08		 jmp	 SHORT $LN13@BlPoolVeri
$LN12@BlPoolVeri:
  000ff	8b 45 e4	 mov	 eax, DWORD PTR _BlockEntry$[ebp]
  00102	8b 00		 mov	 eax, DWORD PTR [eax]
  00104	89 45 e4	 mov	 DWORD PTR _BlockEntry$[ebp], eax
$LN13@BlPoolVeri:
  00107	8b 45 e4	 mov	 eax, DWORD PTR _BlockEntry$[ebp]
  0010a	3b 45 ec	 cmp	 eax, DWORD PTR _BlockHead$[ebp]
  0010d	0f 84 4b 01 00
	00		 je	 $LN11@BlPoolVeri

; 205  : 
; 206  :             Block = CONTAINING_RECORD(BlockEntry,
; 207  :                                       BL_POOL_BLOCK,
; 208  :                                       Entry);

  00113	8b 45 e4	 mov	 eax, DWORD PTR _BlockEntry$[ebp]
  00116	83 e8 04	 sub	 eax, 4
  00119	89 45 e8	 mov	 DWORD PTR _Block$[ebp], eax

; 209  : 
; 210  :             BLASSERT_PTR(Block->Magic1 == BL_POOL_BLOCK_MAGIC1, Block);

  0011c	8b 45 e8	 mov	 eax, DWORD PTR _Block$[ebp]
  0011f	81 38 04 03 02
	01		 cmp	 DWORD PTR [eax], 16909060 ; 01020304H
  00125	74 12		 je	 SHORT $LN10@BlPoolVeri
  00127	ff 75 e8	 push	 DWORD PTR _Block$[ebp]
  0012a	ba d2 00 00 00	 mov	 edx, 210		; 000000d2H
  0012f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  00134	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN10@BlPoolVeri:

; 211  :             BLASSERT_PTR(Block->Magic2 == BL_POOL_BLOCK_MAGIC2, Block);

  00139	8b 45 e8	 mov	 eax, DWORD PTR _Block$[ebp]
  0013c	81 78 1c 08 07
	06 05		 cmp	 DWORD PTR [eax+28], 84281096 ; 05060708H
  00143	74 12		 je	 SHORT $LN9@BlPoolVeri
  00145	ff 75 e8	 push	 DWORD PTR _Block$[ebp]
  00148	ba d3 00 00 00	 mov	 edx, 211		; 000000d3H
  0014d	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  00152	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN9@BlPoolVeri:

; 212  : 
; 213  :             BLASSERT_PTR((Block->State == BL_POOL_FREE) || ((Block->State == BL_POOL_BUSY)), Block);

  00157	8b 45 e8	 mov	 eax, DWORD PTR _Block$[ebp]
  0015a	83 78 10 01	 cmp	 DWORD PTR [eax+16], 1
  0015e	74 1b		 je	 SHORT $LN8@BlPoolVeri
  00160	8b 45 e8	 mov	 eax, DWORD PTR _Block$[ebp]
  00163	83 78 10 02	 cmp	 DWORD PTR [eax+16], 2
  00167	74 12		 je	 SHORT $LN8@BlPoolVeri
  00169	ff 75 e8	 push	 DWORD PTR _Block$[ebp]
  0016c	ba d5 00 00 00	 mov	 edx, 213		; 000000d5H
  00171	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  00176	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN8@BlPoolVeri:

; 214  : 
; 215  :             BLASSERT_PTR(((ULONG_PTR) Block % BL_POOL_GRANULARITY) == 0, Block);

  0017b	8b 45 e8	 mov	 eax, DWORD PTR _Block$[ebp]
  0017e	33 d2		 xor	 edx, edx
  00180	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00185	f7 f1		 div	 ecx
  00187	85 d2		 test	 edx, edx
  00189	74 12		 je	 SHORT $LN7@BlPoolVeri
  0018b	ff 75 e8	 push	 DWORD PTR _Block$[ebp]
  0018e	ba d7 00 00 00	 mov	 edx, 215		; 000000d7H
  00193	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  00198	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN7@BlPoolVeri:

; 216  : 
; 217  :             BLASSERT_PTR(Block->Size > sizeof(BL_POOL_BLOCK), Block);

  0019d	8b 45 e8	 mov	 eax, DWORD PTR _Block$[ebp]
  001a0	83 78 0c 20	 cmp	 DWORD PTR [eax+12], 32	; 00000020H
  001a4	77 12		 ja	 SHORT $LN6@BlPoolVeri
  001a6	ff 75 e8	 push	 DWORD PTR _Block$[ebp]
  001a9	ba d9 00 00 00	 mov	 edx, 217		; 000000d9H
  001ae	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  001b3	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN6@BlPoolVeri:

; 218  :             BLASSERT_PTR((Block->Size % BL_POOL_GRANULARITY) == 0, Block);

  001b8	8b 45 e8	 mov	 eax, DWORD PTR _Block$[ebp]
  001bb	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  001be	33 d2		 xor	 edx, edx
  001c0	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  001c5	f7 f1		 div	 ecx
  001c7	85 d2		 test	 edx, edx
  001c9	74 12		 je	 SHORT $LN5@BlPoolVeri
  001cb	ff 75 e8	 push	 DWORD PTR _Block$[ebp]
  001ce	ba da 00 00 00	 mov	 edx, 218		; 000000daH
  001d3	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  001d8	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN5@BlPoolVeri:

; 219  : 
; 220  :             if (Block->Entry.Flink != BlockHead) {

  001dd	8b 45 e8	 mov	 eax, DWORD PTR _Block$[ebp]
  001e0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001e3	3b 45 ec	 cmp	 eax, DWORD PTR _BlockHead$[ebp]
  001e6	74 2c		 je	 SHORT $LN4@BlPoolVeri

; 221  : 
; 222  :                 NextBlock = CONTAINING_RECORD(Block->Entry.Flink,
; 223  :                                               BL_POOL_BLOCK,
; 224  :                                               Entry);

  001e8	8b 45 e8	 mov	 eax, DWORD PTR _Block$[ebp]
  001eb	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001ee	83 e8 04	 sub	 eax, 4
  001f1	89 45 f0	 mov	 DWORD PTR _NextBlock$[ebp], eax

; 225  : 
; 226  :                 BLASSERT_PTR(((ULONG_PTR) Block + Block->Size) == ((ULONG_PTR) NextBlock), Block);

  001f4	8b 45 e8	 mov	 eax, DWORD PTR _Block$[ebp]
  001f7	8b 4d e8	 mov	 ecx, DWORD PTR _Block$[ebp]
  001fa	03 48 0c	 add	 ecx, DWORD PTR [eax+12]
  001fd	3b 4d f0	 cmp	 ecx, DWORD PTR _NextBlock$[ebp]
  00200	74 12		 je	 SHORT $LN4@BlPoolVeri
  00202	ff 75 e8	 push	 DWORD PTR _Block$[ebp]
  00205	ba e2 00 00 00	 mov	 edx, 226		; 000000e2H
  0020a	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  0020f	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN4@BlPoolVeri:

; 227  :             }
; 228  : 
; 229  :             BLASSERT_PTR(Block->Entry.Flink->Blink == &Block->Entry, Block);

  00214	8b 45 e8	 mov	 eax, DWORD PTR _Block$[ebp]
  00217	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0021a	8b 4d e8	 mov	 ecx, DWORD PTR _Block$[ebp]
  0021d	83 c1 04	 add	 ecx, 4
  00220	39 48 04	 cmp	 DWORD PTR [eax+4], ecx
  00223	74 12		 je	 SHORT $LN2@BlPoolVeri
  00225	ff 75 e8	 push	 DWORD PTR _Block$[ebp]
  00228	ba e5 00 00 00	 mov	 edx, 229		; 000000e5H
  0022d	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  00232	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN2@BlPoolVeri:

; 230  :             BLASSERT_PTR(Block->Entry.Blink->Flink == &Block->Entry, Block);

  00237	8b 45 e8	 mov	 eax, DWORD PTR _Block$[ebp]
  0023a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0023d	8b 4d e8	 mov	 ecx, DWORD PTR _Block$[ebp]
  00240	83 c1 04	 add	 ecx, 4
  00243	39 08		 cmp	 DWORD PTR [eax], ecx
  00245	74 12		 je	 SHORT $LN1@BlPoolVeri
  00247	ff 75 e8	 push	 DWORD PTR _Block$[ebp]
  0024a	ba e6 00 00 00	 mov	 edx, 230		; 000000e6H
  0024f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  00254	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN1@BlPoolVeri:

; 231  :         }

  00259	e9 a1 fe ff ff	 jmp	 $LN12@BlPoolVeri
$LN11@BlPoolVeri:

; 232  :     }

  0025e	e9 ec fd ff ff	 jmp	 $LN19@BlPoolVeri
$LN23@BlPoolVeri:

; 233  : 
; 234  :     return;
; 235  : }

  00263	c9		 leave
  00264	c3		 ret	 0
?BlPoolVerify@@YIXXZ ENDP				; BlPoolVerify
_TEXT	ENDS
PUBLIC	?BlPoolGrow@@YIXK@Z				; BlPoolGrow
EXTRN	?BlRtlInsertTailList@@YIXPAU_LIST_ENTRY@@0@Z:PROC ; BlRtlInsertTailList
EXTRN	?BlRtlZeroMemory@@YIXPAXK@Z:PROC		; BlRtlZeroMemory
EXTRN	?BlMmAllocatePhysicalRegion@@YI_KKK@Z:PROC	; BlMmAllocatePhysicalRegion
; Function compile flags: /Odsp
;	COMDAT ?BlPoolGrow@@YIXK@Z
_TEXT	SEGMENT
_Size$ = -12						; size = 4
_Block$ = -8						; size = 4
_Segment$ = -4						; size = 4
?BlPoolGrow@@YIXK@Z PROC				; BlPoolGrow, COMDAT
; _Size$ = ecx

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _Size$[ebp], ecx

; 255  :     PBL_POOL_BLOCK Block;
; 256  :     PBL_POOL_SEGMENT Segment;
; 257  : 
; 258  :     BlPoolVerify();

  00009	e8 00 00 00 00	 call	 ?BlPoolVerify@@YIXXZ	; BlPoolVerify

; 259  : 
; 260  :     BLASSERT(Size > 0);

  0000e	83 7d f4 00	 cmp	 DWORD PTR _Size$[ebp], 0
  00012	77 0f		 ja	 SHORT $LN1@BlPoolGrow
  00014	ba 04 01 00 00	 mov	 edx, 260		; 00000104H
  00019	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  0001e	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN1@BlPoolGrow:

; 261  : 
; 262  :     Size = ROUND_UP_TO_PAGES(Size);

  00023	8b 45 f4	 mov	 eax, DWORD PTR _Size$[ebp]
  00026	05 ff 0f 00 00	 add	 eax, 4095		; 00000fffH
  0002b	25 00 f0 ff ff	 and	 eax, -4096		; fffff000H
  00030	89 45 f4	 mov	 DWORD PTR _Size$[ebp], eax

; 263  : 
; 264  :     Segment = (PBL_POOL_SEGMENT) (ULONG_PTR) BlMmAllocatePhysicalRegion(Size, BL_MM_PHYSICAL_REGION_BOOT_LOADER);

  00033	6a 03		 push	 3
  00035	5a		 pop	 edx
  00036	8b 4d f4	 mov	 ecx, DWORD PTR _Size$[ebp]
  00039	e8 00 00 00 00	 call	 ?BlMmAllocatePhysicalRegion@@YI_KKK@Z ; BlMmAllocatePhysicalRegion
  0003e	89 45 fc	 mov	 DWORD PTR _Segment$[ebp], eax

; 265  : 
; 266  :     BlRtlZeroMemory(Segment, Size);

  00041	8b 55 f4	 mov	 edx, DWORD PTR _Size$[ebp]
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _Segment$[ebp]
  00047	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 267  : 
; 268  :     Segment->Magic1 = BL_POOL_SEGMENT_MAGIC1;

  0004c	8b 45 fc	 mov	 eax, DWORD PTR _Segment$[ebp]
  0004f	c7 00 fc fd fe
	ff		 mov	 DWORD PTR [eax], -66052	; fffefdfcH

; 269  :     Segment->Magic2 = BL_POOL_SEGMENT_MAGIC2;

  00055	8b 45 fc	 mov	 eax, DWORD PTR _Segment$[ebp]
  00058	c7 40 20 f8 f9
	fa fb		 mov	 DWORD PTR [eax+32], -67438088 ; fbfaf9f8H

; 270  :     Segment->Start = (ULONG_PTR) Segment;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _Segment$[ebp]
  00062	8b 4d fc	 mov	 ecx, DWORD PTR _Segment$[ebp]
  00065	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 271  :     Segment->Size = Size;

  00068	8b 45 fc	 mov	 eax, DWORD PTR _Segment$[ebp]
  0006b	8b 4d f4	 mov	 ecx, DWORD PTR _Size$[ebp]
  0006e	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 272  :     Segment->Limit = Segment->Start + Segment->Size;

  00071	8b 45 fc	 mov	 eax, DWORD PTR _Segment$[ebp]
  00074	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00077	8b 4d fc	 mov	 ecx, DWORD PTR _Segment$[ebp]
  0007a	03 41 0c	 add	 eax, DWORD PTR [ecx+12]
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR _Segment$[ebp]
  00080	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 273  :     BlRtlInitializeListHead(&Segment->BlockList);

  00083	8b 4d fc	 mov	 ecx, DWORD PTR _Segment$[ebp]
  00086	83 c1 18	 add	 ecx, 24			; 00000018H
  00089	e8 00 00 00 00	 call	 ?BlRtlInitializeListHead@@YIXPAU_LIST_ENTRY@@@Z ; BlRtlInitializeListHead

; 274  : 
; 275  :     Block = (PBL_POOL_BLOCK) (BL_POOL_ROUND_UP(((ULONG_PTR) (Segment + 1))));

  0008e	8b 45 fc	 mov	 eax, DWORD PTR _Segment$[ebp]
  00091	05 23 01 00 00	 add	 eax, 291		; 00000123H
  00096	25 00 ff ff ff	 and	 eax, -256		; ffffff00H
  0009b	89 45 f8	 mov	 DWORD PTR _Block$[ebp], eax

; 276  :     Block->Magic1 = BL_POOL_BLOCK_MAGIC1;

  0009e	8b 45 f8	 mov	 eax, DWORD PTR _Block$[ebp]
  000a1	c7 00 04 03 02
	01		 mov	 DWORD PTR [eax], 16909060 ; 01020304H

; 277  :     Block->Magic2 = BL_POOL_BLOCK_MAGIC2;

  000a7	8b 45 f8	 mov	 eax, DWORD PTR _Block$[ebp]
  000aa	c7 40 1c 08 07
	06 05		 mov	 DWORD PTR [eax+28], 84281096 ; 05060708H

; 278  :     Block->Size = Segment->Limit - (ULONG_PTR) Block;

  000b1	8b 45 fc	 mov	 eax, DWORD PTR _Segment$[ebp]
  000b4	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  000b7	2b 45 f8	 sub	 eax, DWORD PTR _Block$[ebp]
  000ba	8b 4d f8	 mov	 ecx, DWORD PTR _Block$[ebp]
  000bd	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 279  :     Block->State = BL_POOL_FREE;

  000c0	8b 45 f8	 mov	 eax, DWORD PTR _Block$[ebp]
  000c3	c7 40 10 01 00
	00 00		 mov	 DWORD PTR [eax+16], 1

; 280  :     Block->Allocator = NULL;

  000ca	8b 45 f8	 mov	 eax, DWORD PTR _Block$[ebp]
  000cd	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 281  : 
; 282  :     BlRtlInsertTailList(&Segment->BlockList, &Block->Entry);

  000d1	8b 55 f8	 mov	 edx, DWORD PTR _Block$[ebp]
  000d4	83 c2 04	 add	 edx, 4
  000d7	8b 4d fc	 mov	 ecx, DWORD PTR _Segment$[ebp]
  000da	83 c1 18	 add	 ecx, 24			; 00000018H
  000dd	e8 00 00 00 00	 call	 ?BlRtlInsertTailList@@YIXPAU_LIST_ENTRY@@0@Z ; BlRtlInsertTailList

; 283  : 
; 284  :     BlRtlInsertTailList(&BlPoolSegmentList, &Segment->Entry);

  000e2	8b 55 fc	 mov	 edx, DWORD PTR _Segment$[ebp]
  000e5	83 c2 04	 add	 edx, 4
  000e8	b9 00 00 00 00	 mov	 ecx, OFFSET ?BlPoolSegmentList@@3U_LIST_ENTRY@@A ; BlPoolSegmentList
  000ed	e8 00 00 00 00	 call	 ?BlRtlInsertTailList@@YIXPAU_LIST_ENTRY@@0@Z ; BlRtlInsertTailList

; 285  : 
; 286  :     BlPoolVerify();

  000f2	e8 00 00 00 00	 call	 ?BlPoolVerify@@YIXXZ	; BlPoolVerify

; 287  : 
; 288  :     return;
; 289  : }

  000f7	c9		 leave
  000f8	c3		 ret	 0
?BlPoolGrow@@YIXK@Z ENDP				; BlPoolGrow
_TEXT	ENDS
PUBLIC	__$ReturnAddr$
PUBLIC	?BlPoolAllocateBlock@@YIPAXK@Z			; BlPoolAllocateBlock
EXTRN	?BlRtlInsertHeadList@@YIXPAU_LIST_ENTRY@@0@Z:PROC ; BlRtlInsertHeadList
; Function compile flags: /Odsp
;	COMDAT ?BlPoolAllocateBlock@@YIPAXK@Z
_TEXT	SEGMENT
_Size$ = -36						; size = 4
_BlockEntry$ = -32					; size = 4
_Block$ = -28						; size = 4
_BlockHead$ = -24					; size = 4
_SegmentHead$ = -20					; size = 4
_GrowthSize$ = -16					; size = 4
_NewBlock$ = -12					; size = 4
_SegmentEntry$ = -8					; size = 4
_Segment$ = -4						; size = 4
__$ReturnAddr$ = 4					; size = 4
?BlPoolAllocateBlock@@YIPAXK@Z PROC			; BlPoolAllocateBlock, COMDAT
; _Size$ = ecx

; 312  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d dc	 mov	 DWORD PTR _Size$[ebp], ecx

; 313  :     PBL_POOL_BLOCK Block;
; 314  :     PLIST_ENTRY BlockEntry;
; 315  :     PLIST_ENTRY BlockHead;
; 316  :     UINT32 GrowthSize;
; 317  :     PBL_POOL_BLOCK NewBlock;
; 318  :     PBL_POOL_SEGMENT Segment;
; 319  :     PLIST_ENTRY SegmentEntry;
; 320  :     PLIST_ENTRY SegmentHead;
; 321  : 
; 322  :     BlPoolVerify();

  00009	e8 00 00 00 00	 call	 ?BlPoolVerify@@YIXXZ	; BlPoolVerify

; 323  : 
; 324  :     BLASSERT(Size > 0);

  0000e	83 7d dc 00	 cmp	 DWORD PTR _Size$[ebp], 0
  00012	77 0f		 ja	 SHORT $LN11@BlPoolAllo
  00014	ba 44 01 00 00	 mov	 edx, 324		; 00000144H
  00019	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  0001e	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN11@BlPoolAllo:

; 325  : 
; 326  :     Size += sizeof(BL_POOL_BLOCK);

  00023	8b 45 dc	 mov	 eax, DWORD PTR _Size$[ebp]
  00026	83 c0 20	 add	 eax, 32			; 00000020H
  00029	89 45 dc	 mov	 DWORD PTR _Size$[ebp], eax

; 327  :     Size = BL_POOL_ROUND_UP(Size);

  0002c	8b 45 dc	 mov	 eax, DWORD PTR _Size$[ebp]
  0002f	05 ff 00 00 00	 add	 eax, 255		; 000000ffH
  00034	25 00 ff ff ff	 and	 eax, -256		; ffffff00H
  00039	89 45 dc	 mov	 DWORD PTR _Size$[ebp], eax

; 328  : 
; 329  :     SegmentHead = &BlPoolSegmentList;

  0003c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _SegmentHead$[ebp], OFFSET ?BlPoolSegmentList@@3U_LIST_ENTRY@@A ; BlPoolSegmentList
$LN10@BlPoolAllo:

; 330  : 
; 331  :     for (;;) {
; 332  : 
; 333  :         for (SegmentEntry = SegmentHead->Flink; SegmentEntry != SegmentHead; SegmentEntry = SegmentEntry->Flink) {

  00043	8b 45 ec	 mov	 eax, DWORD PTR _SegmentHead$[ebp]
  00046	8b 00		 mov	 eax, DWORD PTR [eax]
  00048	89 45 f8	 mov	 DWORD PTR _SegmentEntry$[ebp], eax
  0004b	eb 08		 jmp	 SHORT $LN8@BlPoolAllo
$LN7@BlPoolAllo:
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _SegmentEntry$[ebp]
  00050	8b 00		 mov	 eax, DWORD PTR [eax]
  00052	89 45 f8	 mov	 DWORD PTR _SegmentEntry$[ebp], eax
$LN8@BlPoolAllo:
  00055	8b 45 f8	 mov	 eax, DWORD PTR _SegmentEntry$[ebp]
  00058	3b 45 ec	 cmp	 eax, DWORD PTR _SegmentHead$[ebp]
  0005b	0f 84 ff 00 00
	00		 je	 $LN6@BlPoolAllo

; 334  : 
; 335  :             Segment = CONTAINING_RECORD(SegmentEntry,
; 336  :                                         BL_POOL_SEGMENT,
; 337  :                                         Entry);

  00061	8b 45 f8	 mov	 eax, DWORD PTR _SegmentEntry$[ebp]
  00064	83 e8 04	 sub	 eax, 4
  00067	89 45 fc	 mov	 DWORD PTR _Segment$[ebp], eax

; 338  : 
; 339  :             BlockHead = &Segment->BlockList;

  0006a	8b 45 fc	 mov	 eax, DWORD PTR _Segment$[ebp]
  0006d	83 c0 18	 add	 eax, 24			; 00000018H
  00070	89 45 e8	 mov	 DWORD PTR _BlockHead$[ebp], eax

; 340  : 
; 341  :             for (BlockEntry = BlockHead->Flink; BlockEntry != BlockHead; BlockEntry = BlockEntry->Flink) {

  00073	8b 45 e8	 mov	 eax, DWORD PTR _BlockHead$[ebp]
  00076	8b 00		 mov	 eax, DWORD PTR [eax]
  00078	89 45 e0	 mov	 DWORD PTR _BlockEntry$[ebp], eax
  0007b	eb 08		 jmp	 SHORT $LN5@BlPoolAllo
$LN4@BlPoolAllo:
  0007d	8b 45 e0	 mov	 eax, DWORD PTR _BlockEntry$[ebp]
  00080	8b 00		 mov	 eax, DWORD PTR [eax]
  00082	89 45 e0	 mov	 DWORD PTR _BlockEntry$[ebp], eax
$LN5@BlPoolAllo:
  00085	8b 45 e0	 mov	 eax, DWORD PTR _BlockEntry$[ebp]
  00088	3b 45 e8	 cmp	 eax, DWORD PTR _BlockHead$[ebp]
  0008b	0f 84 ca 00 00
	00		 je	 $LN3@BlPoolAllo

; 342  : 
; 343  :                 Block = CONTAINING_RECORD(BlockEntry,
; 344  :                                           BL_POOL_BLOCK,
; 345  :                                           Entry);

  00091	8b 45 e0	 mov	 eax, DWORD PTR _BlockEntry$[ebp]
  00094	83 e8 04	 sub	 eax, 4
  00097	89 45 e4	 mov	 DWORD PTR _Block$[ebp], eax

; 346  : 
; 347  :                 if ((Block->State == BL_POOL_FREE) && (Block->Size >= Size)) {

  0009a	8b 45 e4	 mov	 eax, DWORD PTR _Block$[ebp]
  0009d	83 78 10 01	 cmp	 DWORD PTR [eax+16], 1
  000a1	0f 85 af 00 00
	00		 jne	 $LN2@BlPoolAllo
  000a7	8b 45 e4	 mov	 eax, DWORD PTR _Block$[ebp]
  000aa	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000ad	3b 45 dc	 cmp	 eax, DWORD PTR _Size$[ebp]
  000b0	0f 82 a0 00 00
	00		 jb	 $LN2@BlPoolAllo

; 348  : 
; 349  :                     if (Block->Size > Size) {

  000b6	8b 45 e4	 mov	 eax, DWORD PTR _Block$[ebp]
  000b9	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000bc	3b 45 dc	 cmp	 eax, DWORD PTR _Size$[ebp]
  000bf	76 61		 jbe	 SHORT $LN1@BlPoolAllo

; 350  : 
; 351  :                         NewBlock = (PBL_POOL_BLOCK) ((ULONG_PTR) Block + Size);

  000c1	8b 45 e4	 mov	 eax, DWORD PTR _Block$[ebp]
  000c4	03 45 dc	 add	 eax, DWORD PTR _Size$[ebp]
  000c7	89 45 f4	 mov	 DWORD PTR _NewBlock$[ebp], eax

; 352  : 
; 353  :                         BlRtlZeroMemory(NewBlock, sizeof(BL_POOL_BLOCK));

  000ca	6a 20		 push	 32			; 00000020H
  000cc	5a		 pop	 edx
  000cd	8b 4d f4	 mov	 ecx, DWORD PTR _NewBlock$[ebp]
  000d0	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 354  : 
; 355  :                         NewBlock->Magic1 = BL_POOL_BLOCK_MAGIC1;

  000d5	8b 45 f4	 mov	 eax, DWORD PTR _NewBlock$[ebp]
  000d8	c7 00 04 03 02
	01		 mov	 DWORD PTR [eax], 16909060 ; 01020304H

; 356  :                         NewBlock->Magic2 = BL_POOL_BLOCK_MAGIC2;

  000de	8b 45 f4	 mov	 eax, DWORD PTR _NewBlock$[ebp]
  000e1	c7 40 1c 08 07
	06 05		 mov	 DWORD PTR [eax+28], 84281096 ; 05060708H

; 357  :                         NewBlock->Size = Block->Size - Size;

  000e8	8b 45 e4	 mov	 eax, DWORD PTR _Block$[ebp]
  000eb	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000ee	2b 45 dc	 sub	 eax, DWORD PTR _Size$[ebp]
  000f1	8b 4d f4	 mov	 ecx, DWORD PTR _NewBlock$[ebp]
  000f4	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 358  :                         NewBlock->State = BL_POOL_FREE;

  000f7	8b 45 f4	 mov	 eax, DWORD PTR _NewBlock$[ebp]
  000fa	c7 40 10 01 00
	00 00		 mov	 DWORD PTR [eax+16], 1

; 359  :                         NewBlock->Allocator = NULL;

  00101	8b 45 f4	 mov	 eax, DWORD PTR _NewBlock$[ebp]
  00104	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 360  : 
; 361  :                         BlRtlInsertHeadList(&Block->Entry, &NewBlock->Entry);

  00108	8b 55 f4	 mov	 edx, DWORD PTR _NewBlock$[ebp]
  0010b	83 c2 04	 add	 edx, 4
  0010e	8b 4d e4	 mov	 ecx, DWORD PTR _Block$[ebp]
  00111	83 c1 04	 add	 ecx, 4
  00114	e8 00 00 00 00	 call	 ?BlRtlInsertHeadList@@YIXPAU_LIST_ENTRY@@0@Z ; BlRtlInsertHeadList

; 362  : 
; 363  :                         Block->Size = Size;

  00119	8b 45 e4	 mov	 eax, DWORD PTR _Block$[ebp]
  0011c	8b 4d dc	 mov	 ecx, DWORD PTR _Size$[ebp]
  0011f	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
$LN1@BlPoolAllo:

; 364  :                     }
; 365  : 
; 366  :                     Block->State = BL_POOL_BUSY;

  00122	8b 45 e4	 mov	 eax, DWORD PTR _Block$[ebp]
  00125	c7 40 10 02 00
	00 00		 mov	 DWORD PTR [eax+16], 2

; 367  :                     Block->Allocator = _ReturnAddress();

  0012c	8b 45 04	 mov	 eax, DWORD PTR __$ReturnAddr$[ebp]
  0012f	8b 4d e4	 mov	 ecx, DWORD PTR _Block$[ebp]
  00132	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 368  : 
; 369  :                     BlRtlZeroMemory(Block + 1, Block->Size - sizeof(BL_POOL_BLOCK));

  00135	8b 45 e4	 mov	 eax, DWORD PTR _Block$[ebp]
  00138	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0013b	83 ea 20	 sub	 edx, 32			; 00000020H
  0013e	8b 4d e4	 mov	 ecx, DWORD PTR _Block$[ebp]
  00141	83 c1 20	 add	 ecx, 32			; 00000020H
  00144	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 370  : 
; 371  :                     BlPoolVerify();

  00149	e8 00 00 00 00	 call	 ?BlPoolVerify@@YIXXZ	; BlPoolVerify

; 372  : 
; 373  :                     return (Block + 1);

  0014e	8b 45 e4	 mov	 eax, DWORD PTR _Block$[ebp]
  00151	83 c0 20	 add	 eax, 32			; 00000020H
  00154	eb 27		 jmp	 SHORT $LN12@BlPoolAllo
$LN2@BlPoolAllo:

; 374  :                 }
; 375  :             }

  00156	e9 22 ff ff ff	 jmp	 $LN4@BlPoolAllo
$LN3@BlPoolAllo:

; 376  :         }

  0015b	e9 ed fe ff ff	 jmp	 $LN7@BlPoolAllo
$LN6@BlPoolAllo:

; 377  : 
; 378  :         GrowthSize = BL_POOL_SEGMENT_ROUND_UP(Size);

  00160	8b 45 dc	 mov	 eax, DWORD PTR _Size$[ebp]
  00163	05 ff 7f 00 00	 add	 eax, 32767		; 00007fffH
  00168	25 00 80 ff ff	 and	 eax, -32768		; ffff8000H
  0016d	89 45 f0	 mov	 DWORD PTR _GrowthSize$[ebp], eax

; 379  : 
; 380  :         BlPoolGrow(GrowthSize);

  00170	8b 4d f0	 mov	 ecx, DWORD PTR _GrowthSize$[ebp]
  00173	e8 00 00 00 00	 call	 ?BlPoolGrow@@YIXK@Z	; BlPoolGrow

; 381  :     }

  00178	e9 c6 fe ff ff	 jmp	 $LN10@BlPoolAllo
$LN12@BlPoolAllo:

; 382  : }

  0017d	c9		 leave
  0017e	c3		 ret	 0
?BlPoolAllocateBlock@@YIPAXK@Z ENDP			; BlPoolAllocateBlock
_TEXT	ENDS
PUBLIC	?BlPoolFreeBlock@@YIXPAX@Z			; BlPoolFreeBlock
; Function compile flags: /Odsp
;	COMDAT ?BlPoolFreeBlock@@YIXPAX@Z
_TEXT	SEGMENT
_P$ = -8						; size = 4
_Block$ = -4						; size = 4
?BlPoolFreeBlock@@YIXPAX@Z PROC				; BlPoolFreeBlock, COMDAT
; _P$ = ecx

; 401  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _P$[ebp], ecx

; 402  :     PBL_POOL_BLOCK Block;
; 403  : 
; 404  :     BlPoolVerify();

  00008	e8 00 00 00 00	 call	 ?BlPoolVerify@@YIXXZ	; BlPoolVerify

; 405  : 
; 406  :     BLASSERT(((ULONG_PTR) P % __alignof(BL_POOL_BLOCK)) == 0);

  0000d	8b 45 f8	 mov	 eax, DWORD PTR _P$[ebp]
  00010	33 d2		 xor	 edx, edx
  00012	6a 04		 push	 4
  00014	59		 pop	 ecx
  00015	f7 f1		 div	 ecx
  00017	85 d2		 test	 edx, edx
  00019	74 0f		 je	 SHORT $LN3@BlPoolFree
  0001b	ba 96 01 00 00	 mov	 edx, 406		; 00000196H
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  00025	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN3@BlPoolFree:

; 407  : 
; 408  :     Block = ((PBL_POOL_BLOCK) P) - 1;

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _P$[ebp]
  0002d	83 e8 20	 sub	 eax, 32			; 00000020H
  00030	89 45 fc	 mov	 DWORD PTR _Block$[ebp], eax

; 409  : 
; 410  :     BLASSERT(((ULONG_PTR) Block % BL_POOL_GRANULARITY) == 0);

  00033	8b 45 fc	 mov	 eax, DWORD PTR _Block$[ebp]
  00036	33 d2		 xor	 edx, edx
  00038	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0003d	f7 f1		 div	 ecx
  0003f	85 d2		 test	 edx, edx
  00041	74 0f		 je	 SHORT $LN2@BlPoolFree
  00043	ba 9a 01 00 00	 mov	 edx, 410		; 0000019aH
  00048	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  0004d	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN2@BlPoolFree:

; 411  : 
; 412  :     BLASSERT(Block->State == BL_POOL_BUSY);

  00052	8b 45 fc	 mov	 eax, DWORD PTR _Block$[ebp]
  00055	83 78 10 02	 cmp	 DWORD PTR [eax+16], 2
  00059	74 0f		 je	 SHORT $LN1@BlPoolFree
  0005b	ba 9c 01 00 00	 mov	 edx, 412		; 0000019cH
  00060	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  00065	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN1@BlPoolFree:

; 413  : 
; 414  :     Block->State = BL_POOL_FREE;

  0006a	8b 45 fc	 mov	 eax, DWORD PTR _Block$[ebp]
  0006d	c7 40 10 01 00
	00 00		 mov	 DWORD PTR [eax+16], 1

; 415  :     Block->Allocator = NULL;

  00074	8b 45 fc	 mov	 eax, DWORD PTR _Block$[ebp]
  00077	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 416  : 
; 417  :     //
; 418  :     // AIFIX: Check for adjacent free blocks and coalesce.
; 419  :     //
; 420  : 
; 421  :     BlPoolVerify();

  0007b	e8 00 00 00 00	 call	 ?BlPoolVerify@@YIXXZ	; BlPoolVerify

; 422  : 
; 423  :     return;
; 424  : }

  00080	c9		 leave
  00081	c3		 ret	 0
?BlPoolFreeBlock@@YIXPAX@Z ENDP				; BlPoolFreeBlock
_TEXT	ENDS
END
