; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	C:\Users\cc\source\repos\Singularity-OS\base\Boot\SingLdrPc\blpci.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?BlPciInstallationCheck@@3U_PCI_INSTALLATION_CHECK@@A ; BlPciInstallationCheck
PUBLIC	?BlPciOhci1394BaseAddress@@3KA			; BlPciOhci1394BaseAddress
_BSS	SEGMENT
?BlPciInstallationCheck@@3U_PCI_INSTALLATION_CHECK@@A DB 018H DUP (?) ; BlPciInstallationCheck
?BlPciOhci1394BaseAddress@@3KA DD 01H DUP (?)		; BlPciOhci1394BaseAddress
_BSS	ENDS
PUBLIC	?BlPciCheckBios@@YIEPAU_PCI_INSTALLATION_CHECK@@@Z ; BlPciCheckBios
EXTRN	?BlRtlCallLegacyInterruptService@@YIXEPAU_BL_LEGACY_CALL_CONTEXT@@0@Z:PROC ; BlRtlCallLegacyInterruptService
EXTRN	?BlRtlZeroMemory@@YIXPAXK@Z:PROC		; BlRtlZeroMemory
; Function compile flags: /Odsp
; File c:\users\cc\source\repos\singularity-os\base\boot\singldrpc\blpci.cpp
;	COMDAT ?BlPciCheckBios@@YIEPAU_PCI_INSTALLATION_CHECK@@@Z
_TEXT	SEGMENT
_PciInstallationCheck$ = -40				; size = 4
_Context$ = -36						; size = 36
?BlPciCheckBios@@YIEPAU_PCI_INSTALLATION_CHECK@@@Z PROC	; BlPciCheckBios, COMDAT
; _PciInstallationCheck$ = ecx

; 165  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d d8	 mov	 DWORD PTR _PciInstallationCheck$[ebp], ecx

; 166  :     BL_LEGACY_CALL_CONTEXT Context;
; 167  : 
; 168  :     //
; 169  :     // Call PCI detection service.
; 170  :     //
; 171  : 
; 172  :     BlRtlZeroMemory(&Context, sizeof(Context));

  00009	6a 24		 push	 36			; 00000024H
  0000b	5a		 pop	 edx
  0000c	8d 4d dc	 lea	 ecx, DWORD PTR _Context$[ebp]
  0000f	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 173  : 
; 174  :     Context.eax = 0xB101;

  00014	c7 45 dc 01 b1
	00 00		 mov	 DWORD PTR _Context$[ebp], 45313 ; 0000b101H

; 175  : 
; 176  :     BlRtlCallLegacyInterruptService(0x1A,
; 177  :                                     &Context,
; 178  :                                     &Context);

  0001b	8d 45 dc	 lea	 eax, DWORD PTR _Context$[ebp]
  0001e	50		 push	 eax
  0001f	8d 55 dc	 lea	 edx, DWORD PTR _Context$[ebp]
  00022	b1 1a		 mov	 cl, 26			; 0000001aH
  00024	e8 00 00 00 00	 call	 ?BlRtlCallLegacyInterruptService@@YIXEPAU_BL_LEGACY_CALL_CONTEXT@@0@Z ; BlRtlCallLegacyInterruptService

; 179  : 
; 180  :     //
; 181  :     // If CF is set, AH is not zero, or if the signature is not ' ICP', then
; 182  :     // there is no PCI BIOS.
; 183  :     //
; 184  : 
; 185  :     if (((Context.eflags & RFLAGS_CF) != 0) ||
; 186  :         (((Context.eax >> 8) & 0xFF) != 0) ||
; 187  :         (Context.edx != 0x20494350)) {

  00029	8b 45 fc	 mov	 eax, DWORD PTR _Context$[ebp+32]
  0002c	83 e0 01	 and	 eax, 1
  0002f	75 16		 jne	 SHORT $LN1@BlPciCheck
  00031	8b 45 dc	 mov	 eax, DWORD PTR _Context$[ebp]
  00034	c1 e8 08	 shr	 eax, 8
  00037	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0003c	75 09		 jne	 SHORT $LN1@BlPciCheck
  0003e	81 7d e8 50 43
	49 20		 cmp	 DWORD PTR _Context$[ebp+12], 541672272 ; 20494350H
  00045	74 04		 je	 SHORT $LN2@BlPciCheck
$LN1@BlPciCheck:

; 188  : 
; 189  :         return FALSE;

  00047	32 c0		 xor	 al, al
  00049	eb 69		 jmp	 SHORT $LN3@BlPciCheck
$LN2@BlPciCheck:

; 190  :     }
; 191  : 
; 192  :     //
; 193  :     // Populate the provided installation check structure and return success.
; 194  :     //
; 195  : 
; 196  :     PciInstallationCheck->Eax = Context.eax;

  0004b	8b 45 d8	 mov	 eax, DWORD PTR _PciInstallationCheck$[ebp]
  0004e	8b 4d dc	 mov	 ecx, DWORD PTR _Context$[ebp]
  00051	89 08		 mov	 DWORD PTR [eax], ecx

; 197  :     PciInstallationCheck->Ebx = Context.ebx;

  00053	8b 45 d8	 mov	 eax, DWORD PTR _PciInstallationCheck$[ebp]
  00056	8b 4d e0	 mov	 ecx, DWORD PTR _Context$[ebp+4]
  00059	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 198  :     PciInstallationCheck->Ecx = Context.ecx;

  0005c	8b 45 d8	 mov	 eax, DWORD PTR _PciInstallationCheck$[ebp]
  0005f	8b 4d e4	 mov	 ecx, DWORD PTR _Context$[ebp+8]
  00062	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 199  :     PciInstallationCheck->Edx = Context.edx;

  00065	8b 45 d8	 mov	 eax, DWORD PTR _PciInstallationCheck$[ebp]
  00068	8b 4d e8	 mov	 ecx, DWORD PTR _Context$[ebp+12]
  0006b	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 200  :     PciInstallationCheck->HardwareCharacteristics = (UINT8) (Context.eax & 0xFF);

  0006e	8b 45 dc	 mov	 eax, DWORD PTR _Context$[ebp]
  00071	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00076	8b 4d d8	 mov	 ecx, DWORD PTR _PciInstallationCheck$[ebp]
  00079	88 41 10	 mov	 BYTE PTR [ecx+16], al

; 201  :     PciInstallationCheck->LastBusNumber = (UINT8) (Context.ecx & 0xFF);

  0007c	8b 45 e4	 mov	 eax, DWORD PTR _Context$[ebp+8]
  0007f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00084	8b 4d d8	 mov	 ecx, DWORD PTR _PciInstallationCheck$[ebp]
  00087	88 41 13	 mov	 BYTE PTR [ecx+19], al

; 202  :     PciInstallationCheck->MajorVersion = (UINT8) ((Context.ebx >> 8) & 0xFF);

  0008a	8b 45 e0	 mov	 eax, DWORD PTR _Context$[ebp+4]
  0008d	c1 e8 08	 shr	 eax, 8
  00090	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00095	8b 4d d8	 mov	 ecx, DWORD PTR _PciInstallationCheck$[ebp]
  00098	88 41 11	 mov	 BYTE PTR [ecx+17], al

; 203  :     PciInstallationCheck->MinorVersion = (UINT8) (Context.ebx & 0xFF);

  0009b	8b 45 e0	 mov	 eax, DWORD PTR _Context$[ebp+4]
  0009e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000a3	8b 4d d8	 mov	 ecx, DWORD PTR _PciInstallationCheck$[ebp]
  000a6	88 41 12	 mov	 BYTE PTR [ecx+18], al

; 204  :     PciInstallationCheck->ProtectedModeEntryPoint = Context.edi;

  000a9	8b 45 d8	 mov	 eax, DWORD PTR _PciInstallationCheck$[ebp]
  000ac	8b 4d f0	 mov	 ecx, DWORD PTR _Context$[ebp+20]
  000af	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 205  : 
; 206  :     return TRUE;

  000b2	b0 01		 mov	 al, 1
$LN3@BlPciCheck:

; 207  : }

  000b4	c9		 leave
  000b5	c3		 ret	 0
?BlPciCheckBios@@YIEPAU_PCI_INSTALLATION_CHECK@@@Z ENDP	; BlPciCheckBios
_TEXT	ENDS
PUBLIC	??_C@_09GGGJHACA@blpci?4cpp?$AA@		; `string'
PUBLIC	?BlPciReadConfigurationRegister@@YIKEEEE@Z	; BlPciReadConfigurationRegister
EXTRN	?BlRtlReadPort32@@YIKG@Z:PROC			; BlRtlReadPort32
EXTRN	?BlRtlWritePort32@@YIXGK@Z:PROC			; BlRtlWritePort32
EXTRN	?BlRtlAssertFailed@@YIXPBDK@Z:PROC		; BlRtlAssertFailed
;	COMDAT ??_C@_09GGGJHACA@blpci?4cpp?$AA@
CONST	SEGMENT
??_C@_09GGGJHACA@blpci?4cpp?$AA@ DB 'blpci.cpp', 00H	; `string'
; Function compile flags: /Odsp
CONST	ENDS
;	COMDAT ?BlPciReadConfigurationRegister@@YIKEEEE@Z
_TEXT	SEGMENT
_DeviceNumber$ = -16					; size = 1
_BusNumber$ = -12					; size = 1
_ConfigAddress$ = -8					; size = 4
_Value$ = -4						; size = 4
_FunctionNumber$ = 8					; size = 1
_RegisterNumber$ = 12					; size = 1
?BlPciReadConfigurationRegister@@YIKEEEE@Z PROC		; BlPciReadConfigurationRegister, COMDAT
; _BusNumber$ = cl
; _DeviceNumber$ = dl

; 239  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	88 55 f0	 mov	 BYTE PTR _DeviceNumber$[ebp], dl
  00009	88 4d f4	 mov	 BYTE PTR _BusNumber$[ebp], cl

; 240  :     PCI_CONFIG_ADDRESS ConfigAddress;
; 241  :     UINT32 Value;
; 242  : 
; 243  :     BLASSERT(DeviceNumber < PCI_MAX_DEVICES);

  0000c	0f b6 45 f0	 movzx	 eax, BYTE PTR _DeviceNumber$[ebp]
  00010	83 f8 20	 cmp	 eax, 32			; 00000020H
  00013	7c 0f		 jl	 SHORT $LN3@BlPciReadC
  00015	ba f3 00 00 00	 mov	 edx, 243		; 000000f3H
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09GGGJHACA@blpci?4cpp?$AA@
  0001f	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN3@BlPciReadC:

; 244  :     BLASSERT(FunctionNumber < PCI_MAX_FUNCTIONS);

  00024	0f b6 45 08	 movzx	 eax, BYTE PTR _FunctionNumber$[ebp]
  00028	83 f8 08	 cmp	 eax, 8
  0002b	7c 0f		 jl	 SHORT $LN2@BlPciReadC
  0002d	ba f4 00 00 00	 mov	 edx, 244		; 000000f4H
  00032	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09GGGJHACA@blpci?4cpp?$AA@
  00037	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN2@BlPciReadC:

; 245  :     BLASSERT((RegisterNumber % sizeof(UINT32)) == 0);

  0003c	0f b6 45 0c	 movzx	 eax, BYTE PTR _RegisterNumber$[ebp]
  00040	33 d2		 xor	 edx, edx
  00042	6a 04		 push	 4
  00044	59		 pop	 ecx
  00045	f7 f1		 div	 ecx
  00047	85 d2		 test	 edx, edx
  00049	74 0f		 je	 SHORT $LN1@BlPciReadC
  0004b	ba f5 00 00 00	 mov	 edx, 245		; 000000f5H
  00050	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09GGGJHACA@blpci?4cpp?$AA@
  00055	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN1@BlPciReadC:

; 246  : 
; 247  :     BlRtlZeroMemory(&ConfigAddress, sizeof(ConfigAddress));

  0005a	6a 04		 push	 4
  0005c	5a		 pop	 edx
  0005d	8d 4d f8	 lea	 ecx, DWORD PTR _ConfigAddress$[ebp]
  00060	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 248  : 
; 249  :     ConfigAddress.u1.s1.BusNumber = BusNumber;

  00065	0f b6 45 f4	 movzx	 eax, BYTE PTR _BusNumber$[ebp]
  00069	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0006e	c1 e0 10	 shl	 eax, 16			; 00000010H
  00071	8b 4d f8	 mov	 ecx, DWORD PTR _ConfigAddress$[ebp]
  00074	81 e1 ff ff 00
	ff		 and	 ecx, -16711681		; ff00ffffH
  0007a	0b c8		 or	 ecx, eax
  0007c	89 4d f8	 mov	 DWORD PTR _ConfigAddress$[ebp], ecx

; 250  :     ConfigAddress.u1.s1.DeviceNumber = DeviceNumber;

  0007f	0f b6 45 f0	 movzx	 eax, BYTE PTR _DeviceNumber$[ebp]
  00083	83 e0 1f	 and	 eax, 31			; 0000001fH
  00086	c1 e0 0b	 shl	 eax, 11			; 0000000bH
  00089	8b 4d f8	 mov	 ecx, DWORD PTR _ConfigAddress$[ebp]
  0008c	81 e1 ff 07 ff
	ff		 and	 ecx, -63489		; ffff07ffH
  00092	0b c8		 or	 ecx, eax
  00094	89 4d f8	 mov	 DWORD PTR _ConfigAddress$[ebp], ecx

; 251  :     ConfigAddress.u1.s1.FunctionNumber = FunctionNumber;

  00097	0f b6 45 08	 movzx	 eax, BYTE PTR _FunctionNumber$[ebp]
  0009b	83 e0 07	 and	 eax, 7
  0009e	c1 e0 08	 shl	 eax, 8
  000a1	8b 4d f8	 mov	 ecx, DWORD PTR _ConfigAddress$[ebp]
  000a4	81 e1 ff f8 ff
	ff		 and	 ecx, -1793		; fffff8ffH
  000aa	0b c8		 or	 ecx, eax
  000ac	89 4d f8	 mov	 DWORD PTR _ConfigAddress$[ebp], ecx

; 252  :     ConfigAddress.u1.s1.RegisterNumber = RegisterNumber >> 2;

  000af	0f b6 45 0c	 movzx	 eax, BYTE PTR _RegisterNumber$[ebp]
  000b3	c1 f8 02	 sar	 eax, 2
  000b6	83 e0 3f	 and	 eax, 63			; 0000003fH
  000b9	c1 e0 02	 shl	 eax, 2
  000bc	8b 4d f8	 mov	 ecx, DWORD PTR _ConfigAddress$[ebp]
  000bf	81 e1 03 ff ff
	ff		 and	 ecx, -253		; ffffff03H
  000c5	0b c8		 or	 ecx, eax
  000c7	89 4d f8	 mov	 DWORD PTR _ConfigAddress$[ebp], ecx

; 253  :     ConfigAddress.u1.s1.Enable = 1;

  000ca	8b 45 f8	 mov	 eax, DWORD PTR _ConfigAddress$[ebp]
  000cd	0d 00 00 00 80	 or	 eax, -2147483648	; 80000000H
  000d2	89 45 f8	 mov	 DWORD PTR _ConfigAddress$[ebp], eax

; 254  : 
; 255  :     BlRtlWritePort32(PCI_ADDRESS_PORT, ConfigAddress.u1.Value);

  000d5	8b 55 f8	 mov	 edx, DWORD PTR _ConfigAddress$[ebp]
  000d8	66 b9 f8 0c	 mov	 cx, 3320		; 00000cf8H
  000dc	e8 00 00 00 00	 call	 ?BlRtlWritePort32@@YIXGK@Z ; BlRtlWritePort32

; 256  : 
; 257  :     Value = BlRtlReadPort32(PCI_DATA_PORT);

  000e1	66 b9 fc 0c	 mov	 cx, 3324		; 00000cfcH
  000e5	e8 00 00 00 00	 call	 ?BlRtlReadPort32@@YIKG@Z ; BlRtlReadPort32
  000ea	89 45 fc	 mov	 DWORD PTR _Value$[ebp], eax

; 258  : 
; 259  :     return Value;

  000ed	8b 45 fc	 mov	 eax, DWORD PTR _Value$[ebp]

; 260  : }

  000f0	c9		 leave
  000f1	c2 08 00	 ret	 8
?BlPciReadConfigurationRegister@@YIKEEEE@Z ENDP		; BlPciReadConfigurationRegister
_TEXT	ENDS
PUBLIC	?BlPciWriteConfigurationRegister@@YIXEEEEK@Z	; BlPciWriteConfigurationRegister
; Function compile flags: /Odsp
;	COMDAT ?BlPciWriteConfigurationRegister@@YIXEEEEK@Z
_TEXT	SEGMENT
_DeviceNumber$ = -12					; size = 1
_BusNumber$ = -8					; size = 1
_ConfigAddress$ = -4					; size = 4
_FunctionNumber$ = 8					; size = 1
_RegisterNumber$ = 12					; size = 1
_Value$ = 16						; size = 4
?BlPciWriteConfigurationRegister@@YIXEEEEK@Z PROC	; BlPciWriteConfigurationRegister, COMDAT
; _BusNumber$ = cl
; _DeviceNumber$ = dl

; 291  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	88 55 f4	 mov	 BYTE PTR _DeviceNumber$[ebp], dl
  00009	88 4d f8	 mov	 BYTE PTR _BusNumber$[ebp], cl

; 292  :     PCI_CONFIG_ADDRESS ConfigAddress;
; 293  : 
; 294  :     BLASSERT(DeviceNumber < PCI_MAX_DEVICES);

  0000c	0f b6 45 f4	 movzx	 eax, BYTE PTR _DeviceNumber$[ebp]
  00010	83 f8 20	 cmp	 eax, 32			; 00000020H
  00013	7c 0f		 jl	 SHORT $LN3@BlPciWrite
  00015	ba 26 01 00 00	 mov	 edx, 294		; 00000126H
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09GGGJHACA@blpci?4cpp?$AA@
  0001f	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN3@BlPciWrite:

; 295  :     BLASSERT(FunctionNumber < PCI_MAX_FUNCTIONS);

  00024	0f b6 45 08	 movzx	 eax, BYTE PTR _FunctionNumber$[ebp]
  00028	83 f8 08	 cmp	 eax, 8
  0002b	7c 0f		 jl	 SHORT $LN2@BlPciWrite
  0002d	ba 27 01 00 00	 mov	 edx, 295		; 00000127H
  00032	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09GGGJHACA@blpci?4cpp?$AA@
  00037	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN2@BlPciWrite:

; 296  :     BLASSERT((RegisterNumber % sizeof(UINT32)) == 0);

  0003c	0f b6 45 0c	 movzx	 eax, BYTE PTR _RegisterNumber$[ebp]
  00040	33 d2		 xor	 edx, edx
  00042	6a 04		 push	 4
  00044	59		 pop	 ecx
  00045	f7 f1		 div	 ecx
  00047	85 d2		 test	 edx, edx
  00049	74 0f		 je	 SHORT $LN1@BlPciWrite
  0004b	ba 28 01 00 00	 mov	 edx, 296		; 00000128H
  00050	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09GGGJHACA@blpci?4cpp?$AA@
  00055	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN1@BlPciWrite:

; 297  : 
; 298  :     BlRtlZeroMemory(&ConfigAddress, sizeof(ConfigAddress));

  0005a	6a 04		 push	 4
  0005c	5a		 pop	 edx
  0005d	8d 4d fc	 lea	 ecx, DWORD PTR _ConfigAddress$[ebp]
  00060	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 299  : 
; 300  :     ConfigAddress.u1.s1.BusNumber = BusNumber;

  00065	0f b6 45 f8	 movzx	 eax, BYTE PTR _BusNumber$[ebp]
  00069	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0006e	c1 e0 10	 shl	 eax, 16			; 00000010H
  00071	8b 4d fc	 mov	 ecx, DWORD PTR _ConfigAddress$[ebp]
  00074	81 e1 ff ff 00
	ff		 and	 ecx, -16711681		; ff00ffffH
  0007a	0b c8		 or	 ecx, eax
  0007c	89 4d fc	 mov	 DWORD PTR _ConfigAddress$[ebp], ecx

; 301  :     ConfigAddress.u1.s1.DeviceNumber = DeviceNumber;

  0007f	0f b6 45 f4	 movzx	 eax, BYTE PTR _DeviceNumber$[ebp]
  00083	83 e0 1f	 and	 eax, 31			; 0000001fH
  00086	c1 e0 0b	 shl	 eax, 11			; 0000000bH
  00089	8b 4d fc	 mov	 ecx, DWORD PTR _ConfigAddress$[ebp]
  0008c	81 e1 ff 07 ff
	ff		 and	 ecx, -63489		; ffff07ffH
  00092	0b c8		 or	 ecx, eax
  00094	89 4d fc	 mov	 DWORD PTR _ConfigAddress$[ebp], ecx

; 302  :     ConfigAddress.u1.s1.FunctionNumber = FunctionNumber;

  00097	0f b6 45 08	 movzx	 eax, BYTE PTR _FunctionNumber$[ebp]
  0009b	83 e0 07	 and	 eax, 7
  0009e	c1 e0 08	 shl	 eax, 8
  000a1	8b 4d fc	 mov	 ecx, DWORD PTR _ConfigAddress$[ebp]
  000a4	81 e1 ff f8 ff
	ff		 and	 ecx, -1793		; fffff8ffH
  000aa	0b c8		 or	 ecx, eax
  000ac	89 4d fc	 mov	 DWORD PTR _ConfigAddress$[ebp], ecx

; 303  :     ConfigAddress.u1.s1.RegisterNumber = RegisterNumber >> 2;

  000af	0f b6 45 0c	 movzx	 eax, BYTE PTR _RegisterNumber$[ebp]
  000b3	c1 f8 02	 sar	 eax, 2
  000b6	83 e0 3f	 and	 eax, 63			; 0000003fH
  000b9	c1 e0 02	 shl	 eax, 2
  000bc	8b 4d fc	 mov	 ecx, DWORD PTR _ConfigAddress$[ebp]
  000bf	81 e1 03 ff ff
	ff		 and	 ecx, -253		; ffffff03H
  000c5	0b c8		 or	 ecx, eax
  000c7	89 4d fc	 mov	 DWORD PTR _ConfigAddress$[ebp], ecx

; 304  :     ConfigAddress.u1.s1.Enable = 1;

  000ca	8b 45 fc	 mov	 eax, DWORD PTR _ConfigAddress$[ebp]
  000cd	0d 00 00 00 80	 or	 eax, -2147483648	; 80000000H
  000d2	89 45 fc	 mov	 DWORD PTR _ConfigAddress$[ebp], eax

; 305  : 
; 306  :     BlRtlWritePort32(PCI_ADDRESS_PORT, ConfigAddress.u1.Value);

  000d5	8b 55 fc	 mov	 edx, DWORD PTR _ConfigAddress$[ebp]
  000d8	66 b9 f8 0c	 mov	 cx, 3320		; 00000cf8H
  000dc	e8 00 00 00 00	 call	 ?BlRtlWritePort32@@YIXGK@Z ; BlRtlWritePort32

; 307  : 
; 308  :     BlRtlWritePort32(PCI_DATA_PORT, Value);

  000e1	8b 55 10	 mov	 edx, DWORD PTR _Value$[ebp]
  000e4	66 b9 fc 0c	 mov	 cx, 3324		; 00000cfcH
  000e8	e8 00 00 00 00	 call	 ?BlRtlWritePort32@@YIXGK@Z ; BlRtlWritePort32

; 309  : 
; 310  :     return;
; 311  : }

  000ed	c9		 leave
  000ee	c2 0c 00	 ret	 12			; 0000000cH
?BlPciWriteConfigurationRegister@@YIXEEEEK@Z ENDP	; BlPciWriteConfigurationRegister
_TEXT	ENDS
PUBLIC	?BlPciReadConfigurationSpace@@YIXEEEEPAXG@Z	; BlPciReadConfigurationSpace
; Function compile flags: /Odsp
;	COMDAT ?BlPciReadConfigurationSpace@@YIXEEEEPAXG@Z
_TEXT	SEGMENT
_DeviceNumber$ = -16					; size = 1
_BusNumber$ = -12					; size = 1
_Count$ = -8						; size = 2
_Index$ = -4						; size = 2
_FunctionNumber$ = 8					; size = 1
_RegisterNumber$ = 12					; size = 1
_Buffer$ = 16						; size = 4
_BufferSize$ = 20					; size = 2
?BlPciReadConfigurationSpace@@YIXEEEEPAXG@Z PROC	; BlPciReadConfigurationSpace, COMDAT
; _BusNumber$ = cl
; _DeviceNumber$ = dl

; 345  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	88 55 f0	 mov	 BYTE PTR _DeviceNumber$[ebp], dl
  00009	88 4d f4	 mov	 BYTE PTR _BusNumber$[ebp], cl

; 346  :     UINT16 Count;
; 347  :     UINT16 Index;
; 348  : 
; 349  :     BLASSERT((RegisterNumber % sizeof(UINT32)) == 0);

  0000c	0f b6 45 0c	 movzx	 eax, BYTE PTR _RegisterNumber$[ebp]
  00010	33 d2		 xor	 edx, edx
  00012	6a 04		 push	 4
  00014	59		 pop	 ecx
  00015	f7 f1		 div	 ecx
  00017	85 d2		 test	 edx, edx
  00019	74 0f		 je	 SHORT $LN5@BlPciReadC@2
  0001b	ba 5d 01 00 00	 mov	 edx, 349		; 0000015dH
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09GGGJHACA@blpci?4cpp?$AA@
  00025	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN5@BlPciReadC@2:

; 350  :     BLASSERT((BufferSize % sizeof(UINT32)) == 0);

  0002a	0f b7 45 14	 movzx	 eax, WORD PTR _BufferSize$[ebp]
  0002e	33 d2		 xor	 edx, edx
  00030	6a 04		 push	 4
  00032	59		 pop	 ecx
  00033	f7 f1		 div	 ecx
  00035	85 d2		 test	 edx, edx
  00037	74 0f		 je	 SHORT $LN4@BlPciReadC@2
  00039	ba 5e 01 00 00	 mov	 edx, 350		; 0000015eH
  0003e	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09GGGJHACA@blpci?4cpp?$AA@
  00043	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN4@BlPciReadC@2:

; 351  : 
; 352  :     Count = BufferSize / sizeof(UINT32);

  00048	0f b7 45 14	 movzx	 eax, WORD PTR _BufferSize$[ebp]
  0004c	c1 e8 02	 shr	 eax, 2
  0004f	66 89 45 f8	 mov	 WORD PTR _Count$[ebp], ax

; 353  : 
; 354  :     for (Index = 0; Index < Count; Index += 1) {

  00053	66 83 65 fc 00	 and	 WORD PTR _Index$[ebp], 0
  00058	eb 09		 jmp	 SHORT $LN3@BlPciReadC@2
$LN2@BlPciReadC@2:
  0005a	0f b7 45 fc	 movzx	 eax, WORD PTR _Index$[ebp]
  0005e	40		 inc	 eax
  0005f	66 89 45 fc	 mov	 WORD PTR _Index$[ebp], ax
$LN3@BlPciReadC@2:
  00063	0f b7 45 fc	 movzx	 eax, WORD PTR _Index$[ebp]
  00067	0f b7 4d f8	 movzx	 ecx, WORD PTR _Count$[ebp]
  0006b	3b c1		 cmp	 eax, ecx
  0006d	7d 26		 jge	 SHORT $LN6@BlPciReadC@2

; 355  : 
; 356  :         ((PUINT32) Buffer)[Index] = BlPciReadConfigurationRegister(BusNumber,
; 357  :                                                                   DeviceNumber,
; 358  :                                                                   FunctionNumber,
; 359  :                                                                   (UINT8) (RegisterNumber + (Index * sizeof(UINT32))));

  0006f	0f b6 45 0c	 movzx	 eax, BYTE PTR _RegisterNumber$[ebp]
  00073	0f b7 4d fc	 movzx	 ecx, WORD PTR _Index$[ebp]
  00077	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  0007a	50		 push	 eax
  0007b	ff 75 08	 push	 DWORD PTR _FunctionNumber$[ebp]
  0007e	8a 55 f0	 mov	 dl, BYTE PTR _DeviceNumber$[ebp]
  00081	8a 4d f4	 mov	 cl, BYTE PTR _BusNumber$[ebp]
  00084	e8 00 00 00 00	 call	 ?BlPciReadConfigurationRegister@@YIKEEEE@Z ; BlPciReadConfigurationRegister
  00089	0f b7 4d fc	 movzx	 ecx, WORD PTR _Index$[ebp]
  0008d	8b 55 10	 mov	 edx, DWORD PTR _Buffer$[ebp]
  00090	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 360  :     }

  00093	eb c5		 jmp	 SHORT $LN2@BlPciReadC@2
$LN6@BlPciReadC@2:

; 361  : 
; 362  :     return;
; 363  : }

  00095	c9		 leave
  00096	c2 10 00	 ret	 16			; 00000010H
?BlPciReadConfigurationSpace@@YIXEEEEPAXG@Z ENDP	; BlPciReadConfigurationSpace
_TEXT	ENDS
PUBLIC	?BlPciScanDevices@@YIXXZ			; BlPciScanDevices
EXTRN	?BlMmMapVirtualRange@@YIXPAX0KEEE@Z:PROC	; BlMmMapVirtualRange
EXTRN	__allshl:PROC
EXTRN	__aullshr:PROC
; Function compile flags: /Odsp
;	COMDAT ?BlPciScanDevices@@YIXXZ
_TEXT	SEGMENT
tv309 = -132						; size = 8
tv296 = -124						; size = 8
tv152 = -116						; size = 4
tv149 = -112						; size = 4
tv128 = -108						; size = 4
_Config$ = -104						; size = 65
_NodeType$ = -30					; size = 1
_FunctionNumber$ = -29					; size = 1
_BaseAddress$ = -28					; size = 4
_DeviceNumber$ = -21					; size = 1
_OldValue$ = -20					; size = 4
_Address$ = -16						; size = 8
_Size$ = -8						; size = 4
_BaseAddressRegister$ = -3				; size = 1
_BusNumber$ = -2					; size = 1
_Index$ = -1						; size = 1
?BlPciScanDevices@@YIXXZ PROC				; BlPciScanDevices, COMDAT

; 378  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H

; 379  :     UINT64 Address;
; 380  :     PPCI_BASE_ADDRESS BaseAddress;
; 381  :     UINT8 BaseAddressRegister;
; 382  :     UINT8 BusNumber;
; 383  :     PCI_CONFIGURATION_SPACE_HEADER Config;
; 384  :     UINT8 DeviceNumber;
; 385  :     UINT8 FunctionNumber;
; 386  :     UINT8 Index;
; 387  :     UINT8 NodeType;
; 388  :     UINT32 OldValue;
; 389  :     UINT32 Size;
; 390  : 
; 391  :     for (BusNumber = 0; BusNumber <= BlPciInstallationCheck.LastBusNumber; BusNumber += 1) {

  00009	c6 45 fe 00	 mov	 BYTE PTR _BusNumber$[ebp], 0
  0000d	eb 08		 jmp	 SHORT $LN30@BlPciScanD
$LN29@BlPciScanD:
  0000f	0f b6 45 fe	 movzx	 eax, BYTE PTR _BusNumber$[ebp]
  00013	40		 inc	 eax
  00014	88 45 fe	 mov	 BYTE PTR _BusNumber$[ebp], al
$LN30@BlPciScanD:
  00017	0f b6 45 fe	 movzx	 eax, BYTE PTR _BusNumber$[ebp]
  0001b	0f b6 0d 13 00
	00 00		 movzx	 ecx, BYTE PTR ?BlPciInstallationCheck@@3U_PCI_INSTALLATION_CHECK@@A+19
  00022	3b c1		 cmp	 eax, ecx
  00024	0f 8f f7 02 00
	00		 jg	 $LN31@BlPciScanD

; 392  : 
; 393  :         for (DeviceNumber = 0; DeviceNumber < PCI_MAX_DEVICES; DeviceNumber += 1) {

  0002a	c6 45 eb 00	 mov	 BYTE PTR _DeviceNumber$[ebp], 0
  0002e	eb 08		 jmp	 SHORT $LN27@BlPciScanD
$LN26@BlPciScanD:
  00030	0f b6 45 eb	 movzx	 eax, BYTE PTR _DeviceNumber$[ebp]
  00034	40		 inc	 eax
  00035	88 45 eb	 mov	 BYTE PTR _DeviceNumber$[ebp], al
$LN27@BlPciScanD:
  00038	0f b6 45 eb	 movzx	 eax, BYTE PTR _DeviceNumber$[ebp]
  0003c	83 f8 20	 cmp	 eax, 32			; 00000020H
  0003f	0f 8d d7 02 00
	00		 jge	 $LN25@BlPciScanD

; 394  : 
; 395  :             for (FunctionNumber = 0; FunctionNumber < PCI_MAX_FUNCTIONS; FunctionNumber += 1) {

  00045	c6 45 e3 00	 mov	 BYTE PTR _FunctionNumber$[ebp], 0
  00049	eb 08		 jmp	 SHORT $LN24@BlPciScanD
$LN23@BlPciScanD:
  0004b	0f b6 45 e3	 movzx	 eax, BYTE PTR _FunctionNumber$[ebp]
  0004f	40		 inc	 eax
  00050	88 45 e3	 mov	 BYTE PTR _FunctionNumber$[ebp], al
$LN24@BlPciScanD:
  00053	0f b6 45 e3	 movzx	 eax, BYTE PTR _FunctionNumber$[ebp]
  00057	83 f8 08	 cmp	 eax, 8
  0005a	0f 8d b7 02 00
	00		 jge	 $LN22@BlPciScanD

; 396  : 
; 397  :                 BlRtlZeroMemory(&Config, sizeof(Config));

  00060	6a 41		 push	 65			; 00000041H
  00062	5a		 pop	 edx
  00063	8d 4d 98	 lea	 ecx, DWORD PTR _Config$[ebp]
  00066	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 398  : 
; 399  :                 Config.VendorId = PCI_INVALID_VENDORID;

  0006b	66 81 4d 98 ff
	ff		 or	 WORD PTR _Config$[ebp], 65535 ; 0000ffffH

; 400  : 
; 401  :                 BlPciReadConfigurationSpace(BusNumber,
; 402  :                                             DeviceNumber,
; 403  :                                             FunctionNumber,
; 404  :                                             0,
; 405  :                                             &Config,
; 406  :                                             FIELD_OFFSET(PCI_CONFIGURATION_SPACE_HEADER, u1.DynamicStart));

  00071	6a 10		 push	 16			; 00000010H
  00073	8d 45 98	 lea	 eax, DWORD PTR _Config$[ebp]
  00076	50		 push	 eax
  00077	6a 00		 push	 0
  00079	ff 75 e3	 push	 DWORD PTR _FunctionNumber$[ebp]
  0007c	8a 55 eb	 mov	 dl, BYTE PTR _DeviceNumber$[ebp]
  0007f	8a 4d fe	 mov	 cl, BYTE PTR _BusNumber$[ebp]
  00082	e8 00 00 00 00	 call	 ?BlPciReadConfigurationSpace@@YIXEEEEPAXG@Z ; BlPciReadConfigurationSpace

; 407  : 
; 408  :                 if ((Config.VendorId == PCI_INVALID_VENDORID) || (Config.VendorId == 0)) {

  00087	0f b7 45 98	 movzx	 eax, WORD PTR _Config$[ebp]
  0008b	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00090	74 08		 je	 SHORT $LN20@BlPciScanD
  00092	0f b7 45 98	 movzx	 eax, WORD PTR _Config$[ebp]
  00096	85 c0		 test	 eax, eax
  00098	75 02		 jne	 SHORT $LN21@BlPciScanD
$LN20@BlPciScanD:

; 409  : 
; 410  :                     continue;

  0009a	eb af		 jmp	 SHORT $LN23@BlPciScanD
$LN21@BlPciScanD:

; 411  :                 }
; 412  : 
; 413  :                 NodeType = Config.HeaderType & PCI_TYPE_MASK;

  0009c	0f b6 45 a6	 movzx	 eax, BYTE PTR _Config$[ebp+14]
  000a0	83 e0 7f	 and	 eax, 127		; 0000007fH
  000a3	88 45 e2	 mov	 BYTE PTR _NodeType$[ebp], al

; 414  : 
; 415  :                 switch (NodeType) {

  000a6	8a 45 e2	 mov	 al, BYTE PTR _NodeType$[ebp]
  000a9	88 45 94	 mov	 BYTE PTR tv128[ebp], al
  000ac	80 7d 94 00	 cmp	 BYTE PTR tv128[ebp], 0
  000b0	74 05		 je	 SHORT $LN17@BlPciScanD
  000b2	e9 4e 02 00 00	 jmp	 $LN18@BlPciScanD
$LN17@BlPciScanD:

; 416  : 
; 417  :                     case PCI_DEVICE: {
; 418  : 
; 419  : #if PCI_VERBOSE
; 420  : 
; 421  :                         BlRtlPrintf("PCI: %02x:%02x:%02x: Device %04x:%04x [BC=%02x SC=%02x PI=%02x]\n",
; 422  :                                     BusNumber,
; 423  :                                     DeviceNumber,
; 424  :                                     FunctionNumber,
; 425  :                                     Config.VendorId,
; 426  :                                     Config.DeviceId,
; 427  :                                     Config.BaseClass,
; 428  :                                     Config.SubClass,
; 429  :                                     Config.ProgrammingInterface
; 430  :                                     );
; 431  : 
; 432  : #endif
; 433  : 
; 434  :                         BlPciReadConfigurationSpace(BusNumber,
; 435  :                                                     DeviceNumber,
; 436  :                                                     FunctionNumber,
; 437  :                                                     FIELD_OFFSET(PCI_CONFIGURATION_SPACE_HEADER, u1.DynamicStart),
; 438  :                                                     &Config.u1.DynamicStart,
; 439  :                                                     FIELD_OFFSET(PCI_CONFIGURATION_SPACE_HEADER, u1.Device.__End) - FIELD_OFFSET(PCI_CONFIGURATION_SPACE_HEADER, u1.DynamicStart));

  000b7	6a 30		 push	 48			; 00000030H
  000b9	8d 45 a8	 lea	 eax, DWORD PTR _Config$[ebp+16]
  000bc	50		 push	 eax
  000bd	6a 10		 push	 16			; 00000010H
  000bf	ff 75 e3	 push	 DWORD PTR _FunctionNumber$[ebp]
  000c2	8a 55 eb	 mov	 dl, BYTE PTR _DeviceNumber$[ebp]
  000c5	8a 4d fe	 mov	 cl, BYTE PTR _BusNumber$[ebp]
  000c8	e8 00 00 00 00	 call	 ?BlPciReadConfigurationSpace@@YIXEEEEPAXG@Z ; BlPciReadConfigurationSpace

; 440  : 
; 441  :                         for (Index = 0; Index < PCI_DEVICE_BASE_ADDRESS_COUNT; Index += 1) {

  000cd	c6 45 ff 00	 mov	 BYTE PTR _Index$[ebp], 0
  000d1	eb 08		 jmp	 SHORT $LN16@BlPciScanD
$LN15@BlPciScanD:
  000d3	0f b6 45 ff	 movzx	 eax, BYTE PTR _Index$[ebp]
  000d7	40		 inc	 eax
  000d8	88 45 ff	 mov	 BYTE PTR _Index$[ebp], al
$LN16@BlPciScanD:
  000db	0f b6 45 ff	 movzx	 eax, BYTE PTR _Index$[ebp]
  000df	83 f8 06	 cmp	 eax, 6
  000e2	0f 8d 1d 02 00
	00		 jge	 $LN18@BlPciScanD

; 442  : 
; 443  :                             BaseAddress = (PPCI_BASE_ADDRESS) &Config.u1.Device.BaseAddressRegister[Index];

  000e8	0f b6 45 ff	 movzx	 eax, BYTE PTR _Index$[ebp]
  000ec	8d 44 85 a8	 lea	 eax, DWORD PTR _Config$[ebp+eax*4+16]
  000f0	89 45 e4	 mov	 DWORD PTR _BaseAddress$[ebp], eax

; 444  :                             BaseAddressRegister = (UINT8) FIELD_OFFSET(PCI_CONFIGURATION_SPACE_HEADER, u1.Device.BaseAddressRegister[Index]);

  000f3	33 c0		 xor	 eax, eax
  000f5	83 c0 10	 add	 eax, 16			; 00000010H
  000f8	0f b6 4d ff	 movzx	 ecx, BYTE PTR _Index$[ebp]
  000fc	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  000ff	88 45 fd	 mov	 BYTE PTR _BaseAddressRegister$[ebp], al

; 445  :                             Address = 0;

  00102	83 65 f0 00	 and	 DWORD PTR _Address$[ebp], 0
  00106	83 65 f4 00	 and	 DWORD PTR _Address$[ebp+4], 0

; 446  : 
; 447  :                             switch (BaseAddress->u1.Common.Type) {

  0010a	8b 45 e4	 mov	 eax, DWORD PTR _BaseAddress$[ebp]
  0010d	8b 00		 mov	 eax, DWORD PTR [eax]
  0010f	83 e0 01	 and	 eax, 1
  00112	89 45 90	 mov	 DWORD PTR tv149[ebp], eax
  00115	74 05		 je	 SHORT $LN11@BlPciScanD
  00117	e9 e4 01 00 00	 jmp	 $LN12@BlPciScanD
$LN11@BlPciScanD:

; 448  : 
; 449  :                                 case PCI_BASE_ADDRESS_MEMORY: {
; 450  : 
; 451  :                                     SATISFY_OVERZEALOUS_COMPILER(Size = 0);

  0011c	83 65 f8 00	 and	 DWORD PTR _Size$[ebp], 0

; 452  : 
; 453  :                                     switch (BaseAddress->u1.Memory.Type) {

  00120	8b 45 e4	 mov	 eax, DWORD PTR _BaseAddress$[ebp]
  00123	8b 00		 mov	 eax, DWORD PTR [eax]
  00125	d1 e8		 shr	 eax, 1
  00127	83 e0 03	 and	 eax, 3
  0012a	89 45 8c	 mov	 DWORD PTR tv152[ebp], eax
  0012d	0f 82 08 01 00
	00		 jb	 $LN9@BlPciScanD
  00133	83 7d 8c 01	 cmp	 DWORD PTR tv152[ebp], 1
  00137	76 0b		 jbe	 SHORT $LN8@BlPciScanD
  00139	83 7d 8c 02	 cmp	 DWORD PTR tv152[ebp], 2
  0013d	74 7a		 je	 SHORT $LN7@BlPciScanD
  0013f	e9 f7 00 00 00	 jmp	 $LN9@BlPciScanD
$LN8@BlPciScanD:

; 454  : 
; 455  :                                         case PCI_BASE_ADDRESS_MEMORY_32:
; 456  :                                         case PCI_BASE_ADDRESS_MEMORY_32_1MB: {
; 457  : 
; 458  :                                             Address = BaseAddress->u1.Memory.Base << PCI_BASE_ADDRESS_SHIFT;

  00144	8b 45 e4	 mov	 eax, DWORD PTR _BaseAddress$[ebp]
  00147	8b 00		 mov	 eax, DWORD PTR [eax]
  00149	c1 e8 04	 shr	 eax, 4
  0014c	25 ff ff ff 0f	 and	 eax, 268435455		; 0fffffffH
  00151	c1 e0 04	 shl	 eax, 4
  00154	33 c9		 xor	 ecx, ecx
  00156	89 45 f0	 mov	 DWORD PTR _Address$[ebp], eax
  00159	89 4d f4	 mov	 DWORD PTR _Address$[ebp+4], ecx

; 459  : 
; 460  :                                             OldValue = Config.u1.Device.BaseAddressRegister[Index];

  0015c	0f b6 45 ff	 movzx	 eax, BYTE PTR _Index$[ebp]
  00160	8b 44 85 a8	 mov	 eax, DWORD PTR _Config$[ebp+eax*4+16]
  00164	89 45 ec	 mov	 DWORD PTR _OldValue$[ebp], eax

; 461  : 
; 462  :                                             BlPciWriteConfigurationRegister(BusNumber,
; 463  :                                                                             DeviceNumber,
; 464  :                                                                             FunctionNumber,
; 465  :                                                                             BaseAddressRegister,
; 466  :                                                                             (UINT32) -1);

  00167	6a ff		 push	 -1
  00169	ff 75 fd	 push	 DWORD PTR _BaseAddressRegister$[ebp]
  0016c	ff 75 e3	 push	 DWORD PTR _FunctionNumber$[ebp]
  0016f	8a 55 eb	 mov	 dl, BYTE PTR _DeviceNumber$[ebp]
  00172	8a 4d fe	 mov	 cl, BYTE PTR _BusNumber$[ebp]
  00175	e8 00 00 00 00	 call	 ?BlPciWriteConfigurationRegister@@YIXEEEEK@Z ; BlPciWriteConfigurationRegister

; 467  : 
; 468  :                                             Size = BlPciReadConfigurationRegister(BusNumber,
; 469  :                                                                                   DeviceNumber,
; 470  :                                                                                   FunctionNumber,
; 471  :                                                                                   BaseAddressRegister);

  0017a	ff 75 fd	 push	 DWORD PTR _BaseAddressRegister$[ebp]
  0017d	ff 75 e3	 push	 DWORD PTR _FunctionNumber$[ebp]
  00180	8a 55 eb	 mov	 dl, BYTE PTR _DeviceNumber$[ebp]
  00183	8a 4d fe	 mov	 cl, BYTE PTR _BusNumber$[ebp]
  00186	e8 00 00 00 00	 call	 ?BlPciReadConfigurationRegister@@YIKEEEE@Z ; BlPciReadConfigurationRegister
  0018b	89 45 f8	 mov	 DWORD PTR _Size$[ebp], eax

; 472  : 
; 473  :                                             BlPciWriteConfigurationRegister(BusNumber,
; 474  :                                                                             DeviceNumber,
; 475  :                                                                             FunctionNumber,
; 476  :                                                                             BaseAddressRegister,
; 477  :                                                                             OldValue);

  0018e	ff 75 ec	 push	 DWORD PTR _OldValue$[ebp]
  00191	ff 75 fd	 push	 DWORD PTR _BaseAddressRegister$[ebp]
  00194	ff 75 e3	 push	 DWORD PTR _FunctionNumber$[ebp]
  00197	8a 55 eb	 mov	 dl, BYTE PTR _DeviceNumber$[ebp]
  0019a	8a 4d fe	 mov	 cl, BYTE PTR _BusNumber$[ebp]
  0019d	e8 00 00 00 00	 call	 ?BlPciWriteConfigurationRegister@@YIXEEEEK@Z ; BlPciWriteConfigurationRegister

; 478  : 
; 479  :                                             Size &= ~(PCI_BASE_ADDRESS_FLAGS_MASK);

  001a2	8b 45 f8	 mov	 eax, DWORD PTR _Size$[ebp]
  001a5	83 e0 f0	 and	 eax, -16		; fffffff0H
  001a8	89 45 f8	 mov	 DWORD PTR _Size$[ebp], eax

; 480  : 
; 481  :                                             Size = (~Size) + 1;

  001ab	8b 45 f8	 mov	 eax, DWORD PTR _Size$[ebp]
  001ae	f7 d0		 not	 eax
  001b0	40		 inc	 eax
  001b1	89 45 f8	 mov	 DWORD PTR _Size$[ebp], eax

; 482  : 
; 483  :                                             break;

  001b4	e9 82 00 00 00	 jmp	 $LN9@BlPciScanD
$LN7@BlPciScanD:

; 484  :                                         }
; 485  : 
; 486  :                                         case PCI_BASE_ADDRESS_MEMORY_64: {
; 487  : 
; 488  :                                             Address = BaseAddress->u1.Memory64.Base << PCI_BASE_ADDRESS_SHIFT;

  001b9	8b 4d e4	 mov	 ecx, DWORD PTR _BaseAddress$[ebp]
  001bc	8b 01		 mov	 eax, DWORD PTR [ecx]
  001be	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001c1	b1 04		 mov	 cl, 4
  001c3	e8 00 00 00 00	 call	 __aullshr
  001c8	81 e2 ff ff ff
	0f		 and	 edx, 268435455		; 0fffffffH
  001ce	b1 04		 mov	 cl, 4
  001d0	e8 00 00 00 00	 call	 __allshl
  001d5	89 45 f0	 mov	 DWORD PTR _Address$[ebp], eax
  001d8	89 55 f4	 mov	 DWORD PTR _Address$[ebp+4], edx

; 489  : 
; 490  :                                             OldValue = Config.u1.Device.BaseAddressRegister[Index];

  001db	0f b6 45 ff	 movzx	 eax, BYTE PTR _Index$[ebp]
  001df	8b 44 85 a8	 mov	 eax, DWORD PTR _Config$[ebp+eax*4+16]
  001e3	89 45 ec	 mov	 DWORD PTR _OldValue$[ebp], eax

; 491  : 
; 492  :                                             BlPciWriteConfigurationRegister(BusNumber,
; 493  :                                                                             DeviceNumber,
; 494  :                                                                             FunctionNumber,
; 495  :                                                                             BaseAddressRegister,
; 496  :                                                                             (UINT32) -1);

  001e6	6a ff		 push	 -1
  001e8	ff 75 fd	 push	 DWORD PTR _BaseAddressRegister$[ebp]
  001eb	ff 75 e3	 push	 DWORD PTR _FunctionNumber$[ebp]
  001ee	8a 55 eb	 mov	 dl, BYTE PTR _DeviceNumber$[ebp]
  001f1	8a 4d fe	 mov	 cl, BYTE PTR _BusNumber$[ebp]
  001f4	e8 00 00 00 00	 call	 ?BlPciWriteConfigurationRegister@@YIXEEEEK@Z ; BlPciWriteConfigurationRegister

; 497  : 
; 498  :                                             Size = BlPciReadConfigurationRegister(BusNumber,
; 499  :                                                                                   DeviceNumber,
; 500  :                                                                                   FunctionNumber,
; 501  :                                                                                   BaseAddressRegister);

  001f9	ff 75 fd	 push	 DWORD PTR _BaseAddressRegister$[ebp]
  001fc	ff 75 e3	 push	 DWORD PTR _FunctionNumber$[ebp]
  001ff	8a 55 eb	 mov	 dl, BYTE PTR _DeviceNumber$[ebp]
  00202	8a 4d fe	 mov	 cl, BYTE PTR _BusNumber$[ebp]
  00205	e8 00 00 00 00	 call	 ?BlPciReadConfigurationRegister@@YIKEEEE@Z ; BlPciReadConfigurationRegister
  0020a	89 45 f8	 mov	 DWORD PTR _Size$[ebp], eax

; 502  : 
; 503  :                                             BlPciWriteConfigurationRegister(BusNumber,
; 504  :                                                                             DeviceNumber,
; 505  :                                                                             FunctionNumber,
; 506  :                                                                             BaseAddressRegister,
; 507  :                                                                             OldValue);

  0020d	ff 75 ec	 push	 DWORD PTR _OldValue$[ebp]
  00210	ff 75 fd	 push	 DWORD PTR _BaseAddressRegister$[ebp]
  00213	ff 75 e3	 push	 DWORD PTR _FunctionNumber$[ebp]
  00216	8a 55 eb	 mov	 dl, BYTE PTR _DeviceNumber$[ebp]
  00219	8a 4d fe	 mov	 cl, BYTE PTR _BusNumber$[ebp]
  0021c	e8 00 00 00 00	 call	 ?BlPciWriteConfigurationRegister@@YIXEEEEK@Z ; BlPciWriteConfigurationRegister

; 508  : 
; 509  :                                             Size &= ~(PCI_BASE_ADDRESS_FLAGS_MASK);

  00221	8b 45 f8	 mov	 eax, DWORD PTR _Size$[ebp]
  00224	83 e0 f0	 and	 eax, -16		; fffffff0H
  00227	89 45 f8	 mov	 DWORD PTR _Size$[ebp], eax

; 510  : 
; 511  :                                             Size = (~Size) + 1;

  0022a	8b 45 f8	 mov	 eax, DWORD PTR _Size$[ebp]
  0022d	f7 d0		 not	 eax
  0022f	40		 inc	 eax
  00230	89 45 f8	 mov	 DWORD PTR _Size$[ebp], eax

; 512  : 
; 513  :                                             Index += 1;

  00233	0f b6 45 ff	 movzx	 eax, BYTE PTR _Index$[ebp]
  00237	40		 inc	 eax
  00238	88 45 ff	 mov	 BYTE PTR _Index$[ebp], al
$LN9@BlPciScanD:

; 514  : 
; 515  :                                             break;
; 516  :                                         }
; 517  :                                     }
; 518  : 
; 519  :                                     if (Address != 0) {

  0023b	8b 45 f0	 mov	 eax, DWORD PTR _Address$[ebp]
  0023e	0b 45 f4	 or	 eax, DWORD PTR _Address$[ebp+4]
  00241	0f 84 b9 00 00
	00		 je	 $LN12@BlPciScanD

; 520  : 
; 521  :                                         BLASSERT(Size > 0);

  00247	83 7d f8 00	 cmp	 DWORD PTR _Size$[ebp], 0
  0024b	77 0f		 ja	 SHORT $LN5@BlPciScanD
  0024d	ba 09 02 00 00	 mov	 edx, 521		; 00000209H
  00252	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09GGGJHACA@blpci?4cpp?$AA@
  00257	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN5@BlPciScanD:

; 522  : 
; 523  : #if PCI_VERBOSE
; 524  : 
; 525  :                                         BlRtlPrintf("PCI: %02x:%02x:%02x: IO Memory [%016I64x ... %016I64x]\n",
; 526  :                                                     BusNumber,
; 527  :                                                     DeviceNumber,
; 528  :                                                     FunctionNumber,
; 529  :                                                     Address,
; 530  :                                                     Address + Size - 1);
; 531  : 
; 532  : #endif
; 533  : 
; 534  :                                         if ((Address >= LEGACY_MEMORY_LIMIT) &&
; 535  :                                             ((Address + Size) > Address) &&
; 536  :                                             ((Address + Size) <= 0x100000000UI64)
; 537  :                                             ) {

  0025c	83 7d f4 00	 cmp	 DWORD PTR _Address$[ebp+4], 0
  00260	77 09		 ja	 SHORT $LN33@BlPciScanD
  00262	81 7d f0 00 00
	10 00		 cmp	 DWORD PTR _Address$[ebp], 1048576 ; 00100000H
  00269	72 6a		 jb	 SHORT $LN4@BlPciScanD
$LN33@BlPciScanD:
  0026b	8b 45 f8	 mov	 eax, DWORD PTR _Size$[ebp]
  0026e	33 c9		 xor	 ecx, ecx
  00270	03 45 f0	 add	 eax, DWORD PTR _Address$[ebp]
  00273	8b 55 f4	 mov	 edx, DWORD PTR _Address$[ebp+4]
  00276	13 d1		 adc	 edx, ecx
  00278	89 45 84	 mov	 DWORD PTR tv296[ebp], eax
  0027b	89 55 88	 mov	 DWORD PTR tv296[ebp+4], edx
  0027e	8b 45 88	 mov	 eax, DWORD PTR tv296[ebp+4]
  00281	3b 45 f4	 cmp	 eax, DWORD PTR _Address$[ebp+4]
  00284	72 4f		 jb	 SHORT $LN4@BlPciScanD
  00286	77 08		 ja	 SHORT $LN34@BlPciScanD
  00288	8b 45 84	 mov	 eax, DWORD PTR tv296[ebp]
  0028b	3b 45 f0	 cmp	 eax, DWORD PTR _Address$[ebp]
  0028e	76 45		 jbe	 SHORT $LN4@BlPciScanD
$LN34@BlPciScanD:
  00290	8b 45 f8	 mov	 eax, DWORD PTR _Size$[ebp]
  00293	33 c9		 xor	 ecx, ecx
  00295	03 45 f0	 add	 eax, DWORD PTR _Address$[ebp]
  00298	8b 55 f4	 mov	 edx, DWORD PTR _Address$[ebp+4]
  0029b	13 d1		 adc	 edx, ecx
  0029d	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv309[ebp], eax
  002a3	89 55 80	 mov	 DWORD PTR tv309[ebp+4], edx
  002a6	83 7d 80 01	 cmp	 DWORD PTR tv309[ebp+4], 1
  002aa	77 29		 ja	 SHORT $LN4@BlPciScanD
  002ac	72 09		 jb	 SHORT $LN35@BlPciScanD
  002ae	83 bd 7c ff ff
	ff 00		 cmp	 DWORD PTR tv309[ebp], 0
  002b5	77 1e		 ja	 SHORT $LN4@BlPciScanD
$LN35@BlPciScanD:

; 538  : 
; 539  :                                             BlMmMapVirtualRange((PVOID) (ULONG_PTR) Address,
; 540  :                                                                 (PVOID) (ULONG_PTR) Address,
; 541  :                                                                 Size,
; 542  :                                                                 TRUE,
; 543  :                                                                 (BOOLEAN) BaseAddress->u1.Memory.Prefetch,
; 544  :                                                                 FALSE);

  002b7	6a 00		 push	 0
  002b9	8b 45 e4	 mov	 eax, DWORD PTR _BaseAddress$[ebp]
  002bc	8b 00		 mov	 eax, DWORD PTR [eax]
  002be	c1 e8 03	 shr	 eax, 3
  002c1	83 e0 01	 and	 eax, 1
  002c4	50		 push	 eax
  002c5	6a 01		 push	 1
  002c7	ff 75 f8	 push	 DWORD PTR _Size$[ebp]
  002ca	8b 55 f0	 mov	 edx, DWORD PTR _Address$[ebp]
  002cd	8b 4d f0	 mov	 ecx, DWORD PTR _Address$[ebp]
  002d0	e8 00 00 00 00	 call	 ?BlMmMapVirtualRange@@YIXPAX0KEEE@Z ; BlMmMapVirtualRange
$LN4@BlPciScanD:

; 545  :                                         }
; 546  : 
; 547  :                                         //
; 548  :                                         // Check if this memory range maps OHCI 1394 registers.
; 549  :                                         //
; 550  : 
; 551  :                                         if ((Config.BaseClass == 0x0C) &&
; 552  :                                             (Config.SubClass == 0x00) &&
; 553  :                                             (Config.ProgrammingInterface == 0x10) &&
; 554  :                                             (BlPciOhci1394BaseAddress == 0)) {

  002d5	0f b6 45 a3	 movzx	 eax, BYTE PTR _Config$[ebp+11]
  002d9	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  002dc	75 22		 jne	 SHORT $LN12@BlPciScanD
  002de	0f b6 45 a2	 movzx	 eax, BYTE PTR _Config$[ebp+10]
  002e2	85 c0		 test	 eax, eax
  002e4	75 1a		 jne	 SHORT $LN12@BlPciScanD
  002e6	0f b6 45 a1	 movzx	 eax, BYTE PTR _Config$[ebp+9]
  002ea	83 f8 10	 cmp	 eax, 16			; 00000010H
  002ed	75 11		 jne	 SHORT $LN12@BlPciScanD
  002ef	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?BlPciOhci1394BaseAddress@@3KA, 0 ; BlPciOhci1394BaseAddress
  002f6	75 08		 jne	 SHORT $LN12@BlPciScanD

; 555  : 
; 556  :                                             BlPciOhci1394BaseAddress = (UINT32) Address;

  002f8	8b 45 f0	 mov	 eax, DWORD PTR _Address$[ebp]
  002fb	a3 00 00 00 00	 mov	 DWORD PTR ?BlPciOhci1394BaseAddress@@3KA, eax ; BlPciOhci1394BaseAddress
$LN12@BlPciScanD:

; 557  :                                         }
; 558  :                                     }
; 559  : 
; 560  :                                     break;
; 561  :                                 }
; 562  :                             }
; 563  :                         }

  00300	e9 ce fd ff ff	 jmp	 $LN15@BlPciScanD
$LN18@BlPciScanD:

; 564  : 
; 565  :                         break;
; 566  :                     }
; 567  : 
; 568  :                     case PCI_BRIDGE: {
; 569  : 
; 570  : #if PCI_VERBOSE
; 571  : 
; 572  :                         BlRtlPrintf("PCI: %02x:%02x:%02x: Bridge %04x:%04x\n",
; 573  :                                     BusNumber,
; 574  :                                     DeviceNumber,
; 575  :                                     FunctionNumber,
; 576  :                                     Config.VendorId,
; 577  :                                     Config.DeviceId);
; 578  : 
; 579  : #endif
; 580  : 
; 581  :                         break;
; 582  :                     }
; 583  :                 }
; 584  : 
; 585  :                 if ((Config.HeaderType & PCI_MULTI_FUNCTION) == 0) {

  00305	0f b6 45 a6	 movzx	 eax, BYTE PTR _Config$[ebp+14]
  00309	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0030e	75 02		 jne	 SHORT $LN1@BlPciScanD

; 586  : 
; 587  :                     break;

  00310	eb 05		 jmp	 SHORT $LN22@BlPciScanD
$LN1@BlPciScanD:

; 588  :                 }
; 589  :             }

  00312	e9 34 fd ff ff	 jmp	 $LN23@BlPciScanD
$LN22@BlPciScanD:

; 590  :         }

  00317	e9 14 fd ff ff	 jmp	 $LN26@BlPciScanD
$LN25@BlPciScanD:

; 591  :     }

  0031c	e9 ee fc ff ff	 jmp	 $LN29@BlPciScanD
$LN31@BlPciScanD:

; 592  : }

  00321	c9		 leave
  00322	c3		 ret	 0
?BlPciScanDevices@@YIXXZ ENDP				; BlPciScanDevices
_TEXT	ENDS
PUBLIC	??_C@_0BN@OCAODDMI@pci?3?5PCI?5BIOS?5not?5detected?$CB?6?$AA@ ; `string'
PUBLIC	?BlPciInitialize@@YIXXZ				; BlPciInitialize
EXTRN	?BlRtlHaltInternal@@YIXPBDK@Z:PROC		; BlRtlHaltInternal
EXTRN	?BlRtlPrintf@@YAEPBDZZ:PROC			; BlRtlPrintf
;	COMDAT ??_C@_0BN@OCAODDMI@pci?3?5PCI?5BIOS?5not?5detected?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BN@OCAODDMI@pci?3?5PCI?5BIOS?5not?5detected?$CB?6?$AA@ DB 'pci: PC'
	DB	'I BIOS not detected!', 0aH, 00H		; `string'
; Function compile flags: /Odsp
CONST	ENDS
;	COMDAT ?BlPciInitialize@@YIXXZ
_TEXT	SEGMENT
?BlPciInitialize@@YIXXZ PROC				; BlPciInitialize, COMDAT

; 606  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 607  :     if (BlPciCheckBios(&BlPciInstallationCheck) == FALSE) {

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?BlPciInstallationCheck@@3U_PCI_INSTALLATION_CHECK@@A ; BlPciInstallationCheck
  00008	e8 00 00 00 00	 call	 ?BlPciCheckBios@@YIEPAU_PCI_INSTALLATION_CHECK@@@Z ; BlPciCheckBios
  0000d	0f b6 c0	 movzx	 eax, al
  00010	85 c0		 test	 eax, eax
  00012	75 1a		 jne	 SHORT $LN1@BlPciIniti

; 608  : 
; 609  :         BlRtlPrintf("pci: PCI BIOS not detected!\n");

  00014	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@OCAODDMI@pci?3?5PCI?5BIOS?5not?5detected?$CB?6?$AA@
  00019	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  0001e	59		 pop	 ecx

; 610  :         BlRtlHalt();

  0001f	ba 62 02 00 00	 mov	 edx, 610		; 00000262H
  00024	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09GGGJHACA@blpci?4cpp?$AA@
  00029	e8 00 00 00 00	 call	 ?BlRtlHaltInternal@@YIXPBDK@Z ; BlRtlHaltInternal
$LN1@BlPciIniti:

; 611  :     }
; 612  : 
; 613  : #if PCI_VERBOSE
; 614  : 
; 615  :     BlRtlPrintf("PCI: PCI BIOS detected.\n"
; 616  :                 "PCI:   Version         : %u.%u\n"
; 617  :                 "PCI:   Last Bus Number : %u\n",
; 618  :                 BlPciInstallationCheck.MajorVersion,
; 619  :                 BlPciInstallationCheck.MinorVersion,
; 620  :                 BlPciInstallationCheck.LastBusNumber);
; 621  : 
; 622  : #endif
; 623  : 
; 624  :     BlPciScanDevices();

  0002e	e8 00 00 00 00	 call	 ?BlPciScanDevices@@YIXXZ ; BlPciScanDevices

; 625  : 
; 626  :     return;
; 627  : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?BlPciInitialize@@YIXXZ ENDP				; BlPciInitialize
_TEXT	ENDS
END
