; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	C:\Users\cc\source\repos\Singularity-OS\base\Boot\SingLdrPc\blfat.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?BlFatRootStart@@3KA				; BlFatRootStart
PUBLIC	?BlFatDriveId@@3EA				; BlFatDriveId
PUBLIC	?BlFatGetNextCluster@@3P6IEKPAK@ZA		; BlFatGetNextCluster
PUBLIC	?BlFatTotalSectorCount@@3KA			; BlFatTotalSectorCount
PUBLIC	?BlFatNumberOfDataClusters@@3KA			; BlFatNumberOfDataClusters
PUBLIC	?BlFatPartitionId@@3KA				; BlFatPartitionId
PUBLIC	?BlFatTableStart@@3KA				; BlFatTableStart
PUBLIC	?BlFatBytesPerCluster@@3KA			; BlFatBytesPerCluster
PUBLIC	?BlFatPartitionSize@@3KA			; BlFatPartitionSize
PUBLIC	?BlFatRootDirectory@@3PAU_FAT_DIRECTORY_ENTRY@@A ; BlFatRootDirectory
PUBLIC	?BlFatLinkTerminator@@3KA			; BlFatLinkTerminator
PUBLIC	?BlFatBootSector@@3U_FAT_BOOT_SECTOR@@A		; BlFatBootSector
PUBLIC	?BlFatNumberOfRootDirectoryEntries@@3KA		; BlFatNumberOfRootDirectoryEntries
PUBLIC	?BlFatMbr@@3U_MBR@@A				; BlFatMbr
PUBLIC	?BlFatDataStart@@3KA				; BlFatDataStart
PUBLIC	?BlFatDriveParameters@@3U_INT13_DRIVE_PARAMETERS@@A ; BlFatDriveParameters
PUBLIC	?BlFatSectorsPerCluster@@3KA			; BlFatSectorsPerCluster
PUBLIC	?BlFatTemporaryBlock@@3PAU_FAT_SECTOR@@A	; BlFatTemporaryBlock
PUBLIC	?BlFatPartitionStart@@3KA			; BlFatPartitionStart
PUBLIC	?BlFatTemporaryBlockCount@@3GA			; BlFatTemporaryBlockCount
_BSS	SEGMENT
?BlFatRootStart@@3KA DD 01H DUP (?)			; BlFatRootStart
?BlFatDriveId@@3EA DB 01H DUP (?)			; BlFatDriveId
	ALIGN	4

?BlFatGetNextCluster@@3P6IEKPAK@ZA DD 01H DUP (?)	; BlFatGetNextCluster
?BlFatTotalSectorCount@@3KA DD 01H DUP (?)		; BlFatTotalSectorCount
?BlFatNumberOfDataClusters@@3KA DD 01H DUP (?)		; BlFatNumberOfDataClusters
?BlFatPartitionId@@3KA DD 01H DUP (?)			; BlFatPartitionId
?BlFatTableStart@@3KA DD 01H DUP (?)			; BlFatTableStart
?BlFatBytesPerCluster@@3KA DD 01H DUP (?)		; BlFatBytesPerCluster
?BlFatPartitionSize@@3KA DD 01H DUP (?)			; BlFatPartitionSize
?BlFatRootDirectory@@3PAU_FAT_DIRECTORY_ENTRY@@A DD 01H DUP (?) ; BlFatRootDirectory
?BlFatLinkTerminator@@3KA DD 01H DUP (?)		; BlFatLinkTerminator
?BlFatBootSector@@3U_FAT_BOOT_SECTOR@@A DB 0200H DUP (?) ; BlFatBootSector
?BlFatNumberOfRootDirectoryEntries@@3KA DD 01H DUP (?)	; BlFatNumberOfRootDirectoryEntries
?BlFatMbr@@3U_MBR@@A DB 0200H DUP (?)			; BlFatMbr
?BlFatDataStart@@3KA DD 01H DUP (?)			; BlFatDataStart
?BlFatDriveParameters@@3U_INT13_DRIVE_PARAMETERS@@A DB 01aH DUP (?) ; BlFatDriveParameters
	ALIGN	4

?BlFatSectorsPerCluster@@3KA DD 01H DUP (?)		; BlFatSectorsPerCluster
?BlFatTemporaryBlock@@3PAU_FAT_SECTOR@@A DB 08000H DUP (?) ; BlFatTemporaryBlock
?BlFatPartitionStart@@3KA DD 01H DUP (?)		; BlFatPartitionStart
_BSS	ENDS
_DATA	SEGMENT
?BlFatTemporaryBlockCount@@3GA DW 040H			; BlFatTemporaryBlockCount
_DATA	ENDS
PUBLIC	??_C@_09PEGKEIOA@blfat?4cpp?$AA@		; `string'
PUBLIC	??_C@_0CA@LMKLIJFF@FAT?3?5Error?5reading?5disk?5image?$CB?6?$AA@ ; `string'
PUBLIC	?BlFatHaltInternal@@YIXK@Z			; BlFatHaltInternal
EXTRN	?BlRtlHaltInternal@@YIXPBDK@Z:PROC		; BlRtlHaltInternal
EXTRN	?BlRtlPrintf@@YAEPBDZZ:PROC			; BlRtlPrintf
;	COMDAT ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
; File c:\users\cc\source\repos\singularity-os\base\boot\singldrpc\blfat.cpp
CONST	SEGMENT
??_C@_09PEGKEIOA@blfat?4cpp?$AA@ DB 'blfat.cpp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LMKLIJFF@FAT?3?5Error?5reading?5disk?5image?$CB?6?$AA@
CONST	SEGMENT
??_C@_0CA@LMKLIJFF@FAT?3?5Error?5reading?5disk?5image?$CB?6?$AA@ DB 'FAT:'
	DB	' Error reading disk image!', 0aH, 00H	; `string'
; Function compile flags: /Odsp
CONST	ENDS
;	COMDAT ?BlFatHaltInternal@@YIXK@Z
_TEXT	SEGMENT
_Line$ = -4						; size = 4
?BlFatHaltInternal@@YIXK@Z PROC				; BlFatHaltInternal, COMDAT
; _Line$ = ecx

; 237  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _Line$[ebp], ecx

; 238  :     BlRtlPrintf("FAT: Error reading disk image!\n");

  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@LMKLIJFF@FAT?3?5Error?5reading?5disk?5image?$CB?6?$AA@
  0000c	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  00011	59		 pop	 ecx

; 239  :     BlRtlHaltInternal(__FILE__, Line);

  00012	8b 55 fc	 mov	 edx, DWORD PTR _Line$[ebp]
  00015	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  0001a	e8 00 00 00 00	 call	 ?BlRtlHaltInternal@@YIXPBDK@Z ; BlRtlHaltInternal

; 240  : }

  0001f	c9		 leave
  00020	c3		 ret	 0
?BlFatHaltInternal@@YIXK@Z ENDP				; BlFatHaltInternal
_TEXT	ENDS
PUBLIC	?BlFatReadSector@@YIEKKPAU_FAT_SECTOR@@@Z	; BlFatReadSector
EXTRN	?BlRtlCopyMemory@@YIXPAXPBXK@Z:PROC		; BlRtlCopyMemory
EXTRN	?BlRtlReadDrive@@YIEE_KGPAX@Z:PROC		; BlRtlReadDrive
EXTRN	?BlRtlAssertFailed@@YIXPBDK@Z:PROC		; BlRtlAssertFailed
EXTRN	?BlRtlAssertFailedPtr@@YIXPBDKK@Z:PROC		; BlRtlAssertFailedPtr
; Function compile flags: /Odsp
;	COMDAT ?BlFatReadSector@@YIEKKPAU_FAT_SECTOR@@@Z
_TEXT	SEGMENT
_NumberOfSectors$ = -12					; size = 4
_FirstSector$ = -8					; size = 4
_StepSize$ = -4						; size = 2
_Buffer$ = 8						; size = 4
?BlFatReadSector@@YIEKKPAU_FAT_SECTOR@@@Z PROC		; BlFatReadSector, COMDAT
; _FirstSector$ = ecx
; _NumberOfSectors$ = edx

; 270  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 55 f4	 mov	 DWORD PTR _NumberOfSectors$[ebp], edx
  00009	89 4d f8	 mov	 DWORD PTR _FirstSector$[ebp], ecx

; 271  :     UINT16 StepSize;
; 272  : 
; 273  :     BLASSERT_PTR(FirstSector < BlFatTotalSectorCount, FirstSector);

  0000c	8b 45 f8	 mov	 eax, DWORD PTR _FirstSector$[ebp]
  0000f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?BlFatTotalSectorCount@@3KA ; BlFatTotalSectorCount
  00015	72 12		 jb	 SHORT $LN9@BlFatReadS
  00017	ff 75 f8	 push	 DWORD PTR _FirstSector$[ebp]
  0001a	ba 11 01 00 00	 mov	 edx, 273		; 00000111H
  0001f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  00024	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN9@BlFatReadS:

; 274  : 
; 275  :     BLASSERT(NumberOfSectors > 0);

  00029	83 7d f4 00	 cmp	 DWORD PTR _NumberOfSectors$[ebp], 0
  0002d	77 0f		 ja	 SHORT $LN8@BlFatReadS
  0002f	ba 13 01 00 00	 mov	 edx, 275		; 00000113H
  00034	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  00039	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN8@BlFatReadS:

; 276  : 
; 277  :     BLASSERT(FirstSector + NumberOfSectors > FirstSector);

  0003e	8b 45 f8	 mov	 eax, DWORD PTR _FirstSector$[ebp]
  00041	03 45 f4	 add	 eax, DWORD PTR _NumberOfSectors$[ebp]
  00044	3b 45 f8	 cmp	 eax, DWORD PTR _FirstSector$[ebp]
  00047	77 0f		 ja	 SHORT $LN7@BlFatReadS
  00049	ba 15 01 00 00	 mov	 edx, 277		; 00000115H
  0004e	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  00053	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN7@BlFatReadS:

; 278  : 
; 279  :     BLASSERT((FirstSector + NumberOfSectors) < BlFatTotalSectorCount);

  00058	8b 45 f8	 mov	 eax, DWORD PTR _FirstSector$[ebp]
  0005b	03 45 f4	 add	 eax, DWORD PTR _NumberOfSectors$[ebp]
  0005e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?BlFatTotalSectorCount@@3KA ; BlFatTotalSectorCount
  00064	72 0f		 jb	 SHORT $LN5@BlFatReadS
  00066	ba 17 01 00 00	 mov	 edx, 279		; 00000117H
  0006b	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  00070	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN5@BlFatReadS:

; 280  : 
; 281  :     while (NumberOfSectors > 0) {

  00075	83 7d f4 00	 cmp	 DWORD PTR _NumberOfSectors$[ebp], 0
  00079	0f 86 87 00 00
	00		 jbe	 $LN4@BlFatReadS

; 282  : 
; 283  :         if (NumberOfSectors < BlFatTemporaryBlockCount) {

  0007f	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?BlFatTemporaryBlockCount@@3GA ; BlFatTemporaryBlockCount
  00086	39 45 f4	 cmp	 DWORD PTR _NumberOfSectors$[ebp], eax
  00089	73 0a		 jae	 SHORT $LN3@BlFatReadS

; 284  : 
; 285  :             StepSize = (UINT16) NumberOfSectors;

  0008b	66 8b 45 f4	 mov	 ax, WORD PTR _NumberOfSectors$[ebp]
  0008f	66 89 45 fc	 mov	 WORD PTR _StepSize$[ebp], ax

; 286  : 
; 287  :         } else {

  00093	eb 0a		 jmp	 SHORT $LN2@BlFatReadS
$LN3@BlFatReadS:

; 288  : 
; 289  :             StepSize = BlFatTemporaryBlockCount;

  00095	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?BlFatTemporaryBlockCount@@3GA ; BlFatTemporaryBlockCount
  0009b	66 89 45 fc	 mov	 WORD PTR _StepSize$[ebp], ax
$LN2@BlFatReadS:

; 290  :         }
; 291  : 
; 292  :         if (BlRtlReadDrive(BlFatDriveId,
; 293  :                            BlFatPartitionStart + FirstSector,
; 294  :                            StepSize,
; 295  :                            BlFatTemporaryBlock) == FALSE) {

  0009f	68 00 00 00 00	 push	 OFFSET ?BlFatTemporaryBlock@@3PAU_FAT_SECTOR@@A ; BlFatTemporaryBlock
  000a4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatPartitionStart@@3KA ; BlFatPartitionStart
  000a9	03 45 f8	 add	 eax, DWORD PTR _FirstSector$[ebp]
  000ac	33 c9		 xor	 ecx, ecx
  000ae	51		 push	 ecx
  000af	50		 push	 eax
  000b0	8b 55 fc	 mov	 edx, DWORD PTR _StepSize$[ebp]
  000b3	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?BlFatDriveId@@3EA ; BlFatDriveId
  000b9	e8 00 00 00 00	 call	 ?BlRtlReadDrive@@YIEE_KGPAX@Z ; BlRtlReadDrive
  000be	0f b6 c0	 movzx	 eax, al
  000c1	85 c0		 test	 eax, eax
  000c3	75 04		 jne	 SHORT $LN1@BlFatReadS

; 296  : 
; 297  : #if FAT_VERBOSE
; 298  : 
; 299  :             BlRtlPrintf("FAT: I/O error reading sector %u on drive 0x%02x!\n",
; 300  :                         BlFatPartitionStart + FirstSector,
; 301  :                         BlFatDriveId);
; 302  : 
; 303  : #endif
; 304  : 
; 305  :             return FALSE;

  000c5	32 c0		 xor	 al, al
  000c7	eb 3f		 jmp	 SHORT $LN10@BlFatReadS
$LN1@BlFatReadS:

; 306  :         }
; 307  : 
; 308  :         BlRtlCopyMemory(Buffer,
; 309  :                         BlFatTemporaryBlock,
; 310  :                         StepSize * FAT_SECTOR_SIZE);

  000c9	0f b7 45 fc	 movzx	 eax, WORD PTR _StepSize$[ebp]
  000cd	c1 e0 09	 shl	 eax, 9
  000d0	50		 push	 eax
  000d1	ba 00 00 00 00	 mov	 edx, OFFSET ?BlFatTemporaryBlock@@3PAU_FAT_SECTOR@@A ; BlFatTemporaryBlock
  000d6	8b 4d 08	 mov	 ecx, DWORD PTR _Buffer$[ebp]
  000d9	e8 00 00 00 00	 call	 ?BlRtlCopyMemory@@YIXPAXPBXK@Z ; BlRtlCopyMemory

; 311  : 
; 312  :         FirstSector += StepSize;

  000de	0f b7 45 fc	 movzx	 eax, WORD PTR _StepSize$[ebp]
  000e2	03 45 f8	 add	 eax, DWORD PTR _FirstSector$[ebp]
  000e5	89 45 f8	 mov	 DWORD PTR _FirstSector$[ebp], eax

; 313  :         NumberOfSectors -= StepSize;

  000e8	0f b7 45 fc	 movzx	 eax, WORD PTR _StepSize$[ebp]
  000ec	8b 4d f4	 mov	 ecx, DWORD PTR _NumberOfSectors$[ebp]
  000ef	2b c8		 sub	 ecx, eax
  000f1	89 4d f4	 mov	 DWORD PTR _NumberOfSectors$[ebp], ecx

; 314  :         Buffer += StepSize;

  000f4	0f b7 45 fc	 movzx	 eax, WORD PTR _StepSize$[ebp]
  000f8	c1 e0 09	 shl	 eax, 9
  000fb	03 45 08	 add	 eax, DWORD PTR _Buffer$[ebp]
  000fe	89 45 08	 mov	 DWORD PTR _Buffer$[ebp], eax

; 315  :     }

  00101	e9 6f ff ff ff	 jmp	 $LN5@BlFatReadS
$LN4@BlFatReadS:

; 316  : 
; 317  :     return TRUE;

  00106	b0 01		 mov	 al, 1
$LN10@BlFatReadS:

; 318  : }

  00108	c9		 leave
  00109	c2 04 00	 ret	 4
?BlFatReadSector@@YIEKKPAU_FAT_SECTOR@@@Z ENDP		; BlFatReadSector
_TEXT	ENDS
PUBLIC	?BlFatDirectoryEntryToName@@YIEPAU_FAT_DIRECTORY_ENTRY@@PAU_FAT_NAME@@0@Z ; BlFatDirectoryEntryToName
; Function compile flags: /Odsp
;	COMDAT ?BlFatDirectoryEntryToName@@YIEPAU_FAT_DIRECTORY_ENTRY@@PAU_FAT_NAME@@0@Z
_TEXT	SEGMENT
_Name$ = -28						; size = 4
_ShortEntry$ = -24					; size = 4
_Entry$ = -20						; size = 4
_LongNameComponentIndex$ = -13				; size = 1
_SourceIndex$ = -12					; size = 4
_TargetIndex$ = -8					; size = 4
_Character$ = -1					; size = 1
_TableStart$ = 8					; size = 4
?BlFatDirectoryEntryToName@@YIEPAU_FAT_DIRECTORY_ENTRY@@PAU_FAT_NAME@@0@Z PROC ; BlFatDirectoryEntryToName, COMDAT
; _ShortEntry$ = ecx
; _Name$ = edx

; 348  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 55 e4	 mov	 DWORD PTR _Name$[ebp], edx
  00009	89 4d e8	 mov	 DWORD PTR _ShortEntry$[ebp], ecx

; 349  :     UINT8 Character;
; 350  :     PFAT_DIRECTORY_ENTRY Entry;
; 351  :     UINT8 LongNameComponentIndex;
; 352  :     UINT32 SourceIndex;
; 353  :     UINT32 TargetIndex;
; 354  : 
; 355  :     if ((ShortEntry->u1.Short.Attribute & FAT_ATTRIBUTE_MASK) == FAT_ATTRIBUTE_LONG_NAME) {

  0000c	8b 45 e8	 mov	 eax, DWORD PTR _ShortEntry$[ebp]
  0000f	0f b6 40 0b	 movzx	 eax, BYTE PTR [eax+11]
  00013	83 e0 3f	 and	 eax, 63			; 0000003fH
  00016	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00019	75 07		 jne	 SHORT $LN47@BlFatDirec

; 356  : 
; 357  :         return FALSE;

  0001b	32 c0		 xor	 al, al
  0001d	e9 a6 04 00 00	 jmp	 $LN48@BlFatDirec
$LN47@BlFatDirec:

; 358  :     }
; 359  : 
; 360  :     //
; 361  :     // Extract short name.
; 362  :     //
; 363  : 
; 364  :     TargetIndex = 0;

  00022	83 65 f8 00	 and	 DWORD PTR _TargetIndex$[ebp], 0

; 365  : 
; 366  :     for (SourceIndex = 0; SourceIndex < 8; SourceIndex += 1) {

  00026	83 65 f4 00	 and	 DWORD PTR _SourceIndex$[ebp], 0
  0002a	eb 07		 jmp	 SHORT $LN46@BlFatDirec
$LN45@BlFatDirec:
  0002c	8b 45 f4	 mov	 eax, DWORD PTR _SourceIndex$[ebp]
  0002f	40		 inc	 eax
  00030	89 45 f4	 mov	 DWORD PTR _SourceIndex$[ebp], eax
$LN46@BlFatDirec:
  00033	83 7d f4 08	 cmp	 DWORD PTR _SourceIndex$[ebp], 8
  00037	73 47		 jae	 SHORT $LN44@BlFatDirec

; 367  : 
; 368  :         Character = ShortEntry->u1.Short.Name[SourceIndex];

  00039	8b 45 e8	 mov	 eax, DWORD PTR _ShortEntry$[ebp]
  0003c	03 45 f4	 add	 eax, DWORD PTR _SourceIndex$[ebp]
  0003f	8a 00		 mov	 al, BYTE PTR [eax]
  00041	88 45 ff	 mov	 BYTE PTR _Character$[ebp], al

; 369  : 
; 370  :         if (Character == ' ') {

  00044	0f b6 45 ff	 movzx	 eax, BYTE PTR _Character$[ebp]
  00048	83 f8 20	 cmp	 eax, 32			; 00000020H
  0004b	75 0f		 jne	 SHORT $LN43@BlFatDirec

; 371  : 
; 372  :             if (SourceIndex == 0) {

  0004d	83 7d f4 00	 cmp	 DWORD PTR _SourceIndex$[ebp], 0
  00051	75 07		 jne	 SHORT $LN42@BlFatDirec

; 373  : 
; 374  :                 return FALSE;

  00053	32 c0		 xor	 al, al
  00055	e9 6e 04 00 00	 jmp	 $LN48@BlFatDirec
$LN42@BlFatDirec:

; 375  :             }
; 376  : 
; 377  :             break;

  0005a	eb 24		 jmp	 SHORT $LN44@BlFatDirec
$LN43@BlFatDirec:

; 378  :         }
; 379  : 
; 380  :         if (Character == '.') {

  0005c	0f b6 45 ff	 movzx	 eax, BYTE PTR _Character$[ebp]
  00060	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00063	75 07		 jne	 SHORT $LN41@BlFatDirec

; 381  : 
; 382  :             return FALSE;

  00065	32 c0		 xor	 al, al
  00067	e9 5c 04 00 00	 jmp	 $LN48@BlFatDirec
$LN41@BlFatDirec:

; 383  :         }
; 384  : 
; 385  :         Name->ShortName[TargetIndex] = Character;

  0006c	8b 45 e4	 mov	 eax, DWORD PTR _Name$[ebp]
  0006f	03 45 f8	 add	 eax, DWORD PTR _TargetIndex$[ebp]
  00072	8a 4d ff	 mov	 cl, BYTE PTR _Character$[ebp]
  00075	88 08		 mov	 BYTE PTR [eax], cl

; 386  :         TargetIndex += 1;

  00077	8b 45 f8	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  0007a	40		 inc	 eax
  0007b	89 45 f8	 mov	 DWORD PTR _TargetIndex$[ebp], eax

; 387  :     }

  0007e	eb ac		 jmp	 SHORT $LN45@BlFatDirec
$LN44@BlFatDirec:

; 388  : 
; 389  :     if (ShortEntry->u1.Short.Name[8] != ' ') {

  00080	8b 45 e8	 mov	 eax, DWORD PTR _ShortEntry$[ebp]
  00083	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  00087	83 f8 20	 cmp	 eax, 32			; 00000020H
  0008a	74 60		 je	 SHORT $LN40@BlFatDirec

; 390  : 
; 391  :         Name->ShortName[TargetIndex] = '.';

  0008c	8b 45 e4	 mov	 eax, DWORD PTR _Name$[ebp]
  0008f	03 45 f8	 add	 eax, DWORD PTR _TargetIndex$[ebp]
  00092	c6 00 2e	 mov	 BYTE PTR [eax], 46	; 0000002eH

; 392  :         TargetIndex += 1;

  00095	8b 45 f8	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  00098	40		 inc	 eax
  00099	89 45 f8	 mov	 DWORD PTR _TargetIndex$[ebp], eax

; 393  : 
; 394  :         for (SourceIndex = 8; SourceIndex < 11; SourceIndex += 1) {

  0009c	c7 45 f4 08 00
	00 00		 mov	 DWORD PTR _SourceIndex$[ebp], 8
  000a3	eb 07		 jmp	 SHORT $LN39@BlFatDirec
$LN38@BlFatDirec:
  000a5	8b 45 f4	 mov	 eax, DWORD PTR _SourceIndex$[ebp]
  000a8	40		 inc	 eax
  000a9	89 45 f4	 mov	 DWORD PTR _SourceIndex$[ebp], eax
$LN39@BlFatDirec:
  000ac	83 7d f4 0b	 cmp	 DWORD PTR _SourceIndex$[ebp], 11 ; 0000000bH
  000b0	73 3a		 jae	 SHORT $LN40@BlFatDirec

; 395  : 
; 396  :             Character = ShortEntry->u1.Short.Name[SourceIndex];

  000b2	8b 45 e8	 mov	 eax, DWORD PTR _ShortEntry$[ebp]
  000b5	03 45 f4	 add	 eax, DWORD PTR _SourceIndex$[ebp]
  000b8	8a 00		 mov	 al, BYTE PTR [eax]
  000ba	88 45 ff	 mov	 BYTE PTR _Character$[ebp], al

; 397  : 
; 398  :             if (Character == ' ') {

  000bd	0f b6 45 ff	 movzx	 eax, BYTE PTR _Character$[ebp]
  000c1	83 f8 20	 cmp	 eax, 32			; 00000020H
  000c4	75 02		 jne	 SHORT $LN36@BlFatDirec

; 399  : 
; 400  :                 break;

  000c6	eb 24		 jmp	 SHORT $LN40@BlFatDirec
$LN36@BlFatDirec:

; 401  :             }
; 402  : 
; 403  :             if (Character == '.') {

  000c8	0f b6 45 ff	 movzx	 eax, BYTE PTR _Character$[ebp]
  000cc	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  000cf	75 07		 jne	 SHORT $LN35@BlFatDirec

; 404  : 
; 405  :                 return FALSE;

  000d1	32 c0		 xor	 al, al
  000d3	e9 f0 03 00 00	 jmp	 $LN48@BlFatDirec
$LN35@BlFatDirec:

; 406  :             }
; 407  : 
; 408  :             Name->ShortName[TargetIndex] = Character;

  000d8	8b 45 e4	 mov	 eax, DWORD PTR _Name$[ebp]
  000db	03 45 f8	 add	 eax, DWORD PTR _TargetIndex$[ebp]
  000de	8a 4d ff	 mov	 cl, BYTE PTR _Character$[ebp]
  000e1	88 08		 mov	 BYTE PTR [eax], cl

; 409  :             TargetIndex += 1;

  000e3	8b 45 f8	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  000e6	40		 inc	 eax
  000e7	89 45 f8	 mov	 DWORD PTR _TargetIndex$[ebp], eax

; 410  :         }

  000ea	eb b9		 jmp	 SHORT $LN38@BlFatDirec
$LN40@BlFatDirec:

; 411  :     }
; 412  : 
; 413  :     Name->ShortName[TargetIndex] = 0;

  000ec	8b 45 e4	 mov	 eax, DWORD PTR _Name$[ebp]
  000ef	03 45 f8	 add	 eax, DWORD PTR _TargetIndex$[ebp]
  000f2	c6 00 00	 mov	 BYTE PTR [eax], 0

; 414  : 
; 415  :     //
; 416  :     // If there is a long name, extract it by walking backwards from the short entry.
; 417  :     // Otherwise, set long name to empty string.
; 418  :     //
; 419  : 
; 420  :     Name->LongName[0] = 0;

  000f5	8b 45 e4	 mov	 eax, DWORD PTR _Name$[ebp]
  000f8	c6 40 0d 00	 mov	 BYTE PTR [eax+13], 0

; 421  : 
; 422  :     Entry = ShortEntry - 1;

  000fc	8b 45 e8	 mov	 eax, DWORD PTR _ShortEntry$[ebp]
  000ff	83 e8 20	 sub	 eax, 32			; 00000020H
  00102	89 45 ec	 mov	 DWORD PTR _Entry$[ebp], eax

; 423  : 
; 424  :     if (Entry < TableStart) {

  00105	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  00108	3b 45 08	 cmp	 eax, DWORD PTR _TableStart$[ebp]
  0010b	73 07		 jae	 SHORT $LN34@BlFatDirec

; 425  : 
; 426  :         return TRUE;

  0010d	b0 01		 mov	 al, 1
  0010f	e9 b4 03 00 00	 jmp	 $LN48@BlFatDirec
$LN34@BlFatDirec:

; 427  :     }
; 428  : 
; 429  :     if ((Entry->u1.Short.Attribute & FAT_ATTRIBUTE_MASK) != FAT_ATTRIBUTE_LONG_NAME) {

  00114	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  00117	0f b6 40 0b	 movzx	 eax, BYTE PTR [eax+11]
  0011b	83 e0 3f	 and	 eax, 63			; 0000003fH
  0011e	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00121	74 07		 je	 SHORT $LN33@BlFatDirec

; 430  : 
; 431  :         return TRUE;

  00123	b0 01		 mov	 al, 1
  00125	e9 9e 03 00 00	 jmp	 $LN48@BlFatDirec
$LN33@BlFatDirec:

; 432  :     }
; 433  : 
; 434  :     LongNameComponentIndex = 1;

  0012a	c6 45 f3 01	 mov	 BYTE PTR _LongNameComponentIndex$[ebp], 1

; 435  :     TargetIndex = 0;

  0012e	83 65 f8 00	 and	 DWORD PTR _TargetIndex$[ebp], 0
$LN32@BlFatDirec:

; 436  : 
; 437  :     for (;;) {
; 438  : 
; 439  :         if (TargetIndex == FAT_MAX_PATH) {

  00132	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _TargetIndex$[ebp], 255 ; 000000ffH
  00139	75 07		 jne	 SHORT $LN30@BlFatDirec

; 440  : 
; 441  :             return FALSE;

  0013b	32 c0		 xor	 al, al
  0013d	e9 86 03 00 00	 jmp	 $LN48@BlFatDirec
$LN30@BlFatDirec:

; 442  :         }
; 443  : 
; 444  :         if (Entry < TableStart) {

  00142	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  00145	3b 45 08	 cmp	 eax, DWORD PTR _TableStart$[ebp]
  00148	73 07		 jae	 SHORT $LN29@BlFatDirec

; 445  : 
; 446  :             return FALSE;

  0014a	32 c0		 xor	 al, al
  0014c	e9 77 03 00 00	 jmp	 $LN48@BlFatDirec
$LN29@BlFatDirec:

; 447  :         }
; 448  : 
; 449  :         if ((Entry->u1.Long.Order & FAT_LONG_NAME_ORDER_MASK) != LongNameComponentIndex) {

  00151	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  00154	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00157	83 e0 3f	 and	 eax, 63			; 0000003fH
  0015a	0f b6 4d f3	 movzx	 ecx, BYTE PTR _LongNameComponentIndex$[ebp]
  0015e	3b c1		 cmp	 eax, ecx
  00160	74 07		 je	 SHORT $LN28@BlFatDirec

; 450  : 
; 451  :             return FALSE;

  00162	32 c0		 xor	 al, al
  00164	e9 5f 03 00 00	 jmp	 $LN48@BlFatDirec
$LN28@BlFatDirec:

; 452  :         }
; 453  : 
; 454  : #define ADD_CHARACTER(C)                                \
; 455  :                                                         \
; 456  :         if (TargetIndex == FAT_MAX_PATH) {              \
; 457  :                                                         \
; 458  :             return FALSE;                               \
; 459  :         }                                               \
; 460  :                                                         \
; 461  :         if (((C) != 0) && ((C) != 0xFFFF)) {            \
; 462  :                                                         \
; 463  :             Name->LongName[TargetIndex] = (UINT8) (C);  \
; 464  :             TargetIndex += 1;                           \
; 465  :         }
; 466  : 
; 467  :         ADD_CHARACTER(Entry->u1.Long.NameW1_5[0]);

  00169	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _TargetIndex$[ebp], 255 ; 000000ffH
  00170	75 07		 jne	 SHORT $LN27@BlFatDirec
  00172	32 c0		 xor	 al, al
  00174	e9 4f 03 00 00	 jmp	 $LN48@BlFatDirec
$LN27@BlFatDirec:
  00179	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  0017c	0f b7 40 01	 movzx	 eax, WORD PTR [eax+1]
  00180	85 c0		 test	 eax, eax
  00182	74 24		 je	 SHORT $LN26@BlFatDirec
  00184	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  00187	0f b7 40 01	 movzx	 eax, WORD PTR [eax+1]
  0018b	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00190	74 16		 je	 SHORT $LN26@BlFatDirec
  00192	8b 45 e4	 mov	 eax, DWORD PTR _Name$[ebp]
  00195	03 45 f8	 add	 eax, DWORD PTR _TargetIndex$[ebp]
  00198	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0019b	8a 49 01	 mov	 cl, BYTE PTR [ecx+1]
  0019e	88 48 0d	 mov	 BYTE PTR [eax+13], cl
  001a1	8b 45 f8	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  001a4	40		 inc	 eax
  001a5	89 45 f8	 mov	 DWORD PTR _TargetIndex$[ebp], eax
$LN26@BlFatDirec:

; 468  :         ADD_CHARACTER(Entry->u1.Long.NameW1_5[1]);

  001a8	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _TargetIndex$[ebp], 255 ; 000000ffH
  001af	75 07		 jne	 SHORT $LN25@BlFatDirec
  001b1	32 c0		 xor	 al, al
  001b3	e9 10 03 00 00	 jmp	 $LN48@BlFatDirec
$LN25@BlFatDirec:
  001b8	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  001bb	0f b7 40 03	 movzx	 eax, WORD PTR [eax+3]
  001bf	85 c0		 test	 eax, eax
  001c1	74 24		 je	 SHORT $LN24@BlFatDirec
  001c3	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  001c6	0f b7 40 03	 movzx	 eax, WORD PTR [eax+3]
  001ca	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  001cf	74 16		 je	 SHORT $LN24@BlFatDirec
  001d1	8b 45 e4	 mov	 eax, DWORD PTR _Name$[ebp]
  001d4	03 45 f8	 add	 eax, DWORD PTR _TargetIndex$[ebp]
  001d7	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  001da	8a 49 03	 mov	 cl, BYTE PTR [ecx+3]
  001dd	88 48 0d	 mov	 BYTE PTR [eax+13], cl
  001e0	8b 45 f8	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  001e3	40		 inc	 eax
  001e4	89 45 f8	 mov	 DWORD PTR _TargetIndex$[ebp], eax
$LN24@BlFatDirec:

; 469  :         ADD_CHARACTER(Entry->u1.Long.NameW1_5[2]);

  001e7	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _TargetIndex$[ebp], 255 ; 000000ffH
  001ee	75 07		 jne	 SHORT $LN23@BlFatDirec
  001f0	32 c0		 xor	 al, al
  001f2	e9 d1 02 00 00	 jmp	 $LN48@BlFatDirec
$LN23@BlFatDirec:
  001f7	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  001fa	0f b7 40 05	 movzx	 eax, WORD PTR [eax+5]
  001fe	85 c0		 test	 eax, eax
  00200	74 24		 je	 SHORT $LN22@BlFatDirec
  00202	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  00205	0f b7 40 05	 movzx	 eax, WORD PTR [eax+5]
  00209	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  0020e	74 16		 je	 SHORT $LN22@BlFatDirec
  00210	8b 45 e4	 mov	 eax, DWORD PTR _Name$[ebp]
  00213	03 45 f8	 add	 eax, DWORD PTR _TargetIndex$[ebp]
  00216	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00219	8a 49 05	 mov	 cl, BYTE PTR [ecx+5]
  0021c	88 48 0d	 mov	 BYTE PTR [eax+13], cl
  0021f	8b 45 f8	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  00222	40		 inc	 eax
  00223	89 45 f8	 mov	 DWORD PTR _TargetIndex$[ebp], eax
$LN22@BlFatDirec:

; 470  :         ADD_CHARACTER(Entry->u1.Long.NameW1_5[3]);

  00226	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _TargetIndex$[ebp], 255 ; 000000ffH
  0022d	75 07		 jne	 SHORT $LN21@BlFatDirec
  0022f	32 c0		 xor	 al, al
  00231	e9 92 02 00 00	 jmp	 $LN48@BlFatDirec
$LN21@BlFatDirec:
  00236	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  00239	0f b7 40 07	 movzx	 eax, WORD PTR [eax+7]
  0023d	85 c0		 test	 eax, eax
  0023f	74 24		 je	 SHORT $LN20@BlFatDirec
  00241	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  00244	0f b7 40 07	 movzx	 eax, WORD PTR [eax+7]
  00248	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  0024d	74 16		 je	 SHORT $LN20@BlFatDirec
  0024f	8b 45 e4	 mov	 eax, DWORD PTR _Name$[ebp]
  00252	03 45 f8	 add	 eax, DWORD PTR _TargetIndex$[ebp]
  00255	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00258	8a 49 07	 mov	 cl, BYTE PTR [ecx+7]
  0025b	88 48 0d	 mov	 BYTE PTR [eax+13], cl
  0025e	8b 45 f8	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  00261	40		 inc	 eax
  00262	89 45 f8	 mov	 DWORD PTR _TargetIndex$[ebp], eax
$LN20@BlFatDirec:

; 471  :         ADD_CHARACTER(Entry->u1.Long.NameW1_5[4]);

  00265	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _TargetIndex$[ebp], 255 ; 000000ffH
  0026c	75 07		 jne	 SHORT $LN19@BlFatDirec
  0026e	32 c0		 xor	 al, al
  00270	e9 53 02 00 00	 jmp	 $LN48@BlFatDirec
$LN19@BlFatDirec:
  00275	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  00278	0f b7 40 09	 movzx	 eax, WORD PTR [eax+9]
  0027c	85 c0		 test	 eax, eax
  0027e	74 24		 je	 SHORT $LN18@BlFatDirec
  00280	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  00283	0f b7 40 09	 movzx	 eax, WORD PTR [eax+9]
  00287	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  0028c	74 16		 je	 SHORT $LN18@BlFatDirec
  0028e	8b 45 e4	 mov	 eax, DWORD PTR _Name$[ebp]
  00291	03 45 f8	 add	 eax, DWORD PTR _TargetIndex$[ebp]
  00294	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00297	8a 49 09	 mov	 cl, BYTE PTR [ecx+9]
  0029a	88 48 0d	 mov	 BYTE PTR [eax+13], cl
  0029d	8b 45 f8	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  002a0	40		 inc	 eax
  002a1	89 45 f8	 mov	 DWORD PTR _TargetIndex$[ebp], eax
$LN18@BlFatDirec:

; 472  :         ADD_CHARACTER(Entry->u1.Long.NameW6_11[0]);

  002a4	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _TargetIndex$[ebp], 255 ; 000000ffH
  002ab	75 07		 jne	 SHORT $LN17@BlFatDirec
  002ad	32 c0		 xor	 al, al
  002af	e9 14 02 00 00	 jmp	 $LN48@BlFatDirec
$LN17@BlFatDirec:
  002b4	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  002b7	0f b7 40 0e	 movzx	 eax, WORD PTR [eax+14]
  002bb	85 c0		 test	 eax, eax
  002bd	74 24		 je	 SHORT $LN16@BlFatDirec
  002bf	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  002c2	0f b7 40 0e	 movzx	 eax, WORD PTR [eax+14]
  002c6	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  002cb	74 16		 je	 SHORT $LN16@BlFatDirec
  002cd	8b 45 e4	 mov	 eax, DWORD PTR _Name$[ebp]
  002d0	03 45 f8	 add	 eax, DWORD PTR _TargetIndex$[ebp]
  002d3	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  002d6	8a 49 0e	 mov	 cl, BYTE PTR [ecx+14]
  002d9	88 48 0d	 mov	 BYTE PTR [eax+13], cl
  002dc	8b 45 f8	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  002df	40		 inc	 eax
  002e0	89 45 f8	 mov	 DWORD PTR _TargetIndex$[ebp], eax
$LN16@BlFatDirec:

; 473  :         ADD_CHARACTER(Entry->u1.Long.NameW6_11[1]);

  002e3	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _TargetIndex$[ebp], 255 ; 000000ffH
  002ea	75 07		 jne	 SHORT $LN15@BlFatDirec
  002ec	32 c0		 xor	 al, al
  002ee	e9 d5 01 00 00	 jmp	 $LN48@BlFatDirec
$LN15@BlFatDirec:
  002f3	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  002f6	0f b7 40 10	 movzx	 eax, WORD PTR [eax+16]
  002fa	85 c0		 test	 eax, eax
  002fc	74 24		 je	 SHORT $LN14@BlFatDirec
  002fe	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  00301	0f b7 40 10	 movzx	 eax, WORD PTR [eax+16]
  00305	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  0030a	74 16		 je	 SHORT $LN14@BlFatDirec
  0030c	8b 45 e4	 mov	 eax, DWORD PTR _Name$[ebp]
  0030f	03 45 f8	 add	 eax, DWORD PTR _TargetIndex$[ebp]
  00312	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00315	8a 49 10	 mov	 cl, BYTE PTR [ecx+16]
  00318	88 48 0d	 mov	 BYTE PTR [eax+13], cl
  0031b	8b 45 f8	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  0031e	40		 inc	 eax
  0031f	89 45 f8	 mov	 DWORD PTR _TargetIndex$[ebp], eax
$LN14@BlFatDirec:

; 474  :         ADD_CHARACTER(Entry->u1.Long.NameW6_11[2]);

  00322	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _TargetIndex$[ebp], 255 ; 000000ffH
  00329	75 07		 jne	 SHORT $LN13@BlFatDirec
  0032b	32 c0		 xor	 al, al
  0032d	e9 96 01 00 00	 jmp	 $LN48@BlFatDirec
$LN13@BlFatDirec:
  00332	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  00335	0f b7 40 12	 movzx	 eax, WORD PTR [eax+18]
  00339	85 c0		 test	 eax, eax
  0033b	74 24		 je	 SHORT $LN12@BlFatDirec
  0033d	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  00340	0f b7 40 12	 movzx	 eax, WORD PTR [eax+18]
  00344	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00349	74 16		 je	 SHORT $LN12@BlFatDirec
  0034b	8b 45 e4	 mov	 eax, DWORD PTR _Name$[ebp]
  0034e	03 45 f8	 add	 eax, DWORD PTR _TargetIndex$[ebp]
  00351	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00354	8a 49 12	 mov	 cl, BYTE PTR [ecx+18]
  00357	88 48 0d	 mov	 BYTE PTR [eax+13], cl
  0035a	8b 45 f8	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  0035d	40		 inc	 eax
  0035e	89 45 f8	 mov	 DWORD PTR _TargetIndex$[ebp], eax
$LN12@BlFatDirec:

; 475  :         ADD_CHARACTER(Entry->u1.Long.NameW6_11[3]);

  00361	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _TargetIndex$[ebp], 255 ; 000000ffH
  00368	75 07		 jne	 SHORT $LN11@BlFatDirec
  0036a	32 c0		 xor	 al, al
  0036c	e9 57 01 00 00	 jmp	 $LN48@BlFatDirec
$LN11@BlFatDirec:
  00371	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  00374	0f b7 40 14	 movzx	 eax, WORD PTR [eax+20]
  00378	85 c0		 test	 eax, eax
  0037a	74 24		 je	 SHORT $LN10@BlFatDirec
  0037c	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  0037f	0f b7 40 14	 movzx	 eax, WORD PTR [eax+20]
  00383	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00388	74 16		 je	 SHORT $LN10@BlFatDirec
  0038a	8b 45 e4	 mov	 eax, DWORD PTR _Name$[ebp]
  0038d	03 45 f8	 add	 eax, DWORD PTR _TargetIndex$[ebp]
  00390	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00393	8a 49 14	 mov	 cl, BYTE PTR [ecx+20]
  00396	88 48 0d	 mov	 BYTE PTR [eax+13], cl
  00399	8b 45 f8	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  0039c	40		 inc	 eax
  0039d	89 45 f8	 mov	 DWORD PTR _TargetIndex$[ebp], eax
$LN10@BlFatDirec:

; 476  :         ADD_CHARACTER(Entry->u1.Long.NameW6_11[4]);

  003a0	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _TargetIndex$[ebp], 255 ; 000000ffH
  003a7	75 07		 jne	 SHORT $LN9@BlFatDirec
  003a9	32 c0		 xor	 al, al
  003ab	e9 18 01 00 00	 jmp	 $LN48@BlFatDirec
$LN9@BlFatDirec:
  003b0	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  003b3	0f b7 40 16	 movzx	 eax, WORD PTR [eax+22]
  003b7	85 c0		 test	 eax, eax
  003b9	74 24		 je	 SHORT $LN8@BlFatDirec
  003bb	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  003be	0f b7 40 16	 movzx	 eax, WORD PTR [eax+22]
  003c2	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  003c7	74 16		 je	 SHORT $LN8@BlFatDirec
  003c9	8b 45 e4	 mov	 eax, DWORD PTR _Name$[ebp]
  003cc	03 45 f8	 add	 eax, DWORD PTR _TargetIndex$[ebp]
  003cf	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  003d2	8a 49 16	 mov	 cl, BYTE PTR [ecx+22]
  003d5	88 48 0d	 mov	 BYTE PTR [eax+13], cl
  003d8	8b 45 f8	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  003db	40		 inc	 eax
  003dc	89 45 f8	 mov	 DWORD PTR _TargetIndex$[ebp], eax
$LN8@BlFatDirec:

; 477  :         ADD_CHARACTER(Entry->u1.Long.NameW6_11[5]);

  003df	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _TargetIndex$[ebp], 255 ; 000000ffH
  003e6	75 07		 jne	 SHORT $LN7@BlFatDirec
  003e8	32 c0		 xor	 al, al
  003ea	e9 d9 00 00 00	 jmp	 $LN48@BlFatDirec
$LN7@BlFatDirec:
  003ef	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  003f2	0f b7 40 18	 movzx	 eax, WORD PTR [eax+24]
  003f6	85 c0		 test	 eax, eax
  003f8	74 24		 je	 SHORT $LN6@BlFatDirec
  003fa	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  003fd	0f b7 40 18	 movzx	 eax, WORD PTR [eax+24]
  00401	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00406	74 16		 je	 SHORT $LN6@BlFatDirec
  00408	8b 45 e4	 mov	 eax, DWORD PTR _Name$[ebp]
  0040b	03 45 f8	 add	 eax, DWORD PTR _TargetIndex$[ebp]
  0040e	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00411	8a 49 18	 mov	 cl, BYTE PTR [ecx+24]
  00414	88 48 0d	 mov	 BYTE PTR [eax+13], cl
  00417	8b 45 f8	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  0041a	40		 inc	 eax
  0041b	89 45 f8	 mov	 DWORD PTR _TargetIndex$[ebp], eax
$LN6@BlFatDirec:

; 478  :         ADD_CHARACTER(Entry->u1.Long.NameW12_13[0]);

  0041e	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _TargetIndex$[ebp], 255 ; 000000ffH
  00425	75 07		 jne	 SHORT $LN5@BlFatDirec
  00427	32 c0		 xor	 al, al
  00429	e9 9a 00 00 00	 jmp	 $LN48@BlFatDirec
$LN5@BlFatDirec:
  0042e	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  00431	0f b7 40 1c	 movzx	 eax, WORD PTR [eax+28]
  00435	85 c0		 test	 eax, eax
  00437	74 24		 je	 SHORT $LN4@BlFatDirec
  00439	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  0043c	0f b7 40 1c	 movzx	 eax, WORD PTR [eax+28]
  00440	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00445	74 16		 je	 SHORT $LN4@BlFatDirec
  00447	8b 45 e4	 mov	 eax, DWORD PTR _Name$[ebp]
  0044a	03 45 f8	 add	 eax, DWORD PTR _TargetIndex$[ebp]
  0044d	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00450	8a 49 1c	 mov	 cl, BYTE PTR [ecx+28]
  00453	88 48 0d	 mov	 BYTE PTR [eax+13], cl
  00456	8b 45 f8	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  00459	40		 inc	 eax
  0045a	89 45 f8	 mov	 DWORD PTR _TargetIndex$[ebp], eax
$LN4@BlFatDirec:

; 479  :         ADD_CHARACTER(Entry->u1.Long.NameW12_13[1]);

  0045d	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _TargetIndex$[ebp], 255 ; 000000ffH
  00464	75 04		 jne	 SHORT $LN3@BlFatDirec
  00466	32 c0		 xor	 al, al
  00468	eb 5e		 jmp	 SHORT $LN48@BlFatDirec
$LN3@BlFatDirec:
  0046a	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  0046d	0f b7 40 1e	 movzx	 eax, WORD PTR [eax+30]
  00471	85 c0		 test	 eax, eax
  00473	74 24		 je	 SHORT $LN2@BlFatDirec
  00475	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  00478	0f b7 40 1e	 movzx	 eax, WORD PTR [eax+30]
  0047c	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00481	74 16		 je	 SHORT $LN2@BlFatDirec
  00483	8b 45 e4	 mov	 eax, DWORD PTR _Name$[ebp]
  00486	03 45 f8	 add	 eax, DWORD PTR _TargetIndex$[ebp]
  00489	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0048c	8a 49 1e	 mov	 cl, BYTE PTR [ecx+30]
  0048f	88 48 0d	 mov	 BYTE PTR [eax+13], cl
  00492	8b 45 f8	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  00495	40		 inc	 eax
  00496	89 45 f8	 mov	 DWORD PTR _TargetIndex$[ebp], eax
$LN2@BlFatDirec:

; 480  : 
; 481  : #undef ADD_CHARACTER
; 482  : 
; 483  :         if ((Entry->u1.Long.Order & FAT_LONG_NAME_TERMINATOR)) {

  00499	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  0049c	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0049f	83 e0 40	 and	 eax, 64			; 00000040H
  004a2	74 02		 je	 SHORT $LN1@BlFatDirec

; 484  : 
; 485  :             break;

  004a4	eb 16		 jmp	 SHORT $LN31@BlFatDirec
$LN1@BlFatDirec:

; 486  :         }
; 487  : 
; 488  :         Entry -= 1;

  004a6	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  004a9	83 e8 20	 sub	 eax, 32			; 00000020H
  004ac	89 45 ec	 mov	 DWORD PTR _Entry$[ebp], eax

; 489  :         LongNameComponentIndex += 1;

  004af	0f b6 45 f3	 movzx	 eax, BYTE PTR _LongNameComponentIndex$[ebp]
  004b3	40		 inc	 eax
  004b4	88 45 f3	 mov	 BYTE PTR _LongNameComponentIndex$[ebp], al

; 490  :     }

  004b7	e9 76 fc ff ff	 jmp	 $LN32@BlFatDirec
$LN31@BlFatDirec:

; 491  : 
; 492  :     Name->LongName[TargetIndex] = 0;

  004bc	8b 45 e4	 mov	 eax, DWORD PTR _Name$[ebp]
  004bf	03 45 f8	 add	 eax, DWORD PTR _TargetIndex$[ebp]
  004c2	c6 40 0d 00	 mov	 BYTE PTR [eax+13], 0

; 493  : 
; 494  :     return TRUE;

  004c6	b0 01		 mov	 al, 1
$LN48@BlFatDirec:

; 495  : }

  004c8	c9		 leave
  004c9	c2 04 00	 ret	 4
?BlFatDirectoryEntryToName@@YIEPAU_FAT_DIRECTORY_ENTRY@@PAU_FAT_NAME@@0@Z ENDP ; BlFatDirectoryEntryToName
_TEXT	ENDS
PUBLIC	?BlFatFindDirectoryTableEntry@@YIPAU_FAT_DIRECTORY_ENTRY@@PAU1@KPBD@Z ; BlFatFindDirectoryTableEntry
EXTRN	?BlRtlEqualStringI@@YIEPBD0@Z:PROC		; BlRtlEqualStringI
; Function compile flags: /Odsp
;	COMDAT ?BlFatFindDirectoryTableEntry@@YIPAU_FAT_DIRECTORY_ENTRY@@PAU1@KPBD@Z
_TEXT	SEGMENT
_NumberOfEntries$ = -292				; size = 4
_Table$ = -288						; size = 4
_Entry$ = -284						; size = 4
_EntryName$ = -280					; size = 269
_Limit$ = -4						; size = 4
_Name$ = 8						; size = 4
?BlFatFindDirectoryTableEntry@@YIPAU_FAT_DIRECTORY_ENTRY@@PAU1@KPBD@Z PROC ; BlFatFindDirectoryTableEntry, COMDAT
; _Table$ = ecx
; _NumberOfEntries$ = edx

; 525  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00009	89 95 dc fe ff
	ff		 mov	 DWORD PTR _NumberOfEntries$[ebp], edx
  0000f	89 8d e0 fe ff
	ff		 mov	 DWORD PTR _Table$[ebp], ecx

; 526  :     PFAT_DIRECTORY_ENTRY Entry;
; 527  :     FAT_NAME EntryName;
; 528  :     PFAT_DIRECTORY_ENTRY Limit;
; 529  : 
; 530  :     BLASSERT(Name[0] != 0);

  00015	8b 45 08	 mov	 eax, DWORD PTR _Name$[ebp]
  00018	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0001b	85 c0		 test	 eax, eax
  0001d	75 0f		 jne	 SHORT $LN11@BlFatFindD
  0001f	ba 12 02 00 00	 mov	 edx, 530		; 00000212H
  00024	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  00029	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN11@BlFatFindD:

; 531  : 
; 532  :     Limit = Table + NumberOfEntries;

  0002e	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _NumberOfEntries$[ebp]
  00034	c1 e0 05	 shl	 eax, 5
  00037	03 85 e0 fe ff
	ff		 add	 eax, DWORD PTR _Table$[ebp]
  0003d	89 45 fc	 mov	 DWORD PTR _Limit$[ebp], eax

; 533  : 
; 534  :     for (Entry = Table; Entry != Limit; Entry += 1) {

  00040	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _Table$[ebp]
  00046	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _Entry$[ebp], eax
  0004c	eb 0f		 jmp	 SHORT $LN10@BlFatFindD
$LN9@BlFatFindD:
  0004e	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _Entry$[ebp]
  00054	83 c0 20	 add	 eax, 32			; 00000020H
  00057	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _Entry$[ebp], eax
$LN10@BlFatFindD:
  0005d	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _Entry$[ebp]
  00063	3b 45 fc	 cmp	 eax, DWORD PTR _Limit$[ebp]
  00066	0f 84 9a 00 00
	00		 je	 $LN8@BlFatFindD

; 535  : 
; 536  :         if (Entry->u1.Short.Name[0] == FAT_DIRECTORY_ENTRY_FREE) {

  0006c	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _Entry$[ebp]
  00072	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00075	3d e5 00 00 00	 cmp	 eax, 229		; 000000e5H
  0007a	75 02		 jne	 SHORT $LN7@BlFatFindD

; 537  : 
; 538  :             continue;

  0007c	eb d0		 jmp	 SHORT $LN9@BlFatFindD
$LN7@BlFatFindD:

; 539  :         }
; 540  : 
; 541  :         if (Entry->u1.Short.Name[0] == FAT_DIRECTORY_ENTRY_LAST) {

  0007e	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _Entry$[ebp]
  00084	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00087	85 c0		 test	 eax, eax
  00089	75 02		 jne	 SHORT $LN6@BlFatFindD

; 542  : 
; 543  :             break;

  0008b	eb 79		 jmp	 SHORT $LN8@BlFatFindD
$LN6@BlFatFindD:

; 544  :         }
; 545  : 
; 546  :         if (Entry->u1.Short.Name[0] == '.') {

  0008d	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _Entry$[ebp]
  00093	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00096	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00099	75 02		 jne	 SHORT $LN5@BlFatFindD

; 547  : 
; 548  :             continue;

  0009b	eb b1		 jmp	 SHORT $LN9@BlFatFindD
$LN5@BlFatFindD:

; 549  :         }
; 550  : 
; 551  :         if ((Entry->u1.Short.Attribute & FAT_ATTRIBUTE_MASK) == FAT_ATTRIBUTE_VOLUME_ID) {

  0009d	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _Entry$[ebp]
  000a3	0f b6 40 0b	 movzx	 eax, BYTE PTR [eax+11]
  000a7	83 e0 3f	 and	 eax, 63			; 0000003fH
  000aa	83 f8 08	 cmp	 eax, 8
  000ad	75 02		 jne	 SHORT $LN4@BlFatFindD

; 552  : 
; 553  :             continue;

  000af	eb 9d		 jmp	 SHORT $LN9@BlFatFindD
$LN4@BlFatFindD:

; 554  :         }
; 555  : 
; 556  :         if (BlFatDirectoryEntryToName(Entry,
; 557  :                                       &EntryName,
; 558  :                                       Table) != FALSE) {

  000b1	ff b5 e0 fe ff
	ff		 push	 DWORD PTR _Table$[ebp]
  000b7	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR _EntryName$[ebp]
  000bd	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _Entry$[ebp]
  000c3	e8 00 00 00 00	 call	 ?BlFatDirectoryEntryToName@@YIEPAU_FAT_DIRECTORY_ENTRY@@PAU_FAT_NAME@@0@Z ; BlFatDirectoryEntryToName
  000c8	0f b6 c0	 movzx	 eax, al
  000cb	85 c0		 test	 eax, eax
  000cd	74 32		 je	 SHORT $LN3@BlFatFindD

; 559  : 
; 560  :             if ((BlRtlEqualStringI(Name, (PCSTR) EntryName.ShortName) != FALSE) ||
; 561  :                 (BlRtlEqualStringI(Name, (PCSTR) EntryName.LongName) != FALSE)) {

  000cf	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR _EntryName$[ebp]
  000d5	8b 4d 08	 mov	 ecx, DWORD PTR _Name$[ebp]
  000d8	e8 00 00 00 00	 call	 ?BlRtlEqualStringI@@YIEPBD0@Z ; BlRtlEqualStringI
  000dd	0f b6 c0	 movzx	 eax, al
  000e0	85 c0		 test	 eax, eax
  000e2	75 15		 jne	 SHORT $LN1@BlFatFindD
  000e4	8d 95 f5 fe ff
	ff		 lea	 edx, DWORD PTR _EntryName$[ebp+13]
  000ea	8b 4d 08	 mov	 ecx, DWORD PTR _Name$[ebp]
  000ed	e8 00 00 00 00	 call	 ?BlRtlEqualStringI@@YIEPBD0@Z ; BlRtlEqualStringI
  000f2	0f b6 c0	 movzx	 eax, al
  000f5	85 c0		 test	 eax, eax
  000f7	74 08		 je	 SHORT $LN3@BlFatFindD
$LN1@BlFatFindD:

; 562  : 
; 563  :                 return Entry;

  000f9	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _Entry$[ebp]
  000ff	eb 07		 jmp	 SHORT $LN12@BlFatFindD
$LN3@BlFatFindD:

; 564  :             }
; 565  :         }
; 566  :     }

  00101	e9 48 ff ff ff	 jmp	 $LN9@BlFatFindD
$LN8@BlFatFindD:

; 567  : 
; 568  :     return NULL;

  00106	33 c0		 xor	 eax, eax
$LN12@BlFatFindD:

; 569  : }

  00108	c9		 leave
  00109	c2 04 00	 ret	 4
?BlFatFindDirectoryTableEntry@@YIPAU_FAT_DIRECTORY_ENTRY@@PAU1@KPBD@Z ENDP ; BlFatFindDirectoryTableEntry
_TEXT	ENDS
PUBLIC	?BlFatGetLengthClusterChain@@YIEKPAK@Z		; BlFatGetLengthClusterChain
; Function compile flags: /Odsp
;	COMDAT ?BlFatGetLengthClusterChain@@YIEKPAK@Z
_TEXT	SEGMENT
tv67 = -12						; size = 4
_Length$ = -8						; size = 4
_Cluster$ = -4						; size = 4
?BlFatGetLengthClusterChain@@YIEKPAK@Z PROC		; BlFatGetLengthClusterChain, COMDAT
; _Cluster$ = ecx
; _Length$ = edx

; 596  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 55 f8	 mov	 DWORD PTR _Length$[ebp], edx
  00009	89 4d fc	 mov	 DWORD PTR _Cluster$[ebp], ecx

; 597  :     *Length = 0;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR _Length$[ebp]
  0000f	83 20 00	 and	 DWORD PTR [eax], 0
$LN5@BlFatGetLe:

; 598  : 
; 599  :     do {
; 600  : 
; 601  :         if (FAT_IS_DATA_CLUSTER(Cluster) == FALSE) {

  00012	83 7d fc 02	 cmp	 DWORD PTR _Cluster$[ebp], 2
  00016	72 16		 jb	 SHORT $LN8@BlFatGetLe
  00018	8b 45 fc	 mov	 eax, DWORD PTR _Cluster$[ebp]
  0001b	48		 dec	 eax
  0001c	48		 dec	 eax
  0001d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?BlFatNumberOfDataClusters@@3KA ; BlFatNumberOfDataClusters
  00023	73 09		 jae	 SHORT $LN8@BlFatGetLe
  00025	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  0002c	eb 04		 jmp	 SHORT $LN9@BlFatGetLe
$LN8@BlFatGetLe:
  0002e	83 65 f4 00	 and	 DWORD PTR tv67[ebp], 0
$LN9@BlFatGetLe:
  00032	83 7d f4 00	 cmp	 DWORD PTR tv67[ebp], 0
  00036	75 04		 jne	 SHORT $LN2@BlFatGetLe

; 602  : 
; 603  :             return FALSE;

  00038	32 c0		 xor	 al, al
  0003a	eb 2f		 jmp	 SHORT $LN6@BlFatGetLe
$LN2@BlFatGetLe:

; 604  :         }
; 605  : 
; 606  :         if (BlFatGetNextCluster(Cluster, &Cluster) == FALSE) {

  0003c	8d 55 fc	 lea	 edx, DWORD PTR _Cluster$[ebp]
  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _Cluster$[ebp]
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR ?BlFatGetNextCluster@@3P6IEKPAK@ZA ; BlFatGetNextCluster
  00048	0f b6 c0	 movzx	 eax, al
  0004b	85 c0		 test	 eax, eax
  0004d	75 04		 jne	 SHORT $LN1@BlFatGetLe

; 607  : 
; 608  :             return FALSE;

  0004f	32 c0		 xor	 al, al
  00051	eb 18		 jmp	 SHORT $LN6@BlFatGetLe
$LN1@BlFatGetLe:

; 609  :         }
; 610  : 
; 611  :         *Length += 1;

  00053	8b 45 f8	 mov	 eax, DWORD PTR _Length$[ebp]
  00056	8b 00		 mov	 eax, DWORD PTR [eax]
  00058	40		 inc	 eax
  00059	8b 4d f8	 mov	 ecx, DWORD PTR _Length$[ebp]
  0005c	89 01		 mov	 DWORD PTR [ecx], eax

; 612  : 
; 613  :     } while (Cluster != BlFatLinkTerminator);

  0005e	8b 45 fc	 mov	 eax, DWORD PTR _Cluster$[ebp]
  00061	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?BlFatLinkTerminator@@3KA ; BlFatLinkTerminator
  00067	75 a9		 jne	 SHORT $LN5@BlFatGetLe

; 614  : 
; 615  :     return TRUE;

  00069	b0 01		 mov	 al, 1
$LN6@BlFatGetLe:

; 616  : }

  0006b	c9		 leave
  0006c	c3		 ret	 0
?BlFatGetLengthClusterChain@@YIEKPAK@Z ENDP		; BlFatGetLengthClusterChain
_TEXT	ENDS
PUBLIC	?BlFatReadClusterChain@@YIEKKPAX@Z		; BlFatReadClusterChain
EXTRN	?BlPoolFreeBlock@@YIXPAX@Z:PROC			; BlPoolFreeBlock
EXTRN	?BlPoolAllocateBlock@@YIPAXK@Z:PROC		; BlPoolAllocateBlock
; Function compile flags: /Odsp
;	COMDAT ?BlFatReadClusterChain@@YIEKKPAX@Z
_TEXT	SEGMENT
tv78 = -28						; size = 4
tv67 = -24						; size = 4
_BytesToRead$ = -20					; size = 4
_Cluster$ = -16						; size = 4
_Next$ = -12						; size = 4
_Sector$ = -8						; size = 4
_ClusterData$ = -4					; size = 4
_Buffer$ = 8						; size = 4
?BlFatReadClusterChain@@YIEKKPAX@Z PROC			; BlFatReadClusterChain, COMDAT
; _Cluster$ = ecx
; _BytesToRead$ = edx

; 646  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 55 ec	 mov	 DWORD PTR _BytesToRead$[ebp], edx
  00009	89 4d f0	 mov	 DWORD PTR _Cluster$[ebp], ecx

; 647  :     PVOID ClusterData;
; 648  :     PUINT8 Next;
; 649  :     UINT32 Sector;
; 650  : 
; 651  :     BLASSERT_PTR(FAT_IS_DATA_CLUSTER(Cluster) != FALSE, Cluster);

  0000c	83 7d f0 02	 cmp	 DWORD PTR _Cluster$[ebp], 2
  00010	72 16		 jb	 SHORT $LN13@BlFatReadC
  00012	8b 45 f0	 mov	 eax, DWORD PTR _Cluster$[ebp]
  00015	48		 dec	 eax
  00016	48		 dec	 eax
  00017	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?BlFatNumberOfDataClusters@@3KA ; BlFatNumberOfDataClusters
  0001d	73 09		 jae	 SHORT $LN13@BlFatReadC
  0001f	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  00026	eb 04		 jmp	 SHORT $LN14@BlFatReadC
$LN13@BlFatReadC:
  00028	83 65 e8 00	 and	 DWORD PTR tv67[ebp], 0
$LN14@BlFatReadC:
  0002c	83 7d e8 00	 cmp	 DWORD PTR tv67[ebp], 0
  00030	75 12		 jne	 SHORT $LN10@BlFatReadC
  00032	ff 75 f0	 push	 DWORD PTR _Cluster$[ebp]
  00035	ba 8b 02 00 00	 mov	 edx, 651		; 0000028bH
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  0003f	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN10@BlFatReadC:

; 652  : 
; 653  :     BLASSERT(BytesToRead > 0);

  00044	83 7d ec 00	 cmp	 DWORD PTR _BytesToRead$[ebp], 0
  00048	77 0f		 ja	 SHORT $LN9@BlFatReadC
  0004a	ba 8d 02 00 00	 mov	 edx, 653		; 0000028dH
  0004f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  00054	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN9@BlFatReadC:

; 654  : 
; 655  :     Next = (PUINT8) Buffer;

  00059	8b 45 08	 mov	 eax, DWORD PTR _Buffer$[ebp]
  0005c	89 45 f4	 mov	 DWORD PTR _Next$[ebp], eax
$LN8@BlFatReadC:

; 656  : 
; 657  :     for (;;) {
; 658  : 
; 659  :         //
; 660  :         // If the cluster number is not within the valid data range, then fail the read operation.
; 661  :         //
; 662  : 
; 663  :         if (FAT_IS_DATA_CLUSTER(Cluster) == FALSE) {

  0005f	83 7d f0 02	 cmp	 DWORD PTR _Cluster$[ebp], 2
  00063	72 16		 jb	 SHORT $LN15@BlFatReadC
  00065	8b 45 f0	 mov	 eax, DWORD PTR _Cluster$[ebp]
  00068	48		 dec	 eax
  00069	48		 dec	 eax
  0006a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?BlFatNumberOfDataClusters@@3KA ; BlFatNumberOfDataClusters
  00070	73 09		 jae	 SHORT $LN15@BlFatReadC
  00072	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
  00079	eb 04		 jmp	 SHORT $LN16@BlFatReadC
$LN15@BlFatReadC:
  0007b	83 65 e4 00	 and	 DWORD PTR tv78[ebp], 0
$LN16@BlFatReadC:
  0007f	83 7d e4 00	 cmp	 DWORD PTR tv78[ebp], 0
  00083	75 07		 jne	 SHORT $LN6@BlFatReadC

; 664  : 
; 665  : #if FAT_VERBOSE
; 666  : 
; 667  :             BlRtlPrintf("FAT: ReadClusterChain: Cluster %u is out of range!\n", Cluster);
; 668  : 
; 669  : #endif
; 670  : 
; 671  :             return FALSE;

  00085	32 c0		 xor	 al, al
  00087	e9 d2 00 00 00	 jmp	 $LN11@BlFatReadC
$LN6@BlFatReadC:

; 672  :         }
; 673  : 
; 674  :         //
; 675  :         // Calculate the first sector in the cluster.
; 676  :         //
; 677  : 
; 678  :         Sector = FAT_DATA_CLUSTER_TO_SECTOR(Cluster);

  0008c	8b 45 f0	 mov	 eax, DWORD PTR _Cluster$[ebp]
  0008f	48		 dec	 eax
  00090	48		 dec	 eax
  00091	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR ?BlFatSectorsPerCluster@@3KA ; BlFatSectorsPerCluster
  00098	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?BlFatDataStart@@3KA ; BlFatDataStart
  0009e	89 45 f8	 mov	 DWORD PTR _Sector$[ebp], eax

; 679  : 
; 680  :         //
; 681  :         // If remaining bytes to read is less than the cluster size, then read it using a
; 682  :         // temporary buffer, since the caller provided buffer is not necessarily a multiple
; 683  :         // of cluster size.
; 684  :         //
; 685  : 
; 686  :         if (BytesToRead < BlFatBytesPerCluster) {

  000a1	8b 45 ec	 mov	 eax, DWORD PTR _BytesToRead$[ebp]
  000a4	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?BlFatBytesPerCluster@@3KA ; BlFatBytesPerCluster
  000aa	73 58		 jae	 SHORT $LN5@BlFatReadC

; 687  : 
; 688  :             ClusterData = BlPoolAllocateBlock(BlFatBytesPerCluster);

  000ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BlFatBytesPerCluster@@3KA ; BlFatBytesPerCluster
  000b2	e8 00 00 00 00	 call	 ?BlPoolAllocateBlock@@YIPAXK@Z ; BlPoolAllocateBlock
  000b7	89 45 fc	 mov	 DWORD PTR _ClusterData$[ebp], eax

; 689  : 
; 690  :             if (BlFatReadSector(Sector,
; 691  :                                 ROUND_UP_TO_POWER2(BytesToRead, FAT_SECTOR_SIZE) / FAT_SECTOR_SIZE,
; 692  :                                 (PFAT_SECTOR) ClusterData) == FALSE) {

  000ba	ff 75 fc	 push	 DWORD PTR _ClusterData$[ebp]
  000bd	8b 55 ec	 mov	 edx, DWORD PTR _BytesToRead$[ebp]
  000c0	81 c2 ff 01 00
	00		 add	 edx, 511		; 000001ffH
  000c6	81 e2 00 fe ff
	ff		 and	 edx, -512		; fffffe00H
  000cc	c1 ea 09	 shr	 edx, 9
  000cf	8b 4d f8	 mov	 ecx, DWORD PTR _Sector$[ebp]
  000d2	e8 00 00 00 00	 call	 ?BlFatReadSector@@YIEKKPAU_FAT_SECTOR@@@Z ; BlFatReadSector
  000d7	0f b6 c0	 movzx	 eax, al
  000da	85 c0		 test	 eax, eax
  000dc	75 0c		 jne	 SHORT $LN4@BlFatReadC

; 693  : 
; 694  :                 BlPoolFreeBlock(ClusterData);

  000de	8b 4d fc	 mov	 ecx, DWORD PTR _ClusterData$[ebp]
  000e1	e8 00 00 00 00	 call	 ?BlPoolFreeBlock@@YIXPAX@Z ; BlPoolFreeBlock

; 695  : 
; 696  :                 return FALSE;

  000e6	32 c0		 xor	 al, al
  000e8	eb 74		 jmp	 SHORT $LN11@BlFatReadC
$LN4@BlFatReadC:

; 697  :             }
; 698  : 
; 699  :             BlRtlCopyMemory(Next,
; 700  :                             ClusterData,
; 701  :                             BytesToRead);

  000ea	ff 75 ec	 push	 DWORD PTR _BytesToRead$[ebp]
  000ed	8b 55 fc	 mov	 edx, DWORD PTR _ClusterData$[ebp]
  000f0	8b 4d f4	 mov	 ecx, DWORD PTR _Next$[ebp]
  000f3	e8 00 00 00 00	 call	 ?BlRtlCopyMemory@@YIXPAXPBXK@Z ; BlRtlCopyMemory

; 702  : 
; 703  :             BlPoolFreeBlock(ClusterData);

  000f8	8b 4d fc	 mov	 ecx, DWORD PTR _ClusterData$[ebp]
  000fb	e8 00 00 00 00	 call	 ?BlPoolFreeBlock@@YIXPAX@Z ; BlPoolFreeBlock

; 704  : 
; 705  :             return TRUE;

  00100	b0 01		 mov	 al, 1
  00102	eb 5a		 jmp	 SHORT $LN11@BlFatReadC
$LN5@BlFatReadC:

; 706  :         }
; 707  : 
; 708  :         //
; 709  :         // Otherwise, read the entire cluster and advance by full cluster size.
; 710  :         //
; 711  : 
; 712  :         if (BlFatReadSector(Sector,
; 713  :                             BlFatSectorsPerCluster,
; 714  :                             (PFAT_SECTOR) Next) == FALSE) {

  00104	ff 75 f4	 push	 DWORD PTR _Next$[ebp]
  00107	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?BlFatSectorsPerCluster@@3KA ; BlFatSectorsPerCluster
  0010d	8b 4d f8	 mov	 ecx, DWORD PTR _Sector$[ebp]
  00110	e8 00 00 00 00	 call	 ?BlFatReadSector@@YIEKKPAU_FAT_SECTOR@@@Z ; BlFatReadSector
  00115	0f b6 c0	 movzx	 eax, al
  00118	85 c0		 test	 eax, eax
  0011a	75 04		 jne	 SHORT $LN3@BlFatReadC

; 715  : 
; 716  :             return FALSE;

  0011c	32 c0		 xor	 al, al
  0011e	eb 3e		 jmp	 SHORT $LN11@BlFatReadC
$LN3@BlFatReadC:

; 717  :         }
; 718  : 
; 719  :         BytesToRead -= BlFatBytesPerCluster;

  00120	8b 45 ec	 mov	 eax, DWORD PTR _BytesToRead$[ebp]
  00123	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?BlFatBytesPerCluster@@3KA ; BlFatBytesPerCluster
  00129	89 45 ec	 mov	 DWORD PTR _BytesToRead$[ebp], eax

; 720  :         Next += BlFatBytesPerCluster;

  0012c	8b 45 f4	 mov	 eax, DWORD PTR _Next$[ebp]
  0012f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?BlFatBytesPerCluster@@3KA ; BlFatBytesPerCluster
  00135	89 45 f4	 mov	 DWORD PTR _Next$[ebp], eax

; 721  : 
; 722  :         if (BytesToRead == 0) {

  00138	83 7d ec 00	 cmp	 DWORD PTR _BytesToRead$[ebp], 0
  0013c	75 04		 jne	 SHORT $LN2@BlFatReadC

; 723  : 
; 724  :             return TRUE;

  0013e	b0 01		 mov	 al, 1
  00140	eb 1c		 jmp	 SHORT $LN11@BlFatReadC
$LN2@BlFatReadC:

; 725  :         }
; 726  : 
; 727  :         //
; 728  :         // Get the next cluster index.
; 729  :         //
; 730  : 
; 731  :         if (BlFatGetNextCluster(Cluster, &Cluster) == FALSE) {

  00142	8d 55 f0	 lea	 edx, DWORD PTR _Cluster$[ebp]
  00145	8b 4d f0	 mov	 ecx, DWORD PTR _Cluster$[ebp]
  00148	ff 15 00 00 00
	00		 call	 DWORD PTR ?BlFatGetNextCluster@@3P6IEKPAK@ZA ; BlFatGetNextCluster
  0014e	0f b6 c0	 movzx	 eax, al
  00151	85 c0		 test	 eax, eax
  00153	75 04		 jne	 SHORT $LN1@BlFatReadC

; 732  : 
; 733  :             return FALSE;

  00155	32 c0		 xor	 al, al
  00157	eb 05		 jmp	 SHORT $LN11@BlFatReadC
$LN1@BlFatReadC:

; 734  :         }
; 735  :     }

  00159	e9 01 ff ff ff	 jmp	 $LN8@BlFatReadC
$LN11@BlFatReadC:

; 736  : }

  0015e	c9		 leave
  0015f	c2 04 00	 ret	 4
?BlFatReadClusterChain@@YIEKKPAX@Z ENDP			; BlFatReadClusterChain
_TEXT	ENDS
PUBLIC	?BlFatFindFileEntry@@YIEPBDPAU_FAT_DIRECTORY_ENTRY@@@Z ; BlFatFindFileEntry
EXTRN	?BlRtlZeroMemory@@YIXPAXK@Z:PROC		; BlRtlZeroMemory
EXTRN	?BlRtlStringLength@@YIKPBD@Z:PROC		; BlRtlStringLength
; Function compile flags: /Odsp
;	COMDAT ?BlFatFindFileEntry@@YIEPBDPAU_FAT_DIRECTORY_ENTRY@@@Z
_TEXT	SEGMENT
_FileEntry$ = -332					; size = 4
_Path$ = -328						; size = 4
_TableSize$ = -324					; size = 4
_Token$ = -320						; size = 255
_Match$ = -60						; size = 4
_Next$ = -56						; size = 4
_Depth$ = -52						; size = 4
_Table$ = -48						; size = 4
_Entry$ = -44						; size = 32
_TokenIndex$ = -12					; size = 4
_DirectoryCluster$ = -8					; size = 4
_DirectoryClusterCount$ = -4				; size = 4
?BlFatFindFileEntry@@YIEPBDPAU_FAT_DIRECTORY_ENTRY@@@Z PROC ; BlFatFindFileEntry, COMDAT
; _Path$ = ecx
; _FileEntry$ = edx

; 763  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 4c 01 00
	00		 sub	 esp, 332		; 0000014cH
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	89 95 b4 fe ff
	ff		 mov	 DWORD PTR _FileEntry$[ebp], edx
  00011	89 8d b8 fe ff
	ff		 mov	 DWORD PTR _Path$[ebp], ecx

; 764  :     UINT32 DirectoryCluster;
; 765  :     UINT32 DirectoryClusterCount;
; 766  :     UINT32 Depth;
; 767  :     FAT_DIRECTORY_ENTRY Entry;
; 768  :     PFAT_DIRECTORY_ENTRY Match;
; 769  :     PCSTR Next;
; 770  :     PFAT_DIRECTORY_ENTRY Table;
; 771  :     UINT32 TableSize;
; 772  :     UINT8 Token[FAT_MAX_PATH];
; 773  :     UINT32 TokenIndex;
; 774  : 
; 775  :     if ((Path[0] == 0) ||
; 776  :         (Path[0] == '/') ||
; 777  :         (BlRtlStringLength(Path) >= FAT_MAX_PATH)) {

  00017	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _Path$[ebp]
  0001d	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00020	85 c0		 test	 eax, eax
  00022	74 20		 je	 SHORT $LN18@BlFatFindF
  00024	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _Path$[ebp]
  0002a	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0002d	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00030	74 12		 je	 SHORT $LN18@BlFatFindF
  00032	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _Path$[ebp]
  00038	e8 00 00 00 00	 call	 ?BlRtlStringLength@@YIKPBD@Z ; BlRtlStringLength
  0003d	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00042	72 07		 jb	 SHORT $LN19@BlFatFindF
$LN18@BlFatFindF:

; 778  : 
; 779  :         return FALSE;

  00044	32 c0		 xor	 al, al
  00046	e9 a3 01 00 00	 jmp	 $LN20@BlFatFindF
$LN19@BlFatFindF:

; 780  :     }
; 781  : 
; 782  :     Next = Path;

  0004b	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _Path$[ebp]
  00051	89 45 c8	 mov	 DWORD PTR _Next$[ebp], eax

; 783  :     Depth = 0;

  00054	83 65 cc 00	 and	 DWORD PTR _Depth$[ebp], 0

; 784  : 
; 785  :     SATISFY_OVERZEALOUS_COMPILER(BlRtlZeroMemory(&Entry, sizeof(Entry)));

  00058	6a 20		 push	 32			; 00000020H
  0005a	5a		 pop	 edx
  0005b	8d 4d d4	 lea	 ecx, DWORD PTR _Entry$[ebp]
  0005e	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory
$LN17@BlFatFindF:

; 786  : 
; 787  :     for (;;) {
; 788  : 
; 789  :         if (*Next == 0) {

  00063	8b 45 c8	 mov	 eax, DWORD PTR _Next$[ebp]
  00066	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00069	85 c0		 test	 eax, eax
  0006b	75 25		 jne	 SHORT $LN15@BlFatFindF

; 790  : 
; 791  :             if ((Entry.u1.Short.Attribute & FAT_ATTRIBUTE_DIRECTORY) != 0) {

  0006d	0f b6 45 df	 movzx	 eax, BYTE PTR _Entry$[ebp+11]
  00071	83 e0 10	 and	 eax, 16			; 00000010H
  00074	74 07		 je	 SHORT $LN14@BlFatFindF

; 792  : 
; 793  : #if FAT_VERBOSE
; 794  : 
; 795  :                 BlRtlPrintf("FAT: FindFileEntry: %s is a directory!\n", Path);
; 796  : 
; 797  : #endif
; 798  : 
; 799  :                 return FALSE;

  00076	32 c0		 xor	 al, al
  00078	e9 71 01 00 00	 jmp	 $LN20@BlFatFindF
$LN14@BlFatFindF:

; 800  :             }
; 801  : 
; 802  :             *FileEntry = Entry;

  0007d	6a 08		 push	 8
  0007f	59		 pop	 ecx
  00080	8d 75 d4	 lea	 esi, DWORD PTR _Entry$[ebp]
  00083	8b bd b4 fe ff
	ff		 mov	 edi, DWORD PTR _FileEntry$[ebp]
  00089	f3 a5		 rep movsd

; 803  : 
; 804  :             return TRUE;

  0008b	b0 01		 mov	 al, 1
  0008d	e9 5c 01 00 00	 jmp	 $LN20@BlFatFindF
$LN15@BlFatFindF:

; 805  :         }
; 806  : 
; 807  :         //
; 808  :         // If the next token is empty (i.e. back to back separators), then this is a malformed path.
; 809  :         //
; 810  : 
; 811  :         if (*Next == '/') {

  00092	8b 45 c8	 mov	 eax, DWORD PTR _Next$[ebp]
  00095	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00098	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0009b	75 07		 jne	 SHORT $LN13@BlFatFindF

; 812  : 
; 813  : #if FAT_VERBOSE
; 814  : 
; 815  :             BlRtlPrintf("FAT: FindFileEntry: %s is a malformed path!\n", Path);
; 816  : 
; 817  : #endif
; 818  : 
; 819  :             return FALSE;

  0009d	32 c0		 xor	 al, al
  0009f	e9 4a 01 00 00	 jmp	 $LN20@BlFatFindF
$LN13@BlFatFindF:

; 820  :         }
; 821  : 
; 822  :         //
; 823  :         // Extract the next token.
; 824  :         //
; 825  : 
; 826  :         TokenIndex = 0;

  000a4	83 65 f4 00	 and	 DWORD PTR _TokenIndex$[ebp], 0
$LN12@BlFatFindF:

; 827  : 
; 828  :         for (;;) {
; 829  : 
; 830  :             if (*Next == 0) {

  000a8	8b 45 c8	 mov	 eax, DWORD PTR _Next$[ebp]
  000ab	0f be 00	 movsx	 eax, BYTE PTR [eax]
  000ae	85 c0		 test	 eax, eax
  000b0	75 02		 jne	 SHORT $LN10@BlFatFindF

; 831  : 
; 832  :                 break;

  000b2	eb 33		 jmp	 SHORT $LN11@BlFatFindF
$LN10@BlFatFindF:

; 833  :             }
; 834  : 
; 835  :             if (*Next == '/') {

  000b4	8b 45 c8	 mov	 eax, DWORD PTR _Next$[ebp]
  000b7	0f be 00	 movsx	 eax, BYTE PTR [eax]
  000ba	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  000bd	75 09		 jne	 SHORT $LN9@BlFatFindF

; 836  : 
; 837  :                 Next += 1;

  000bf	8b 45 c8	 mov	 eax, DWORD PTR _Next$[ebp]
  000c2	40		 inc	 eax
  000c3	89 45 c8	 mov	 DWORD PTR _Next$[ebp], eax

; 838  : 
; 839  :                 break;

  000c6	eb 1f		 jmp	 SHORT $LN11@BlFatFindF
$LN9@BlFatFindF:

; 840  :             }
; 841  : 
; 842  :             Token[TokenIndex] = *Next;

  000c8	8b 45 f4	 mov	 eax, DWORD PTR _TokenIndex$[ebp]
  000cb	8b 4d c8	 mov	 ecx, DWORD PTR _Next$[ebp]
  000ce	8a 09		 mov	 cl, BYTE PTR [ecx]
  000d0	88 8c 05 c0 fe
	ff ff		 mov	 BYTE PTR _Token$[ebp+eax], cl

; 843  :             TokenIndex += 1;

  000d7	8b 45 f4	 mov	 eax, DWORD PTR _TokenIndex$[ebp]
  000da	40		 inc	 eax
  000db	89 45 f4	 mov	 DWORD PTR _TokenIndex$[ebp], eax

; 844  :             Next += 1;

  000de	8b 45 c8	 mov	 eax, DWORD PTR _Next$[ebp]
  000e1	40		 inc	 eax
  000e2	89 45 c8	 mov	 DWORD PTR _Next$[ebp], eax

; 845  :         }

  000e5	eb c1		 jmp	 SHORT $LN12@BlFatFindF
$LN11@BlFatFindF:

; 846  : 
; 847  :         BLASSERT(TokenIndex > 0);

  000e7	83 7d f4 00	 cmp	 DWORD PTR _TokenIndex$[ebp], 0
  000eb	77 0f		 ja	 SHORT $LN8@BlFatFindF
  000ed	ba 4f 03 00 00	 mov	 edx, 847		; 0000034fH
  000f2	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  000f7	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN8@BlFatFindF:

; 848  : 
; 849  :         Token[TokenIndex] = 0;

  000fc	8b 45 f4	 mov	 eax, DWORD PTR _TokenIndex$[ebp]
  000ff	c6 84 05 c0 fe
	ff ff 00	 mov	 BYTE PTR _Token$[ebp+eax], 0

; 850  : 
; 851  :         if (Depth == 0) {

  00107	83 7d cc 00	 cmp	 DWORD PTR _Depth$[ebp], 0
  0010b	75 15		 jne	 SHORT $LN7@BlFatFindF

; 852  : 
; 853  :             Table = BlFatRootDirectory;

  0010d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatRootDirectory@@3PAU_FAT_DIRECTORY_ENTRY@@A ; BlFatRootDirectory
  00112	89 45 d0	 mov	 DWORD PTR _Table$[ebp], eax

; 854  :             TableSize = BlFatNumberOfRootDirectoryEntries;

  00115	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatNumberOfRootDirectoryEntries@@3KA ; BlFatNumberOfRootDirectoryEntries
  0011a	89 85 bc fe ff
	ff		 mov	 DWORD PTR _TableSize$[ebp], eax

; 855  : 
; 856  :         } else {

  00120	eb 6d		 jmp	 SHORT $LN6@BlFatFindF
$LN7@BlFatFindF:

; 857  : 
; 858  :             DirectoryCluster = Entry.u1.Short.FirstClusterLow;

  00122	0f b7 45 ee	 movzx	 eax, WORD PTR _Entry$[ebp+26]
  00126	89 45 f8	 mov	 DWORD PTR _DirectoryCluster$[ebp], eax

; 859  : 
; 860  :             if (BlFatGetLengthClusterChain(DirectoryCluster, &DirectoryClusterCount) == FALSE) {

  00129	8d 55 fc	 lea	 edx, DWORD PTR _DirectoryClusterCount$[ebp]
  0012c	8b 4d f8	 mov	 ecx, DWORD PTR _DirectoryCluster$[ebp]
  0012f	e8 00 00 00 00	 call	 ?BlFatGetLengthClusterChain@@YIEKPAK@Z ; BlFatGetLengthClusterChain
  00134	0f b6 c0	 movzx	 eax, al
  00137	85 c0		 test	 eax, eax
  00139	75 07		 jne	 SHORT $LN5@BlFatFindF

; 861  : 
; 862  :                 return FALSE;

  0013b	32 c0		 xor	 al, al
  0013d	e9 ac 00 00 00	 jmp	 $LN20@BlFatFindF
$LN5@BlFatFindF:

; 863  :             }
; 864  : 
; 865  :             Table = (PFAT_DIRECTORY_ENTRY)
; 866  :                 BlPoolAllocateBlock(DirectoryClusterCount * BlFatBytesPerCluster);

  00142	8b 4d fc	 mov	 ecx, DWORD PTR _DirectoryClusterCount$[ebp]
  00145	0f af 0d 00 00
	00 00		 imul	 ecx, DWORD PTR ?BlFatBytesPerCluster@@3KA ; BlFatBytesPerCluster
  0014c	e8 00 00 00 00	 call	 ?BlPoolAllocateBlock@@YIPAXK@Z ; BlPoolAllocateBlock
  00151	89 45 d0	 mov	 DWORD PTR _Table$[ebp], eax

; 867  : 
; 868  :             if (BlFatReadClusterChain(DirectoryCluster,
; 869  :                                       DirectoryClusterCount * BlFatBytesPerCluster,
; 870  :                                       Table) == FALSE) {

  00154	ff 75 d0	 push	 DWORD PTR _Table$[ebp]
  00157	8b 55 fc	 mov	 edx, DWORD PTR _DirectoryClusterCount$[ebp]
  0015a	0f af 15 00 00
	00 00		 imul	 edx, DWORD PTR ?BlFatBytesPerCluster@@3KA ; BlFatBytesPerCluster
  00161	8b 4d f8	 mov	 ecx, DWORD PTR _DirectoryCluster$[ebp]
  00164	e8 00 00 00 00	 call	 ?BlFatReadClusterChain@@YIEKKPAX@Z ; BlFatReadClusterChain
  00169	0f b6 c0	 movzx	 eax, al
  0016c	85 c0		 test	 eax, eax
  0016e	75 0c		 jne	 SHORT $LN4@BlFatFindF

; 871  : 
; 872  :                 BlPoolFreeBlock(Table);

  00170	8b 4d d0	 mov	 ecx, DWORD PTR _Table$[ebp]
  00173	e8 00 00 00 00	 call	 ?BlPoolFreeBlock@@YIXPAX@Z ; BlPoolFreeBlock

; 873  : 
; 874  :                 return FALSE;

  00178	32 c0		 xor	 al, al
  0017a	eb 72		 jmp	 SHORT $LN20@BlFatFindF
$LN4@BlFatFindF:

; 875  :             }
; 876  : 
; 877  :             TableSize = (DirectoryClusterCount * BlFatBytesPerCluster) / sizeof(FAT_DIRECTORY_ENTRY);

  0017c	8b 45 fc	 mov	 eax, DWORD PTR _DirectoryClusterCount$[ebp]
  0017f	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR ?BlFatBytesPerCluster@@3KA ; BlFatBytesPerCluster
  00186	c1 e8 05	 shr	 eax, 5
  00189	89 85 bc fe ff
	ff		 mov	 DWORD PTR _TableSize$[ebp], eax
$LN6@BlFatFindF:

; 878  :         }
; 879  : 
; 880  :         //
; 881  :         // Walk the directory table matching the previous token for an entry matching the next token.
; 882  :         //
; 883  : 
; 884  :         Match = BlFatFindDirectoryTableEntry(Table,
; 885  :                                              TableSize,
; 886  :                                              (PCSTR) Token);

  0018f	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR _Token$[ebp]
  00195	50		 push	 eax
  00196	8b 95 bc fe ff
	ff		 mov	 edx, DWORD PTR _TableSize$[ebp]
  0019c	8b 4d d0	 mov	 ecx, DWORD PTR _Table$[ebp]
  0019f	e8 00 00 00 00	 call	 ?BlFatFindDirectoryTableEntry@@YIPAU_FAT_DIRECTORY_ENTRY@@PAU1@KPBD@Z ; BlFatFindDirectoryTableEntry
  001a4	89 45 c4	 mov	 DWORD PTR _Match$[ebp], eax

; 887  : 
; 888  :         if (Match == NULL) {

  001a7	83 7d c4 00	 cmp	 DWORD PTR _Match$[ebp], 0
  001ab	75 17		 jne	 SHORT $LN3@BlFatFindF

; 889  : 
; 890  : #if FAT_VERBOSE
; 891  : 
; 892  :             BlRtlPrintf("FAT: FindFileEntry: Unable to find directory entry for token %s.\n", Token);
; 893  : 
; 894  : #endif
; 895  : 
; 896  :             if (Table != BlFatRootDirectory) {

  001ad	8b 45 d0	 mov	 eax, DWORD PTR _Table$[ebp]
  001b0	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?BlFatRootDirectory@@3PAU_FAT_DIRECTORY_ENTRY@@A ; BlFatRootDirectory
  001b6	74 08		 je	 SHORT $LN2@BlFatFindF

; 897  : 
; 898  :                 BlPoolFreeBlock(Table);

  001b8	8b 4d d0	 mov	 ecx, DWORD PTR _Table$[ebp]
  001bb	e8 00 00 00 00	 call	 ?BlPoolFreeBlock@@YIXPAX@Z ; BlPoolFreeBlock
$LN2@BlFatFindF:

; 899  :             }
; 900  : 
; 901  :             return FALSE;

  001c0	32 c0		 xor	 al, al
  001c2	eb 2a		 jmp	 SHORT $LN20@BlFatFindF
$LN3@BlFatFindF:

; 902  :         }
; 903  : 
; 904  :         Entry = *Match;

  001c4	8b 75 c4	 mov	 esi, DWORD PTR _Match$[ebp]
  001c7	6a 08		 push	 8
  001c9	59		 pop	 ecx
  001ca	8d 7d d4	 lea	 edi, DWORD PTR _Entry$[ebp]
  001cd	f3 a5		 rep movsd

; 905  : 
; 906  :         if (Table != BlFatRootDirectory) {

  001cf	8b 45 d0	 mov	 eax, DWORD PTR _Table$[ebp]
  001d2	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?BlFatRootDirectory@@3PAU_FAT_DIRECTORY_ENTRY@@A ; BlFatRootDirectory
  001d8	74 08		 je	 SHORT $LN1@BlFatFindF

; 907  : 
; 908  :             BlPoolFreeBlock(Table);

  001da	8b 4d d0	 mov	 ecx, DWORD PTR _Table$[ebp]
  001dd	e8 00 00 00 00	 call	 ?BlPoolFreeBlock@@YIXPAX@Z ; BlPoolFreeBlock
$LN1@BlFatFindF:

; 909  :         }
; 910  : 
; 911  :         Depth += 1;

  001e2	8b 45 cc	 mov	 eax, DWORD PTR _Depth$[ebp]
  001e5	40		 inc	 eax
  001e6	89 45 cc	 mov	 DWORD PTR _Depth$[ebp], eax

; 912  :     }

  001e9	e9 75 fe ff ff	 jmp	 $LN17@BlFatFindF
$LN20@BlFatFindF:

; 913  : }

  001ee	5f		 pop	 edi
  001ef	5e		 pop	 esi
  001f0	c9		 leave
  001f1	c3		 ret	 0
?BlFatFindFileEntry@@YIEPBDPAU_FAT_DIRECTORY_ENTRY@@@Z ENDP ; BlFatFindFileEntry
_TEXT	ENDS
PUBLIC	?BlFatGetFileSize@@YIEPBDPAK@Z			; BlFatGetFileSize
; Function compile flags: /Odsp
;	COMDAT ?BlFatGetFileSize@@YIEPBDPAK@Z
_TEXT	SEGMENT
_FileSize$ = -40					; size = 4
_Path$ = -36						; size = 4
_Entry$ = -32						; size = 32
?BlFatGetFileSize@@YIEPBDPAK@Z PROC			; BlFatGetFileSize, COMDAT
; _Path$ = ecx
; _FileSize$ = edx

; 940  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 55 d8	 mov	 DWORD PTR _FileSize$[ebp], edx
  00009	89 4d dc	 mov	 DWORD PTR _Path$[ebp], ecx

; 941  :     FAT_DIRECTORY_ENTRY Entry;
; 942  : 
; 943  :     if (BlFatFindFileEntry(Path, &Entry) == FALSE) {

  0000c	8d 55 e0	 lea	 edx, DWORD PTR _Entry$[ebp]
  0000f	8b 4d dc	 mov	 ecx, DWORD PTR _Path$[ebp]
  00012	e8 00 00 00 00	 call	 ?BlFatFindFileEntry@@YIEPBDPAU_FAT_DIRECTORY_ENTRY@@@Z ; BlFatFindFileEntry
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	75 04		 jne	 SHORT $LN1@BlFatGetFi

; 944  : 
; 945  :         return FALSE;

  0001e	32 c0		 xor	 al, al
  00020	eb 0a		 jmp	 SHORT $LN2@BlFatGetFi
$LN1@BlFatGetFi:

; 946  :     }
; 947  : 
; 948  :     *FileSize = Entry.u1.Short.Size;

  00022	8b 45 d8	 mov	 eax, DWORD PTR _FileSize$[ebp]
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _Entry$[ebp+28]
  00028	89 08		 mov	 DWORD PTR [eax], ecx

; 949  : 
; 950  :     return TRUE;

  0002a	b0 01		 mov	 al, 1
$LN2@BlFatGetFi:

; 951  : }

  0002c	c9		 leave
  0002d	c3		 ret	 0
?BlFatGetFileSize@@YIEPBDPAK@Z ENDP			; BlFatGetFileSize
_TEXT	ENDS
PUBLIC	?BlFatReadFile@@YIEPBDPAXK@Z			; BlFatReadFile
; Function compile flags: /Odsp
;	COMDAT ?BlFatReadFile@@YIEPBDPAXK@Z
_TEXT	SEGMENT
_Buffer$ = -44						; size = 4
_Path$ = -40						; size = 4
_Entry$ = -36						; size = 32
_Result$ = -1						; size = 1
_NumberOfBytes$ = 8					; size = 4
?BlFatReadFile@@YIEPBDPAXK@Z PROC			; BlFatReadFile, COMDAT
; _Path$ = ecx
; _Buffer$ = edx

; 981  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 55 d4	 mov	 DWORD PTR _Buffer$[ebp], edx
  00009	89 4d d8	 mov	 DWORD PTR _Path$[ebp], ecx

; 982  :     FAT_DIRECTORY_ENTRY Entry;
; 983  :     BOOLEAN Result;
; 984  : 
; 985  :     if (BlFatFindFileEntry(Path, &Entry) == FALSE) {

  0000c	8d 55 dc	 lea	 edx, DWORD PTR _Entry$[ebp]
  0000f	8b 4d d8	 mov	 ecx, DWORD PTR _Path$[ebp]
  00012	e8 00 00 00 00	 call	 ?BlFatFindFileEntry@@YIEPBDPAU_FAT_DIRECTORY_ENTRY@@@Z ; BlFatFindFileEntry
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	75 04		 jne	 SHORT $LN2@BlFatReadF

; 986  : 
; 987  :         return FALSE;

  0001e	32 c0		 xor	 al, al
  00020	eb 21		 jmp	 SHORT $LN3@BlFatReadF
$LN2@BlFatReadF:

; 988  :     }
; 989  : 
; 990  :     if (NumberOfBytes > Entry.u1.Short.Size) {

  00022	8b 45 08	 mov	 eax, DWORD PTR _NumberOfBytes$[ebp]
  00025	3b 45 f8	 cmp	 eax, DWORD PTR _Entry$[ebp+28]
  00028	76 04		 jbe	 SHORT $LN1@BlFatReadF

; 991  : 
; 992  :         return FALSE;

  0002a	32 c0		 xor	 al, al
  0002c	eb 15		 jmp	 SHORT $LN3@BlFatReadF
$LN1@BlFatReadF:

; 993  :     }
; 994  : 
; 995  :     Result = BlFatReadClusterChain(Entry.u1.Short.FirstClusterLow,
; 996  :                                    NumberOfBytes,
; 997  :                                    Buffer);

  0002e	ff 75 d4	 push	 DWORD PTR _Buffer$[ebp]
  00031	0f b7 4d f6	 movzx	 ecx, WORD PTR _Entry$[ebp+26]
  00035	8b 55 08	 mov	 edx, DWORD PTR _NumberOfBytes$[ebp]
  00038	e8 00 00 00 00	 call	 ?BlFatReadClusterChain@@YIEKKPAX@Z ; BlFatReadClusterChain
  0003d	88 45 ff	 mov	 BYTE PTR _Result$[ebp], al

; 998  : 
; 999  :     return Result;

  00040	8a 45 ff	 mov	 al, BYTE PTR _Result$[ebp]
$LN3@BlFatReadF:

; 1000 : }

  00043	c9		 leave
  00044	c2 04 00	 ret	 4
?BlFatReadFile@@YIEPBDPAXK@Z ENDP			; BlFatReadFile
_TEXT	ENDS
PUBLIC	?BlFat16GetNextCluster@@YIEKPAK@Z		; BlFat16GetNextCluster
; Function compile flags: /Odsp
;	COMDAT ?BlFat16GetNextCluster@@YIEKPAK@Z
_TEXT	SEGMENT
_TablePage$ = -1024					; size = 512
_Offset$ = -20						; size = 4
_Sector$ = -16						; size = 4
tv67 = -12						; size = 4
_Cluster$ = -8						; size = 4
_NextCluster$ = -4					; size = 4
?BlFat16GetNextCluster@@YIEKPAK@Z PROC			; BlFat16GetNextCluster, COMDAT
; _Cluster$ = ecx
; _NextCluster$ = edx

; 1027 : {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	81 e4 00 fe ff
	ff		 and	 esp, -512		; fffffe00H
  0000b	83 c4 04	 add	 esp, 4
  0000e	55		 push	 ebp
  0000f	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00012	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00016	8b ec		 mov	 ebp, esp
  00018	81 ec 00 04 00
	00		 sub	 esp, 1024		; 00000400H
  0001e	89 55 fc	 mov	 DWORD PTR _NextCluster$[ebp], edx
  00021	89 4d f8	 mov	 DWORD PTR _Cluster$[ebp], ecx

; 1028 :     UINT32 Offset;
; 1029 :     UINT32 Sector;
; 1030 :     FAT_SECTOR TablePage;
; 1031 : 
; 1032 :     if (FAT_IS_DATA_CLUSTER(Cluster) == FALSE) {

  00024	83 7d f8 02	 cmp	 DWORD PTR _Cluster$[ebp], 2
  00028	72 16		 jb	 SHORT $LN5@BlFat16Get
  0002a	8b 45 f8	 mov	 eax, DWORD PTR _Cluster$[ebp]
  0002d	48		 dec	 eax
  0002e	48		 dec	 eax
  0002f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?BlFatNumberOfDataClusters@@3KA ; BlFatNumberOfDataClusters
  00035	73 09		 jae	 SHORT $LN5@BlFat16Get
  00037	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  0003e	eb 04		 jmp	 SHORT $LN6@BlFat16Get
$LN5@BlFat16Get:
  00040	83 65 f4 00	 and	 DWORD PTR tv67[ebp], 0
$LN6@BlFat16Get:
  00044	83 7d f4 00	 cmp	 DWORD PTR tv67[ebp], 0
  00048	75 04		 jne	 SHORT $LN2@BlFat16Get

; 1033 : 
; 1034 : #if FAT_VERBOSE
; 1035 : 
; 1036 :         BlRtlPrintf("FAT: Fat16GetNextCluster: Cluster %u is out of range!\n", Cluster);
; 1037 : 
; 1038 : #endif
; 1039 : 
; 1040 :         return FALSE;

  0004a	32 c0		 xor	 al, al
  0004c	eb 4d		 jmp	 SHORT $LN3@BlFat16Get
$LN2@BlFat16Get:

; 1041 :     }
; 1042 : 
; 1043 :     Sector = BlFatTableStart + (Cluster / 256);

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _Cluster$[ebp]
  00051	c1 e8 08	 shr	 eax, 8
  00054	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?BlFatTableStart@@3KA ; BlFatTableStart
  0005a	89 45 f0	 mov	 DWORD PTR _Sector$[ebp], eax

; 1044 :     Offset = Cluster % 256;

  0005d	8b 45 f8	 mov	 eax, DWORD PTR _Cluster$[ebp]
  00060	33 d2		 xor	 edx, edx
  00062	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00067	f7 f1		 div	 ecx
  00069	89 55 ec	 mov	 DWORD PTR _Offset$[ebp], edx

; 1045 : 
; 1046 :     if (BlFatReadSector(Sector, 1, &TablePage) == FALSE) {

  0006c	8d 85 00 fc ff
	ff		 lea	 eax, DWORD PTR _TablePage$[ebp]
  00072	50		 push	 eax
  00073	33 d2		 xor	 edx, edx
  00075	42		 inc	 edx
  00076	8b 4d f0	 mov	 ecx, DWORD PTR _Sector$[ebp]
  00079	e8 00 00 00 00	 call	 ?BlFatReadSector@@YIEKKPAU_FAT_SECTOR@@@Z ; BlFatReadSector
  0007e	0f b6 c0	 movzx	 eax, al
  00081	85 c0		 test	 eax, eax
  00083	75 04		 jne	 SHORT $LN1@BlFat16Get

; 1047 : 
; 1048 :         return FALSE;

  00085	32 c0		 xor	 al, al
  00087	eb 12		 jmp	 SHORT $LN3@BlFat16Get
$LN1@BlFat16Get:

; 1049 :     }
; 1050 : 
; 1051 :     *NextCluster = (UINT32) (((PUINT16) &TablePage)[Offset]);

  00089	8b 45 ec	 mov	 eax, DWORD PTR _Offset$[ebp]
  0008c	0f b7 84 45 00
	fc ff ff	 movzx	 eax, WORD PTR _TablePage$[ebp+eax*2]
  00094	8b 4d fc	 mov	 ecx, DWORD PTR _NextCluster$[ebp]
  00097	89 01		 mov	 DWORD PTR [ecx], eax

; 1052 : 
; 1053 :     return TRUE;

  00099	b0 01		 mov	 al, 1
$LN3@BlFat16Get:

; 1054 : }

  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	8b e3		 mov	 esp, ebx
  000a0	5b		 pop	 ebx
  000a1	c3		 ret	 0
?BlFat16GetNextCluster@@YIEKPAK@Z ENDP			; BlFat16GetNextCluster
_TEXT	ENDS
PUBLIC	?BlFat16Initialize@@YIXXZ			; BlFat16Initialize
; Function compile flags: /Odsp
;	COMDAT ?BlFat16Initialize@@YIXXZ
_TEXT	SEGMENT
tv179 = -8						; size = 4
_BootSector$ = -4					; size = 4
?BlFat16Initialize@@YIXXZ PROC				; BlFat16Initialize, COMDAT

; 1069 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 1070 :     PFAT16_BOOT_SECTOR BootSector;
; 1071 : 
; 1072 :     BootSector = &BlFatBootSector.u1.Fat16;

  00005	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _BootSector$[ebp], OFFSET ?BlFatBootSector@@3U_FAT_BOOT_SECTOR@@A ; BlFatBootSector

; 1073 : 
; 1074 :     BLASSERT(BlFatMbr.Partition[BlFatPartitionId].Type == MBR_FAT16LBA);

  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatPartitionId@@3KA ; BlFatPartitionId
  00011	c1 e0 04	 shl	 eax, 4
  00014	0f b6 80 c2 01
	00 00		 movzx	 eax, BYTE PTR ?BlFatMbr@@3U_MBR@@A[eax+450]
  0001b	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  0001e	74 0f		 je	 SHORT $LN17@BlFat16Ini
  00020	ba 32 04 00 00	 mov	 edx, 1074		; 00000432H
  00025	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  0002a	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN17@BlFat16Ini:

; 1075 : 
; 1076 :     //
; 1077 :     // Read FAT16 boot sector.
; 1078 :     //
; 1079 : 
; 1080 :     if (BlRtlReadDrive(BlFatDriveId,
; 1081 :                        BlFatPartitionStart,
; 1082 :                        1,
; 1083 :                        BootSector) == FALSE) {

  0002f	ff 75 fc	 push	 DWORD PTR _BootSector$[ebp]
  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatPartitionStart@@3KA ; BlFatPartitionStart
  00037	33 c9		 xor	 ecx, ecx
  00039	51		 push	 ecx
  0003a	50		 push	 eax
  0003b	66 ba 01 00	 mov	 dx, 1
  0003f	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?BlFatDriveId@@3EA ; BlFatDriveId
  00045	e8 00 00 00 00	 call	 ?BlRtlReadDrive@@YIEE_KGPAX@Z ; BlRtlReadDrive
  0004a	0f b6 c0	 movzx	 eax, al
  0004d	85 c0		 test	 eax, eax
  0004f	75 0a		 jne	 SHORT $LN16@BlFat16Ini

; 1084 : 
; 1085 : #if FAT_VERBOSE
; 1086 :         BlRtlPrintf("FAT: Error reading boot sector!\n");
; 1087 : #endif
; 1088 :         BlFatHalt();

  00051	b9 40 04 00 00	 mov	 ecx, 1088		; 00000440H
  00056	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN16@BlFat16Ini:

; 1089 :     }
; 1090 : 
; 1091 :     //
; 1092 :     // Extract volume geometry.
; 1093 :     //
; 1094 : 
; 1095 :     if (BootSector->BytesPerSector != FAT_SECTOR_SIZE) {

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  0005e	0f b7 40 0b	 movzx	 eax, WORD PTR [eax+11]
  00062	3d 00 02 00 00	 cmp	 eax, 512		; 00000200H
  00067	74 0a		 je	 SHORT $LN15@BlFat16Ini

; 1096 : 
; 1097 : #if FAT_VERBOSE
; 1098 :         BlRtlPrintf("FAT: Unsupported sector size (%u)!\n", BootSector->BytesPerSector);
; 1099 : #endif
; 1100 :         BlFatHalt();

  00069	b9 4c 04 00 00	 mov	 ecx, 1100		; 0000044cH
  0006e	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN15@BlFat16Ini:

; 1101 :     }
; 1102 : 
; 1103 :     BlFatSectorsPerCluster = BootSector->SectorsPerCluster;

  00073	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  00076	0f b6 40 0d	 movzx	 eax, BYTE PTR [eax+13]
  0007a	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatSectorsPerCluster@@3KA, eax ; BlFatSectorsPerCluster

; 1104 : 
; 1105 :     if (BlFatSectorsPerCluster == 0) {

  0007f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?BlFatSectorsPerCluster@@3KA, 0 ; BlFatSectorsPerCluster
  00086	75 0a		 jne	 SHORT $LN14@BlFat16Ini

; 1106 : 
; 1107 : #if FAT_VERBOSE
; 1108 :         BlRtlPrintf("FAT: SectorsPerCluster == 0!\n");
; 1109 : #endif
; 1110 :         BlFatHalt();

  00088	b9 56 04 00 00	 mov	 ecx, 1110		; 00000456H
  0008d	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN14@BlFat16Ini:

; 1111 :     }
; 1112 : 
; 1113 :     BlFatBytesPerCluster = BlFatSectorsPerCluster * FAT_SECTOR_SIZE;

  00092	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatSectorsPerCluster@@3KA ; BlFatSectorsPerCluster
  00097	c1 e0 09	 shl	 eax, 9
  0009a	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatBytesPerCluster@@3KA, eax ; BlFatBytesPerCluster

; 1114 : 
; 1115 :     if (BootSector->TotalSectorCount32 > 0) {

  0009f	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  000a2	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  000a6	76 0d		 jbe	 SHORT $LN13@BlFat16Ini

; 1116 : 
; 1117 :         BlFatTotalSectorCount = BootSector->TotalSectorCount32;

  000a8	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  000ab	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  000ae	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatTotalSectorCount@@3KA, eax ; BlFatTotalSectorCount

; 1118 : 
; 1119 :     } else {

  000b3	eb 0c		 jmp	 SHORT $LN12@BlFat16Ini
$LN13@BlFat16Ini:

; 1120 : 
; 1121 :         BlFatTotalSectorCount = BootSector->TotalSectorCount16;

  000b5	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  000b8	0f b7 40 13	 movzx	 eax, WORD PTR [eax+19]
  000bc	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatTotalSectorCount@@3KA, eax ; BlFatTotalSectorCount
$LN12@BlFat16Ini:

; 1122 :     }
; 1123 : 
; 1124 :     if (BlFatTotalSectorCount > BlFatPartitionSize) {

  000c1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatTotalSectorCount@@3KA ; BlFatTotalSectorCount
  000c6	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?BlFatPartitionSize@@3KA ; BlFatPartitionSize
  000cc	76 0a		 jbe	 SHORT $LN11@BlFat16Ini

; 1125 : 
; 1126 : #if FAT_VERBOSE
; 1127 :         BlRtlPrintf("FAT: Boot sector claims more sectors than MBR!\n");
; 1128 : #endif
; 1129 :         BlFatHalt();

  000ce	b9 69 04 00 00	 mov	 ecx, 1129		; 00000469H
  000d3	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN11@BlFat16Ini:

; 1130 :     }
; 1131 : 
; 1132 :     if (BootSector->NumberOfFATs == 0) {

  000d8	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  000db	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]
  000df	85 c0		 test	 eax, eax
  000e1	75 0a		 jne	 SHORT $LN10@BlFat16Ini

; 1133 : 
; 1134 : #if FAT_VERBOSE
; 1135 :         BlRtlPrintf("FAT: NumberOfFATs == 0!\n");
; 1136 : #endif
; 1137 :         BlFatHalt();

  000e3	b9 71 04 00 00	 mov	 ecx, 1137		; 00000471H
  000e8	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN10@BlFat16Ini:

; 1138 :     }
; 1139 : 
; 1140 :     if (BootSector->SectorsPerFAT == 0) {

  000ed	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  000f0	0f b7 40 16	 movzx	 eax, WORD PTR [eax+22]
  000f4	85 c0		 test	 eax, eax
  000f6	75 0a		 jne	 SHORT $LN9@BlFat16Ini

; 1141 : 
; 1142 : #if FAT_VERBOSE
; 1143 :         BlRtlPrintf("FAT: SectorsPerFAT == 0!\n");
; 1144 : #endif
; 1145 :         BlFatHalt();

  000f8	b9 79 04 00 00	 mov	 ecx, 1145		; 00000479H
  000fd	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN9@BlFat16Ini:

; 1146 :     }
; 1147 : 
; 1148 :     BlFatNumberOfRootDirectoryEntries = BootSector->NumberOfRootDirectoryEntries;

  00102	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  00105	0f b7 40 11	 movzx	 eax, WORD PTR [eax+17]
  00109	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatNumberOfRootDirectoryEntries@@3KA, eax ; BlFatNumberOfRootDirectoryEntries

; 1149 : 
; 1150 :     if ((BlFatNumberOfRootDirectoryEntries == 0) ||
; 1151 :         ((BlFatNumberOfRootDirectoryEntries % 64) != 0)) {

  0010e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?BlFatNumberOfRootDirectoryEntries@@3KA, 0 ; BlFatNumberOfRootDirectoryEntries
  00115	74 10		 je	 SHORT $LN7@BlFat16Ini
  00117	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatNumberOfRootDirectoryEntries@@3KA ; BlFatNumberOfRootDirectoryEntries
  0011c	33 d2		 xor	 edx, edx
  0011e	6a 40		 push	 64			; 00000040H
  00120	59		 pop	 ecx
  00121	f7 f1		 div	 ecx
  00123	85 d2		 test	 edx, edx
  00125	74 0a		 je	 SHORT $LN8@BlFat16Ini
$LN7@BlFat16Ini:

; 1152 : 
; 1153 : #if FAT_VERBOSE
; 1154 :         BlRtlPrintf("FAT: Invalid number of root directory entries (%u)!\n", BlFatNumberOfRootDirectoryEntries);
; 1155 : #endif
; 1156 :         BlFatHalt();

  00127	b9 84 04 00 00	 mov	 ecx, 1156		; 00000484H
  0012c	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN8@BlFat16Ini:

; 1157 :     }
; 1158 : 
; 1159 :     BlFatTableStart = BootSector->NumberOfReservedSectors;

  00131	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  00134	0f b7 40 0e	 movzx	 eax, WORD PTR [eax+14]
  00138	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatTableStart@@3KA, eax ; BlFatTableStart

; 1160 : 
; 1161 :     if (BlFatTotalSectorCount < BlFatTableStart) {

  0013d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatTotalSectorCount@@3KA ; BlFatTotalSectorCount
  00142	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?BlFatTableStart@@3KA ; BlFatTableStart
  00148	73 0a		 jae	 SHORT $LN6@BlFat16Ini

; 1162 : 
; 1163 : #if FAT_VERBOSE
; 1164 :         BlRtlPrintf("FAT: TotalSectorCount < TableStart!\n");
; 1165 : #endif
; 1166 :         BlFatHalt();

  0014a	b9 8e 04 00 00	 mov	 ecx, 1166		; 0000048eH
  0014f	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN6@BlFat16Ini:

; 1167 :     }
; 1168 : 
; 1169 :     BlFatRootStart = BlFatTableStart + (BootSector->NumberOfFATs * BootSector->SectorsPerFAT);

  00154	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  00157	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]
  0015b	8b 4d fc	 mov	 ecx, DWORD PTR _BootSector$[ebp]
  0015e	0f b7 49 16	 movzx	 ecx, WORD PTR [ecx+22]
  00162	0f af c1	 imul	 eax, ecx
  00165	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?BlFatTableStart@@3KA ; BlFatTableStart
  0016b	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatRootStart@@3KA, eax ; BlFatRootStart

; 1170 : 
; 1171 :     if (BlFatTotalSectorCount < BlFatRootStart) {

  00170	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatTotalSectorCount@@3KA ; BlFatTotalSectorCount
  00175	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?BlFatRootStart@@3KA ; BlFatRootStart
  0017b	73 0a		 jae	 SHORT $LN5@BlFat16Ini

; 1172 : 
; 1173 : #if FAT_VERBOSE
; 1174 :         BlRtlPrintf("FAT: TotalSectorCount < RootStart!\n");
; 1175 : #endif
; 1176 :         BlFatHalt();

  0017d	b9 98 04 00 00	 mov	 ecx, 1176		; 00000498H
  00182	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN5@BlFat16Ini:

; 1177 :     }
; 1178 : 
; 1179 :     BlFatDataStart = BlFatRootStart + (ROUND_UP_TO_POWER2(BlFatNumberOfRootDirectoryEntries * sizeof(FAT_DIRECTORY_ENTRY), FAT_SECTOR_SIZE) / FAT_SECTOR_SIZE);

  00187	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatNumberOfRootDirectoryEntries@@3KA ; BlFatNumberOfRootDirectoryEntries
  0018c	c1 e0 05	 shl	 eax, 5
  0018f	05 ff 01 00 00	 add	 eax, 511		; 000001ffH
  00194	25 00 fe ff ff	 and	 eax, -512		; fffffe00H
  00199	c1 e8 09	 shr	 eax, 9
  0019c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?BlFatRootStart@@3KA ; BlFatRootStart
  001a2	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatDataStart@@3KA, eax ; BlFatDataStart

; 1180 : 
; 1181 :     if (BlFatTotalSectorCount < BlFatDataStart) {

  001a7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatTotalSectorCount@@3KA ; BlFatTotalSectorCount
  001ac	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?BlFatDataStart@@3KA ; BlFatDataStart
  001b2	73 0a		 jae	 SHORT $LN4@BlFat16Ini

; 1182 : 
; 1183 : #if FAT_VERBOSE
; 1184 :         BlRtlPrintf("FAT: TotalSectorCount < DataStart!\n");
; 1185 : #endif
; 1186 :         BlFatHalt();

  001b4	b9 a2 04 00 00	 mov	 ecx, 1186		; 000004a2H
  001b9	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN4@BlFat16Ini:

; 1187 :     }
; 1188 : 
; 1189 :     BlFatNumberOfDataClusters = (BlFatTotalSectorCount - BlFatDataStart) / BlFatSectorsPerCluster;

  001be	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatTotalSectorCount@@3KA ; BlFatTotalSectorCount
  001c3	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?BlFatDataStart@@3KA ; BlFatDataStart
  001c9	33 d2		 xor	 edx, edx
  001cb	f7 35 00 00 00
	00		 div	 DWORD PTR ?BlFatSectorsPerCluster@@3KA ; BlFatSectorsPerCluster
  001d1	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatNumberOfDataClusters@@3KA, eax ; BlFatNumberOfDataClusters

; 1190 : 
; 1191 :     if (BlFatNumberOfDataClusters == 0) {

  001d6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?BlFatNumberOfDataClusters@@3KA, 0 ; BlFatNumberOfDataClusters
  001dd	75 0a		 jne	 SHORT $LN3@BlFat16Ini

; 1192 : 
; 1193 : #if FAT_VERBOSE
; 1194 :         BlRtlPrintf("FAT: NumberOfDataClusters == 0!\n");
; 1195 : #endif
; 1196 :         BlFatHalt();

  001df	b9 ac 04 00 00	 mov	 ecx, 1196		; 000004acH
  001e4	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN3@BlFat16Ini:

; 1197 :     }
; 1198 : 
; 1199 :     BlFatLinkTerminator = FAT16_LINK_TERMINATOR;

  001e9	c7 05 00 00 00
	00 ff ff 00 00	 mov	 DWORD PTR ?BlFatLinkTerminator@@3KA, 65535 ; BlFatLinkTerminator, 0000ffffH

; 1200 :     BlFatGetNextCluster = BlFat16GetNextCluster;

  001f3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?BlFatGetNextCluster@@3P6IEKPAK@ZA, OFFSET ?BlFat16GetNextCluster@@YIEKPAK@Z ; BlFatGetNextCluster, BlFat16GetNextCluster

; 1201 : 
; 1202 :     //
; 1203 :     // Read root directory.
; 1204 :     //
; 1205 : 
; 1206 :     BlFatRootDirectory = (PFAT_DIRECTORY_ENTRY) BlPoolAllocateBlock((BlFatDataStart - BlFatRootStart) * FAT_SECTOR_SIZE);

  001fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BlFatDataStart@@3KA ; BlFatDataStart
  00203	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR ?BlFatRootStart@@3KA ; BlFatRootStart
  00209	c1 e1 09	 shl	 ecx, 9
  0020c	e8 00 00 00 00	 call	 ?BlPoolAllocateBlock@@YIPAXK@Z ; BlPoolAllocateBlock
  00211	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatRootDirectory@@3PAU_FAT_DIRECTORY_ENTRY@@A, eax ; BlFatRootDirectory

; 1207 : 
; 1208 :     if (BlFatReadSector(BlFatRootStart,
; 1209 :                         BlFatDataStart - BlFatRootStart,
; 1210 :                         (PFAT_SECTOR) BlFatRootDirectory) == FALSE) {

  00216	ff 35 00 00 00
	00		 push	 DWORD PTR ?BlFatRootDirectory@@3PAU_FAT_DIRECTORY_ENTRY@@A ; BlFatRootDirectory
  0021c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?BlFatDataStart@@3KA ; BlFatDataStart
  00222	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR ?BlFatRootStart@@3KA ; BlFatRootStart
  00228	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BlFatRootStart@@3KA ; BlFatRootStart
  0022e	e8 00 00 00 00	 call	 ?BlFatReadSector@@YIEKKPAU_FAT_SECTOR@@@Z ; BlFatReadSector
  00233	0f b6 c0	 movzx	 eax, al
  00236	85 c0		 test	 eax, eax
  00238	75 0a		 jne	 SHORT $LN2@BlFat16Ini

; 1211 : 
; 1212 : #if FAT_VERBOSE
; 1213 :         BlRtlPrintf("FAT: Error reading root directory!\n");
; 1214 : #endif
; 1215 :         BlFatHalt();

  0023a	b9 bf 04 00 00	 mov	 ecx, 1215		; 000004bfH
  0023f	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN2@BlFat16Ini:

; 1216 :     }
; 1217 : 
; 1218 :     BLASSERT(FAT_IS_DATA_CLUSTER(FAT16_LINK_TERMINATOR) == FALSE);

  00244	33 c0		 xor	 eax, eax
  00246	40		 inc	 eax
  00247	74 15		 je	 SHORT $LN20@BlFat16Ini
  00249	81 3d 00 00 00
	00 fd ff 00 00	 cmp	 DWORD PTR ?BlFatNumberOfDataClusters@@3KA, 65533 ; BlFatNumberOfDataClusters, 0000fffdH
  00253	76 09		 jbe	 SHORT $LN20@BlFat16Ini
  00255	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv179[ebp], 1
  0025c	eb 04		 jmp	 SHORT $LN21@BlFat16Ini
$LN20@BlFat16Ini:
  0025e	83 65 f8 00	 and	 DWORD PTR tv179[ebp], 0
$LN21@BlFat16Ini:
  00262	83 7d f8 00	 cmp	 DWORD PTR tv179[ebp], 0
  00266	74 0f		 je	 SHORT $LN18@BlFat16Ini
  00268	ba c2 04 00 00	 mov	 edx, 1218		; 000004c2H
  0026d	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  00272	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN18@BlFat16Ini:

; 1219 : 
; 1220 :     return;
; 1221 : }

  00277	c9		 leave
  00278	c3		 ret	 0
?BlFat16Initialize@@YIXXZ ENDP				; BlFat16Initialize
_TEXT	ENDS
PUBLIC	?BlFat32GetNextCluster@@YIEKPAK@Z		; BlFat32GetNextCluster
; Function compile flags: /Odsp
;	COMDAT ?BlFat32GetNextCluster@@YIEKPAK@Z
_TEXT	SEGMENT
_TablePage$ = -1024					; size = 512
_Offset$ = -20						; size = 4
_Sector$ = -16						; size = 4
tv67 = -12						; size = 4
_Cluster$ = -8						; size = 4
_NextCluster$ = -4					; size = 4
?BlFat32GetNextCluster@@YIEKPAK@Z PROC			; BlFat32GetNextCluster, COMDAT
; _Cluster$ = ecx
; _NextCluster$ = edx

; 1248 : {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	81 e4 00 fe ff
	ff		 and	 esp, -512		; fffffe00H
  0000b	83 c4 04	 add	 esp, 4
  0000e	55		 push	 ebp
  0000f	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00012	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00016	8b ec		 mov	 ebp, esp
  00018	81 ec 00 04 00
	00		 sub	 esp, 1024		; 00000400H
  0001e	89 55 fc	 mov	 DWORD PTR _NextCluster$[ebp], edx
  00021	89 4d f8	 mov	 DWORD PTR _Cluster$[ebp], ecx

; 1249 :     UINT32 Offset;
; 1250 :     UINT32 Sector;
; 1251 :     FAT_SECTOR TablePage;
; 1252 : 
; 1253 :     if (FAT_IS_DATA_CLUSTER(Cluster) == FALSE) {

  00024	83 7d f8 02	 cmp	 DWORD PTR _Cluster$[ebp], 2
  00028	72 16		 jb	 SHORT $LN5@BlFat32Get
  0002a	8b 45 f8	 mov	 eax, DWORD PTR _Cluster$[ebp]
  0002d	48		 dec	 eax
  0002e	48		 dec	 eax
  0002f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?BlFatNumberOfDataClusters@@3KA ; BlFatNumberOfDataClusters
  00035	73 09		 jae	 SHORT $LN5@BlFat32Get
  00037	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  0003e	eb 04		 jmp	 SHORT $LN6@BlFat32Get
$LN5@BlFat32Get:
  00040	83 65 f4 00	 and	 DWORD PTR tv67[ebp], 0
$LN6@BlFat32Get:
  00044	83 7d f4 00	 cmp	 DWORD PTR tv67[ebp], 0
  00048	75 04		 jne	 SHORT $LN2@BlFat32Get

; 1254 : 
; 1255 : #if FAT_VERBOSE
; 1256 : 
; 1257 :         BlRtlPrintf("FAT: Fat32GetNextCluster: Cluster %u is out of range!\n", Cluster);
; 1258 : 
; 1259 : #endif
; 1260 : 
; 1261 :         return FALSE;

  0004a	32 c0		 xor	 al, al
  0004c	eb 4c		 jmp	 SHORT $LN3@BlFat32Get
$LN2@BlFat32Get:

; 1262 :     }
; 1263 : 
; 1264 :     Sector = BlFatTableStart + (Cluster / 128);

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _Cluster$[ebp]
  00051	c1 e8 07	 shr	 eax, 7
  00054	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?BlFatTableStart@@3KA ; BlFatTableStart
  0005a	89 45 f0	 mov	 DWORD PTR _Sector$[ebp], eax

; 1265 :     Offset = Cluster % 128;

  0005d	8b 45 f8	 mov	 eax, DWORD PTR _Cluster$[ebp]
  00060	33 d2		 xor	 edx, edx
  00062	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00067	f7 f1		 div	 ecx
  00069	89 55 ec	 mov	 DWORD PTR _Offset$[ebp], edx

; 1266 : 
; 1267 :     if (BlFatReadSector(Sector, 1, &TablePage) == FALSE) {

  0006c	8d 85 00 fc ff
	ff		 lea	 eax, DWORD PTR _TablePage$[ebp]
  00072	50		 push	 eax
  00073	33 d2		 xor	 edx, edx
  00075	42		 inc	 edx
  00076	8b 4d f0	 mov	 ecx, DWORD PTR _Sector$[ebp]
  00079	e8 00 00 00 00	 call	 ?BlFatReadSector@@YIEKKPAU_FAT_SECTOR@@@Z ; BlFatReadSector
  0007e	0f b6 c0	 movzx	 eax, al
  00081	85 c0		 test	 eax, eax
  00083	75 04		 jne	 SHORT $LN1@BlFat32Get

; 1268 : 
; 1269 :         return FALSE;

  00085	32 c0		 xor	 al, al
  00087	eb 11		 jmp	 SHORT $LN3@BlFat32Get
$LN1@BlFat32Get:

; 1270 :     }
; 1271 : 
; 1272 :     *NextCluster = ((PUINT32) &TablePage)[Offset];

  00089	8b 45 fc	 mov	 eax, DWORD PTR _NextCluster$[ebp]
  0008c	8b 4d ec	 mov	 ecx, DWORD PTR _Offset$[ebp]
  0008f	8b 8c 8d 00 fc
	ff ff		 mov	 ecx, DWORD PTR _TablePage$[ebp+ecx*4]
  00096	89 08		 mov	 DWORD PTR [eax], ecx

; 1273 : 
; 1274 :     return TRUE;

  00098	b0 01		 mov	 al, 1
$LN3@BlFat32Get:

; 1275 : }

  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	8b e3		 mov	 esp, ebx
  0009f	5b		 pop	 ebx
  000a0	c3		 ret	 0
?BlFat32GetNextCluster@@YIEKPAK@Z ENDP			; BlFat32GetNextCluster
_TEXT	ENDS
PUBLIC	?BlFat32Initialize@@YIXXZ			; BlFat32Initialize
; Function compile flags: /Odsp
;	COMDAT ?BlFat32Initialize@@YIXXZ
_TEXT	SEGMENT
tv177 = -12						; size = 4
_RootDirectoryChainLength$ = -8				; size = 4
_BootSector$ = -4					; size = 4
?BlFat32Initialize@@YIXXZ PROC				; BlFat32Initialize, COMDAT

; 1290 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1291 :     PFAT32_BOOT_SECTOR BootSector;
; 1292 :     UINT32 RootDirectoryChainLength;
; 1293 : 
; 1294 :     BootSector = &BlFatBootSector.u1.Fat32;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _BootSector$[ebp], OFFSET ?BlFatBootSector@@3U_FAT_BOOT_SECTOR@@A ; BlFatBootSector

; 1295 : 
; 1296 :     BLASSERT(BlFatMbr.Partition[BlFatPartitionId].Type == MBR_FAT32LBA);

  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatPartitionId@@3KA ; BlFatPartitionId
  00012	c1 e0 04	 shl	 eax, 4
  00015	0f b6 80 c2 01
	00 00		 movzx	 eax, BYTE PTR ?BlFatMbr@@3U_MBR@@A[eax+450]
  0001c	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  0001f	74 0f		 je	 SHORT $LN16@BlFat32Ini
  00021	ba 10 05 00 00	 mov	 edx, 1296		; 00000510H
  00026	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  0002b	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN16@BlFat32Ini:

; 1297 : 
; 1298 :     //
; 1299 :     // Read FAT32 boot sector.
; 1300 :     //
; 1301 : 
; 1302 :     if (BlRtlReadDrive(BlFatDriveId,
; 1303 :                        BlFatPartitionStart,
; 1304 :                        1,
; 1305 :                        BootSector) == FALSE) {

  00030	ff 75 fc	 push	 DWORD PTR _BootSector$[ebp]
  00033	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatPartitionStart@@3KA ; BlFatPartitionStart
  00038	33 c9		 xor	 ecx, ecx
  0003a	51		 push	 ecx
  0003b	50		 push	 eax
  0003c	66 ba 01 00	 mov	 dx, 1
  00040	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?BlFatDriveId@@3EA ; BlFatDriveId
  00046	e8 00 00 00 00	 call	 ?BlRtlReadDrive@@YIEE_KGPAX@Z ; BlRtlReadDrive
  0004b	0f b6 c0	 movzx	 eax, al
  0004e	85 c0		 test	 eax, eax
  00050	75 0a		 jne	 SHORT $LN15@BlFat32Ini

; 1306 : 
; 1307 : #if FAT_VERBOSE
; 1308 :         BlRtlPrintf("FAT: Error reading boot sector!\n");
; 1309 : #endif
; 1310 :         BlFatHalt();

  00052	b9 1e 05 00 00	 mov	 ecx, 1310		; 0000051eH
  00057	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN15@BlFat32Ini:

; 1311 :     }
; 1312 : 
; 1313 :     //
; 1314 :     // Extract volume geometry.
; 1315 :     //
; 1316 : 
; 1317 :     if (BootSector->BytesPerSector != FAT_SECTOR_SIZE) {

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  0005f	0f b7 40 0b	 movzx	 eax, WORD PTR [eax+11]
  00063	3d 00 02 00 00	 cmp	 eax, 512		; 00000200H
  00068	74 0a		 je	 SHORT $LN14@BlFat32Ini

; 1318 : 
; 1319 : #if FAT_VERBOSE
; 1320 :         BlRtlPrintf("FAT: Unsupported sector size (%u)!\n", BootSector->BytesPerSector);
; 1321 : #endif
; 1322 :         BlFatHalt();

  0006a	b9 2a 05 00 00	 mov	 ecx, 1322		; 0000052aH
  0006f	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN14@BlFat32Ini:

; 1323 :     }
; 1324 : 
; 1325 :     BlFatSectorsPerCluster = BootSector->SectorsPerCluster;

  00074	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  00077	0f b6 40 0d	 movzx	 eax, BYTE PTR [eax+13]
  0007b	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatSectorsPerCluster@@3KA, eax ; BlFatSectorsPerCluster

; 1326 : 
; 1327 :     if (BlFatSectorsPerCluster == 0) {

  00080	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?BlFatSectorsPerCluster@@3KA, 0 ; BlFatSectorsPerCluster
  00087	75 0a		 jne	 SHORT $LN13@BlFat32Ini

; 1328 : 
; 1329 : #if FAT_VERBOSE
; 1330 :         BlRtlPrintf("FAT: SectorsPerCluster == 0!\n");
; 1331 : #endif
; 1332 :         BlFatHalt();

  00089	b9 34 05 00 00	 mov	 ecx, 1332		; 00000534H
  0008e	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN13@BlFat32Ini:

; 1333 :     }
; 1334 : 
; 1335 :     BlFatBytesPerCluster = BlFatSectorsPerCluster * FAT_SECTOR_SIZE;

  00093	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatSectorsPerCluster@@3KA ; BlFatSectorsPerCluster
  00098	c1 e0 09	 shl	 eax, 9
  0009b	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatBytesPerCluster@@3KA, eax ; BlFatBytesPerCluster

; 1336 : 
; 1337 :     if (BootSector->TotalSectorCount32 > 0) {

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  000a3	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  000a7	76 0d		 jbe	 SHORT $LN12@BlFat32Ini

; 1338 : 
; 1339 :         BlFatTotalSectorCount = BootSector->TotalSectorCount32;

  000a9	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  000ac	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  000af	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatTotalSectorCount@@3KA, eax ; BlFatTotalSectorCount

; 1340 : 
; 1341 :     } else {

  000b4	eb 0c		 jmp	 SHORT $LN11@BlFat32Ini
$LN12@BlFat32Ini:

; 1342 : 
; 1343 :         BlFatTotalSectorCount = BootSector->TotalSectorCount16;

  000b6	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  000b9	0f b7 40 13	 movzx	 eax, WORD PTR [eax+19]
  000bd	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatTotalSectorCount@@3KA, eax ; BlFatTotalSectorCount
$LN11@BlFat32Ini:

; 1344 :     }
; 1345 : 
; 1346 :     if (BlFatTotalSectorCount > BlFatPartitionSize) {

  000c2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatTotalSectorCount@@3KA ; BlFatTotalSectorCount
  000c7	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?BlFatPartitionSize@@3KA ; BlFatPartitionSize
  000cd	76 0a		 jbe	 SHORT $LN10@BlFat32Ini

; 1347 : 
; 1348 : #if FAT_VERBOSE
; 1349 :         BlRtlPrintf("FAT: Boot sector claims more sectors than MBR!\n");
; 1350 : #endif
; 1351 :         BlFatHalt();

  000cf	b9 47 05 00 00	 mov	 ecx, 1351		; 00000547H
  000d4	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN10@BlFat32Ini:

; 1352 :     }
; 1353 : 
; 1354 :     if (BootSector->NumberOfFATs == 0) {

  000d9	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  000dc	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]
  000e0	85 c0		 test	 eax, eax
  000e2	75 0a		 jne	 SHORT $LN9@BlFat32Ini

; 1355 : 
; 1356 : #if FAT_VERBOSE
; 1357 :         BlRtlPrintf("FAT: NumberOfFATs == 0!\n");
; 1358 : #endif
; 1359 :         BlFatHalt();

  000e4	b9 4f 05 00 00	 mov	 ecx, 1359		; 0000054fH
  000e9	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN9@BlFat32Ini:

; 1360 :     }
; 1361 : 
; 1362 :     if (BootSector->SectorsPerFAT32 == 0) {

  000ee	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  000f1	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  000f5	75 0a		 jne	 SHORT $LN8@BlFat32Ini

; 1363 : 
; 1364 : #if FAT_VERBOSE
; 1365 :         BlRtlPrintf("FAT: SectorsPerFAT == 0!\n");
; 1366 : #endif
; 1367 :         BlFatHalt();

  000f7	b9 57 05 00 00	 mov	 ecx, 1367		; 00000557H
  000fc	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN8@BlFat32Ini:

; 1368 :     }
; 1369 : 
; 1370 :     if (BootSector->NumberOfRootDirectoryEntries != 0) {

  00101	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  00104	0f b7 40 11	 movzx	 eax, WORD PTR [eax+17]
  00108	85 c0		 test	 eax, eax
  0010a	74 0a		 je	 SHORT $LN7@BlFat32Ini

; 1371 : 
; 1372 : #if FAT_VERBOSE
; 1373 :         BlRtlPrintf("FAT: BootSector->NumberOfRootDirectoryEntries != 0!\n");
; 1374 : #endif
; 1375 :         BlFatHalt();

  0010c	b9 5f 05 00 00	 mov	 ecx, 1375		; 0000055fH
  00111	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN7@BlFat32Ini:

; 1376 :     }
; 1377 : 
; 1378 :     BlFatTableStart = BootSector->NumberOfReservedSectors;

  00116	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  00119	0f b7 40 0e	 movzx	 eax, WORD PTR [eax+14]
  0011d	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatTableStart@@3KA, eax ; BlFatTableStart

; 1379 : 
; 1380 :     if (BlFatTotalSectorCount < BlFatTableStart) {

  00122	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatTotalSectorCount@@3KA ; BlFatTotalSectorCount
  00127	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?BlFatTableStart@@3KA ; BlFatTableStart
  0012d	73 0a		 jae	 SHORT $LN6@BlFat32Ini

; 1381 : 
; 1382 : #if FAT_VERBOSE
; 1383 :         BlRtlPrintf("FAT: TotalSectorCount < TableStart!\n");
; 1384 : #endif
; 1385 :         BlFatHalt();

  0012f	b9 69 05 00 00	 mov	 ecx, 1385		; 00000569H
  00134	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN6@BlFat32Ini:

; 1386 :     }
; 1387 : 
; 1388 :     BlFatDataStart = BlFatTableStart + (BootSector->NumberOfFATs * BootSector->SectorsPerFAT32);

  00139	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  0013c	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]
  00140	8b 4d fc	 mov	 ecx, DWORD PTR _BootSector$[ebp]
  00143	0f af 41 24	 imul	 eax, DWORD PTR [ecx+36]
  00147	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?BlFatTableStart@@3KA ; BlFatTableStart
  0014d	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatDataStart@@3KA, eax ; BlFatDataStart

; 1389 : 
; 1390 :     if (BlFatTotalSectorCount < BlFatDataStart) {

  00152	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatTotalSectorCount@@3KA ; BlFatTotalSectorCount
  00157	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?BlFatDataStart@@3KA ; BlFatDataStart
  0015d	73 0a		 jae	 SHORT $LN5@BlFat32Ini

; 1391 : 
; 1392 : #if FAT_VERBOSE
; 1393 :         BlRtlPrintf("FAT: TotalSectorCount < DataStart!\n");
; 1394 : #endif
; 1395 :         BlFatHalt();

  0015f	b9 73 05 00 00	 mov	 ecx, 1395		; 00000573H
  00164	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN5@BlFat32Ini:

; 1396 :     }
; 1397 : 
; 1398 :     BlFatNumberOfDataClusters = (BlFatTotalSectorCount - BlFatDataStart) / BlFatSectorsPerCluster;

  00169	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatTotalSectorCount@@3KA ; BlFatTotalSectorCount
  0016e	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?BlFatDataStart@@3KA ; BlFatDataStart
  00174	33 d2		 xor	 edx, edx
  00176	f7 35 00 00 00
	00		 div	 DWORD PTR ?BlFatSectorsPerCluster@@3KA ; BlFatSectorsPerCluster
  0017c	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatNumberOfDataClusters@@3KA, eax ; BlFatNumberOfDataClusters

; 1399 : 
; 1400 :     if (BlFatNumberOfDataClusters == 0) {

  00181	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?BlFatNumberOfDataClusters@@3KA, 0 ; BlFatNumberOfDataClusters
  00188	75 0a		 jne	 SHORT $LN4@BlFat32Ini

; 1401 : 
; 1402 : #if FAT_VERBOSE
; 1403 :         BlRtlPrintf("FAT: NumberOfDataClusters == 0!\n");
; 1404 : #endif
; 1405 :         BlFatHalt();

  0018a	b9 7d 05 00 00	 mov	 ecx, 1405		; 0000057dH
  0018f	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN4@BlFat32Ini:

; 1406 :     }
; 1407 : 
; 1408 :     BlFatLinkTerminator = FAT32_LINK_TERMINATOR;

  00194	c7 05 00 00 00
	00 ff ff ff 0f	 mov	 DWORD PTR ?BlFatLinkTerminator@@3KA, 268435455 ; BlFatLinkTerminator, 0fffffffH

; 1409 :     BlFatGetNextCluster = BlFat32GetNextCluster;

  0019e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?BlFatGetNextCluster@@3P6IEKPAK@ZA, OFFSET ?BlFat32GetNextCluster@@YIEKPAK@Z ; BlFatGetNextCluster, BlFat32GetNextCluster

; 1410 : 
; 1411 :     //
; 1412 :     // Read root directory.
; 1413 :     //
; 1414 : 
; 1415 :     if (BlFatGetLengthClusterChain(BootSector->RootDirectoryFirstCluster, &RootDirectoryChainLength) == FALSE) {

  001a8	8d 55 f8	 lea	 edx, DWORD PTR _RootDirectoryChainLength$[ebp]
  001ab	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  001ae	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  001b1	e8 00 00 00 00	 call	 ?BlFatGetLengthClusterChain@@YIEKPAK@Z ; BlFatGetLengthClusterChain
  001b6	0f b6 c0	 movzx	 eax, al
  001b9	85 c0		 test	 eax, eax
  001bb	75 0a		 jne	 SHORT $LN3@BlFat32Ini

; 1416 : 
; 1417 : #if FAT_VERBOSE
; 1418 :         BlRtlPrintf("FAT: Error querying chain length of root directory!\n");
; 1419 : #endif
; 1420 :         BlFatHalt();

  001bd	b9 8c 05 00 00	 mov	 ecx, 1420		; 0000058cH
  001c2	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN3@BlFat32Ini:

; 1421 :     }
; 1422 : 
; 1423 :     BlFatRootDirectory = (PFAT_DIRECTORY_ENTRY) BlPoolAllocateBlock(RootDirectoryChainLength * BlFatBytesPerCluster);

  001c7	8b 4d f8	 mov	 ecx, DWORD PTR _RootDirectoryChainLength$[ebp]
  001ca	0f af 0d 00 00
	00 00		 imul	 ecx, DWORD PTR ?BlFatBytesPerCluster@@3KA ; BlFatBytesPerCluster
  001d1	e8 00 00 00 00	 call	 ?BlPoolAllocateBlock@@YIPAXK@Z ; BlPoolAllocateBlock
  001d6	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatRootDirectory@@3PAU_FAT_DIRECTORY_ENTRY@@A, eax ; BlFatRootDirectory

; 1424 : 
; 1425 :     if (BlFatReadClusterChain(BootSector->RootDirectoryFirstCluster,
; 1426 :                               RootDirectoryChainLength * BlFatBytesPerCluster,
; 1427 :                               BlFatRootDirectory) == FALSE) {

  001db	ff 35 00 00 00
	00		 push	 DWORD PTR ?BlFatRootDirectory@@3PAU_FAT_DIRECTORY_ENTRY@@A ; BlFatRootDirectory
  001e1	8b 55 f8	 mov	 edx, DWORD PTR _RootDirectoryChainLength$[ebp]
  001e4	0f af 15 00 00
	00 00		 imul	 edx, DWORD PTR ?BlFatBytesPerCluster@@3KA ; BlFatBytesPerCluster
  001eb	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  001ee	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  001f1	e8 00 00 00 00	 call	 ?BlFatReadClusterChain@@YIEKKPAX@Z ; BlFatReadClusterChain
  001f6	0f b6 c0	 movzx	 eax, al
  001f9	85 c0		 test	 eax, eax
  001fb	75 0a		 jne	 SHORT $LN2@BlFat32Ini

; 1428 : 
; 1429 : #if FAT_VERBOSE
; 1430 :         BlRtlPrintf("FAT: Error reading root directory!\n");
; 1431 : #endif
; 1432 :         BlFatHalt();

  001fd	b9 98 05 00 00	 mov	 ecx, 1432		; 00000598H
  00202	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN2@BlFat32Ini:

; 1433 :     }
; 1434 : 
; 1435 :     BlFatNumberOfRootDirectoryEntries = (RootDirectoryChainLength * BlFatBytesPerCluster) / sizeof(FAT_DIRECTORY_ENTRY);

  00207	8b 45 f8	 mov	 eax, DWORD PTR _RootDirectoryChainLength$[ebp]
  0020a	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR ?BlFatBytesPerCluster@@3KA ; BlFatBytesPerCluster
  00211	c1 e8 05	 shr	 eax, 5
  00214	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatNumberOfRootDirectoryEntries@@3KA, eax ; BlFatNumberOfRootDirectoryEntries

; 1436 : 
; 1437 : 
; 1438 :     BLASSERT(FAT_IS_DATA_CLUSTER(FAT32_LINK_TERMINATOR) == FALSE);

  00219	33 c0		 xor	 eax, eax
  0021b	40		 inc	 eax
  0021c	74 15		 je	 SHORT $LN19@BlFat32Ini
  0021e	81 3d 00 00 00
	00 fd ff ff 0f	 cmp	 DWORD PTR ?BlFatNumberOfDataClusters@@3KA, 268435453 ; BlFatNumberOfDataClusters, 0ffffffdH
  00228	76 09		 jbe	 SHORT $LN19@BlFat32Ini
  0022a	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv177[ebp], 1
  00231	eb 04		 jmp	 SHORT $LN20@BlFat32Ini
$LN19@BlFat32Ini:
  00233	83 65 f4 00	 and	 DWORD PTR tv177[ebp], 0
$LN20@BlFat32Ini:
  00237	83 7d f4 00	 cmp	 DWORD PTR tv177[ebp], 0
  0023b	74 0f		 je	 SHORT $LN17@BlFat32Ini
  0023d	ba 9e 05 00 00	 mov	 edx, 1438		; 0000059eH
  00242	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  00247	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN17@BlFat32Ini:

; 1439 : 
; 1440 :     return;
; 1441 : }

  0024c	c9		 leave
  0024d	c3		 ret	 0
?BlFat32Initialize@@YIXXZ ENDP				; BlFat32Initialize
_TEXT	ENDS
PUBLIC	??_C@_0BI@MOIILNGK@FAT?3?5No?5?$CFs?5partitions?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_05HNJNFBJJ@FAT32?$AA@			; `string'
PUBLIC	??_C@_05BKHFEAPD@FAT16?$AA@			; `string'
PUBLIC	??_C@_0BI@HGHMGDLA@FAT?3?5No?5MBR?5signature?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0BJ@CLMOHOJH@FAT?3?5Error?5reading?5MBR?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0CI@OBAMHFHH@FAT?3?5Unexpected?5bytes?5per?5sector@ ; `string'
PUBLIC	??_C@_0CD@FBPPOBEA@FAT?3?5Can?8t?5get?5drive?5info?50x?$CF02x@ ; `string'
PUBLIC	?BlFatInitialize@@YIXEE@Z			; BlFatInitialize
EXTRN	?BlFsReadFile@@3P6IEPBDPAXK@ZA:DWORD		; BlFsReadFile
EXTRN	?BlFsGetFileSize@@3P6IEPBDPAK@ZA:DWORD		; BlFsGetFileSize
EXTRN	?BlRtlGetDriveParameters@@YIEEPAU_INT13_DRIVE_PARAMETERS@@@Z:PROC ; BlRtlGetDriveParameters
;	COMDAT ??_C@_0BI@MOIILNGK@FAT?3?5No?5?$CFs?5partitions?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BI@MOIILNGK@FAT?3?5No?5?$CFs?5partitions?$CB?6?$AA@ DB 'FAT: No %s'
	DB	' partitions!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05HNJNFBJJ@FAT32?$AA@
CONST	SEGMENT
??_C@_05HNJNFBJJ@FAT32?$AA@ DB 'FAT32', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BKHFEAPD@FAT16?$AA@
CONST	SEGMENT
??_C@_05BKHFEAPD@FAT16?$AA@ DB 'FAT16', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HGHMGDLA@FAT?3?5No?5MBR?5signature?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BI@HGHMGDLA@FAT?3?5No?5MBR?5signature?$CB?6?$AA@ DB 'FAT: No MBR s'
	DB	'ignature!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CLMOHOJH@FAT?3?5Error?5reading?5MBR?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BJ@CLMOHOJH@FAT?3?5Error?5reading?5MBR?$CB?6?$AA@ DB 'FAT: Error r'
	DB	'eading MBR!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@OBAMHFHH@FAT?3?5Unexpected?5bytes?5per?5sector@
CONST	SEGMENT
??_C@_0CI@OBAMHFHH@FAT?3?5Unexpected?5bytes?5per?5sector@ DB 'FAT: Unexpe'
	DB	'cted bytes per sector (%u)!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FBPPOBEA@FAT?3?5Can?8t?5get?5drive?5info?50x?$CF02x@
CONST	SEGMENT
??_C@_0CD@FBPPOBEA@FAT?3?5Can?8t?5get?5drive?5info?50x?$CF02x@ DB 'FAT: C'
	DB	'an''t get drive info 0x%02x!', 0aH, 00H	; `string'
; Function compile flags: /Odsp
CONST	ENDS
;	COMDAT ?BlFatInitialize@@YIXEE@Z
_TEXT	SEGMENT
tv165 = -20						; size = 4
tv144 = -16						; size = 4
_FatType$ = -12						; size = 1
_DriveId$ = -8						; size = 1
_Index$ = -4						; size = 4
?BlFatInitialize@@YIXEE@Z PROC				; BlFatInitialize, COMDAT
; _DriveId$ = cl
; _FatType$ = dl

; 1463 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	88 55 f4	 mov	 BYTE PTR _FatType$[ebp], dl
  00009	88 4d f8	 mov	 BYTE PTR _DriveId$[ebp], cl

; 1464 :     UINT32 Index;
; 1465 : 
; 1466 :     BLASSERT((FatType == MBR_FAT16LBA) || (FatType == MBR_FAT32LBA));

  0000c	0f b6 45 f4	 movzx	 eax, BYTE PTR _FatType$[ebp]
  00010	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  00013	74 18		 je	 SHORT $LN14@BlFatIniti
  00015	0f b6 45 f4	 movzx	 eax, BYTE PTR _FatType$[ebp]
  00019	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  0001c	74 0f		 je	 SHORT $LN14@BlFatIniti
  0001e	ba ba 05 00 00	 mov	 edx, 1466		; 000005baH
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  00028	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN14@BlFatIniti:

; 1467 : 
; 1468 :     if (BlRtlGetDriveParameters(DriveId, &BlFatDriveParameters) == FALSE) {

  0002d	ba 00 00 00 00	 mov	 edx, OFFSET ?BlFatDriveParameters@@3U_INT13_DRIVE_PARAMETERS@@A ; BlFatDriveParameters
  00032	8a 4d f8	 mov	 cl, BYTE PTR _DriveId$[ebp]
  00035	e8 00 00 00 00	 call	 ?BlRtlGetDriveParameters@@YIEEPAU_INT13_DRIVE_PARAMETERS@@@Z ; BlRtlGetDriveParameters
  0003a	0f b6 c0	 movzx	 eax, al
  0003d	85 c0		 test	 eax, eax
  0003f	75 20		 jne	 SHORT $LN13@BlFatIniti

; 1469 : 
; 1470 :         BlRtlPrintf("FAT: Can't get drive info 0x%02x!\n", DriveId);

  00041	0f b6 45 f8	 movzx	 eax, BYTE PTR _DriveId$[ebp]
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@FBPPOBEA@FAT?3?5Can?8t?5get?5drive?5info?50x?$CF02x@
  0004b	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  00050	59		 pop	 ecx
  00051	59		 pop	 ecx

; 1471 :         BlRtlHalt();

  00052	ba bf 05 00 00	 mov	 edx, 1471		; 000005bfH
  00057	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  0005c	e8 00 00 00 00	 call	 ?BlRtlHaltInternal@@YIXPBDK@Z ; BlRtlHaltInternal
$LN13@BlFatIniti:

; 1472 :     }
; 1473 : 
; 1474 :     if (BlFatDriveParameters.BytesPerSector != FAT_SECTOR_SIZE) {

  00061	0f b7 05 18 00
	00 00		 movzx	 eax, WORD PTR ?BlFatDriveParameters@@3U_INT13_DRIVE_PARAMETERS@@A+24
  00068	3d 00 02 00 00	 cmp	 eax, 512		; 00000200H
  0006d	74 23		 je	 SHORT $LN12@BlFatIniti

; 1475 : 
; 1476 :         BlRtlPrintf("FAT: Unexpected bytes per sector (%u)!\n", BlFatDriveParameters.BytesPerSector);

  0006f	0f b7 05 18 00
	00 00		 movzx	 eax, WORD PTR ?BlFatDriveParameters@@3U_INT13_DRIVE_PARAMETERS@@A+24
  00076	50		 push	 eax
  00077	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@OBAMHFHH@FAT?3?5Unexpected?5bytes?5per?5sector@
  0007c	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  00081	59		 pop	 ecx
  00082	59		 pop	 ecx

; 1477 :         BlRtlHalt();

  00083	ba c5 05 00 00	 mov	 edx, 1477		; 000005c5H
  00088	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  0008d	e8 00 00 00 00	 call	 ?BlRtlHaltInternal@@YIXPBDK@Z ; BlRtlHaltInternal
$LN12@BlFatIniti:

; 1478 :     }
; 1479 : 
; 1480 :     if (BlRtlReadDrive(DriveId, 0, 1, &BlFatMbr) == FALSE) {

  00092	68 00 00 00 00	 push	 OFFSET ?BlFatMbr@@3U_MBR@@A ; BlFatMbr
  00097	6a 00		 push	 0
  00099	6a 00		 push	 0
  0009b	66 ba 01 00	 mov	 dx, 1
  0009f	8a 4d f8	 mov	 cl, BYTE PTR _DriveId$[ebp]
  000a2	e8 00 00 00 00	 call	 ?BlRtlReadDrive@@YIEE_KGPAX@Z ; BlRtlReadDrive
  000a7	0f b6 c0	 movzx	 eax, al
  000aa	85 c0		 test	 eax, eax
  000ac	75 1a		 jne	 SHORT $LN11@BlFatIniti

; 1481 : 
; 1482 :         BlRtlPrintf("FAT: Error reading MBR!\n");

  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@CLMOHOJH@FAT?3?5Error?5reading?5MBR?$CB?6?$AA@
  000b3	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  000b8	59		 pop	 ecx

; 1483 :         BlRtlHalt();

  000b9	ba cb 05 00 00	 mov	 edx, 1483		; 000005cbH
  000be	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  000c3	e8 00 00 00 00	 call	 ?BlRtlHaltInternal@@YIXPBDK@Z ; BlRtlHaltInternal
$LN11@BlFatIniti:

; 1484 :     }
; 1485 : 
; 1486 :     if (BlFatMbr.Signature != MBR_SIGNATURE) {

  000c8	0f b7 05 fe 01
	00 00		 movzx	 eax, WORD PTR ?BlFatMbr@@3U_MBR@@A+510
  000cf	3d 55 aa 00 00	 cmp	 eax, 43605		; 0000aa55H
  000d4	74 0b		 je	 SHORT $LN10@BlFatIniti

; 1487 : 
; 1488 :         BlRtlPrintf("FAT: No MBR signature!\n");

  000d6	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@HGHMGDLA@FAT?3?5No?5MBR?5signature?$CB?6?$AA@
  000db	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  000e0	59		 pop	 ecx
$LN10@BlFatIniti:

; 1489 :     }
; 1490 : 
; 1491 :     BlFatPartitionId = (UINT32) -1;

  000e1	83 0d 00 00 00
	00 ff		 or	 DWORD PTR ?BlFatPartitionId@@3KA, -1 ; BlFatPartitionId

; 1492 : 
; 1493 :     for (Index = 0; Index <= 4; Index += 1) {

  000e8	83 65 fc 00	 and	 DWORD PTR _Index$[ebp], 0
  000ec	eb 07		 jmp	 SHORT $LN9@BlFatIniti
$LN8@BlFatIniti:
  000ee	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  000f1	40		 inc	 eax
  000f2	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax
$LN9@BlFatIniti:
  000f5	83 7d fc 04	 cmp	 DWORD PTR _Index$[ebp], 4
  000f9	0f 87 ab 00 00
	00		 ja	 $LN7@BlFatIniti

; 1494 : 
; 1495 :         if (FatType == BlFatMbr.Partition[Index].Type) {

  000ff	0f b6 45 f4	 movzx	 eax, BYTE PTR _FatType$[ebp]
  00103	8b 4d fc	 mov	 ecx, DWORD PTR _Index$[ebp]
  00106	c1 e1 04	 shl	 ecx, 4
  00109	0f b6 89 c2 01
	00 00		 movzx	 ecx, BYTE PTR ?BlFatMbr@@3U_MBR@@A[ecx+450]
  00110	3b c1		 cmp	 eax, ecx
  00112	0f 85 8d 00 00
	00		 jne	 $LN6@BlFatIniti

; 1496 : 
; 1497 :             switch (BlFatMbr.Partition[Index].Type) {

  00118	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  0011b	c1 e0 04	 shl	 eax, 4
  0011e	8a 80 c2 01 00
	00		 mov	 al, BYTE PTR ?BlFatMbr@@3U_MBR@@A[eax+450]
  00124	88 45 f0	 mov	 BYTE PTR tv144[ebp], al
  00127	80 7d f0 0c	 cmp	 BYTE PTR tv144[ebp], 12	; 0000000cH
  0012b	74 41		 je	 SHORT $LN2@BlFatIniti
  0012d	80 7d f0 0e	 cmp	 BYTE PTR tv144[ebp], 14	; 0000000eH
  00131	74 02		 je	 SHORT $LN3@BlFatIniti
  00133	eb 70		 jmp	 SHORT $LN6@BlFatIniti
$LN3@BlFatIniti:

; 1498 : 
; 1499 :                 case MBR_FAT16LBA: {
; 1500 : 
; 1501 :                     BlFatDriveId = DriveId;

  00135	8a 45 f8	 mov	 al, BYTE PTR _DriveId$[ebp]
  00138	a2 00 00 00 00	 mov	 BYTE PTR ?BlFatDriveId@@3EA, al ; BlFatDriveId

; 1502 :                     BlFatPartitionId = Index;

  0013d	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  00140	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatPartitionId@@3KA, eax ; BlFatPartitionId

; 1503 :                     BlFatPartitionStart = BlFatMbr.Partition[Index].FirstSector;

  00145	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  00148	c1 e0 04	 shl	 eax, 4
  0014b	8b 80 c6 01 00
	00		 mov	 eax, DWORD PTR ?BlFatMbr@@3U_MBR@@A[eax+454]
  00151	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatPartitionStart@@3KA, eax ; BlFatPartitionStart

; 1504 :                     BlFatPartitionSize = BlFatMbr.Partition[Index].NumberOfSectors;

  00156	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  00159	c1 e0 04	 shl	 eax, 4
  0015c	8b 80 ca 01 00
	00		 mov	 eax, DWORD PTR ?BlFatMbr@@3U_MBR@@A[eax+458]
  00162	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatPartitionSize@@3KA, eax ; BlFatPartitionSize

; 1505 : 
; 1506 :                     BlFat16Initialize();

  00167	e8 00 00 00 00	 call	 ?BlFat16Initialize@@YIXXZ ; BlFat16Initialize

; 1507 : 
; 1508 :                     break;

  0016c	eb 37		 jmp	 SHORT $LN6@BlFatIniti
$LN2@BlFatIniti:

; 1509 :                 }
; 1510 : 
; 1511 :                 case MBR_FAT32LBA: {
; 1512 : 
; 1513 :                     BlFatDriveId = DriveId;

  0016e	8a 45 f8	 mov	 al, BYTE PTR _DriveId$[ebp]
  00171	a2 00 00 00 00	 mov	 BYTE PTR ?BlFatDriveId@@3EA, al ; BlFatDriveId

; 1514 :                     BlFatPartitionId = Index;

  00176	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  00179	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatPartitionId@@3KA, eax ; BlFatPartitionId

; 1515 :                     BlFatPartitionStart = BlFatMbr.Partition[Index].FirstSector;

  0017e	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  00181	c1 e0 04	 shl	 eax, 4
  00184	8b 80 c6 01 00
	00		 mov	 eax, DWORD PTR ?BlFatMbr@@3U_MBR@@A[eax+454]
  0018a	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatPartitionStart@@3KA, eax ; BlFatPartitionStart

; 1516 :                     BlFatPartitionSize = BlFatMbr.Partition[Index].NumberOfSectors;

  0018f	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  00192	c1 e0 04	 shl	 eax, 4
  00195	8b 80 ca 01 00
	00		 mov	 eax, DWORD PTR ?BlFatMbr@@3U_MBR@@A[eax+458]
  0019b	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatPartitionSize@@3KA, eax ; BlFatPartitionSize

; 1517 : 
; 1518 :                     BlFat32Initialize();

  001a0	e8 00 00 00 00	 call	 ?BlFat32Initialize@@YIXXZ ; BlFat32Initialize
$LN6@BlFatIniti:

; 1519 : 
; 1520 :                     break;
; 1521 :                 }
; 1522 :             }
; 1523 :         }
; 1524 :     }

  001a5	e9 44 ff ff ff	 jmp	 $LN8@BlFatIniti
$LN7@BlFatIniti:

; 1525 : 
; 1526 :     if (BlFatPartitionId == (UINT32) -1) {

  001aa	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?BlFatPartitionId@@3KA, -1 ; BlFatPartitionId
  001b1	75 37		 jne	 SHORT $LN1@BlFatIniti

; 1527 : 
; 1528 :         BlRtlPrintf("FAT: No %s partitions!\n", FatType == MBR_FAT16LBA ? "FAT16" : "FAT32");

  001b3	0f b6 45 f4	 movzx	 eax, BYTE PTR _FatType$[ebp]
  001b7	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  001ba	75 09		 jne	 SHORT $LN17@BlFatIniti
  001bc	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv165[ebp], OFFSET ??_C@_05BKHFEAPD@FAT16?$AA@
  001c3	eb 07		 jmp	 SHORT $LN18@BlFatIniti
$LN17@BlFatIniti:
  001c5	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv165[ebp], OFFSET ??_C@_05HNJNFBJJ@FAT32?$AA@
$LN18@BlFatIniti:
  001cc	ff 75 ec	 push	 DWORD PTR tv165[ebp]
  001cf	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@MOIILNGK@FAT?3?5No?5?$CFs?5partitions?$CB?6?$AA@
  001d4	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  001d9	59		 pop	 ecx
  001da	59		 pop	 ecx

; 1529 : 
; 1530 :         BlRtlHalt();

  001db	ba fa 05 00 00	 mov	 edx, 1530		; 000005faH
  001e0	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  001e5	e8 00 00 00 00	 call	 ?BlRtlHaltInternal@@YIXPBDK@Z ; BlRtlHaltInternal
$LN1@BlFatIniti:

; 1531 :     }
; 1532 : 
; 1533 :     BlFsGetFileSize = BlFatGetFileSize;

  001ea	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?BlFsGetFileSize@@3P6IEPBDPAK@ZA, OFFSET ?BlFatGetFileSize@@YIEPBDPAK@Z ; BlFsGetFileSize, BlFatGetFileSize

; 1534 :     BlFsReadFile = BlFatReadFile;

  001f4	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?BlFsReadFile@@3P6IEPBDPAXK@ZA, OFFSET ?BlFatReadFile@@YIEPBDPAXK@Z ; BlFsReadFile, BlFatReadFile

; 1535 : 
; 1536 :     return;
; 1537 : }

  001fe	c9		 leave
  001ff	c3		 ret	 0
?BlFatInitialize@@YIXEE@Z ENDP				; BlFatInitialize
_TEXT	ENDS
END
