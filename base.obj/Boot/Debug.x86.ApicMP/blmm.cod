; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	C:\Users\cc\source\repos\Singularity-OS\base\Boot\SingLdrPc\blmm.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?BlMmInitialGdtr@@3U_GDTR@@A			; BlMmInitialGdtr
PUBLIC	?BlMmPgTable@@3PAU_BL_MM_PAGE_TABLE@@A		; BlMmPgTable
PUBLIC	?BlMmPhysicalRegionLookaside@@3U<unnamed-tag>@@A ; BlMmPhysicalRegionLookaside
PUBLIC	?BlMmPdTable@@3PAU_BL_MM_PAGE_TABLE@@A		; BlMmPdTable
PUBLIC	?BlMmBootCr3@@3KA				; BlMmBootCr3
PUBLIC	?BlMmPhysicalRegionList@@3U_LIST_ENTRY@@A	; BlMmPhysicalRegionList
PUBLIC	?BlMmLegacyCr3@@3KA				; BlMmLegacyCr3
PUBLIC	?BlMmPdpTable@@3PAU_BL_MM_PAGE_TABLE@@A		; BlMmPdpTable
PUBLIC	?BlMmExtendedBiosDataArea@@3PAXA		; BlMmExtendedBiosDataArea
_BSS	SEGMENT
?BlMmInitialGdtr@@3U_GDTR@@A DT 01H DUP (?)		; BlMmInitialGdtr
	ALIGN	4

?BlMmPgTable@@3PAU_BL_MM_PAGE_TABLE@@A DB 01000H DUP (?) ; BlMmPgTable
?BlMmPhysicalRegionLookaside@@3U<unnamed-tag>@@A DB 0288H DUP (?) ; BlMmPhysicalRegionLookaside
?BlMmPdTable@@3PAU_BL_MM_PAGE_TABLE@@A DB 04000H DUP (?) ; BlMmPdTable
?BlMmBootCr3@@3KA DD 01H DUP (?)			; BlMmBootCr3
?BlMmPhysicalRegionList@@3U_LIST_ENTRY@@A DQ 01H DUP (?) ; BlMmPhysicalRegionList
?BlMmLegacyCr3@@3KA DD 01H DUP (?)			; BlMmLegacyCr3
?BlMmPdpTable@@3PAU_BL_MM_PAGE_TABLE@@A DB 01000H DUP (?) ; BlMmPdpTable
?BlMmExtendedBiosDataArea@@3PAXA DD 01H DUP (?)		; BlMmExtendedBiosDataArea
_BSS	ENDS
PUBLIC	??_C@_08JOIABOAI@blmm?4cpp?$AA@			; `string'
PUBLIC	?BlMmCompactPhysicalRegionList@@YIXXZ		; BlMmCompactPhysicalRegionList
EXTRN	?BlRtlInsertTailList@@YIXPAU_LIST_ENTRY@@0@Z:PROC ; BlRtlInsertTailList
EXTRN	?BlRtlRemoveEntryList@@YIEPAU_LIST_ENTRY@@@Z:PROC ; BlRtlRemoveEntryList
EXTRN	?BlRtlAssertFailed@@YIXPBDK@Z:PROC		; BlRtlAssertFailed
EXTRN	?BlRtlIsListEmpty@@YIEPAU_LIST_ENTRY@@@Z:PROC	; BlRtlIsListEmpty
;	COMDAT ??_C@_08JOIABOAI@blmm?4cpp?$AA@
; File c:\users\cc\source\repos\singularity-os\base\boot\singldrpc\blmm.cpp
CONST	SEGMENT
??_C@_08JOIABOAI@blmm?4cpp?$AA@ DB 'blmm.cpp', 00H	; `string'
; Function compile flags: /Odsp
CONST	ENDS
;	COMDAT ?BlMmCompactPhysicalRegionList@@YIXXZ
_TEXT	SEGMENT
tv187 = -44						; size = 4
tv186 = -40						; size = 4
tv175 = -36						; size = 4
tv174 = -32						; size = 4
tv160 = -28						; size = 4
tv157 = -24						; size = 8
tv142 = -16						; size = 4
_Next$ = -12						; size = 4
_Head$ = -8						; size = 4
_Current$ = -4						; size = 4
?BlMmCompactPhysicalRegionList@@YIXXZ PROC		; BlMmCompactPhysicalRegionList, COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 60   :     PBL_MM_PHYSICAL_REGION Current;
; 61   :     PLIST_ENTRY Head;
; 62   :     PBL_MM_PHYSICAL_REGION Next;
; 63   : 
; 64   :     Head = &BlMmPhysicalRegionList;

  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _Head$[ebp], OFFSET ?BlMmPhysicalRegionList@@3U_LIST_ENTRY@@A ; BlMmPhysicalRegionList

; 65   : 
; 66   :     if (BlRtlIsListEmpty(Head) != FALSE) {

  0000d	8b 4d f8	 mov	 ecx, DWORD PTR _Head$[ebp]
  00010	e8 00 00 00 00	 call	 ?BlRtlIsListEmpty@@YIEPAU_LIST_ENTRY@@@Z ; BlRtlIsListEmpty
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	74 05		 je	 SHORT $LN10@BlMmCompac

; 67   : 
; 68   :         return;

  0001c	e9 65 01 00 00	 jmp	 $LN11@BlMmCompac
$LN10@BlMmCompac:

; 69   :     }
; 70   : 
; 71   :     Current = CONTAINING_RECORD(Head->Flink,
; 72   :                                 BL_MM_PHYSICAL_REGION,
; 73   :                                 Entry);

  00021	8b 45 f8	 mov	 eax, DWORD PTR _Head$[ebp]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	89 45 fc	 mov	 DWORD PTR _Current$[ebp], eax
$LN9@BlMmCompac:

; 74   : 
; 75   :     for (;;) {
; 76   : 
; 77   :         BLASSERT(Current->Size > 0);

  00029	8b 45 fc	 mov	 eax, DWORD PTR _Current$[ebp]
  0002c	89 45 f0	 mov	 DWORD PTR tv142[ebp], eax
  0002f	8b 45 f0	 mov	 eax, DWORD PTR tv142[ebp]
  00032	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00036	77 18		 ja	 SHORT $LN7@BlMmCompac
  00038	72 09		 jb	 SHORT $LN14@BlMmCompac
  0003a	8b 45 f0	 mov	 eax, DWORD PTR tv142[ebp]
  0003d	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00041	77 0d		 ja	 SHORT $LN7@BlMmCompac
$LN14@BlMmCompac:
  00043	6a 4d		 push	 77			; 0000004dH
  00045	5a		 pop	 edx
  00046	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_08JOIABOAI@blmm?4cpp?$AA@
  0004b	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN7@BlMmCompac:

; 78   : 
; 79   :         BLASSERT(Current->Start + Current->Size == Current->Limit);

  00050	8b 45 fc	 mov	 eax, DWORD PTR _Current$[ebp]
  00053	8b 4d fc	 mov	 ecx, DWORD PTR _Current$[ebp]
  00056	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00059	03 51 10	 add	 edx, DWORD PTR [ecx+16]
  0005c	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0005f	13 41 14	 adc	 eax, DWORD PTR [ecx+20]
  00062	8b 4d fc	 mov	 ecx, DWORD PTR _Current$[ebp]
  00065	89 55 e8	 mov	 DWORD PTR tv157[ebp], edx
  00068	89 45 ec	 mov	 DWORD PTR tv157[ebp+4], eax
  0006b	89 4d e4	 mov	 DWORD PTR tv160[ebp], ecx
  0006e	8b 45 e4	 mov	 eax, DWORD PTR tv160[ebp]
  00071	8b 4d e8	 mov	 ecx, DWORD PTR tv157[ebp]
  00074	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  00077	75 0b		 jne	 SHORT $LN15@BlMmCompac
  00079	8b 45 e4	 mov	 eax, DWORD PTR tv160[ebp]
  0007c	8b 4d ec	 mov	 ecx, DWORD PTR tv157[ebp+4]
  0007f	3b 48 1c	 cmp	 ecx, DWORD PTR [eax+28]
  00082	74 0d		 je	 SHORT $LN6@BlMmCompac
$LN15@BlMmCompac:
  00084	6a 4f		 push	 79			; 0000004fH
  00086	5a		 pop	 edx
  00087	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_08JOIABOAI@blmm?4cpp?$AA@
  0008c	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN6@BlMmCompac:

; 80   : 
; 81   :         BLASSERT((Current->Type >= BL_MM_PHYSICAL_REGION_MIN_TYPE) && (Current->Type <= BL_MM_PHYSICAL_REGION_MAX_TYPE));

  00091	8b 45 fc	 mov	 eax, DWORD PTR _Current$[ebp]
  00094	83 78 20 01	 cmp	 DWORD PTR [eax+32], 1
  00098	72 09		 jb	 SHORT $LN4@BlMmCompac
  0009a	8b 45 fc	 mov	 eax, DWORD PTR _Current$[ebp]
  0009d	83 78 20 10	 cmp	 DWORD PTR [eax+32], 16	; 00000010H
  000a1	76 0d		 jbe	 SHORT $LN5@BlMmCompac
$LN4@BlMmCompac:
  000a3	6a 51		 push	 81			; 00000051H
  000a5	5a		 pop	 edx
  000a6	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_08JOIABOAI@blmm?4cpp?$AA@
  000ab	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN5@BlMmCompac:

; 82   : 
; 83   :         if (Current->Entry.Flink == Head) {

  000b0	8b 45 fc	 mov	 eax, DWORD PTR _Current$[ebp]
  000b3	8b 00		 mov	 eax, DWORD PTR [eax]
  000b5	3b 45 f8	 cmp	 eax, DWORD PTR _Head$[ebp]
  000b8	75 05		 jne	 SHORT $LN3@BlMmCompac

; 84   : 
; 85   :             break;

  000ba	e9 c7 00 00 00	 jmp	 $LN11@BlMmCompac
$LN3@BlMmCompac:

; 86   :         }
; 87   : 
; 88   :         Next = CONTAINING_RECORD(Current->Entry.Flink,
; 89   :                                  BL_MM_PHYSICAL_REGION,
; 90   :                                  Entry);

  000bf	8b 45 fc	 mov	 eax, DWORD PTR _Current$[ebp]
  000c2	8b 00		 mov	 eax, DWORD PTR [eax]
  000c4	89 45 f4	 mov	 DWORD PTR _Next$[ebp], eax

; 91   : 
; 92   :         BLASSERT(Next->Start >= Current->Limit);

  000c7	8b 45 f4	 mov	 eax, DWORD PTR _Next$[ebp]
  000ca	8b 4d fc	 mov	 ecx, DWORD PTR _Current$[ebp]
  000cd	89 45 e0	 mov	 DWORD PTR tv174[ebp], eax
  000d0	89 4d dc	 mov	 DWORD PTR tv175[ebp], ecx
  000d3	8b 45 e0	 mov	 eax, DWORD PTR tv174[ebp]
  000d6	8b 4d dc	 mov	 ecx, DWORD PTR tv175[ebp]
  000d9	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000dc	3b 41 1c	 cmp	 eax, DWORD PTR [ecx+28]
  000df	77 1d		 ja	 SHORT $LN2@BlMmCompac
  000e1	72 0e		 jb	 SHORT $LN16@BlMmCompac
  000e3	8b 45 e0	 mov	 eax, DWORD PTR tv174[ebp]
  000e6	8b 4d dc	 mov	 ecx, DWORD PTR tv175[ebp]
  000e9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ec	3b 41 18	 cmp	 eax, DWORD PTR [ecx+24]
  000ef	73 0d		 jae	 SHORT $LN2@BlMmCompac
$LN16@BlMmCompac:
  000f1	6a 5c		 push	 92			; 0000005cH
  000f3	5a		 pop	 edx
  000f4	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_08JOIABOAI@blmm?4cpp?$AA@
  000f9	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN2@BlMmCompac:

; 93   : 
; 94   :         if ((Next->Start == Current->Limit) &&
; 95   :             (Next->Type == Current->Type)) {

  000fe	8b 45 f4	 mov	 eax, DWORD PTR _Next$[ebp]
  00101	8b 4d fc	 mov	 ecx, DWORD PTR _Current$[ebp]
  00104	89 45 d8	 mov	 DWORD PTR tv186[ebp], eax
  00107	89 4d d4	 mov	 DWORD PTR tv187[ebp], ecx
  0010a	8b 45 d8	 mov	 eax, DWORD PTR tv186[ebp]
  0010d	8b 4d d4	 mov	 ecx, DWORD PTR tv187[ebp]
  00110	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00113	3b 41 18	 cmp	 eax, DWORD PTR [ecx+24]
  00116	75 63		 jne	 SHORT $LN1@BlMmCompac
  00118	8b 45 d8	 mov	 eax, DWORD PTR tv186[ebp]
  0011b	8b 4d d4	 mov	 ecx, DWORD PTR tv187[ebp]
  0011e	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00121	3b 41 1c	 cmp	 eax, DWORD PTR [ecx+28]
  00124	75 55		 jne	 SHORT $LN1@BlMmCompac
  00126	8b 45 f4	 mov	 eax, DWORD PTR _Next$[ebp]
  00129	8b 4d fc	 mov	 ecx, DWORD PTR _Current$[ebp]
  0012c	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0012f	3b 41 20	 cmp	 eax, DWORD PTR [ecx+32]
  00132	75 47		 jne	 SHORT $LN1@BlMmCompac

; 96   : 
; 97   :             Current->Limit = Next->Limit;

  00134	8b 45 fc	 mov	 eax, DWORD PTR _Current$[ebp]
  00137	8b 4d f4	 mov	 ecx, DWORD PTR _Next$[ebp]
  0013a	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0013d	89 50 18	 mov	 DWORD PTR [eax+24], edx
  00140	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00143	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 98   :             Current->Size = Current->Limit - Current->Start;

  00146	8b 45 fc	 mov	 eax, DWORD PTR _Current$[ebp]
  00149	8b 4d fc	 mov	 ecx, DWORD PTR _Current$[ebp]
  0014c	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  0014f	2b 51 08	 sub	 edx, DWORD PTR [ecx+8]
  00152	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00155	1b 41 0c	 sbb	 eax, DWORD PTR [ecx+12]
  00158	8b 4d fc	 mov	 ecx, DWORD PTR _Current$[ebp]
  0015b	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0015e	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 99   : 
; 100  :             BlRtlRemoveEntryList(&Next->Entry);

  00161	8b 4d f4	 mov	 ecx, DWORD PTR _Next$[ebp]
  00164	e8 00 00 00 00	 call	 ?BlRtlRemoveEntryList@@YIEPAU_LIST_ENTRY@@@Z ; BlRtlRemoveEntryList

; 101  : 
; 102  :             BlRtlInsertTailList(&BlMmPhysicalRegionLookaside.FreeList, &Next->Entry);

  00169	8b 55 f4	 mov	 edx, DWORD PTR _Next$[ebp]
  0016c	b9 80 02 00 00	 mov	 ecx, OFFSET ?BlMmPhysicalRegionLookaside@@3U<unnamed-tag>@@A+640
  00171	e8 00 00 00 00	 call	 ?BlRtlInsertTailList@@YIXPAU_LIST_ENTRY@@0@Z ; BlRtlInsertTailList

; 103  : 
; 104  :             continue;

  00176	e9 ae fe ff ff	 jmp	 $LN9@BlMmCompac
$LN1@BlMmCompac:

; 105  :         }
; 106  : 
; 107  :         Current = Next;

  0017b	8b 45 f4	 mov	 eax, DWORD PTR _Next$[ebp]
  0017e	89 45 fc	 mov	 DWORD PTR _Current$[ebp], eax
  00181	e9 a3 fe ff ff	 jmp	 $LN9@BlMmCompac
$LN11@BlMmCompac:

; 108  :     }
; 109  : }

  00186	c9		 leave
  00187	c3		 ret	 0
?BlMmCompactPhysicalRegionList@@YIXXZ ENDP		; BlMmCompactPhysicalRegionList
_TEXT	ENDS
PUBLIC	?BlMmInsertPhysicalRegion@@YIXPAU_BL_MM_PHYSICAL_REGION@@@Z ; BlMmInsertPhysicalRegion
; Function compile flags: /Odsp
;	COMDAT ?BlMmInsertPhysicalRegion@@YIXPAU_BL_MM_PHYSICAL_REGION@@@Z
_TEXT	SEGMENT
tv77 = -24						; size = 4
tv76 = -20						; size = 4
_Region$ = -16						; size = 4
_Next$ = -12						; size = 4
_Entry$ = -8						; size = 4
_Head$ = -4						; size = 4
?BlMmInsertPhysicalRegion@@YIXPAU_BL_MM_PHYSICAL_REGION@@@Z PROC ; BlMmInsertPhysicalRegion, COMDAT
; _Region$ = ecx

; 128  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f0	 mov	 DWORD PTR _Region$[ebp], ecx

; 129  :     PLIST_ENTRY Entry;
; 130  :     PLIST_ENTRY Head;
; 131  :     PBL_MM_PHYSICAL_REGION Next;
; 132  : 
; 133  :     Head = &BlMmPhysicalRegionList;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Head$[ebp], OFFSET ?BlMmPhysicalRegionList@@3U_LIST_ENTRY@@A ; BlMmPhysicalRegionList

; 134  :     Entry = Head->Flink;

  00010	8b 45 fc	 mov	 eax, DWORD PTR _Head$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]
  00015	89 45 f8	 mov	 DWORD PTR _Entry$[ebp], eax
$LN3@BlMmInsert:

; 135  : 
; 136  :     while (Entry != Head) {

  00018	8b 45 f8	 mov	 eax, DWORD PTR _Entry$[ebp]
  0001b	3b 45 fc	 cmp	 eax, DWORD PTR _Head$[ebp]
  0001e	74 3c		 je	 SHORT $LN2@BlMmInsert

; 137  : 
; 138  :         Next = CONTAINING_RECORD(Entry,
; 139  :                                  BL_MM_PHYSICAL_REGION,
; 140  :                                  Entry);

  00020	8b 45 f8	 mov	 eax, DWORD PTR _Entry$[ebp]
  00023	89 45 f4	 mov	 DWORD PTR _Next$[ebp], eax

; 141  : 
; 142  :         if (Next->Start > Region->Start) {

  00026	8b 45 f4	 mov	 eax, DWORD PTR _Next$[ebp]
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _Region$[ebp]
  0002c	89 45 ec	 mov	 DWORD PTR tv76[ebp], eax
  0002f	89 4d e8	 mov	 DWORD PTR tv77[ebp], ecx
  00032	8b 45 ec	 mov	 eax, DWORD PTR tv76[ebp]
  00035	8b 4d e8	 mov	 ecx, DWORD PTR tv77[ebp]
  00038	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0003b	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  0003e	72 12		 jb	 SHORT $LN1@BlMmInsert
  00040	77 0e		 ja	 SHORT $LN6@BlMmInsert
  00042	8b 45 ec	 mov	 eax, DWORD PTR tv76[ebp]
  00045	8b 4d e8	 mov	 ecx, DWORD PTR tv77[ebp]
  00048	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0004b	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0004e	76 02		 jbe	 SHORT $LN1@BlMmInsert
$LN6@BlMmInsert:

; 143  : 
; 144  :             break;

  00050	eb 0a		 jmp	 SHORT $LN2@BlMmInsert
$LN1@BlMmInsert:

; 145  :         }
; 146  : 
; 147  :         Entry = Entry->Flink;

  00052	8b 45 f8	 mov	 eax, DWORD PTR _Entry$[ebp]
  00055	8b 00		 mov	 eax, DWORD PTR [eax]
  00057	89 45 f8	 mov	 DWORD PTR _Entry$[ebp], eax

; 148  :     }

  0005a	eb bc		 jmp	 SHORT $LN3@BlMmInsert
$LN2@BlMmInsert:

; 149  : 
; 150  :     BlRtlInsertTailList(Entry, &Region->Entry);

  0005c	8b 55 f0	 mov	 edx, DWORD PTR _Region$[ebp]
  0005f	8b 4d f8	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00062	e8 00 00 00 00	 call	 ?BlRtlInsertTailList@@YIXPAU_LIST_ENTRY@@0@Z ; BlRtlInsertTailList

; 151  : 
; 152  :     BlMmCompactPhysicalRegionList();

  00067	e8 00 00 00 00	 call	 ?BlMmCompactPhysicalRegionList@@YIXXZ ; BlMmCompactPhysicalRegionList

; 153  : 
; 154  :     return;
; 155  : }

  0006c	c9		 leave
  0006d	c3		 ret	 0
?BlMmInsertPhysicalRegion@@YIXPAU_BL_MM_PHYSICAL_REGION@@@Z ENDP ; BlMmInsertPhysicalRegion
_TEXT	ENDS
PUBLIC	??_C@_0CA@ENJPJAHG@MM?3?5Physical?5region?5collision?$CB?6?$AA@ ; `string'
PUBLIC	?BlMmCreatePhysicalRegion@@YIX_K0K@Z		; BlMmCreatePhysicalRegion
EXTRN	?BlRtlRemoveHeadList@@YIPAU_LIST_ENTRY@@PAU1@@Z:PROC ; BlRtlRemoveHeadList
EXTRN	?BlRtlHaltInternal@@YIXPBDK@Z:PROC		; BlRtlHaltInternal
EXTRN	?BlRtlPrintf@@YAEPBDZZ:PROC			; BlRtlPrintf
EXTRN	__aullrem:PROC
;	COMDAT ??_C@_0CA@ENJPJAHG@MM?3?5Physical?5region?5collision?$CB?6?$AA@
CONST	SEGMENT
??_C@_0CA@ENJPJAHG@MM?3?5Physical?5region?5collision?$CB?6?$AA@ DB 'MM: P'
	DB	'hysical region collision!', 0aH, 00H	; `string'
; Function compile flags: /Odsp
CONST	ENDS
;	COMDAT ?BlMmCreatePhysicalRegion@@YIX_K0K@Z
_TEXT	SEGMENT
tv213 = -56						; size = 4
tv199 = -52						; size = 4
tv191 = -48						; size = 4
tv171 = -44						; size = 8
tv152 = -36						; size = 8
_Type$ = -28						; size = 4
_Entry$ = -24						; size = 4
_Head$ = -20						; size = 4
_Limit$ = -16						; size = 8
_Region$ = -4						; size = 4
_Start$ = 8						; size = 8
_Size$ = 16						; size = 8
?BlMmCreatePhysicalRegion@@YIX_K0K@Z PROC		; BlMmCreatePhysicalRegion, COMDAT
; _Type$ = ecx

; 180  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d e4	 mov	 DWORD PTR _Type$[ebp], ecx

; 181  :     PLIST_ENTRY Entry;
; 182  :     PLIST_ENTRY Head;
; 183  :     UINT64 Limit;
; 184  :     PBL_MM_PHYSICAL_REGION Region;
; 185  : 
; 186  :     BLASSERT((Start % PAGE_SIZE) == 0);

  00009	6a 00		 push	 0
  0000b	68 00 10 00 00	 push	 4096			; 00001000H
  00010	ff 75 0c	 push	 DWORD PTR _Start$[ebp+4]
  00013	ff 75 08	 push	 DWORD PTR _Start$[ebp]
  00016	e8 00 00 00 00	 call	 __aullrem
  0001b	89 45 dc	 mov	 DWORD PTR tv152[ebp], eax
  0001e	89 55 e0	 mov	 DWORD PTR tv152[ebp+4], edx
  00021	8b 45 dc	 mov	 eax, DWORD PTR tv152[ebp]
  00024	0b 45 e0	 or	 eax, DWORD PTR tv152[ebp+4]
  00027	74 0f		 je	 SHORT $LN13@BlMmCreate
  00029	ba ba 00 00 00	 mov	 edx, 186		; 000000baH
  0002e	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_08JOIABOAI@blmm?4cpp?$AA@
  00033	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN13@BlMmCreate:

; 187  :     BLASSERT(Size > 0);

  00038	83 7d 14 00	 cmp	 DWORD PTR _Size$[ebp+4], 0
  0003c	77 17		 ja	 SHORT $LN12@BlMmCreate
  0003e	72 06		 jb	 SHORT $LN16@BlMmCreate
  00040	83 7d 10 00	 cmp	 DWORD PTR _Size$[ebp], 0
  00044	77 0f		 ja	 SHORT $LN12@BlMmCreate
$LN16@BlMmCreate:
  00046	ba bb 00 00 00	 mov	 edx, 187		; 000000bbH
  0004b	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_08JOIABOAI@blmm?4cpp?$AA@
  00050	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN12@BlMmCreate:

; 188  :     BLASSERT((Size % PAGE_SIZE) == 0);

  00055	6a 00		 push	 0
  00057	68 00 10 00 00	 push	 4096			; 00001000H
  0005c	ff 75 14	 push	 DWORD PTR _Size$[ebp+4]
  0005f	ff 75 10	 push	 DWORD PTR _Size$[ebp]
  00062	e8 00 00 00 00	 call	 __aullrem
  00067	89 45 d4	 mov	 DWORD PTR tv171[ebp], eax
  0006a	89 55 d8	 mov	 DWORD PTR tv171[ebp+4], edx
  0006d	8b 45 d4	 mov	 eax, DWORD PTR tv171[ebp]
  00070	0b 45 d8	 or	 eax, DWORD PTR tv171[ebp+4]
  00073	74 0f		 je	 SHORT $LN11@BlMmCreate
  00075	ba bc 00 00 00	 mov	 edx, 188		; 000000bcH
  0007a	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_08JOIABOAI@blmm?4cpp?$AA@
  0007f	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN11@BlMmCreate:

; 189  :     BLASSERT(Type >= BL_MM_PHYSICAL_REGION_MIN_TYPE);

  00084	83 7d e4 01	 cmp	 DWORD PTR _Type$[ebp], 1
  00088	73 0f		 jae	 SHORT $LN10@BlMmCreate
  0008a	ba bd 00 00 00	 mov	 edx, 189		; 000000bdH
  0008f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_08JOIABOAI@blmm?4cpp?$AA@
  00094	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN10@BlMmCreate:

; 190  :     BLASSERT(Type <= BL_MM_PHYSICAL_REGION_MAX_TYPE);

  00099	83 7d e4 10	 cmp	 DWORD PTR _Type$[ebp], 16 ; 00000010H
  0009d	76 0f		 jbe	 SHORT $LN9@BlMmCreate
  0009f	ba be 00 00 00	 mov	 edx, 190		; 000000beH
  000a4	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_08JOIABOAI@blmm?4cpp?$AA@
  000a9	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN9@BlMmCreate:

; 191  : 
; 192  :     Limit = Start + Size;

  000ae	8b 45 08	 mov	 eax, DWORD PTR _Start$[ebp]
  000b1	03 45 10	 add	 eax, DWORD PTR _Size$[ebp]
  000b4	8b 4d 0c	 mov	 ecx, DWORD PTR _Start$[ebp+4]
  000b7	13 4d 14	 adc	 ecx, DWORD PTR _Size$[ebp+4]
  000ba	89 45 f0	 mov	 DWORD PTR _Limit$[ebp], eax
  000bd	89 4d f4	 mov	 DWORD PTR _Limit$[ebp+4], ecx

; 193  : 
; 194  :     BLASSERT(Limit > Start);

  000c0	8b 45 f4	 mov	 eax, DWORD PTR _Limit$[ebp+4]
  000c3	3b 45 0c	 cmp	 eax, DWORD PTR _Start$[ebp+4]
  000c6	77 19		 ja	 SHORT $LN8@BlMmCreate
  000c8	72 08		 jb	 SHORT $LN17@BlMmCreate
  000ca	8b 45 f0	 mov	 eax, DWORD PTR _Limit$[ebp]
  000cd	3b 45 08	 cmp	 eax, DWORD PTR _Start$[ebp]
  000d0	77 0f		 ja	 SHORT $LN8@BlMmCreate
$LN17@BlMmCreate:
  000d2	ba c2 00 00 00	 mov	 edx, 194		; 000000c2H
  000d7	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_08JOIABOAI@blmm?4cpp?$AA@
  000dc	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN8@BlMmCreate:

; 195  : 
; 196  :     Head = &BlMmPhysicalRegionList;

  000e1	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _Head$[ebp], OFFSET ?BlMmPhysicalRegionList@@3U_LIST_ENTRY@@A ; BlMmPhysicalRegionList

; 197  :     Entry = Head->Flink;

  000e8	8b 45 ec	 mov	 eax, DWORD PTR _Head$[ebp]
  000eb	8b 00		 mov	 eax, DWORD PTR [eax]
  000ed	89 45 e8	 mov	 DWORD PTR _Entry$[ebp], eax
$LN7@BlMmCreate:

; 198  : 
; 199  :     while (Entry != Head) {

  000f0	8b 45 e8	 mov	 eax, DWORD PTR _Entry$[ebp]
  000f3	3b 45 ec	 cmp	 eax, DWORD PTR _Head$[ebp]
  000f6	74 66		 je	 SHORT $LN6@BlMmCreate

; 200  : 
; 201  :         Region = CONTAINING_RECORD(Entry,
; 202  :                                    BL_MM_PHYSICAL_REGION,
; 203  :                                    Entry);

  000f8	8b 45 e8	 mov	 eax, DWORD PTR _Entry$[ebp]
  000fb	89 45 fc	 mov	 DWORD PTR _Region$[ebp], eax

; 204  : 
; 205  :         if ((Start < Region->Limit) && (Limit > Region->Start)) {

  000fe	8b 45 fc	 mov	 eax, DWORD PTR _Region$[ebp]
  00101	89 45 d0	 mov	 DWORD PTR tv191[ebp], eax
  00104	8b 45 d0	 mov	 eax, DWORD PTR tv191[ebp]
  00107	8b 4d 0c	 mov	 ecx, DWORD PTR _Start$[ebp+4]
  0010a	3b 48 1c	 cmp	 ecx, DWORD PTR [eax+28]
  0010d	77 45		 ja	 SHORT $LN5@BlMmCreate
  0010f	72 0b		 jb	 SHORT $LN18@BlMmCreate
  00111	8b 45 d0	 mov	 eax, DWORD PTR tv191[ebp]
  00114	8b 4d 08	 mov	 ecx, DWORD PTR _Start$[ebp]
  00117	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  0011a	73 38		 jae	 SHORT $LN5@BlMmCreate
$LN18@BlMmCreate:
  0011c	8b 45 fc	 mov	 eax, DWORD PTR _Region$[ebp]
  0011f	89 45 cc	 mov	 DWORD PTR tv199[ebp], eax
  00122	8b 45 cc	 mov	 eax, DWORD PTR tv199[ebp]
  00125	8b 4d f4	 mov	 ecx, DWORD PTR _Limit$[ebp+4]
  00128	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  0012b	72 27		 jb	 SHORT $LN5@BlMmCreate
  0012d	77 0b		 ja	 SHORT $LN19@BlMmCreate
  0012f	8b 45 cc	 mov	 eax, DWORD PTR tv199[ebp]
  00132	8b 4d f0	 mov	 ecx, DWORD PTR _Limit$[ebp]
  00135	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00138	76 1a		 jbe	 SHORT $LN5@BlMmCreate
$LN19@BlMmCreate:

; 206  : 
; 207  :             BlRtlPrintf("MM: Physical region collision!\n");

  0013a	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@ENJPJAHG@MM?3?5Physical?5region?5collision?$CB?6?$AA@
  0013f	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  00144	59		 pop	 ecx

; 208  :             BlRtlHalt();

  00145	ba d0 00 00 00	 mov	 edx, 208		; 000000d0H
  0014a	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_08JOIABOAI@blmm?4cpp?$AA@
  0014f	e8 00 00 00 00	 call	 ?BlRtlHaltInternal@@YIXPBDK@Z ; BlRtlHaltInternal
$LN5@BlMmCreate:

; 209  :         }
; 210  : 
; 211  :         Entry = Entry->Flink;

  00154	8b 45 e8	 mov	 eax, DWORD PTR _Entry$[ebp]
  00157	8b 00		 mov	 eax, DWORD PTR [eax]
  00159	89 45 e8	 mov	 DWORD PTR _Entry$[ebp], eax

; 212  :     }

  0015c	eb 92		 jmp	 SHORT $LN7@BlMmCreate
$LN6@BlMmCreate:

; 213  : 
; 214  :     Entry = Head->Flink;

  0015e	8b 45 ec	 mov	 eax, DWORD PTR _Head$[ebp]
  00161	8b 00		 mov	 eax, DWORD PTR [eax]
  00163	89 45 e8	 mov	 DWORD PTR _Entry$[ebp], eax
$LN4@BlMmCreate:

; 215  : 
; 216  :     while (Entry != Head) {

  00166	8b 45 e8	 mov	 eax, DWORD PTR _Entry$[ebp]
  00169	3b 45 ec	 cmp	 eax, DWORD PTR _Head$[ebp]
  0016c	74 30		 je	 SHORT $LN3@BlMmCreate

; 217  : 
; 218  :         Region = CONTAINING_RECORD(Entry,
; 219  :                                    BL_MM_PHYSICAL_REGION,
; 220  :                                    Entry);

  0016e	8b 45 e8	 mov	 eax, DWORD PTR _Entry$[ebp]
  00171	89 45 fc	 mov	 DWORD PTR _Region$[ebp], eax

; 221  : 
; 222  :         if (Start < Region->Start) {

  00174	8b 45 fc	 mov	 eax, DWORD PTR _Region$[ebp]
  00177	89 45 c8	 mov	 DWORD PTR tv213[ebp], eax
  0017a	8b 45 c8	 mov	 eax, DWORD PTR tv213[ebp]
  0017d	8b 4d 0c	 mov	 ecx, DWORD PTR _Start$[ebp+4]
  00180	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00183	77 0f		 ja	 SHORT $LN2@BlMmCreate
  00185	72 0b		 jb	 SHORT $LN20@BlMmCreate
  00187	8b 45 c8	 mov	 eax, DWORD PTR tv213[ebp]
  0018a	8b 4d 08	 mov	 ecx, DWORD PTR _Start$[ebp]
  0018d	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00190	73 02		 jae	 SHORT $LN2@BlMmCreate
$LN20@BlMmCreate:

; 223  : 
; 224  :             break;

  00192	eb 0a		 jmp	 SHORT $LN3@BlMmCreate
$LN2@BlMmCreate:

; 225  :         }
; 226  : 
; 227  :         Entry = Entry->Flink;

  00194	8b 45 e8	 mov	 eax, DWORD PTR _Entry$[ebp]
  00197	8b 00		 mov	 eax, DWORD PTR [eax]
  00199	89 45 e8	 mov	 DWORD PTR _Entry$[ebp], eax

; 228  :     }

  0019c	eb c8		 jmp	 SHORT $LN4@BlMmCreate
$LN3@BlMmCreate:

; 229  : 
; 230  :     BLASSERT(BlRtlIsListEmpty(&BlMmPhysicalRegionLookaside.FreeList) == FALSE);

  0019e	b9 80 02 00 00	 mov	 ecx, OFFSET ?BlMmPhysicalRegionLookaside@@3U<unnamed-tag>@@A+640
  001a3	e8 00 00 00 00	 call	 ?BlRtlIsListEmpty@@YIEPAU_LIST_ENTRY@@@Z ; BlRtlIsListEmpty
  001a8	0f b6 c0	 movzx	 eax, al
  001ab	85 c0		 test	 eax, eax
  001ad	74 0f		 je	 SHORT $LN1@BlMmCreate
  001af	ba e6 00 00 00	 mov	 edx, 230		; 000000e6H
  001b4	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_08JOIABOAI@blmm?4cpp?$AA@
  001b9	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN1@BlMmCreate:

; 231  : 
; 232  :     Region = CONTAINING_RECORD(BlRtlRemoveHeadList(&BlMmPhysicalRegionLookaside.FreeList),
; 233  :                                BL_MM_PHYSICAL_REGION,
; 234  :                                Entry);

  001be	b9 80 02 00 00	 mov	 ecx, OFFSET ?BlMmPhysicalRegionLookaside@@3U<unnamed-tag>@@A+640
  001c3	e8 00 00 00 00	 call	 ?BlRtlRemoveHeadList@@YIPAU_LIST_ENTRY@@PAU1@@Z ; BlRtlRemoveHeadList
  001c8	89 45 fc	 mov	 DWORD PTR _Region$[ebp], eax

; 235  : 
; 236  :     Region->Start = Start;

  001cb	8b 45 fc	 mov	 eax, DWORD PTR _Region$[ebp]
  001ce	8b 4d 08	 mov	 ecx, DWORD PTR _Start$[ebp]
  001d1	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  001d4	8b 4d 0c	 mov	 ecx, DWORD PTR _Start$[ebp+4]
  001d7	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 237  :     Region->Size = Size;

  001da	8b 45 fc	 mov	 eax, DWORD PTR _Region$[ebp]
  001dd	8b 4d 10	 mov	 ecx, DWORD PTR _Size$[ebp]
  001e0	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  001e3	8b 4d 14	 mov	 ecx, DWORD PTR _Size$[ebp+4]
  001e6	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 238  :     Region->Limit = Limit;

  001e9	8b 45 fc	 mov	 eax, DWORD PTR _Region$[ebp]
  001ec	8b 4d f0	 mov	 ecx, DWORD PTR _Limit$[ebp]
  001ef	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  001f2	8b 4d f4	 mov	 ecx, DWORD PTR _Limit$[ebp+4]
  001f5	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 239  :     Region->Type = Type;

  001f8	8b 45 fc	 mov	 eax, DWORD PTR _Region$[ebp]
  001fb	8b 4d e4	 mov	 ecx, DWORD PTR _Type$[ebp]
  001fe	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 240  : 
; 241  :     BlMmInsertPhysicalRegion(Region);

  00201	8b 4d fc	 mov	 ecx, DWORD PTR _Region$[ebp]
  00204	e8 00 00 00 00	 call	 ?BlMmInsertPhysicalRegion@@YIXPAU_BL_MM_PHYSICAL_REGION@@@Z ; BlMmInsertPhysicalRegion

; 242  : 
; 243  :     return;
; 244  : }

  00209	c9		 leave
  0020a	c2 10 00	 ret	 16			; 00000010H
?BlMmCreatePhysicalRegion@@YIX_K0K@Z ENDP		; BlMmCreatePhysicalRegion
_TEXT	ENDS
PUBLIC	??_C@_0CC@GFMNFNPB@MM?3?5Unable?5to?5allocate?5?$CFx?5bytes?$CB@ ; `string'
PUBLIC	?BlMmAllocatePhysicalRegion@@YI_KKK@Z		; BlMmAllocatePhysicalRegion
EXTRN	?BlRtlZeroMemory@@YIXPAXK@Z:PROC		; BlRtlZeroMemory
;	COMDAT ??_C@_0CC@GFMNFNPB@MM?3?5Unable?5to?5allocate?5?$CFx?5bytes?$CB@
CONST	SEGMENT
??_C@_0CC@GFMNFNPB@MM?3?5Unable?5to?5allocate?5?$CFx?5bytes?$CB@ DB 'MM: '
	DB	'Unable to allocate %x bytes!', 0aH, 00H	; `string'
; Function compile flags: /Odsp
CONST	ENDS
;	COMDAT ?BlMmAllocatePhysicalRegion@@YI_KKK@Z
_TEXT	SEGMENT
tv191 = -52						; size = 8
tv190 = -44						; size = 4
tv179 = -40						; size = 4
tv169 = -36						; size = 8
tv168 = -28						; size = 4
_Type$ = -24						; size = 4
_Size$ = -20						; size = 4
_FreeRegion$ = -16					; size = 4
_Entry$ = -12						; size = 4
_Head$ = -8						; size = 4
_Region$ = -4						; size = 4
?BlMmAllocatePhysicalRegion@@YI_KKK@Z PROC		; BlMmAllocatePhysicalRegion, COMDAT
; _Size$ = ecx
; _Type$ = edx

; 271  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	56		 push	 esi
  00007	89 55 e8	 mov	 DWORD PTR _Type$[ebp], edx
  0000a	89 4d ec	 mov	 DWORD PTR _Size$[ebp], ecx

; 272  :     PLIST_ENTRY Entry;
; 273  :     PBL_MM_PHYSICAL_REGION FreeRegion;
; 274  :     PLIST_ENTRY Head;
; 275  :     PBL_MM_PHYSICAL_REGION Region;
; 276  : 
; 277  :     BLASSERT(Size > 0);

  0000d	83 7d ec 00	 cmp	 DWORD PTR _Size$[ebp], 0
  00011	77 0f		 ja	 SHORT $LN8@BlMmAlloca
  00013	ba 15 01 00 00	 mov	 edx, 277		; 00000115H
  00018	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_08JOIABOAI@blmm?4cpp?$AA@
  0001d	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN8@BlMmAlloca:

; 278  :     BLASSERT(Type != BL_MM_PHYSICAL_REGION_FREE);

  00022	83 7d e8 01	 cmp	 DWORD PTR _Type$[ebp], 1
  00026	75 0f		 jne	 SHORT $LN7@BlMmAlloca
  00028	ba 16 01 00 00	 mov	 edx, 278		; 00000116H
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_08JOIABOAI@blmm?4cpp?$AA@
  00032	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN7@BlMmAlloca:

; 279  : 
; 280  :     SATISFY_OVERZEALOUS_COMPILER(Region = NULL);

  00037	83 65 fc 00	 and	 DWORD PTR _Region$[ebp], 0

; 281  : 
; 282  :     Size = ROUND_UP_TO_PAGES(Size);

  0003b	8b 45 ec	 mov	 eax, DWORD PTR _Size$[ebp]
  0003e	05 ff 0f 00 00	 add	 eax, 4095		; 00000fffH
  00043	25 00 f0 ff ff	 and	 eax, -4096		; fffff000H
  00048	89 45 ec	 mov	 DWORD PTR _Size$[ebp], eax

; 283  : 
; 284  :     Head = &BlMmPhysicalRegionList;

  0004b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _Head$[ebp], OFFSET ?BlMmPhysicalRegionList@@3U_LIST_ENTRY@@A ; BlMmPhysicalRegionList

; 285  :     Entry = Head->Blink;

  00052	8b 45 f8	 mov	 eax, DWORD PTR _Head$[ebp]
  00055	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00058	89 45 f4	 mov	 DWORD PTR _Entry$[ebp], eax
$LN6@BlMmAlloca:

; 286  : 
; 287  :     while (Entry != Head) {

  0005b	8b 45 f4	 mov	 eax, DWORD PTR _Entry$[ebp]
  0005e	3b 45 f8	 cmp	 eax, DWORD PTR _Head$[ebp]
  00061	74 5f		 je	 SHORT $LN5@BlMmAlloca

; 288  : 
; 289  :         Region = CONTAINING_RECORD(Entry,
; 290  :                                    BL_MM_PHYSICAL_REGION,
; 291  :                                    Entry);

  00063	8b 45 f4	 mov	 eax, DWORD PTR _Entry$[ebp]
  00066	89 45 fc	 mov	 DWORD PTR _Region$[ebp], eax

; 292  : 
; 293  :         if ((Region->Type == BL_MM_PHYSICAL_REGION_FREE) &&
; 294  :             (Region->Size >= Size) &&
; 295  :             (Region->Limit < 0x100000000UI64)) {

  00069	8b 45 fc	 mov	 eax, DWORD PTR _Region$[ebp]
  0006c	83 78 20 01	 cmp	 DWORD PTR [eax+32], 1
  00070	75 45		 jne	 SHORT $LN4@BlMmAlloca
  00072	8b 45 ec	 mov	 eax, DWORD PTR _Size$[ebp]
  00075	33 c9		 xor	 ecx, ecx
  00077	8b 55 fc	 mov	 edx, DWORD PTR _Region$[ebp]
  0007a	89 55 e4	 mov	 DWORD PTR tv168[ebp], edx
  0007d	89 45 dc	 mov	 DWORD PTR tv169[ebp], eax
  00080	89 4d e0	 mov	 DWORD PTR tv169[ebp+4], ecx
  00083	8b 45 e4	 mov	 eax, DWORD PTR tv168[ebp]
  00086	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00089	3b 45 e0	 cmp	 eax, DWORD PTR tv169[ebp+4]
  0008c	72 29		 jb	 SHORT $LN4@BlMmAlloca
  0008e	77 0b		 ja	 SHORT $LN11@BlMmAlloca
  00090	8b 45 e4	 mov	 eax, DWORD PTR tv168[ebp]
  00093	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00096	3b 45 dc	 cmp	 eax, DWORD PTR tv169[ebp]
  00099	72 1c		 jb	 SHORT $LN4@BlMmAlloca
$LN11@BlMmAlloca:
  0009b	8b 45 fc	 mov	 eax, DWORD PTR _Region$[ebp]
  0009e	89 45 d8	 mov	 DWORD PTR tv179[ebp], eax
  000a1	8b 45 d8	 mov	 eax, DWORD PTR tv179[ebp]
  000a4	83 78 1c 01	 cmp	 DWORD PTR [eax+28], 1
  000a8	77 0d		 ja	 SHORT $LN4@BlMmAlloca
  000aa	72 09		 jb	 SHORT $LN12@BlMmAlloca
  000ac	8b 45 d8	 mov	 eax, DWORD PTR tv179[ebp]
  000af	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  000b3	73 02		 jae	 SHORT $LN4@BlMmAlloca
$LN12@BlMmAlloca:

; 296  : 
; 297  :             break;

  000b5	eb 0b		 jmp	 SHORT $LN5@BlMmAlloca
$LN4@BlMmAlloca:

; 298  :         }
; 299  : 
; 300  :         Entry = Entry->Blink;

  000b7	8b 45 f4	 mov	 eax, DWORD PTR _Entry$[ebp]
  000ba	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000bd	89 45 f4	 mov	 DWORD PTR _Entry$[ebp], eax

; 301  :     }

  000c0	eb 99		 jmp	 SHORT $LN6@BlMmAlloca
$LN5@BlMmAlloca:

; 302  : 
; 303  :     if (Entry == Head) {

  000c2	8b 45 f4	 mov	 eax, DWORD PTR _Entry$[ebp]
  000c5	3b 45 f8	 cmp	 eax, DWORD PTR _Head$[ebp]
  000c8	75 1e		 jne	 SHORT $LN3@BlMmAlloca

; 304  : 
; 305  :         BlRtlPrintf("MM: Unable to allocate %x bytes!\n", Size);

  000ca	ff 75 ec	 push	 DWORD PTR _Size$[ebp]
  000cd	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@GFMNFNPB@MM?3?5Unable?5to?5allocate?5?$CFx?5bytes?$CB@
  000d2	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  000d7	59		 pop	 ecx
  000d8	59		 pop	 ecx

; 306  :         BlRtlHalt();

  000d9	ba 32 01 00 00	 mov	 edx, 306		; 00000132H
  000de	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_08JOIABOAI@blmm?4cpp?$AA@
  000e3	e8 00 00 00 00	 call	 ?BlRtlHaltInternal@@YIXPBDK@Z ; BlRtlHaltInternal
$LN3@BlMmAlloca:

; 307  :     }
; 308  : 
; 309  :     if (Region->Size == Size) {

  000e8	8b 45 ec	 mov	 eax, DWORD PTR _Size$[ebp]
  000eb	33 c9		 xor	 ecx, ecx
  000ed	8b 55 fc	 mov	 edx, DWORD PTR _Region$[ebp]
  000f0	89 55 d4	 mov	 DWORD PTR tv190[ebp], edx
  000f3	89 45 cc	 mov	 DWORD PTR tv191[ebp], eax
  000f6	89 4d d0	 mov	 DWORD PTR tv191[ebp+4], ecx
  000f9	8b 45 d4	 mov	 eax, DWORD PTR tv190[ebp]
  000fc	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  000ff	3b 45 cc	 cmp	 eax, DWORD PTR tv191[ebp]
  00102	75 22		 jne	 SHORT $LN2@BlMmAlloca
  00104	8b 45 d4	 mov	 eax, DWORD PTR tv190[ebp]
  00107	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0010a	3b 45 d0	 cmp	 eax, DWORD PTR tv191[ebp+4]
  0010d	75 17		 jne	 SHORT $LN2@BlMmAlloca

; 310  : 
; 311  :         Region->Type = Type;

  0010f	8b 45 fc	 mov	 eax, DWORD PTR _Region$[ebp]
  00112	8b 4d e8	 mov	 ecx, DWORD PTR _Type$[ebp]
  00115	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 312  :         return Region->Start;

  00118	8b 4d fc	 mov	 ecx, DWORD PTR _Region$[ebp]
  0011b	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0011e	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00121	e9 d8 00 00 00	 jmp	 $LN9@BlMmAlloca
$LN2@BlMmAlloca:

; 313  :     }
; 314  : 
; 315  :     FreeRegion = Region;

  00126	8b 45 fc	 mov	 eax, DWORD PTR _Region$[ebp]
  00129	89 45 f0	 mov	 DWORD PTR _FreeRegion$[ebp], eax

; 316  : 
; 317  :     BLASSERT(BlRtlIsListEmpty(&BlMmPhysicalRegionLookaside.FreeList) == FALSE);

  0012c	b9 80 02 00 00	 mov	 ecx, OFFSET ?BlMmPhysicalRegionLookaside@@3U<unnamed-tag>@@A+640
  00131	e8 00 00 00 00	 call	 ?BlRtlIsListEmpty@@YIEPAU_LIST_ENTRY@@@Z ; BlRtlIsListEmpty
  00136	0f b6 c0	 movzx	 eax, al
  00139	85 c0		 test	 eax, eax
  0013b	74 0f		 je	 SHORT $LN1@BlMmAlloca
  0013d	ba 3d 01 00 00	 mov	 edx, 317		; 0000013dH
  00142	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_08JOIABOAI@blmm?4cpp?$AA@
  00147	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN1@BlMmAlloca:

; 318  : 
; 319  :     Region = CONTAINING_RECORD(BlRtlRemoveHeadList(&BlMmPhysicalRegionLookaside.FreeList),
; 320  :                                BL_MM_PHYSICAL_REGION,
; 321  :                                Entry);

  0014c	b9 80 02 00 00	 mov	 ecx, OFFSET ?BlMmPhysicalRegionLookaside@@3U<unnamed-tag>@@A+640
  00151	e8 00 00 00 00	 call	 ?BlRtlRemoveHeadList@@YIPAU_LIST_ENTRY@@PAU1@@Z ; BlRtlRemoveHeadList
  00156	89 45 fc	 mov	 DWORD PTR _Region$[ebp], eax

; 322  : 
; 323  :     Region->Start = FreeRegion->Limit - Size;

  00159	8b 45 ec	 mov	 eax, DWORD PTR _Size$[ebp]
  0015c	33 c9		 xor	 ecx, ecx
  0015e	8b 55 f0	 mov	 edx, DWORD PTR _FreeRegion$[ebp]
  00161	8b 72 18	 mov	 esi, DWORD PTR [edx+24]
  00164	2b f0		 sub	 esi, eax
  00166	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00169	1b c1		 sbb	 eax, ecx
  0016b	8b 4d fc	 mov	 ecx, DWORD PTR _Region$[ebp]
  0016e	89 71 08	 mov	 DWORD PTR [ecx+8], esi
  00171	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 324  :     FreeRegion->Limit -= Size;

  00174	8b 45 ec	 mov	 eax, DWORD PTR _Size$[ebp]
  00177	33 c9		 xor	 ecx, ecx
  00179	8b 55 f0	 mov	 edx, DWORD PTR _FreeRegion$[ebp]
  0017c	8b 72 18	 mov	 esi, DWORD PTR [edx+24]
  0017f	2b f0		 sub	 esi, eax
  00181	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00184	1b c1		 sbb	 eax, ecx
  00186	8b 4d f0	 mov	 ecx, DWORD PTR _FreeRegion$[ebp]
  00189	89 71 18	 mov	 DWORD PTR [ecx+24], esi
  0018c	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 325  :     FreeRegion->Size -= Size;

  0018f	8b 45 ec	 mov	 eax, DWORD PTR _Size$[ebp]
  00192	33 c9		 xor	 ecx, ecx
  00194	8b 55 f0	 mov	 edx, DWORD PTR _FreeRegion$[ebp]
  00197	8b 72 10	 mov	 esi, DWORD PTR [edx+16]
  0019a	2b f0		 sub	 esi, eax
  0019c	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0019f	1b c1		 sbb	 eax, ecx
  001a1	8b 4d f0	 mov	 ecx, DWORD PTR _FreeRegion$[ebp]
  001a4	89 71 10	 mov	 DWORD PTR [ecx+16], esi
  001a7	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 326  : 
; 327  :     Region->Size = Size;

  001aa	8b 45 ec	 mov	 eax, DWORD PTR _Size$[ebp]
  001ad	33 c9		 xor	 ecx, ecx
  001af	8b 55 fc	 mov	 edx, DWORD PTR _Region$[ebp]
  001b2	89 42 10	 mov	 DWORD PTR [edx+16], eax
  001b5	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 328  :     Region->Limit = Region->Start + Region->Size;

  001b8	8b 45 fc	 mov	 eax, DWORD PTR _Region$[ebp]
  001bb	8b 4d fc	 mov	 ecx, DWORD PTR _Region$[ebp]
  001be	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001c1	03 51 10	 add	 edx, DWORD PTR [ecx+16]
  001c4	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  001c7	13 41 14	 adc	 eax, DWORD PTR [ecx+20]
  001ca	8b 4d fc	 mov	 ecx, DWORD PTR _Region$[ebp]
  001cd	89 51 18	 mov	 DWORD PTR [ecx+24], edx
  001d0	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 329  :     Region->Type = Type;

  001d3	8b 45 fc	 mov	 eax, DWORD PTR _Region$[ebp]
  001d6	8b 4d e8	 mov	 ecx, DWORD PTR _Type$[ebp]
  001d9	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 330  : 
; 331  :     BlRtlZeroMemory((PVOID) (ULONG_PTR) Region->Start, (ULONG_PTR) (UINT32) Region->Size);

  001dc	8b 45 fc	 mov	 eax, DWORD PTR _Region$[ebp]
  001df	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  001e2	8b 45 fc	 mov	 eax, DWORD PTR _Region$[ebp]
  001e5	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001e8	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 332  : 
; 333  :     BlMmInsertPhysicalRegion(Region);

  001ed	8b 4d fc	 mov	 ecx, DWORD PTR _Region$[ebp]
  001f0	e8 00 00 00 00	 call	 ?BlMmInsertPhysicalRegion@@YIXPAU_BL_MM_PHYSICAL_REGION@@@Z ; BlMmInsertPhysicalRegion

; 334  : 
; 335  :     return Region->Start;

  001f5	8b 4d fc	 mov	 ecx, DWORD PTR _Region$[ebp]
  001f8	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001fb	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
$LN9@BlMmAlloca:

; 336  : }

  001fe	5e		 pop	 esi
  001ff	c9		 leave
  00200	c3		 ret	 0
?BlMmAllocatePhysicalRegion@@YI_KKK@Z ENDP		; BlMmAllocatePhysicalRegion
_TEXT	ENDS
PUBLIC	?BlMmAllocateSpecificPhysicalRegion@@YIE_K0K@Z	; BlMmAllocateSpecificPhysicalRegion
; Function compile flags: /Odsp
;	COMDAT ?BlMmAllocateSpecificPhysicalRegion@@YIE_K0K@Z
_TEXT	SEGMENT
tv261 = -76						; size = 4
tv231 = -72						; size = 4
tv219 = -68						; size = 4
tv211 = -64						; size = 4
tv191 = -60						; size = 8
tv172 = -52						; size = 8
_Type$ = -44						; size = 4
_End$ = -40						; size = 8
_NextRegion$ = -28					; size = 4
_Entry$ = -24						; size = 4
_Head$ = -20						; size = 4
_PreviousRegion$ = -16					; size = 4
_Region$ = -12						; size = 4
_Start$ = -8						; size = 8
_Base$ = 8						; size = 8
_Size$ = 16						; size = 8
?BlMmAllocateSpecificPhysicalRegion@@YIE_K0K@Z PROC	; BlMmAllocateSpecificPhysicalRegion, COMDAT
; _Type$ = ecx

; 366  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d d4	 mov	 DWORD PTR _Type$[ebp], ecx

; 367  :     UINT64 End;
; 368  :     PLIST_ENTRY Entry;
; 369  :     PLIST_ENTRY Head;
; 370  :     PBL_MM_PHYSICAL_REGION NextRegion;
; 371  :     PBL_MM_PHYSICAL_REGION PreviousRegion;
; 372  :     PBL_MM_PHYSICAL_REGION Region;
; 373  :     UINT64 Start;
; 374  : 
; 375  :     BLASSERT((Base % PAGE_SIZE) == 0);

  00009	6a 00		 push	 0
  0000b	68 00 10 00 00	 push	 4096			; 00001000H
  00010	ff 75 0c	 push	 DWORD PTR _Base$[ebp+4]
  00013	ff 75 08	 push	 DWORD PTR _Base$[ebp]
  00016	e8 00 00 00 00	 call	 __aullrem
  0001b	89 45 cc	 mov	 DWORD PTR tv172[ebp], eax
  0001e	89 55 d0	 mov	 DWORD PTR tv172[ebp+4], edx
  00021	8b 45 cc	 mov	 eax, DWORD PTR tv172[ebp]
  00024	0b 45 d0	 or	 eax, DWORD PTR tv172[ebp+4]
  00027	74 0f		 je	 SHORT $LN16@BlMmAlloca@2
  00029	ba 77 01 00 00	 mov	 edx, 375		; 00000177H
  0002e	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_08JOIABOAI@blmm?4cpp?$AA@
  00033	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN16@BlMmAlloca@2:

; 376  : 
; 377  :     BLASSERT(Size > 0);

  00038	83 7d 14 00	 cmp	 DWORD PTR _Size$[ebp+4], 0
  0003c	77 17		 ja	 SHORT $LN15@BlMmAlloca@2
  0003e	72 06		 jb	 SHORT $LN19@BlMmAlloca@2
  00040	83 7d 10 00	 cmp	 DWORD PTR _Size$[ebp], 0
  00044	77 0f		 ja	 SHORT $LN15@BlMmAlloca@2
$LN19@BlMmAlloca@2:
  00046	ba 79 01 00 00	 mov	 edx, 377		; 00000179H
  0004b	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_08JOIABOAI@blmm?4cpp?$AA@
  00050	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN15@BlMmAlloca@2:

; 378  : 
; 379  :     BLASSERT((Size % PAGE_SIZE) == 0);

  00055	6a 00		 push	 0
  00057	68 00 10 00 00	 push	 4096			; 00001000H
  0005c	ff 75 14	 push	 DWORD PTR _Size$[ebp+4]
  0005f	ff 75 10	 push	 DWORD PTR _Size$[ebp]
  00062	e8 00 00 00 00	 call	 __aullrem
  00067	89 45 c4	 mov	 DWORD PTR tv191[ebp], eax
  0006a	89 55 c8	 mov	 DWORD PTR tv191[ebp+4], edx
  0006d	8b 45 c4	 mov	 eax, DWORD PTR tv191[ebp]
  00070	0b 45 c8	 or	 eax, DWORD PTR tv191[ebp+4]
  00073	74 0f		 je	 SHORT $LN14@BlMmAlloca@2
  00075	ba 7b 01 00 00	 mov	 edx, 379		; 0000017bH
  0007a	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_08JOIABOAI@blmm?4cpp?$AA@
  0007f	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN14@BlMmAlloca@2:

; 380  : 
; 381  :     BLASSERT(Type != BL_MM_PHYSICAL_REGION_FREE);

  00084	83 7d d4 01	 cmp	 DWORD PTR _Type$[ebp], 1
  00088	75 0f		 jne	 SHORT $LN13@BlMmAlloca@2
  0008a	ba 7d 01 00 00	 mov	 edx, 381		; 0000017dH
  0008f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_08JOIABOAI@blmm?4cpp?$AA@
  00094	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN13@BlMmAlloca@2:

; 382  : 
; 383  :     SATISFY_OVERZEALOUS_COMPILER(Region = NULL);

  00099	83 65 f4 00	 and	 DWORD PTR _Region$[ebp], 0

; 384  : 
; 385  :     Start = Base;

  0009d	8b 45 08	 mov	 eax, DWORD PTR _Base$[ebp]
  000a0	89 45 f8	 mov	 DWORD PTR _Start$[ebp], eax
  000a3	8b 45 0c	 mov	 eax, DWORD PTR _Base$[ebp+4]
  000a6	89 45 fc	 mov	 DWORD PTR _Start$[ebp+4], eax

; 386  :     End = Start + Size;

  000a9	8b 45 f8	 mov	 eax, DWORD PTR _Start$[ebp]
  000ac	03 45 10	 add	 eax, DWORD PTR _Size$[ebp]
  000af	8b 4d fc	 mov	 ecx, DWORD PTR _Start$[ebp+4]
  000b2	13 4d 14	 adc	 ecx, DWORD PTR _Size$[ebp+4]
  000b5	89 45 d8	 mov	 DWORD PTR _End$[ebp], eax
  000b8	89 4d dc	 mov	 DWORD PTR _End$[ebp+4], ecx

; 387  : 
; 388  :     Head = &BlMmPhysicalRegionList;

  000bb	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _Head$[ebp], OFFSET ?BlMmPhysicalRegionList@@3U_LIST_ENTRY@@A ; BlMmPhysicalRegionList

; 389  : 
; 390  :     for (Entry = Head->Flink; Entry != Head; Entry = Entry->Flink) {

  000c2	8b 45 ec	 mov	 eax, DWORD PTR _Head$[ebp]
  000c5	8b 00		 mov	 eax, DWORD PTR [eax]
  000c7	89 45 e8	 mov	 DWORD PTR _Entry$[ebp], eax
  000ca	eb 08		 jmp	 SHORT $LN12@BlMmAlloca@2
$LN11@BlMmAlloca@2:
  000cc	8b 45 e8	 mov	 eax, DWORD PTR _Entry$[ebp]
  000cf	8b 00		 mov	 eax, DWORD PTR [eax]
  000d1	89 45 e8	 mov	 DWORD PTR _Entry$[ebp], eax
$LN12@BlMmAlloca@2:
  000d4	8b 45 e8	 mov	 eax, DWORD PTR _Entry$[ebp]
  000d7	3b 45 ec	 cmp	 eax, DWORD PTR _Head$[ebp]
  000da	74 46		 je	 SHORT $LN10@BlMmAlloca@2

; 391  : 
; 392  :         Region = CONTAINING_RECORD(Entry,
; 393  :                                    BL_MM_PHYSICAL_REGION,
; 394  :                                    Entry);

  000dc	8b 45 e8	 mov	 eax, DWORD PTR _Entry$[ebp]
  000df	89 45 f4	 mov	 DWORD PTR _Region$[ebp], eax

; 395  : 
; 396  :         if ((Start >= Region->Start) && (End <= Region->Limit)) {

  000e2	8b 45 f4	 mov	 eax, DWORD PTR _Region$[ebp]
  000e5	89 45 c0	 mov	 DWORD PTR tv211[ebp], eax
  000e8	8b 45 c0	 mov	 eax, DWORD PTR tv211[ebp]
  000eb	8b 4d fc	 mov	 ecx, DWORD PTR _Start$[ebp+4]
  000ee	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  000f1	72 2d		 jb	 SHORT $LN9@BlMmAlloca@2
  000f3	77 0b		 ja	 SHORT $LN20@BlMmAlloca@2
  000f5	8b 45 c0	 mov	 eax, DWORD PTR tv211[ebp]
  000f8	8b 4d f8	 mov	 ecx, DWORD PTR _Start$[ebp]
  000fb	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  000fe	72 20		 jb	 SHORT $LN9@BlMmAlloca@2
$LN20@BlMmAlloca@2:
  00100	8b 45 f4	 mov	 eax, DWORD PTR _Region$[ebp]
  00103	89 45 bc	 mov	 DWORD PTR tv219[ebp], eax
  00106	8b 45 bc	 mov	 eax, DWORD PTR tv219[ebp]
  00109	8b 4d dc	 mov	 ecx, DWORD PTR _End$[ebp+4]
  0010c	3b 48 1c	 cmp	 ecx, DWORD PTR [eax+28]
  0010f	77 0f		 ja	 SHORT $LN9@BlMmAlloca@2
  00111	72 0b		 jb	 SHORT $LN21@BlMmAlloca@2
  00113	8b 45 bc	 mov	 eax, DWORD PTR tv219[ebp]
  00116	8b 4d d8	 mov	 ecx, DWORD PTR _End$[ebp]
  00119	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  0011c	77 02		 ja	 SHORT $LN9@BlMmAlloca@2
$LN21@BlMmAlloca@2:

; 397  : 
; 398  :             break;

  0011e	eb 02		 jmp	 SHORT $LN10@BlMmAlloca@2
$LN9@BlMmAlloca@2:

; 399  :         }
; 400  :     }

  00120	eb aa		 jmp	 SHORT $LN11@BlMmAlloca@2
$LN10@BlMmAlloca@2:

; 401  : 
; 402  :     if (Entry == Head) {

  00122	8b 45 e8	 mov	 eax, DWORD PTR _Entry$[ebp]
  00125	3b 45 ec	 cmp	 eax, DWORD PTR _Head$[ebp]
  00128	75 07		 jne	 SHORT $LN8@BlMmAlloca@2

; 403  : 
; 404  :         return FALSE;

  0012a	32 c0		 xor	 al, al
  0012c	e9 88 01 00 00	 jmp	 $LN17@BlMmAlloca@2
$LN8@BlMmAlloca@2:

; 405  :     }
; 406  : 
; 407  :     if (Region->Type != BL_MM_PHYSICAL_REGION_FREE) {

  00131	8b 45 f4	 mov	 eax, DWORD PTR _Region$[ebp]
  00134	83 78 20 01	 cmp	 DWORD PTR [eax+32], 1
  00138	74 07		 je	 SHORT $LN7@BlMmAlloca@2

; 408  : 
; 409  :         return FALSE;

  0013a	32 c0		 xor	 al, al
  0013c	e9 78 01 00 00	 jmp	 $LN17@BlMmAlloca@2
$LN7@BlMmAlloca@2:

; 410  :     }
; 411  : 
; 412  :     PreviousRegion = NULL;

  00141	83 65 f0 00	 and	 DWORD PTR _PreviousRegion$[ebp], 0

; 413  :     NextRegion = NULL;

  00145	83 65 e4 00	 and	 DWORD PTR _NextRegion$[ebp], 0

; 414  : 
; 415  :     if (Region->Start < Start) {

  00149	8b 45 f4	 mov	 eax, DWORD PTR _Region$[ebp]
  0014c	89 45 b8	 mov	 DWORD PTR tv231[ebp], eax
  0014f	8b 45 b8	 mov	 eax, DWORD PTR tv231[ebp]
  00152	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00155	3b 45 fc	 cmp	 eax, DWORD PTR _Start$[ebp+4]
  00158	77 7d		 ja	 SHORT $LN6@BlMmAlloca@2
  0015a	72 0b		 jb	 SHORT $LN22@BlMmAlloca@2
  0015c	8b 45 b8	 mov	 eax, DWORD PTR tv231[ebp]
  0015f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00162	3b 45 f8	 cmp	 eax, DWORD PTR _Start$[ebp]
  00165	73 70		 jae	 SHORT $LN6@BlMmAlloca@2
$LN22@BlMmAlloca@2:

; 416  : 
; 417  :         BLASSERT(BlRtlIsListEmpty(&BlMmPhysicalRegionLookaside.FreeList) == FALSE);

  00167	b9 80 02 00 00	 mov	 ecx, OFFSET ?BlMmPhysicalRegionLookaside@@3U<unnamed-tag>@@A+640
  0016c	e8 00 00 00 00	 call	 ?BlRtlIsListEmpty@@YIEPAU_LIST_ENTRY@@@Z ; BlRtlIsListEmpty
  00171	0f b6 c0	 movzx	 eax, al
  00174	85 c0		 test	 eax, eax
  00176	74 0f		 je	 SHORT $LN5@BlMmAlloca@2
  00178	ba a1 01 00 00	 mov	 edx, 417		; 000001a1H
  0017d	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_08JOIABOAI@blmm?4cpp?$AA@
  00182	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN5@BlMmAlloca@2:

; 418  : 
; 419  :         PreviousRegion = CONTAINING_RECORD(BlRtlRemoveHeadList(&BlMmPhysicalRegionLookaside.FreeList),
; 420  :                                            BL_MM_PHYSICAL_REGION,
; 421  :                                            Entry);

  00187	b9 80 02 00 00	 mov	 ecx, OFFSET ?BlMmPhysicalRegionLookaside@@3U<unnamed-tag>@@A+640
  0018c	e8 00 00 00 00	 call	 ?BlRtlRemoveHeadList@@YIPAU_LIST_ENTRY@@PAU1@@Z ; BlRtlRemoveHeadList
  00191	89 45 f0	 mov	 DWORD PTR _PreviousRegion$[ebp], eax

; 422  : 
; 423  :         PreviousRegion->Start = Region->Start;

  00194	8b 45 f0	 mov	 eax, DWORD PTR _PreviousRegion$[ebp]
  00197	8b 4d f4	 mov	 ecx, DWORD PTR _Region$[ebp]
  0019a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0019d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  001a0	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  001a3	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 424  :         PreviousRegion->Size = Start - Region->Start;

  001a6	8b 45 f4	 mov	 eax, DWORD PTR _Region$[ebp]
  001a9	8b 4d f8	 mov	 ecx, DWORD PTR _Start$[ebp]
  001ac	2b 48 08	 sub	 ecx, DWORD PTR [eax+8]
  001af	8b 55 fc	 mov	 edx, DWORD PTR _Start$[ebp+4]
  001b2	1b 50 0c	 sbb	 edx, DWORD PTR [eax+12]
  001b5	8b 45 f0	 mov	 eax, DWORD PTR _PreviousRegion$[ebp]
  001b8	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  001bb	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 425  :         PreviousRegion->Limit = Start;

  001be	8b 45 f0	 mov	 eax, DWORD PTR _PreviousRegion$[ebp]
  001c1	8b 4d f8	 mov	 ecx, DWORD PTR _Start$[ebp]
  001c4	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  001c7	8b 4d fc	 mov	 ecx, DWORD PTR _Start$[ebp+4]
  001ca	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 426  :         PreviousRegion->Type = BL_MM_PHYSICAL_REGION_FREE;

  001cd	8b 45 f0	 mov	 eax, DWORD PTR _PreviousRegion$[ebp]
  001d0	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [eax+32], 1
$LN6@BlMmAlloca@2:

; 427  :     }
; 428  : 
; 429  :     if (Region->Limit > End) {

  001d7	8b 45 f4	 mov	 eax, DWORD PTR _Region$[ebp]
  001da	89 45 b4	 mov	 DWORD PTR tv261[ebp], eax
  001dd	8b 45 b4	 mov	 eax, DWORD PTR tv261[ebp]
  001e0	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  001e3	3b 45 dc	 cmp	 eax, DWORD PTR _End$[ebp+4]
  001e6	72 7d		 jb	 SHORT $LN4@BlMmAlloca@2
  001e8	77 0b		 ja	 SHORT $LN23@BlMmAlloca@2
  001ea	8b 45 b4	 mov	 eax, DWORD PTR tv261[ebp]
  001ed	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  001f0	3b 45 d8	 cmp	 eax, DWORD PTR _End$[ebp]
  001f3	76 70		 jbe	 SHORT $LN4@BlMmAlloca@2
$LN23@BlMmAlloca@2:

; 430  : 
; 431  :         BLASSERT(BlRtlIsListEmpty(&BlMmPhysicalRegionLookaside.FreeList) == FALSE);

  001f5	b9 80 02 00 00	 mov	 ecx, OFFSET ?BlMmPhysicalRegionLookaside@@3U<unnamed-tag>@@A+640
  001fa	e8 00 00 00 00	 call	 ?BlRtlIsListEmpty@@YIEPAU_LIST_ENTRY@@@Z ; BlRtlIsListEmpty
  001ff	0f b6 c0	 movzx	 eax, al
  00202	85 c0		 test	 eax, eax
  00204	74 0f		 je	 SHORT $LN3@BlMmAlloca@2
  00206	ba af 01 00 00	 mov	 edx, 431		; 000001afH
  0020b	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_08JOIABOAI@blmm?4cpp?$AA@
  00210	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN3@BlMmAlloca@2:

; 432  : 
; 433  :         NextRegion = CONTAINING_RECORD(BlRtlRemoveHeadList(&BlMmPhysicalRegionLookaside.FreeList),
; 434  :                                        BL_MM_PHYSICAL_REGION,
; 435  :                                        Entry);

  00215	b9 80 02 00 00	 mov	 ecx, OFFSET ?BlMmPhysicalRegionLookaside@@3U<unnamed-tag>@@A+640
  0021a	e8 00 00 00 00	 call	 ?BlRtlRemoveHeadList@@YIPAU_LIST_ENTRY@@PAU1@@Z ; BlRtlRemoveHeadList
  0021f	89 45 e4	 mov	 DWORD PTR _NextRegion$[ebp], eax

; 436  : 
; 437  :         NextRegion->Start = End;

  00222	8b 45 e4	 mov	 eax, DWORD PTR _NextRegion$[ebp]
  00225	8b 4d d8	 mov	 ecx, DWORD PTR _End$[ebp]
  00228	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0022b	8b 4d dc	 mov	 ecx, DWORD PTR _End$[ebp+4]
  0022e	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 438  :         NextRegion->Size = Region->Limit - End;

  00231	8b 45 f4	 mov	 eax, DWORD PTR _Region$[ebp]
  00234	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00237	2b 4d d8	 sub	 ecx, DWORD PTR _End$[ebp]
  0023a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0023d	1b 45 dc	 sbb	 eax, DWORD PTR _End$[ebp+4]
  00240	8b 55 e4	 mov	 edx, DWORD PTR _NextRegion$[ebp]
  00243	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  00246	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 439  :         NextRegion->Limit = Region->Limit;

  00249	8b 45 e4	 mov	 eax, DWORD PTR _NextRegion$[ebp]
  0024c	8b 4d f4	 mov	 ecx, DWORD PTR _Region$[ebp]
  0024f	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00252	89 50 18	 mov	 DWORD PTR [eax+24], edx
  00255	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00258	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 440  :         NextRegion->Type = BL_MM_PHYSICAL_REGION_FREE;

  0025b	8b 45 e4	 mov	 eax, DWORD PTR _NextRegion$[ebp]
  0025e	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [eax+32], 1
$LN4@BlMmAlloca@2:

; 441  :     }
; 442  : 
; 443  :     Region->Start = Start;

  00265	8b 45 f4	 mov	 eax, DWORD PTR _Region$[ebp]
  00268	8b 4d f8	 mov	 ecx, DWORD PTR _Start$[ebp]
  0026b	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0026e	8b 4d fc	 mov	 ecx, DWORD PTR _Start$[ebp+4]
  00271	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 444  :     Region->Size = Size;

  00274	8b 45 f4	 mov	 eax, DWORD PTR _Region$[ebp]
  00277	8b 4d 10	 mov	 ecx, DWORD PTR _Size$[ebp]
  0027a	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0027d	8b 4d 14	 mov	 ecx, DWORD PTR _Size$[ebp+4]
  00280	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 445  :     Region->Limit = End;

  00283	8b 45 f4	 mov	 eax, DWORD PTR _Region$[ebp]
  00286	8b 4d d8	 mov	 ecx, DWORD PTR _End$[ebp]
  00289	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  0028c	8b 4d dc	 mov	 ecx, DWORD PTR _End$[ebp+4]
  0028f	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 446  :     Region->Type = Type;

  00292	8b 45 f4	 mov	 eax, DWORD PTR _Region$[ebp]
  00295	8b 4d d4	 mov	 ecx, DWORD PTR _Type$[ebp]
  00298	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 447  : 
; 448  :     if (PreviousRegion != NULL) {

  0029b	83 7d f0 00	 cmp	 DWORD PTR _PreviousRegion$[ebp], 0
  0029f	74 08		 je	 SHORT $LN2@BlMmAlloca@2

; 449  : 
; 450  :         BlMmInsertPhysicalRegion(PreviousRegion);

  002a1	8b 4d f0	 mov	 ecx, DWORD PTR _PreviousRegion$[ebp]
  002a4	e8 00 00 00 00	 call	 ?BlMmInsertPhysicalRegion@@YIXPAU_BL_MM_PHYSICAL_REGION@@@Z ; BlMmInsertPhysicalRegion
$LN2@BlMmAlloca@2:

; 451  :     }
; 452  : 
; 453  :     if (NextRegion != NULL) {

  002a9	83 7d e4 00	 cmp	 DWORD PTR _NextRegion$[ebp], 0
  002ad	74 08		 je	 SHORT $LN1@BlMmAlloca@2

; 454  : 
; 455  :         BlMmInsertPhysicalRegion(NextRegion);

  002af	8b 4d e4	 mov	 ecx, DWORD PTR _NextRegion$[ebp]
  002b2	e8 00 00 00 00	 call	 ?BlMmInsertPhysicalRegion@@YIXPAU_BL_MM_PHYSICAL_REGION@@@Z ; BlMmInsertPhysicalRegion
$LN1@BlMmAlloca@2:

; 456  :     }
; 457  : 
; 458  :     return TRUE;

  002b7	b0 01		 mov	 al, 1
$LN17@BlMmAlloca@2:

; 459  : }

  002b9	c9		 leave
  002ba	c2 10 00	 ret	 16			; 00000010H
?BlMmAllocateSpecificPhysicalRegion@@YIE_K0K@Z ENDP	; BlMmAllocateSpecificPhysicalRegion
_TEXT	ENDS
PUBLIC	?BlMmFindFreePhysicalRegion@@YIEPA_K0@Z		; BlMmFindFreePhysicalRegion
; Function compile flags: /Odsp
;	COMDAT ?BlMmFindFreePhysicalRegion@@YIEPA_K0@Z
_TEXT	SEGMENT
_Size$ = -20						; size = 4
_Base$ = -16						; size = 4
_Entry$ = -12						; size = 4
_Head$ = -8						; size = 4
_Region$ = -4						; size = 4
?BlMmFindFreePhysicalRegion@@YIEPA_K0@Z PROC		; BlMmFindFreePhysicalRegion, COMDAT
; _Base$ = ecx
; _Size$ = edx

; 486  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 55 ec	 mov	 DWORD PTR _Size$[ebp], edx
  00009	89 4d f0	 mov	 DWORD PTR _Base$[ebp], ecx

; 487  :     PLIST_ENTRY Entry;
; 488  :     PLIST_ENTRY Head;
; 489  :     PBL_MM_PHYSICAL_REGION Region;
; 490  : 
; 491  :     Head = &BlMmPhysicalRegionList;

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _Head$[ebp], OFFSET ?BlMmPhysicalRegionList@@3U_LIST_ENTRY@@A ; BlMmPhysicalRegionList

; 492  : 
; 493  :     for (Entry = Head->Flink; Entry != Head; Entry = Entry->Flink) {

  00013	8b 45 f8	 mov	 eax, DWORD PTR _Head$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR _Entry$[ebp], eax
  0001b	eb 08		 jmp	 SHORT $LN4@BlMmFindFr
$LN3@BlMmFindFr:
  0001d	8b 45 f4	 mov	 eax, DWORD PTR _Entry$[ebp]
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
  00022	89 45 f4	 mov	 DWORD PTR _Entry$[ebp], eax
$LN4@BlMmFindFr:
  00025	8b 45 f4	 mov	 eax, DWORD PTR _Entry$[ebp]
  00028	3b 45 f8	 cmp	 eax, DWORD PTR _Head$[ebp]
  0002b	74 37		 je	 SHORT $LN2@BlMmFindFr

; 494  : 
; 495  :         Region = CONTAINING_RECORD(Entry,
; 496  :                                    BL_MM_PHYSICAL_REGION,
; 497  :                                    Entry);

  0002d	8b 45 f4	 mov	 eax, DWORD PTR _Entry$[ebp]
  00030	89 45 fc	 mov	 DWORD PTR _Region$[ebp], eax

; 498  : 
; 499  :         if (Region->Type == BL_MM_PHYSICAL_REGION_FREE) {

  00033	8b 45 fc	 mov	 eax, DWORD PTR _Region$[ebp]
  00036	83 78 20 01	 cmp	 DWORD PTR [eax+32], 1
  0003a	75 26		 jne	 SHORT $LN1@BlMmFindFr

; 500  : 
; 501  :             *Base = Region->Start;

  0003c	8b 45 f0	 mov	 eax, DWORD PTR _Base$[ebp]
  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _Region$[ebp]
  00042	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00045	89 10		 mov	 DWORD PTR [eax], edx
  00047	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  0004a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 502  :             *Size = Region->Size;

  0004d	8b 45 ec	 mov	 eax, DWORD PTR _Size$[ebp]
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _Region$[ebp]
  00053	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00056	89 10		 mov	 DWORD PTR [eax], edx
  00058	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  0005b	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 503  :             return TRUE;

  0005e	b0 01		 mov	 al, 1
  00060	eb 04		 jmp	 SHORT $LN5@BlMmFindFr
$LN1@BlMmFindFr:

; 504  :         }
; 505  :     }

  00062	eb b9		 jmp	 SHORT $LN3@BlMmFindFr
$LN2@BlMmFindFr:

; 506  : 
; 507  :     return FALSE;

  00064	32 c0		 xor	 al, al
$LN5@BlMmFindFr:

; 508  : }

  00066	c9		 leave
  00067	c3		 ret	 0
?BlMmFindFreePhysicalRegion@@YIEPA_K0@Z ENDP		; BlMmFindFreePhysicalRegion
_TEXT	ENDS
PUBLIC	?BlMmGetNextPhysicalRegion@@YIEPAPAXPA_K1PAK@Z	; BlMmGetNextPhysicalRegion
; Function compile flags: /Odsp
;	COMDAT ?BlMmGetNextPhysicalRegion@@YIEPAPAXPA_K1PAK@Z
_TEXT	SEGMENT
_Base$ = -20						; size = 4
_Handle$ = -16						; size = 4
_Entry$ = -12						; size = 4
_Head$ = -8						; size = 4
_Region$ = -4						; size = 4
_Size$ = 8						; size = 4
_Type$ = 12						; size = 4
?BlMmGetNextPhysicalRegion@@YIEPAPAXPA_K1PAK@Z PROC	; BlMmGetNextPhysicalRegion, COMDAT
; _Handle$ = ecx
; _Base$ = edx

; 543  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 55 ec	 mov	 DWORD PTR _Base$[ebp], edx
  00009	89 4d f0	 mov	 DWORD PTR _Handle$[ebp], ecx

; 544  :     PLIST_ENTRY Entry;
; 545  :     PLIST_ENTRY Head;
; 546  :     PBL_MM_PHYSICAL_REGION Region;
; 547  : 
; 548  :     Head = &BlMmPhysicalRegionList;

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _Head$[ebp], OFFSET ?BlMmPhysicalRegionList@@3U_LIST_ENTRY@@A ; BlMmPhysicalRegionList

; 549  : 
; 550  :     if (*Handle == NULL) {

  00013	8b 45 f0	 mov	 eax, DWORD PTR _Handle$[ebp]
  00016	83 38 00	 cmp	 DWORD PTR [eax], 0
  00019	75 08		 jne	 SHORT $LN3@BlMmGetNex

; 551  : 
; 552  :         Entry = Head;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _Head$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR _Entry$[ebp], eax

; 553  : 
; 554  :     } else {

  00021	eb 08		 jmp	 SHORT $LN2@BlMmGetNex
$LN3@BlMmGetNex:

; 555  : 
; 556  :         Entry = (PLIST_ENTRY) *Handle;

  00023	8b 45 f0	 mov	 eax, DWORD PTR _Handle$[ebp]
  00026	8b 00		 mov	 eax, DWORD PTR [eax]
  00028	89 45 f4	 mov	 DWORD PTR _Entry$[ebp], eax
$LN2@BlMmGetNex:

; 557  :     }
; 558  : 
; 559  :     Entry = Entry->Flink;

  0002b	8b 45 f4	 mov	 eax, DWORD PTR _Entry$[ebp]
  0002e	8b 00		 mov	 eax, DWORD PTR [eax]
  00030	89 45 f4	 mov	 DWORD PTR _Entry$[ebp], eax

; 560  : 
; 561  :     if (Entry == Head) {

  00033	8b 45 f4	 mov	 eax, DWORD PTR _Entry$[ebp]
  00036	3b 45 f8	 cmp	 eax, DWORD PTR _Head$[ebp]
  00039	75 04		 jne	 SHORT $LN1@BlMmGetNex

; 562  : 
; 563  :         return FALSE;

  0003b	32 c0		 xor	 al, al
  0003d	eb 3d		 jmp	 SHORT $LN4@BlMmGetNex
$LN1@BlMmGetNex:

; 564  :     }
; 565  : 
; 566  :     Region = CONTAINING_RECORD(Entry,
; 567  :                                BL_MM_PHYSICAL_REGION,
; 568  :                                Entry);

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _Entry$[ebp]
  00042	89 45 fc	 mov	 DWORD PTR _Region$[ebp], eax

; 569  : 
; 570  :     *Handle = &Region->Entry;

  00045	8b 45 f0	 mov	 eax, DWORD PTR _Handle$[ebp]
  00048	8b 4d fc	 mov	 ecx, DWORD PTR _Region$[ebp]
  0004b	89 08		 mov	 DWORD PTR [eax], ecx

; 571  :     *Base = Region->Start;

  0004d	8b 45 ec	 mov	 eax, DWORD PTR _Base$[ebp]
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _Region$[ebp]
  00053	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00056	89 10		 mov	 DWORD PTR [eax], edx
  00058	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  0005b	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 572  :     *Size = Region->Size;

  0005e	8b 45 08	 mov	 eax, DWORD PTR _Size$[ebp]
  00061	8b 4d fc	 mov	 ecx, DWORD PTR _Region$[ebp]
  00064	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00067	89 10		 mov	 DWORD PTR [eax], edx
  00069	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  0006c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 573  :     *Type = Region->Type;

  0006f	8b 45 0c	 mov	 eax, DWORD PTR _Type$[ebp]
  00072	8b 4d fc	 mov	 ecx, DWORD PTR _Region$[ebp]
  00075	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00078	89 08		 mov	 DWORD PTR [eax], ecx

; 574  : 
; 575  :     return TRUE;

  0007a	b0 01		 mov	 al, 1
$LN4@BlMmGetNex:

; 576  : }

  0007c	c9		 leave
  0007d	c2 08 00	 ret	 8
?BlMmGetNextPhysicalRegion@@YIEPAPAXPA_K1PAK@Z ENDP	; BlMmGetNextPhysicalRegion
_TEXT	ENDS
PUBLIC	??_C@_0BB@GBGJFAGF@SINGULARITY_SMAP?$AA@	; `string'
PUBLIC	??_C@_0L@HFEHJDPJ@BOOT_STACK?$AA@		; `string'
PUBLIC	??_C@_0M@KGCABPNA@SINGULARITY?$AA@		; `string'
PUBLIC	??_C@_04KKJBFIJG@TASK?$AA@			; `string'
PUBLIC	??_C@_07GHPPKNEI@CONTEXT?$AA@			; `string'
PUBLIC	??_C@_0N@JIHEIFIK@KERNEL_STACK?$AA@		; `string'
PUBLIC	??_C@_08HALIBMIK@LOG_TEXT?$AA@			; `string'
PUBLIC	??_C@_0L@NNLIGPNO@LOG_RECORD?$AA@		; `string'
PUBLIC	??_C@_0BB@MBLMFHLL@NATIVE_PROCESSOR?$AA@	; `string'
PUBLIC	??_C@_0BA@BBGJNAMD@NATIVE_PLATFORM?$AA@		; `string'
PUBLIC	??_C@_0N@MOEDNENG@KERNEL_IMAGE?$AA@		; `string'
PUBLIC	??_C@_06NJIFKOLF@DISTRO?$AA@			; `string'
PUBLIC	??_C@_0O@CKGIKGKG@SMAP_RESERVED?$AA@		; `string'
PUBLIC	??_C@_0M@CDFHDJDB@BOOT_LOADER?$AA@		; `string'
PUBLIC	??_C@_04BHKCNABG@BIOS?$AA@			; `string'
PUBLIC	??_C@_04HEDFJGEJ@FREE?$AA@			; `string'
PUBLIC	?BlMmPhysicalRegionTypeString@@YIPADK@Z		; BlMmPhysicalRegionTypeString
;	COMDAT ??_C@_0BB@GBGJFAGF@SINGULARITY_SMAP?$AA@
CONST	SEGMENT
??_C@_0BB@GBGJFAGF@SINGULARITY_SMAP?$AA@ DB 'SINGULARITY_SMAP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HFEHJDPJ@BOOT_STACK?$AA@
CONST	SEGMENT
??_C@_0L@HFEHJDPJ@BOOT_STACK?$AA@ DB 'BOOT_STACK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KGCABPNA@SINGULARITY?$AA@
CONST	SEGMENT
??_C@_0M@KGCABPNA@SINGULARITY?$AA@ DB 'SINGULARITY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04KKJBFIJG@TASK?$AA@
CONST	SEGMENT
??_C@_04KKJBFIJG@TASK?$AA@ DB 'TASK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GHPPKNEI@CONTEXT?$AA@
CONST	SEGMENT
??_C@_07GHPPKNEI@CONTEXT?$AA@ DB 'CONTEXT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JIHEIFIK@KERNEL_STACK?$AA@
CONST	SEGMENT
??_C@_0N@JIHEIFIK@KERNEL_STACK?$AA@ DB 'KERNEL_STACK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08HALIBMIK@LOG_TEXT?$AA@
CONST	SEGMENT
??_C@_08HALIBMIK@LOG_TEXT?$AA@ DB 'LOG_TEXT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NNLIGPNO@LOG_RECORD?$AA@
CONST	SEGMENT
??_C@_0L@NNLIGPNO@LOG_RECORD?$AA@ DB 'LOG_RECORD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MBLMFHLL@NATIVE_PROCESSOR?$AA@
CONST	SEGMENT
??_C@_0BB@MBLMFHLL@NATIVE_PROCESSOR?$AA@ DB 'NATIVE_PROCESSOR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BBGJNAMD@NATIVE_PLATFORM?$AA@
CONST	SEGMENT
??_C@_0BA@BBGJNAMD@NATIVE_PLATFORM?$AA@ DB 'NATIVE_PLATFORM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MOEDNENG@KERNEL_IMAGE?$AA@
CONST	SEGMENT
??_C@_0N@MOEDNENG@KERNEL_IMAGE?$AA@ DB 'KERNEL_IMAGE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06NJIFKOLF@DISTRO?$AA@
CONST	SEGMENT
??_C@_06NJIFKOLF@DISTRO?$AA@ DB 'DISTRO', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CKGIKGKG@SMAP_RESERVED?$AA@
CONST	SEGMENT
??_C@_0O@CKGIKGKG@SMAP_RESERVED?$AA@ DB 'SMAP_RESERVED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CDFHDJDB@BOOT_LOADER?$AA@
CONST	SEGMENT
??_C@_0M@CDFHDJDB@BOOT_LOADER?$AA@ DB 'BOOT_LOADER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04BHKCNABG@BIOS?$AA@
CONST	SEGMENT
??_C@_04BHKCNABG@BIOS?$AA@ DB 'BIOS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HEDFJGEJ@FREE?$AA@
CONST	SEGMENT
??_C@_04HEDFJGEJ@FREE?$AA@ DB 'FREE', 00H		; `string'
; Function compile flags: /Odsp
CONST	ENDS
;	COMDAT ?BlMmPhysicalRegionTypeString@@YIPADK@Z
_TEXT	SEGMENT
tv64 = -8						; size = 4
_Type$ = -4						; size = 4
?BlMmPhysicalRegionTypeString@@YIPADK@Z PROC		; BlMmPhysicalRegionTypeString, COMDAT
; _Type$ = ecx

; 599  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _Type$[ebp], ecx

; 600  : 
; 601  : #define CASE(X) case BL_MM_PHYSICAL_REGION_##X: return #X;
; 602  : 
; 603  :     switch (Type) {

  00008	8b 45 fc	 mov	 eax, DWORD PTR _Type$[ebp]
  0000b	89 45 f8	 mov	 DWORD PTR tv64[ebp], eax
  0000e	8b 45 f8	 mov	 eax, DWORD PTR tv64[ebp]
  00011	48		 dec	 eax
  00012	89 45 f8	 mov	 DWORD PTR tv64[ebp], eax
  00015	83 7d f8 0f	 cmp	 DWORD PTR tv64[ebp], 15	; 0000000fH
  00019	77 7a		 ja	 SHORT $LN18@BlMmPhysic
  0001b	8b 45 f8	 mov	 eax, DWORD PTR tv64[ebp]
  0001e	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN22@BlMmPhysic[eax*4]
$LN17@BlMmPhysic:

; 604  : 
; 605  :         CASE(FREE)

  00025	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04HEDFJGEJ@FREE?$AA@
  0002a	eb 7f		 jmp	 SHORT $LN20@BlMmPhysic
$LN16@BlMmPhysic:

; 606  :         CASE(BIOS)

  0002c	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04BHKCNABG@BIOS?$AA@
  00031	eb 78		 jmp	 SHORT $LN20@BlMmPhysic
$LN15@BlMmPhysic:

; 607  :         CASE(BOOT_LOADER)

  00033	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0M@CDFHDJDB@BOOT_LOADER?$AA@
  00038	eb 71		 jmp	 SHORT $LN20@BlMmPhysic
$LN14@BlMmPhysic:

; 608  :         CASE(SMAP_RESERVED)

  0003a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0O@CKGIKGKG@SMAP_RESERVED?$AA@
  0003f	eb 6a		 jmp	 SHORT $LN20@BlMmPhysic
$LN13@BlMmPhysic:

; 609  :         CASE(DISTRO)

  00041	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_06NJIFKOLF@DISTRO?$AA@
  00046	eb 63		 jmp	 SHORT $LN20@BlMmPhysic
$LN12@BlMmPhysic:

; 610  :         CASE(KERNEL_IMAGE)

  00048	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0N@MOEDNENG@KERNEL_IMAGE?$AA@
  0004d	eb 5c		 jmp	 SHORT $LN20@BlMmPhysic
$LN11@BlMmPhysic:

; 611  :         CASE(NATIVE_PLATFORM)

  0004f	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BA@BBGJNAMD@NATIVE_PLATFORM?$AA@
  00054	eb 55		 jmp	 SHORT $LN20@BlMmPhysic
$LN10@BlMmPhysic:

; 612  :         CASE(NATIVE_PROCESSOR)

  00056	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BB@MBLMFHLL@NATIVE_PROCESSOR?$AA@
  0005b	eb 4e		 jmp	 SHORT $LN20@BlMmPhysic
$LN9@BlMmPhysic:

; 613  :         CASE(LOG_RECORD)

  0005d	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0L@NNLIGPNO@LOG_RECORD?$AA@
  00062	eb 47		 jmp	 SHORT $LN20@BlMmPhysic
$LN8@BlMmPhysic:

; 614  :         CASE(LOG_TEXT)

  00064	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08HALIBMIK@LOG_TEXT?$AA@
  00069	eb 40		 jmp	 SHORT $LN20@BlMmPhysic
$LN7@BlMmPhysic:

; 615  :         CASE(KERNEL_STACK)

  0006b	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0N@JIHEIFIK@KERNEL_STACK?$AA@
  00070	eb 39		 jmp	 SHORT $LN20@BlMmPhysic
$LN6@BlMmPhysic:

; 616  :         CASE(CONTEXT)

  00072	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_07GHPPKNEI@CONTEXT?$AA@
  00077	eb 32		 jmp	 SHORT $LN20@BlMmPhysic
$LN5@BlMmPhysic:

; 617  :         CASE(TASK)

  00079	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04KKJBFIJG@TASK?$AA@
  0007e	eb 2b		 jmp	 SHORT $LN20@BlMmPhysic
$LN4@BlMmPhysic:

; 618  :         CASE(SINGULARITY)

  00080	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0M@KGCABPNA@SINGULARITY?$AA@
  00085	eb 24		 jmp	 SHORT $LN20@BlMmPhysic
$LN3@BlMmPhysic:

; 619  :         CASE(BOOT_STACK)

  00087	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0L@HFEHJDPJ@BOOT_STACK?$AA@
  0008c	eb 1d		 jmp	 SHORT $LN20@BlMmPhysic
$LN2@BlMmPhysic:

; 620  :         CASE(SINGULARITY_SMAP)

  0008e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BB@GBGJFAGF@SINGULARITY_SMAP?$AA@
  00093	eb 16		 jmp	 SHORT $LN20@BlMmPhysic
$LN18@BlMmPhysic:

; 621  :     }
; 622  : 
; 623  : #undef CASE
; 624  : 
; 625  :     BLASSERT(FALSE);

  00095	33 c0		 xor	 eax, eax
  00097	40		 inc	 eax
  00098	74 0f		 je	 SHORT $LN1@BlMmPhysic
  0009a	ba 71 02 00 00	 mov	 edx, 625		; 00000271H
  0009f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_08JOIABOAI@blmm?4cpp?$AA@
  000a4	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN1@BlMmPhysic:

; 626  :     return NULL;

  000a9	33 c0		 xor	 eax, eax
$LN20@BlMmPhysic:

; 627  : }

  000ab	c9		 leave
  000ac	c3		 ret	 0
  000ad	8d 49 00	 npad	 3
$LN22@BlMmPhysic:
  000b0	00 00 00 00	 DD	 $LN17@BlMmPhysic
  000b4	00 00 00 00	 DD	 $LN16@BlMmPhysic
  000b8	00 00 00 00	 DD	 $LN15@BlMmPhysic
  000bc	00 00 00 00	 DD	 $LN14@BlMmPhysic
  000c0	00 00 00 00	 DD	 $LN13@BlMmPhysic
  000c4	00 00 00 00	 DD	 $LN12@BlMmPhysic
  000c8	00 00 00 00	 DD	 $LN11@BlMmPhysic
  000cc	00 00 00 00	 DD	 $LN10@BlMmPhysic
  000d0	00 00 00 00	 DD	 $LN9@BlMmPhysic
  000d4	00 00 00 00	 DD	 $LN8@BlMmPhysic
  000d8	00 00 00 00	 DD	 $LN7@BlMmPhysic
  000dc	00 00 00 00	 DD	 $LN6@BlMmPhysic
  000e0	00 00 00 00	 DD	 $LN5@BlMmPhysic
  000e4	00 00 00 00	 DD	 $LN4@BlMmPhysic
  000e8	00 00 00 00	 DD	 $LN3@BlMmPhysic
  000ec	00 00 00 00	 DD	 $LN2@BlMmPhysic
?BlMmPhysicalRegionTypeString@@YIPADK@Z ENDP		; BlMmPhysicalRegionTypeString
_TEXT	ENDS
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0BO@NKCHPHGB@MM?3?5?5?5?$CF016I64x?4?4?4?$CF016I64x?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@CNDFIJED@MM?3?5Physical?5Region?3?6?$AA@ ; `string'
PUBLIC	?BlMmDumpPhysicalRegionList@@YIXXZ		; BlMmDumpPhysicalRegionList
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NKCHPHGB@MM?3?5?5?5?$CF016I64x?4?4?4?$CF016I64x?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BO@NKCHPHGB@MM?3?5?5?5?$CF016I64x?4?4?4?$CF016I64x?5?$CFs?6?$AA@ DB 'M'
	DB	'M:   %016I64x...%016I64x %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CNDFIJED@MM?3?5Physical?5Region?3?6?$AA@
CONST	SEGMENT
??_C@_0BG@CNDFIJED@MM?3?5Physical?5Region?3?6?$AA@ DB 'MM: Physical Regio'
	DB	'n:', 0aH, 00H				; `string'
; Function compile flags: /Odsp
CONST	ENDS
;	COMDAT ?BlMmDumpPhysicalRegionList@@YIXXZ
_TEXT	SEGMENT
_Entry$ = -12						; size = 4
_Head$ = -8						; size = 4
_Region$ = -4						; size = 4
?BlMmDumpPhysicalRegionList@@YIXXZ PROC			; BlMmDumpPhysicalRegionList, COMDAT

; 642  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 643  :     PLIST_ENTRY Entry;
; 644  :     PLIST_ENTRY Head;
; 645  :     PBL_MM_PHYSICAL_REGION Region;
; 646  : 
; 647  :     BlRtlPrintf("MM: Physical Region:\n");

  00006	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@CNDFIJED@MM?3?5Physical?5Region?3?6?$AA@
  0000b	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  00010	59		 pop	 ecx

; 648  : 
; 649  :     Head = &BlMmPhysicalRegionList;

  00011	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _Head$[ebp], OFFSET ?BlMmPhysicalRegionList@@3U_LIST_ENTRY@@A ; BlMmPhysicalRegionList

; 650  : 
; 651  :     for (Entry = Head->Flink; Entry != Head; Entry = Entry->Flink) {

  00018	8b 45 f8	 mov	 eax, DWORD PTR _Head$[ebp]
  0001b	8b 00		 mov	 eax, DWORD PTR [eax]
  0001d	89 45 f4	 mov	 DWORD PTR _Entry$[ebp], eax
  00020	eb 08		 jmp	 SHORT $LN3@BlMmDumpPh
$LN2@BlMmDumpPh:
  00022	8b 45 f4	 mov	 eax, DWORD PTR _Entry$[ebp]
  00025	8b 00		 mov	 eax, DWORD PTR [eax]
  00027	89 45 f4	 mov	 DWORD PTR _Entry$[ebp], eax
$LN3@BlMmDumpPh:
  0002a	8b 45 f4	 mov	 eax, DWORD PTR _Entry$[ebp]
  0002d	3b 45 f8	 cmp	 eax, DWORD PTR _Head$[ebp]
  00030	74 33		 je	 SHORT $LN1@BlMmDumpPh

; 652  : 
; 653  :         Region = CONTAINING_RECORD(Entry, BL_MM_PHYSICAL_REGION, Entry);

  00032	8b 45 f4	 mov	 eax, DWORD PTR _Entry$[ebp]
  00035	89 45 fc	 mov	 DWORD PTR _Region$[ebp], eax

; 654  : 
; 655  :         BlRtlPrintf("MM:   %016I64x...%016I64x %s\n",
; 656  :                     Region->Start,
; 657  :                     Region->Limit,
; 658  :                     BlMmPhysicalRegionTypeString(Region->Type));

  00038	8b 45 fc	 mov	 eax, DWORD PTR _Region$[ebp]
  0003b	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0003e	e8 00 00 00 00	 call	 ?BlMmPhysicalRegionTypeString@@YIPADK@Z ; BlMmPhysicalRegionTypeString
  00043	50		 push	 eax
  00044	8b 45 fc	 mov	 eax, DWORD PTR _Region$[ebp]
  00047	ff 70 1c	 push	 DWORD PTR [eax+28]
  0004a	ff 70 18	 push	 DWORD PTR [eax+24]
  0004d	8b 45 fc	 mov	 eax, DWORD PTR _Region$[ebp]
  00050	ff 70 0c	 push	 DWORD PTR [eax+12]
  00053	ff 70 08	 push	 DWORD PTR [eax+8]
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@NKCHPHGB@MM?3?5?5?5?$CF016I64x?4?4?4?$CF016I64x?5?$CFs?6?$AA@
  0005b	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  00060	83 c4 18	 add	 esp, 24			; 00000018H

; 659  :     }

  00063	eb bd		 jmp	 SHORT $LN2@BlMmDumpPh
$LN1@BlMmDumpPh:

; 660  : 
; 661  :     BlRtlPrintf("\n");

  00065	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  0006a	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  0006f	59		 pop	 ecx

; 662  : 
; 663  :     return;
; 664  : }

  00070	c9		 leave
  00071	c3		 ret	 0
?BlMmDumpPhysicalRegionList@@YIXXZ ENDP			; BlMmDumpPhysicalRegionList
_TEXT	ENDS
PUBLIC	?BlGetBeb@@YIPAU_BEB@@XZ			; BlGetBeb
PUBLIC	?BlMmInitializePageTables@@YIXXZ		; BlMmInitializePageTables
EXTRN	?BlMmSetCr3@@YIXK@Z:PROC			; BlMmSetCr3
EXTRN	__allshl:PROC
EXTRN	__allmul:PROC
; Function compile flags: /Odsp
;	COMDAT ?BlMmInitializePageTables@@YIXXZ
_TEXT	SEGMENT
_Pte$ = -44						; size = 4
_PtBase$ = -40						; size = 8
_Pdpe$ = -32						; size = 4
_Pde$ = -28						; size = 4
_PdptBase$ = -24					; size = 8
_Index$ = -16						; size = 8
_PdtBase$ = -8						; size = 8
?BlMmInitializePageTables@@YIXXZ PROC			; BlMmInitializePageTables, COMDAT

; 683  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	56		 push	 esi
  00007	57		 push	 edi

; 684  :     UINT64 Index;
; 685  :     UINT64 *Pde;
; 686  :     UINT64 PdtBase;
; 687  :     UINT64 *Pdpe;
; 688  :     UINT64 PdptBase;
; 689  : 
; 690  : #if defined(BOOT_X64)
; 691  : 
; 692  :     UINT64 *Pml4e;
; 693  :     UINT64 Pml4tBase;
; 694  : 
; 695  : #endif
; 696  : 
; 697  :     UINT64 *Pte;
; 698  :     UINT64 PtBase;
; 699  : 
; 700  : #if defined(BOOT_X64)
; 701  : 
; 702  :     Pml4tBase = (UINT64) (ULONG_PTR) BlMmPml4Table;
; 703  : 
; 704  : #endif
; 705  : 
; 706  :     PdptBase = (UINT64) (ULONG_PTR) BlMmPdpTable;

  00008	b8 00 00 00 00	 mov	 eax, OFFSET ?BlMmPdpTable@@3PAU_BL_MM_PAGE_TABLE@@A ; BlMmPdpTable
  0000d	33 c9		 xor	 ecx, ecx
  0000f	89 45 e8	 mov	 DWORD PTR _PdptBase$[ebp], eax
  00012	89 4d ec	 mov	 DWORD PTR _PdptBase$[ebp+4], ecx

; 707  :     PdtBase = (UINT64) (ULONG_PTR) BlMmPdTable;

  00015	b8 00 00 00 00	 mov	 eax, OFFSET ?BlMmPdTable@@3PAU_BL_MM_PAGE_TABLE@@A ; BlMmPdTable
  0001a	33 c9		 xor	 ecx, ecx
  0001c	89 45 f8	 mov	 DWORD PTR _PdtBase$[ebp], eax
  0001f	89 4d fc	 mov	 DWORD PTR _PdtBase$[ebp+4], ecx

; 708  :     PtBase = (UINT64) (ULONG_PTR) BlMmPgTable;

  00022	b8 00 00 00 00	 mov	 eax, OFFSET ?BlMmPgTable@@3PAU_BL_MM_PAGE_TABLE@@A ; BlMmPgTable
  00027	33 c9		 xor	 ecx, ecx
  00029	89 45 d8	 mov	 DWORD PTR _PtBase$[ebp], eax
  0002c	89 4d dc	 mov	 DWORD PTR _PtBase$[ebp+4], ecx

; 709  : 
; 710  : #if defined(BOOT_X64)
; 711  : 
; 712  :     Pml4e = (UINT64 *) (PVOID) Pml4tBase;
; 713  : 
; 714  : #endif
; 715  : 
; 716  :     Pdpe = (UINT64 *) (PVOID) (ULONG_PTR) PdptBase;

  0002f	8b 45 e8	 mov	 eax, DWORD PTR _PdptBase$[ebp]
  00032	89 45 e0	 mov	 DWORD PTR _Pdpe$[ebp], eax

; 717  :     Pde = (UINT64 *) (PVOID) (ULONG_PTR) PdtBase;

  00035	8b 45 f8	 mov	 eax, DWORD PTR _PdtBase$[ebp]
  00038	89 45 e4	 mov	 DWORD PTR _Pde$[ebp], eax

; 718  :     Pte = (UINT64 *) (PVOID) (ULONG_PTR) PtBase;

  0003b	8b 45 d8	 mov	 eax, DWORD PTR _PtBase$[ebp]
  0003e	89 45 d4	 mov	 DWORD PTR _Pte$[ebp], eax

; 719  : 
; 720  : #if defined(BOOT_X64)
; 721  : 
; 722  :     Pml4e[0] = PdptBase | PAGE_PRESENT | PAGE_WRITEABLE | PAGE_ACCESSED;
; 723  : 
; 724  : #endif
; 725  : 
; 726  :     for (Index = 0; Index < 4; Index += 1) {

  00041	83 65 f0 00	 and	 DWORD PTR _Index$[ebp], 0
  00045	83 65 f4 00	 and	 DWORD PTR _Index$[ebp+4], 0
  00049	eb 12		 jmp	 SHORT $LN9@BlMmInitia
$LN8@BlMmInitia:
  0004b	8b 45 f0	 mov	 eax, DWORD PTR _Index$[ebp]
  0004e	83 c0 01	 add	 eax, 1
  00051	8b 4d f4	 mov	 ecx, DWORD PTR _Index$[ebp+4]
  00054	83 d1 00	 adc	 ecx, 0
  00057	89 45 f0	 mov	 DWORD PTR _Index$[ebp], eax
  0005a	89 4d f4	 mov	 DWORD PTR _Index$[ebp+4], ecx
$LN9@BlMmInitia:
  0005d	83 7d f4 00	 cmp	 DWORD PTR _Index$[ebp+4], 0
  00061	77 42		 ja	 SHORT $LN7@BlMmInitia
  00063	72 06		 jb	 SHORT $LN12@BlMmInitia
  00065	83 7d f0 04	 cmp	 DWORD PTR _Index$[ebp], 4
  00069	73 3a		 jae	 SHORT $LN7@BlMmInitia
$LN12@BlMmInitia:

; 727  : 
; 728  :         Pdpe[Index] = (PdtBase + (Index * PAGE_SIZE)) | PAGE_PRESENT;

  0006b	6a 00		 push	 0
  0006d	68 00 10 00 00	 push	 4096			; 00001000H
  00072	ff 75 f4	 push	 DWORD PTR _Index$[ebp+4]
  00075	ff 75 f0	 push	 DWORD PTR _Index$[ebp]
  00078	e8 00 00 00 00	 call	 __allmul
  0007d	8b f0		 mov	 esi, eax
  0007f	03 75 f8	 add	 esi, DWORD PTR _PdtBase$[ebp]
  00082	8b 7d fc	 mov	 edi, DWORD PTR _PdtBase$[ebp+4]
  00085	13 fa		 adc	 edi, edx
  00087	83 ce 01	 or	 esi, 1
  0008a	6a 00		 push	 0
  0008c	6a 08		 push	 8
  0008e	ff 75 f4	 push	 DWORD PTR _Index$[ebp+4]
  00091	ff 75 f0	 push	 DWORD PTR _Index$[ebp]
  00094	e8 00 00 00 00	 call	 __allmul
  00099	8b 4d e0	 mov	 ecx, DWORD PTR _Pdpe$[ebp]
  0009c	89 34 01	 mov	 DWORD PTR [ecx+eax], esi
  0009f	89 7c 01 04	 mov	 DWORD PTR [ecx+eax+4], edi

; 729  : 
; 730  : #if defined(BOOT_X64)
; 731  : 
; 732  :         Pdpe[Index] |= PAGE_WRITEABLE | PAGE_ACCESSED;
; 733  : 
; 734  : #endif
; 735  : 
; 736  :     }

  000a3	eb a6		 jmp	 SHORT $LN8@BlMmInitia
$LN7@BlMmInitia:

; 737  : 
; 738  :     Pde[0] = PtBase | PAGE_PRESENT | PAGE_WRITEABLE | PAGE_ACCESSED;

  000a5	8b 45 d8	 mov	 eax, DWORD PTR _PtBase$[ebp]
  000a8	83 c8 01	 or	 eax, 1
  000ab	8b 4d dc	 mov	 ecx, DWORD PTR _PtBase$[ebp+4]
  000ae	83 c8 02	 or	 eax, 2
  000b1	83 c8 20	 or	 eax, 32			; 00000020H
  000b4	8b 55 e4	 mov	 edx, DWORD PTR _Pde$[ebp]
  000b7	89 02		 mov	 DWORD PTR [edx], eax
  000b9	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 739  : 
; 740  :     for (Index = 1; Index < 512; Index += 1) {

  000bc	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _Index$[ebp], 1
  000c3	83 65 f4 00	 and	 DWORD PTR _Index$[ebp+4], 0
  000c7	eb 12		 jmp	 SHORT $LN6@BlMmInitia
$LN5@BlMmInitia:
  000c9	8b 45 f0	 mov	 eax, DWORD PTR _Index$[ebp]
  000cc	83 c0 01	 add	 eax, 1
  000cf	8b 4d f4	 mov	 ecx, DWORD PTR _Index$[ebp+4]
  000d2	83 d1 00	 adc	 ecx, 0
  000d5	89 45 f0	 mov	 DWORD PTR _Index$[ebp], eax
  000d8	89 4d f4	 mov	 DWORD PTR _Index$[ebp+4], ecx
$LN6@BlMmInitia:
  000db	83 7d f4 00	 cmp	 DWORD PTR _Index$[ebp+4], 0
  000df	77 40		 ja	 SHORT $LN4@BlMmInitia
  000e1	72 09		 jb	 SHORT $LN13@BlMmInitia
  000e3	81 7d f0 00 02
	00 00		 cmp	 DWORD PTR _Index$[ebp], 512 ; 00000200H
  000ea	73 35		 jae	 SHORT $LN4@BlMmInitia
$LN13@BlMmInitia:

; 741  : 
; 742  :         Pte[Index] = (Index << 12) | PAGE_PRESENT | PAGE_WRITEABLE | PAGE_ACCESSED;

  000ec	8b 45 f0	 mov	 eax, DWORD PTR _Index$[ebp]
  000ef	8b 55 f4	 mov	 edx, DWORD PTR _Index$[ebp+4]
  000f2	b1 0c		 mov	 cl, 12			; 0000000cH
  000f4	e8 00 00 00 00	 call	 __allshl
  000f9	8b f0		 mov	 esi, eax
  000fb	8b fa		 mov	 edi, edx
  000fd	83 ce 01	 or	 esi, 1
  00100	83 ce 02	 or	 esi, 2
  00103	83 ce 20	 or	 esi, 32			; 00000020H
  00106	6a 00		 push	 0
  00108	6a 08		 push	 8
  0010a	ff 75 f4	 push	 DWORD PTR _Index$[ebp+4]
  0010d	ff 75 f0	 push	 DWORD PTR _Index$[ebp]
  00110	e8 00 00 00 00	 call	 __allmul
  00115	8b 4d d4	 mov	 ecx, DWORD PTR _Pte$[ebp]
  00118	89 34 01	 mov	 DWORD PTR [ecx+eax], esi
  0011b	89 7c 01 04	 mov	 DWORD PTR [ecx+eax+4], edi

; 743  :     }

  0011f	eb a8		 jmp	 SHORT $LN5@BlMmInitia
$LN4@BlMmInitia:

; 744  : 
; 745  :     for (Index = 1; Index < 2048; Index += 1) {

  00121	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _Index$[ebp], 1
  00128	83 65 f4 00	 and	 DWORD PTR _Index$[ebp+4], 0
  0012c	eb 12		 jmp	 SHORT $LN3@BlMmInitia
$LN2@BlMmInitia:
  0012e	8b 45 f0	 mov	 eax, DWORD PTR _Index$[ebp]
  00131	83 c0 01	 add	 eax, 1
  00134	8b 4d f4	 mov	 ecx, DWORD PTR _Index$[ebp+4]
  00137	83 d1 00	 adc	 ecx, 0
  0013a	89 45 f0	 mov	 DWORD PTR _Index$[ebp], eax
  0013d	89 4d f4	 mov	 DWORD PTR _Index$[ebp+4], ecx
$LN3@BlMmInitia:
  00140	83 7d f4 00	 cmp	 DWORD PTR _Index$[ebp+4], 0
  00144	77 46		 ja	 SHORT $LN1@BlMmInitia
  00146	72 09		 jb	 SHORT $LN14@BlMmInitia
  00148	81 7d f0 00 08
	00 00		 cmp	 DWORD PTR _Index$[ebp], 2048 ; 00000800H
  0014f	73 3b		 jae	 SHORT $LN1@BlMmInitia
$LN14@BlMmInitia:

; 746  : 
; 747  :         Pde[Index] = (Index << 21) | PAGE_PRESENT | PAGE_WRITEABLE | PAGE_ACCESSED | PAGE_2MB;

  00151	8b 45 f0	 mov	 eax, DWORD PTR _Index$[ebp]
  00154	8b 55 f4	 mov	 edx, DWORD PTR _Index$[ebp+4]
  00157	b1 15		 mov	 cl, 21			; 00000015H
  00159	e8 00 00 00 00	 call	 __allshl
  0015e	8b f0		 mov	 esi, eax
  00160	8b fa		 mov	 edi, edx
  00162	83 ce 01	 or	 esi, 1
  00165	83 ce 02	 or	 esi, 2
  00168	83 ce 20	 or	 esi, 32			; 00000020H
  0016b	81 ce 80 00 00
	00		 or	 esi, 128		; 00000080H
  00171	6a 00		 push	 0
  00173	6a 08		 push	 8
  00175	ff 75 f4	 push	 DWORD PTR _Index$[ebp+4]
  00178	ff 75 f0	 push	 DWORD PTR _Index$[ebp]
  0017b	e8 00 00 00 00	 call	 __allmul
  00180	8b 4d e4	 mov	 ecx, DWORD PTR _Pde$[ebp]
  00183	89 34 01	 mov	 DWORD PTR [ecx+eax], esi
  00186	89 7c 01 04	 mov	 DWORD PTR [ecx+eax+4], edi

; 748  :     }

  0018a	eb a2		 jmp	 SHORT $LN2@BlMmInitia
$LN1@BlMmInitia:

; 749  : 
; 750  : #if defined(BOOT_X86)
; 751  : 
; 752  :     BlMmBootCr3 = (ULONG_PTR) PdptBase;

  0018c	8b 45 e8	 mov	 eax, DWORD PTR _PdptBase$[ebp]
  0018f	a3 00 00 00 00	 mov	 DWORD PTR ?BlMmBootCr3@@3KA, eax ; BlMmBootCr3

; 753  : 
; 754  : #elif defined(BOOT_X64)
; 755  : 
; 756  :     BlMmBootCr3 = Pml4tBase;
; 757  : 
; 758  : #endif
; 759  : 
; 760  :     BlMmSetCr3(BlMmBootCr3);

  00194	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BlMmBootCr3@@3KA ; BlMmBootCr3
  0019a	e8 00 00 00 00	 call	 ?BlMmSetCr3@@YIXK@Z	; BlMmSetCr3

; 761  : 
; 762  :     BlGetBeb()->LegacyReturnCr3 = (UINT32) BlMmBootCr3;

  0019f	e8 00 00 00 00	 call	 ?BlGetBeb@@YIPAU_BEB@@XZ ; BlGetBeb
  001a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BlMmBootCr3@@3KA ; BlMmBootCr3
  001aa	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 763  : 
; 764  : #if MM_VERBOSE
; 765  : 
; 766  :     BlRtlPrintf("MM: 4GB identity map [CR3=%p]\n", BlMmBootCr3);
; 767  : 
; 768  : #endif
; 769  : 
; 770  :     return;
; 771  : }

  001ad	5f		 pop	 edi
  001ae	5e		 pop	 esi
  001af	c9		 leave
  001b0	c3		 ret	 0
?BlMmInitializePageTables@@YIXXZ ENDP			; BlMmInitializePageTables
; Function compile flags: /Odsp
; File c:\users\cc\source\repos\singularity-os\base\boot\singldrpc\bl.h
_TEXT	ENDS
;	COMDAT ?BlGetBeb@@YIPAU_BEB@@XZ
_TEXT	SEGMENT
?BlGetBeb@@YIPAU_BEB@@XZ PROC				; BlGetBeb, COMDAT

; 355  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 356  :     return ((PBEB) BEB_BASE);

  00003	b8 00 f0 02 00	 mov	 eax, 192512		; 0002f000H

; 357  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?BlGetBeb@@YIPAU_BEB@@XZ ENDP				; BlGetBeb
_TEXT	ENDS
PUBLIC	?BlMmMapVirtualPage@@YIXPAX0EEE@Z		; BlMmMapVirtualPage
EXTRN	__aullshr:PROC
; Function compile flags: /Odsp
; File c:\users\cc\source\repos\singularity-os\base\boot\singldrpc\blmm.cpp
;	COMDAT ?BlMmMapVirtualPage@@YIXPAX0EEE@Z
_TEXT	SEGMENT
tv219 = -88						; size = 8
tv189 = -80						; size = 8
_PhysicalAddress$ = -72					; size = 4
_VirtualAddress$ = -68					; size = 4
_PtIndex$ = -64						; size = 4
_PtBase$ = -60						; size = 4
_VirtualPageNumber$ = -56				; size = 4
_PdBase$ = -52						; size = 4
_PdpBase$ = -48						; size = 4
_PdpIndex$ = -44					; size = 4
_Entry$ = -40						; size = 8
_PdIndex$ = -28						; size = 4
_LargePageAddress$ = -24				; size = 8
_PhysicalPageNumber$ = -16				; size = 8
_Index$ = -4						; size = 4
_Writeable$ = 8						; size = 1
_Cacheable$ = 12					; size = 1
_WriteThrough$ = 16					; size = 1
?BlMmMapVirtualPage@@YIXPAX0EEE@Z PROC			; BlMmMapVirtualPage, COMDAT
; _VirtualAddress$ = ecx
; _PhysicalAddress$ = edx

; 802  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	56		 push	 esi
  00007	89 55 b8	 mov	 DWORD PTR _PhysicalAddress$[ebp], edx
  0000a	89 4d bc	 mov	 DWORD PTR _VirtualAddress$[ebp], ecx

; 803  :     UINT64 Entry;
; 804  :     UINT32 Index;
; 805  :     UINT64 LargePageAddress;
; 806  :     PUINT64 PdBase;
; 807  :     UINT32 PdIndex;
; 808  :     PUINT64 PdpBase;
; 809  :     UINT32 PdpIndex;
; 810  :     UINT64 PhysicalPageNumber;
; 811  :     PUINT64 PtBase;
; 812  :     UINT32 PtIndex;
; 813  :     ULONG_PTR VirtualPageNumber;
; 814  : 
; 815  :     BLASSERT((((ULONG_PTR) VirtualAddress) & 0xFFF) == 0);

  0000d	8b 45 bc	 mov	 eax, DWORD PTR _VirtualAddress$[ebp]
  00010	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00015	74 0f		 je	 SHORT $LN11@BlMmMapVir
  00017	ba 2f 03 00 00	 mov	 edx, 815		; 0000032fH
  0001c	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_08JOIABOAI@blmm?4cpp?$AA@
  00021	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN11@BlMmMapVir:

; 816  : 
; 817  :     BLASSERT((((ULONG_PTR) PhysicalAddress) & 0xFFF) == 0);

  00026	8b 45 b8	 mov	 eax, DWORD PTR _PhysicalAddress$[ebp]
  00029	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002e	74 0f		 je	 SHORT $LN10@BlMmMapVir
  00030	ba 31 03 00 00	 mov	 edx, 817		; 00000331H
  00035	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_08JOIABOAI@blmm?4cpp?$AA@
  0003a	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN10@BlMmMapVir:

; 818  : 
; 819  : #if defined(BOOT_X64)
; 820  : 
; 821  :     BLASSERT((ULONG_PTR) VirtualAddress < 0x100000000UI64);
; 822  : 
; 823  : #endif
; 824  : 
; 825  :     //
; 826  :     // Compute virtual page number, page directory pointer, page directory, and page table indices.
; 827  :     //
; 828  : 
; 829  :     VirtualPageNumber = ((ULONG_PTR) VirtualAddress) / PAGE_SIZE;

  0003f	8b 45 bc	 mov	 eax, DWORD PTR _VirtualAddress$[ebp]
  00042	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  00045	89 45 c8	 mov	 DWORD PTR _VirtualPageNumber$[ebp], eax

; 830  : 
; 831  :     PdpIndex = (UINT32) ((VirtualPageNumber >> 18) & 0x1FF);

  00048	8b 45 c8	 mov	 eax, DWORD PTR _VirtualPageNumber$[ebp]
  0004b	c1 e8 12	 shr	 eax, 18			; 00000012H
  0004e	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  00053	89 45 d4	 mov	 DWORD PTR _PdpIndex$[ebp], eax

; 832  :     PdIndex = (UINT32) ((VirtualPageNumber >> 9) & 0x1FF);

  00056	8b 45 c8	 mov	 eax, DWORD PTR _VirtualPageNumber$[ebp]
  00059	c1 e8 09	 shr	 eax, 9
  0005c	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  00061	89 45 e4	 mov	 DWORD PTR _PdIndex$[ebp], eax

; 833  :     PtIndex = (UINT32) (VirtualPageNumber & 0x1FF);

  00064	8b 45 c8	 mov	 eax, DWORD PTR _VirtualPageNumber$[ebp]
  00067	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  0006c	89 45 c0	 mov	 DWORD PTR _PtIndex$[ebp], eax

; 834  : 
; 835  :     //
; 836  :     // Look up page directory base address.
; 837  :     //
; 838  : 
; 839  :     PdpBase = &BlMmPdpTable[0].Entry[0];

  0006f	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _PdpBase$[ebp], OFFSET ?BlMmPdpTable@@3PAU_BL_MM_PAGE_TABLE@@A ; BlMmPdpTable

; 840  : 
; 841  :     PdBase = (PUINT64) (ULONG_PTR) (PdpBase[PdpIndex] & (~(0xFFFUI64)));

  00076	8b 45 d4	 mov	 eax, DWORD PTR _PdpIndex$[ebp]
  00079	8b 4d d0	 mov	 ecx, DWORD PTR _PdpBase$[ebp]
  0007c	8b 14 c1	 mov	 edx, DWORD PTR [ecx+eax*8]
  0007f	81 e2 00 f0 ff
	ff		 and	 edx, -4096		; fffff000H
  00085	8b 44 c1 04	 mov	 eax, DWORD PTR [ecx+eax*8+4]
  00089	89 55 cc	 mov	 DWORD PTR _PdBase$[ebp], edx

; 842  : 
; 843  :     //
; 844  :     // If the specified page is currently being mapped with large pages, then split it into 4K mappings.
; 845  :     //
; 846  : 
; 847  :     if ((PdBase[PdIndex] & PAGE_2MB) != 0) {

  0008c	8b 45 e4	 mov	 eax, DWORD PTR _PdIndex$[ebp]
  0008f	8b 4d cc	 mov	 ecx, DWORD PTR _PdBase$[ebp]
  00092	8b 14 c1	 mov	 edx, DWORD PTR [ecx+eax*8]
  00095	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  0009b	8b 44 c1 04	 mov	 eax, DWORD PTR [ecx+eax*8+4]
  0009f	83 e0 00	 and	 eax, 0
  000a2	89 55 b0	 mov	 DWORD PTR tv189[ebp], edx
  000a5	89 45 b4	 mov	 DWORD PTR tv189[ebp+4], eax
  000a8	8b 45 b0	 mov	 eax, DWORD PTR tv189[ebp]
  000ab	0b 45 b4	 or	 eax, DWORD PTR tv189[ebp+4]
  000ae	0f 84 bf 00 00
	00		 je	 $LN9@BlMmMapVir

; 848  : 
; 849  :         PtBase = (PUINT64) (ULONG_PTR) BlMmAllocatePhysicalRegion(PAGE_SIZE, BL_MM_PHYSICAL_REGION_BOOT_LOADER);

  000b4	6a 03		 push	 3
  000b6	5a		 pop	 edx
  000b7	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000bc	e8 00 00 00 00	 call	 ?BlMmAllocatePhysicalRegion@@YI_KKK@Z ; BlMmAllocatePhysicalRegion
  000c1	89 45 c4	 mov	 DWORD PTR _PtBase$[ebp], eax

; 850  : 
; 851  :         LargePageAddress = (PdBase[PdIndex] & (~(0xFFFUI64)));

  000c4	8b 45 e4	 mov	 eax, DWORD PTR _PdIndex$[ebp]
  000c7	8b 4d cc	 mov	 ecx, DWORD PTR _PdBase$[ebp]
  000ca	8b 14 c1	 mov	 edx, DWORD PTR [ecx+eax*8]
  000cd	81 e2 00 f0 ff
	ff		 and	 edx, -4096		; fffff000H
  000d3	8b 44 c1 04	 mov	 eax, DWORD PTR [ecx+eax*8+4]
  000d7	89 55 e8	 mov	 DWORD PTR _LargePageAddress$[ebp], edx
  000da	89 45 ec	 mov	 DWORD PTR _LargePageAddress$[ebp+4], eax

; 852  : 
; 853  :         BLASSERT(((LargePageAddress >> 12) & 0x1FF) == 0);

  000dd	8b 45 e8	 mov	 eax, DWORD PTR _LargePageAddress$[ebp]
  000e0	8b 55 ec	 mov	 edx, DWORD PTR _LargePageAddress$[ebp+4]
  000e3	b1 0c		 mov	 cl, 12			; 0000000cH
  000e5	e8 00 00 00 00	 call	 __aullshr
  000ea	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  000ef	83 e2 00	 and	 edx, 0
  000f2	89 45 a8	 mov	 DWORD PTR tv219[ebp], eax
  000f5	89 55 ac	 mov	 DWORD PTR tv219[ebp+4], edx
  000f8	8b 45 a8	 mov	 eax, DWORD PTR tv219[ebp]
  000fb	0b 45 ac	 or	 eax, DWORD PTR tv219[ebp+4]
  000fe	74 0f		 je	 SHORT $LN8@BlMmMapVir
  00100	ba 55 03 00 00	 mov	 edx, 853		; 00000355H
  00105	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_08JOIABOAI@blmm?4cpp?$AA@
  0010a	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN8@BlMmMapVir:

; 854  : 
; 855  :         //
; 856  :         // Create page table entries to map the region in 4K pages.
; 857  :         //
; 858  : 
; 859  :         for (Index = 0; Index < 512; Index += 1) {

  0010f	83 65 fc 00	 and	 DWORD PTR _Index$[ebp], 0
  00113	eb 07		 jmp	 SHORT $LN7@BlMmMapVir
$LN6@BlMmMapVir:
  00115	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  00118	40		 inc	 eax
  00119	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax
$LN7@BlMmMapVir:
  0011c	81 7d fc 00 02
	00 00		 cmp	 DWORD PTR _Index$[ebp], 512 ; 00000200H
  00123	73 28		 jae	 SHORT $LN5@BlMmMapVir

; 860  : 
; 861  :             PtBase[Index] = (LargePageAddress + (Index * PAGE_SIZE)) | PAGE_PRESENT | PAGE_WRITEABLE | PAGE_ACCESSED;

  00125	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  00128	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  0012b	33 c9		 xor	 ecx, ecx
  0012d	03 45 e8	 add	 eax, DWORD PTR _LargePageAddress$[ebp]
  00130	8b 55 ec	 mov	 edx, DWORD PTR _LargePageAddress$[ebp+4]
  00133	13 d1		 adc	 edx, ecx
  00135	83 c8 01	 or	 eax, 1
  00138	83 c8 02	 or	 eax, 2
  0013b	83 c8 20	 or	 eax, 32			; 00000020H
  0013e	8b 4d fc	 mov	 ecx, DWORD PTR _Index$[ebp]
  00141	8b 75 c4	 mov	 esi, DWORD PTR _PtBase$[ebp]
  00144	89 04 ce	 mov	 DWORD PTR [esi+ecx*8], eax
  00147	89 54 ce 04	 mov	 DWORD PTR [esi+ecx*8+4], edx

; 862  :         }

  0014b	eb c8		 jmp	 SHORT $LN6@BlMmMapVir
$LN5@BlMmMapVir:

; 863  : 
; 864  :         //
; 865  :         // Update page directory entry.
; 866  :         //
; 867  : 
; 868  :         PdBase[PdIndex] = ((UINT64) (ULONG_PTR) PtBase) | PAGE_PRESENT | PAGE_WRITEABLE | PAGE_ACCESSED;

  0014d	8b 45 c4	 mov	 eax, DWORD PTR _PtBase$[ebp]
  00150	33 c9		 xor	 ecx, ecx
  00152	83 c8 01	 or	 eax, 1
  00155	83 c8 02	 or	 eax, 2
  00158	83 c8 20	 or	 eax, 32			; 00000020H
  0015b	8b 55 e4	 mov	 edx, DWORD PTR _PdIndex$[ebp]
  0015e	8b 75 cc	 mov	 esi, DWORD PTR _PdBase$[ebp]
  00161	89 04 d6	 mov	 DWORD PTR [esi+edx*8], eax
  00164	89 4c d6 04	 mov	 DWORD PTR [esi+edx*8+4], ecx

; 869  : 
; 870  :         //
; 871  :         // Flush TLB.
; 872  :         //
; 873  : 
; 874  :         BlMmSetCr3(BlMmBootCr3);

  00168	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BlMmBootCr3@@3KA ; BlMmBootCr3
  0016e	e8 00 00 00 00	 call	 ?BlMmSetCr3@@YIXK@Z	; BlMmSetCr3
$LN9@BlMmMapVir:

; 875  :     }
; 876  : 
; 877  :     //
; 878  :     // Update page mapping.
; 879  :     //
; 880  : 
; 881  :     PtBase = (PUINT64) (ULONG_PTR) (PdBase[PdIndex] & (~(0xFFFUI64)));

  00173	8b 45 e4	 mov	 eax, DWORD PTR _PdIndex$[ebp]
  00176	8b 4d cc	 mov	 ecx, DWORD PTR _PdBase$[ebp]
  00179	8b 14 c1	 mov	 edx, DWORD PTR [ecx+eax*8]
  0017c	81 e2 00 f0 ff
	ff		 and	 edx, -4096		; fffff000H
  00182	8b 44 c1 04	 mov	 eax, DWORD PTR [ecx+eax*8+4]
  00186	89 55 c4	 mov	 DWORD PTR _PtBase$[ebp], edx

; 882  : 
; 883  :     PhysicalPageNumber = ((ULONG_PTR) PhysicalAddress) >> 12;

  00189	8b 45 b8	 mov	 eax, DWORD PTR _PhysicalAddress$[ebp]
  0018c	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  0018f	33 c9		 xor	 ecx, ecx
  00191	89 45 f0	 mov	 DWORD PTR _PhysicalPageNumber$[ebp], eax
  00194	89 4d f4	 mov	 DWORD PTR _PhysicalPageNumber$[ebp+4], ecx

; 884  : 
; 885  :     Entry = (PhysicalPageNumber << 12) | PAGE_PRESENT;

  00197	8b 45 f0	 mov	 eax, DWORD PTR _PhysicalPageNumber$[ebp]
  0019a	8b 55 f4	 mov	 edx, DWORD PTR _PhysicalPageNumber$[ebp+4]
  0019d	b1 0c		 mov	 cl, 12			; 0000000cH
  0019f	e8 00 00 00 00	 call	 __allshl
  001a4	83 c8 01	 or	 eax, 1
  001a7	89 45 d8	 mov	 DWORD PTR _Entry$[ebp], eax
  001aa	89 55 dc	 mov	 DWORD PTR _Entry$[ebp+4], edx

; 886  : 
; 887  :     if (Writeable != FALSE) {

  001ad	0f b6 45 08	 movzx	 eax, BYTE PTR _Writeable$[ebp]
  001b1	85 c0		 test	 eax, eax
  001b3	74 0f		 je	 SHORT $LN4@BlMmMapVir

; 888  : 
; 889  :         Entry |= PAGE_WRITEABLE;

  001b5	8b 45 d8	 mov	 eax, DWORD PTR _Entry$[ebp]
  001b8	83 c8 02	 or	 eax, 2
  001bb	8b 4d dc	 mov	 ecx, DWORD PTR _Entry$[ebp+4]
  001be	89 45 d8	 mov	 DWORD PTR _Entry$[ebp], eax
  001c1	89 4d dc	 mov	 DWORD PTR _Entry$[ebp+4], ecx
$LN4@BlMmMapVir:

; 890  :     }
; 891  : 
; 892  :     if (Cacheable == FALSE) {

  001c4	0f b6 45 0c	 movzx	 eax, BYTE PTR _Cacheable$[ebp]
  001c8	85 c0		 test	 eax, eax
  001ca	75 11		 jne	 SHORT $LN3@BlMmMapVir

; 893  : 
; 894  :         Entry |= PAGE_CACHEDISABLE;

  001cc	8b 45 d8	 mov	 eax, DWORD PTR _Entry$[ebp]
  001cf	83 c8 10	 or	 eax, 16			; 00000010H
  001d2	8b 4d dc	 mov	 ecx, DWORD PTR _Entry$[ebp+4]
  001d5	89 45 d8	 mov	 DWORD PTR _Entry$[ebp], eax
  001d8	89 4d dc	 mov	 DWORD PTR _Entry$[ebp+4], ecx
  001db	eb 17		 jmp	 SHORT $LN2@BlMmMapVir
$LN3@BlMmMapVir:

; 895  : 
; 896  :     } else if (WriteThrough != FALSE) {

  001dd	0f b6 45 10	 movzx	 eax, BYTE PTR _WriteThrough$[ebp]
  001e1	85 c0		 test	 eax, eax
  001e3	74 0f		 je	 SHORT $LN2@BlMmMapVir

; 897  : 
; 898  :         Entry |= PAGE_WRITETHROUGH;

  001e5	8b 45 d8	 mov	 eax, DWORD PTR _Entry$[ebp]
  001e8	83 c8 08	 or	 eax, 8
  001eb	8b 4d dc	 mov	 ecx, DWORD PTR _Entry$[ebp+4]
  001ee	89 45 d8	 mov	 DWORD PTR _Entry$[ebp], eax
  001f1	89 4d dc	 mov	 DWORD PTR _Entry$[ebp+4], ecx
$LN2@BlMmMapVir:

; 899  :     }
; 900  : 
; 901  :     PtBase[PtIndex] = Entry;

  001f4	8b 45 c0	 mov	 eax, DWORD PTR _PtIndex$[ebp]
  001f7	8b 4d c4	 mov	 ecx, DWORD PTR _PtBase$[ebp]
  001fa	8b 55 d8	 mov	 edx, DWORD PTR _Entry$[ebp]
  001fd	89 14 c1	 mov	 DWORD PTR [ecx+eax*8], edx
  00200	8b 55 dc	 mov	 edx, DWORD PTR _Entry$[ebp+4]
  00203	89 54 c1 04	 mov	 DWORD PTR [ecx+eax*8+4], edx

; 902  : 
; 903  :     //
; 904  :     // Flush TLB.
; 905  :     //
; 906  : 
; 907  :     BlMmSetCr3(BlMmBootCr3);

  00207	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BlMmBootCr3@@3KA ; BlMmBootCr3
  0020d	e8 00 00 00 00	 call	 ?BlMmSetCr3@@YIXK@Z	; BlMmSetCr3

; 908  : 
; 909  :     return;
; 910  : }

  00212	5e		 pop	 esi
  00213	c9		 leave
  00214	c2 0c 00	 ret	 12			; 0000000cH
?BlMmMapVirtualPage@@YIXPAX0EEE@Z ENDP			; BlMmMapVirtualPage
_TEXT	ENDS
PUBLIC	?BlMmMapVirtualRange@@YIXPAX0KEEE@Z		; BlMmMapVirtualRange
; Function compile flags: /Odsp
;	COMDAT ?BlMmMapVirtualRange@@YIXPAX0KEEE@Z
_TEXT	SEGMENT
_PhysicalAddress$ = -20					; size = 4
_VirtualAddress$ = -16					; size = 4
_PhysicalNext$ = -12					; size = 4
_VirtualLimit$ = -8					; size = 4
_VirtualNext$ = -4					; size = 4
_Size$ = 8						; size = 4
_Writeable$ = 12					; size = 1
_Cacheable$ = 16					; size = 1
_WriteThrough$ = 20					; size = 1
?BlMmMapVirtualRange@@YIXPAX0KEEE@Z PROC		; BlMmMapVirtualRange, COMDAT
; _VirtualAddress$ = ecx
; _PhysicalAddress$ = edx

; 944  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 55 ec	 mov	 DWORD PTR _PhysicalAddress$[ebp], edx
  00009	89 4d f0	 mov	 DWORD PTR _VirtualAddress$[ebp], ecx

; 945  :     ULONG_PTR PhysicalNext;
; 946  :     ULONG_PTR VirtualLimit;
; 947  :     ULONG_PTR VirtualNext;
; 948  : 
; 949  :     VirtualNext = (ULONG_PTR) VirtualAddress;

  0000c	8b 45 f0	 mov	 eax, DWORD PTR _VirtualAddress$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR _VirtualNext$[ebp], eax

; 950  :     VirtualLimit = VirtualNext + Size;

  00012	8b 45 fc	 mov	 eax, DWORD PTR _VirtualNext$[ebp]
  00015	03 45 08	 add	 eax, DWORD PTR _Size$[ebp]
  00018	89 45 f8	 mov	 DWORD PTR _VirtualLimit$[ebp], eax

; 951  : 
; 952  :     VirtualNext &= (~((ULONG_PTR) 0xFFF));

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _VirtualNext$[ebp]
  0001e	25 00 f0 ff ff	 and	 eax, -4096		; fffff000H
  00023	89 45 fc	 mov	 DWORD PTR _VirtualNext$[ebp], eax

; 953  :     VirtualLimit = ROUND_UP_TO_PAGES(VirtualLimit);

  00026	8b 45 f8	 mov	 eax, DWORD PTR _VirtualLimit$[ebp]
  00029	05 ff 0f 00 00	 add	 eax, 4095		; 00000fffH
  0002e	25 00 f0 ff ff	 and	 eax, -4096		; fffff000H
  00033	89 45 f8	 mov	 DWORD PTR _VirtualLimit$[ebp], eax

; 954  : 
; 955  :     PhysicalNext = (ULONG_PTR) PhysicalAddress;

  00036	8b 45 ec	 mov	 eax, DWORD PTR _PhysicalAddress$[ebp]
  00039	89 45 f4	 mov	 DWORD PTR _PhysicalNext$[ebp], eax

; 956  :     PhysicalNext &= (~((ULONG_PTR) 0xFFF));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR _PhysicalNext$[ebp]
  0003f	25 00 f0 ff ff	 and	 eax, -4096		; fffff000H
  00044	89 45 f4	 mov	 DWORD PTR _PhysicalNext$[ebp], eax
$LN2@BlMmMapVir@2:

; 957  : 
; 958  :     while (VirtualNext < VirtualLimit) {

  00047	8b 45 fc	 mov	 eax, DWORD PTR _VirtualNext$[ebp]
  0004a	3b 45 f8	 cmp	 eax, DWORD PTR _VirtualLimit$[ebp]
  0004d	73 2c		 jae	 SHORT $LN3@BlMmMapVir@2

; 959  : 
; 960  :         BlMmMapVirtualPage((PVOID) VirtualNext,
; 961  :                            (PVOID) PhysicalNext,
; 962  :                            Writeable,
; 963  :                            Cacheable,
; 964  :                            WriteThrough);

  0004f	ff 75 14	 push	 DWORD PTR _WriteThrough$[ebp]
  00052	ff 75 10	 push	 DWORD PTR _Cacheable$[ebp]
  00055	ff 75 0c	 push	 DWORD PTR _Writeable$[ebp]
  00058	8b 55 f4	 mov	 edx, DWORD PTR _PhysicalNext$[ebp]
  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _VirtualNext$[ebp]
  0005e	e8 00 00 00 00	 call	 ?BlMmMapVirtualPage@@YIXPAX0EEE@Z ; BlMmMapVirtualPage

; 965  : 
; 966  :         VirtualNext += PAGE_SIZE;

  00063	8b 45 fc	 mov	 eax, DWORD PTR _VirtualNext$[ebp]
  00066	05 00 10 00 00	 add	 eax, 4096		; 00001000H
  0006b	89 45 fc	 mov	 DWORD PTR _VirtualNext$[ebp], eax

; 967  :         PhysicalNext += PAGE_SIZE;

  0006e	8b 45 f4	 mov	 eax, DWORD PTR _PhysicalNext$[ebp]
  00071	05 00 10 00 00	 add	 eax, 4096		; 00001000H
  00076	89 45 f4	 mov	 DWORD PTR _PhysicalNext$[ebp], eax

; 968  :     }

  00079	eb cc		 jmp	 SHORT $LN2@BlMmMapVir@2
$LN3@BlMmMapVir@2:

; 969  : 
; 970  :     return;
; 971  : }

  0007b	c9		 leave
  0007c	c2 10 00	 ret	 16			; 00000010H
?BlMmMapVirtualRange@@YIXPAX0KEEE@Z ENDP		; BlMmMapVirtualRange
_TEXT	ENDS
PUBLIC	?BlMmInitializeCodeSegment@@YIXPAU_CODE_SEGMENT@@@Z ; BlMmInitializeCodeSegment
; Function compile flags: /Odsp
;	COMDAT ?BlMmInitializeCodeSegment@@YIXPAU_CODE_SEGMENT@@@Z
_TEXT	SEGMENT
_CodeSegment$ = -4					; size = 4
?BlMmInitializeCodeSegment@@YIXPAU_CODE_SEGMENT@@@Z PROC ; BlMmInitializeCodeSegment, COMDAT
; _CodeSegment$ = ecx

; 990  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _CodeSegment$[ebp], ecx

; 991  :     BlRtlZeroMemory(CodeSegment, sizeof(CODE_SEGMENT));

  00007	6a 08		 push	 8
  00009	5a		 pop	 edx
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _CodeSegment$[ebp]
  0000d	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 992  : 
; 993  :     CodeSegment->Accessed = 1;

  00012	8b 45 fc	 mov	 eax, DWORD PTR _CodeSegment$[ebp]
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001a	0d 00 01 00 00	 or	 eax, 256		; 00000100H
  0001f	8b 55 fc	 mov	 edx, DWORD PTR _CodeSegment$[ebp]
  00022	89 0a		 mov	 DWORD PTR [edx], ecx
  00024	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 994  :     CodeSegment->Readable = 1;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _CodeSegment$[ebp]
  0002a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002f	0d 00 02 00 00	 or	 eax, 512		; 00000200H
  00034	8b 55 fc	 mov	 edx, DWORD PTR _CodeSegment$[ebp]
  00037	89 0a		 mov	 DWORD PTR [edx], ecx
  00039	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 995  :     CodeSegment->Code = 1;

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _CodeSegment$[ebp]
  0003f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00041	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00044	0d 00 08 00 00	 or	 eax, 2048		; 00000800H
  00049	8b 55 fc	 mov	 edx, DWORD PTR _CodeSegment$[ebp]
  0004c	89 0a		 mov	 DWORD PTR [edx], ecx
  0004e	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 996  :     CodeSegment->S = 1;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _CodeSegment$[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00059	0d 00 10 00 00	 or	 eax, 4096		; 00001000H
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _CodeSegment$[ebp]
  00061	89 0a		 mov	 DWORD PTR [edx], ecx
  00063	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 997  :     CodeSegment->Present = 1;

  00066	8b 45 fc	 mov	 eax, DWORD PTR _CodeSegment$[ebp]
  00069	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006e	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  00073	8b 55 fc	 mov	 edx, DWORD PTR _CodeSegment$[ebp]
  00076	89 0a		 mov	 DWORD PTR [edx], ecx
  00078	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 998  :     CodeSegment->Long = 1;

  0007b	8b 45 fc	 mov	 eax, DWORD PTR _CodeSegment$[ebp]
  0007e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00080	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00083	0d 00 00 20 00	 or	 eax, 2097152		; 00200000H
  00088	8b 55 fc	 mov	 edx, DWORD PTR _CodeSegment$[ebp]
  0008b	89 0a		 mov	 DWORD PTR [edx], ecx
  0008d	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 999  : 
; 1000 :     return;
; 1001 : }

  00090	c9		 leave
  00091	c3		 ret	 0
?BlMmInitializeCodeSegment@@YIXPAU_CODE_SEGMENT@@@Z ENDP ; BlMmInitializeCodeSegment
_TEXT	ENDS
PUBLIC	?BlMmInitializeDataSegment@@YIXPAU_DATA_SEGMENT@@KK@Z ; BlMmInitializeDataSegment
; Function compile flags: /Odsp
;	COMDAT ?BlMmInitializeDataSegment@@YIXPAU_DATA_SEGMENT@@KK@Z
_TEXT	SEGMENT
_Base$ = -8						; size = 4
_DataSegment$ = -4					; size = 4
_Limit$ = 8						; size = 4
?BlMmInitializeDataSegment@@YIXPAU_DATA_SEGMENT@@KK@Z PROC ; BlMmInitializeDataSegment, COMDAT
; _DataSegment$ = ecx
; _Base$ = edx

; 1026 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	56		 push	 esi
  00006	89 55 f8	 mov	 DWORD PTR _Base$[ebp], edx
  00009	89 4d fc	 mov	 DWORD PTR _DataSegment$[ebp], ecx

; 1027 :     BlRtlZeroMemory(DataSegment, sizeof(DATA_SEGMENT));

  0000c	6a 08		 push	 8
  0000e	5a		 pop	 edx
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _DataSegment$[ebp]
  00012	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 1028 : 
; 1029 :     DataSegment->Accessed = 1;

  00017	8b 45 fc	 mov	 eax, DWORD PTR _DataSegment$[ebp]
  0001a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001f	0d 00 01 00 00	 or	 eax, 256		; 00000100H
  00024	8b 55 fc	 mov	 edx, DWORD PTR _DataSegment$[ebp]
  00027	89 0a		 mov	 DWORD PTR [edx], ecx
  00029	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1030 :     DataSegment->Writable = 1;

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _DataSegment$[ebp]
  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00031	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00034	0d 00 02 00 00	 or	 eax, 512		; 00000200H
  00039	8b 55 fc	 mov	 edx, DWORD PTR _DataSegment$[ebp]
  0003c	89 0a		 mov	 DWORD PTR [edx], ecx
  0003e	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1031 :     DataSegment->S = 1;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _DataSegment$[ebp]
  00044	8b 08		 mov	 ecx, DWORD PTR [eax]
  00046	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00049	0d 00 10 00 00	 or	 eax, 4096		; 00001000H
  0004e	8b 55 fc	 mov	 edx, DWORD PTR _DataSegment$[ebp]
  00051	89 0a		 mov	 DWORD PTR [edx], ecx
  00053	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1032 :     DataSegment->Present = 1;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _DataSegment$[ebp]
  00059	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005e	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  00063	8b 55 fc	 mov	 edx, DWORD PTR _DataSegment$[ebp]
  00066	89 0a		 mov	 DWORD PTR [edx], ecx
  00068	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1033 :     DataSegment->Big = 1;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _DataSegment$[ebp]
  0006e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00070	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00073	0d 00 00 40 00	 or	 eax, 4194304		; 00400000H
  00078	8b 55 fc	 mov	 edx, DWORD PTR _DataSegment$[ebp]
  0007b	89 0a		 mov	 DWORD PTR [edx], ecx
  0007d	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1034 : 
; 1035 :     DataSegment->Base_23_0 = Base & 0xFFFFFF;

  00080	8b 45 f8	 mov	 eax, DWORD PTR _Base$[ebp]
  00083	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00088	33 d2		 xor	 edx, edx
  0008a	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0008f	83 e2 00	 and	 edx, 0
  00092	b1 10		 mov	 cl, 16			; 00000010H
  00094	e8 00 00 00 00	 call	 __allshl
  00099	8b 4d fc	 mov	 ecx, DWORD PTR _DataSegment$[ebp]
  0009c	8b 31		 mov	 esi, DWORD PTR [ecx]
  0009e	81 e6 ff ff 00
	00		 and	 esi, 65535		; 0000ffffH
  000a4	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000a7	81 e1 00 ff ff
	ff		 and	 ecx, -256		; ffffff00H
  000ad	0b f0		 or	 esi, eax
  000af	0b ca		 or	 ecx, edx
  000b1	8b 45 fc	 mov	 eax, DWORD PTR _DataSegment$[ebp]
  000b4	89 30		 mov	 DWORD PTR [eax], esi
  000b6	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1036 :     DataSegment->Base_31_24 = Base >> 24;

  000b9	8b 45 f8	 mov	 eax, DWORD PTR _Base$[ebp]
  000bc	c1 e8 18	 shr	 eax, 24			; 00000018H
  000bf	33 d2		 xor	 edx, edx
  000c1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000c6	83 e2 00	 and	 edx, 0
  000c9	b1 38		 mov	 cl, 56			; 00000038H
  000cb	e8 00 00 00 00	 call	 __allshl
  000d0	8b 4d fc	 mov	 ecx, DWORD PTR _DataSegment$[ebp]
  000d3	8b 31		 mov	 esi, DWORD PTR [ecx]
  000d5	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000d8	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  000de	0b f0		 or	 esi, eax
  000e0	0b ca		 or	 ecx, edx
  000e2	8b 45 fc	 mov	 eax, DWORD PTR _DataSegment$[ebp]
  000e5	89 30		 mov	 DWORD PTR [eax], esi
  000e7	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1037 : 
; 1038 :     if (Limit <= 0xFFFFF) {

  000ea	81 7d 08 ff ff
	0f 00		 cmp	 DWORD PTR _Limit$[ebp], 1048575 ; 000fffffH
  000f1	77 60		 ja	 SHORT $LN2@BlMmInitia@2

; 1039 : 
; 1040 :         DataSegment->Limit_15_0 = Limit & 0xFFFF;

  000f3	8b 45 08	 mov	 eax, DWORD PTR _Limit$[ebp]
  000f6	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000fb	33 c9		 xor	 ecx, ecx
  000fd	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00102	83 e1 00	 and	 ecx, 0
  00105	8b 55 fc	 mov	 edx, DWORD PTR _DataSegment$[ebp]
  00108	8b 32		 mov	 esi, DWORD PTR [edx]
  0010a	81 e6 00 00 ff
	ff		 and	 esi, -65536		; ffff0000H
  00110	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00113	0b f0		 or	 esi, eax
  00115	0b d1		 or	 edx, ecx
  00117	8b 45 fc	 mov	 eax, DWORD PTR _DataSegment$[ebp]
  0011a	89 30		 mov	 DWORD PTR [eax], esi
  0011c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1041 :         DataSegment->Limit_19_16 = (Limit >> 16) & 0xF;

  0011f	8b 45 08	 mov	 eax, DWORD PTR _Limit$[ebp]
  00122	c1 e8 10	 shr	 eax, 16			; 00000010H
  00125	83 e0 0f	 and	 eax, 15			; 0000000fH
  00128	33 d2		 xor	 edx, edx
  0012a	83 e0 0f	 and	 eax, 15			; 0000000fH
  0012d	83 e2 00	 and	 edx, 0
  00130	b1 30		 mov	 cl, 48			; 00000030H
  00132	e8 00 00 00 00	 call	 __allshl
  00137	8b 4d fc	 mov	 ecx, DWORD PTR _DataSegment$[ebp]
  0013a	8b 31		 mov	 esi, DWORD PTR [ecx]
  0013c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0013f	81 e1 ff ff f0
	ff		 and	 ecx, -983041		; fff0ffffH
  00145	0b f0		 or	 esi, eax
  00147	0b ca		 or	 ecx, edx
  00149	8b 45 fc	 mov	 eax, DWORD PTR _DataSegment$[ebp]
  0014c	89 30		 mov	 DWORD PTR [eax], esi
  0014e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1042 : 
; 1043 :     } else {

  00151	eb 76		 jmp	 SHORT $LN3@BlMmInitia@2
$LN2@BlMmInitia@2:

; 1044 : 
; 1045 :         DataSegment->Granularity = 1;

  00153	8b 45 fc	 mov	 eax, DWORD PTR _DataSegment$[ebp]
  00156	8b 08		 mov	 ecx, DWORD PTR [eax]
  00158	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0015b	0d 00 00 80 00	 or	 eax, 8388608		; 00800000H
  00160	8b 55 fc	 mov	 edx, DWORD PTR _DataSegment$[ebp]
  00163	89 0a		 mov	 DWORD PTR [edx], ecx
  00165	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1046 :         DataSegment->Limit_15_0 = (Limit >> 12) & 0xFFFF;

  00168	8b 45 08	 mov	 eax, DWORD PTR _Limit$[ebp]
  0016b	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  0016e	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00173	33 c9		 xor	 ecx, ecx
  00175	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0017a	83 e1 00	 and	 ecx, 0
  0017d	8b 55 fc	 mov	 edx, DWORD PTR _DataSegment$[ebp]
  00180	8b 32		 mov	 esi, DWORD PTR [edx]
  00182	81 e6 00 00 ff
	ff		 and	 esi, -65536		; ffff0000H
  00188	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0018b	0b f0		 or	 esi, eax
  0018d	0b d1		 or	 edx, ecx
  0018f	8b 45 fc	 mov	 eax, DWORD PTR _DataSegment$[ebp]
  00192	89 30		 mov	 DWORD PTR [eax], esi
  00194	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1047 :         DataSegment->Limit_19_16 = (Limit >> 28) & 0xF;

  00197	8b 45 08	 mov	 eax, DWORD PTR _Limit$[ebp]
  0019a	c1 e8 1c	 shr	 eax, 28			; 0000001cH
  0019d	83 e0 0f	 and	 eax, 15			; 0000000fH
  001a0	33 d2		 xor	 edx, edx
  001a2	83 e0 0f	 and	 eax, 15			; 0000000fH
  001a5	83 e2 00	 and	 edx, 0
  001a8	b1 30		 mov	 cl, 48			; 00000030H
  001aa	e8 00 00 00 00	 call	 __allshl
  001af	8b 4d fc	 mov	 ecx, DWORD PTR _DataSegment$[ebp]
  001b2	8b 31		 mov	 esi, DWORD PTR [ecx]
  001b4	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  001b7	81 e1 ff ff f0
	ff		 and	 ecx, -983041		; fff0ffffH
  001bd	0b f0		 or	 esi, eax
  001bf	0b ca		 or	 ecx, edx
  001c1	8b 45 fc	 mov	 eax, DWORD PTR _DataSegment$[ebp]
  001c4	89 30		 mov	 DWORD PTR [eax], esi
  001c6	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@BlMmInitia@2:

; 1048 :     }
; 1049 : 
; 1050 :     return;
; 1051 : }

  001c9	5e		 pop	 esi
  001ca	c9		 leave
  001cb	c2 04 00	 ret	 4
?BlMmInitializeDataSegment@@YIXPAU_DATA_SEGMENT@@KK@Z ENDP ; BlMmInitializeDataSegment
_TEXT	ENDS
PUBLIC	?BlMmInitializeSystemSegment@@YIXPAU_SYSTEM_SEGMENT@@KKK@Z ; BlMmInitializeSystemSegment
; Function compile flags: /Odsp
;	COMDAT ?BlMmInitializeSystemSegment@@YIXPAU_SYSTEM_SEGMENT@@KKK@Z
_TEXT	SEGMENT
_Type$ = -8						; size = 4
_SystemSegment$ = -4					; size = 4
_Base$ = 8						; size = 4
_Limit$ = 12						; size = 4
?BlMmInitializeSystemSegment@@YIXPAU_SYSTEM_SEGMENT@@KKK@Z PROC ; BlMmInitializeSystemSegment, COMDAT
; _SystemSegment$ = ecx
; _Type$ = edx

; 1079 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	56		 push	 esi
  00006	89 55 f8	 mov	 DWORD PTR _Type$[ebp], edx
  00009	89 4d fc	 mov	 DWORD PTR _SystemSegment$[ebp], ecx

; 1080 :     BlRtlZeroMemory(SystemSegment, sizeof(SYSTEM_SEGMENT));

  0000c	6a 08		 push	 8
  0000e	5a		 pop	 edx
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _SystemSegment$[ebp]
  00012	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 1081 : 
; 1082 :     SystemSegment->Type = (Type & 0xF);

  00017	8b 45 f8	 mov	 eax, DWORD PTR _Type$[ebp]
  0001a	83 e0 0f	 and	 eax, 15			; 0000000fH
  0001d	33 d2		 xor	 edx, edx
  0001f	83 e0 0f	 and	 eax, 15			; 0000000fH
  00022	83 e2 00	 and	 edx, 0
  00025	b1 28		 mov	 cl, 40			; 00000028H
  00027	e8 00 00 00 00	 call	 __allshl
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _SystemSegment$[ebp]
  0002f	8b 31		 mov	 esi, DWORD PTR [ecx]
  00031	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00034	81 e1 ff f0 ff
	ff		 and	 ecx, -3841		; fffff0ffH
  0003a	0b f0		 or	 esi, eax
  0003c	0b ca		 or	 ecx, edx
  0003e	8b 45 fc	 mov	 eax, DWORD PTR _SystemSegment$[ebp]
  00041	89 30		 mov	 DWORD PTR [eax], esi
  00043	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1083 :     SystemSegment->Present = 1;

  00046	8b 45 fc	 mov	 eax, DWORD PTR _SystemSegment$[ebp]
  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004e	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  00053	8b 55 fc	 mov	 edx, DWORD PTR _SystemSegment$[ebp]
  00056	89 0a		 mov	 DWORD PTR [edx], ecx
  00058	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1084 : 
; 1085 :     SystemSegment->Base_23_0 = Base & 0xFFFFFF;

  0005b	8b 45 08	 mov	 eax, DWORD PTR _Base$[ebp]
  0005e	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00063	33 d2		 xor	 edx, edx
  00065	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0006a	83 e2 00	 and	 edx, 0
  0006d	b1 10		 mov	 cl, 16			; 00000010H
  0006f	e8 00 00 00 00	 call	 __allshl
  00074	8b 4d fc	 mov	 ecx, DWORD PTR _SystemSegment$[ebp]
  00077	8b 31		 mov	 esi, DWORD PTR [ecx]
  00079	81 e6 ff ff 00
	00		 and	 esi, 65535		; 0000ffffH
  0007f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00082	81 e1 00 ff ff
	ff		 and	 ecx, -256		; ffffff00H
  00088	0b f0		 or	 esi, eax
  0008a	0b ca		 or	 ecx, edx
  0008c	8b 45 fc	 mov	 eax, DWORD PTR _SystemSegment$[ebp]
  0008f	89 30		 mov	 DWORD PTR [eax], esi
  00091	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1086 :     SystemSegment->Base_31_24 = (Base >> 24) & 0xFF;

  00094	8b 45 08	 mov	 eax, DWORD PTR _Base$[ebp]
  00097	c1 e8 18	 shr	 eax, 24			; 00000018H
  0009a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0009f	33 d2		 xor	 edx, edx
  000a1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000a6	83 e2 00	 and	 edx, 0
  000a9	b1 38		 mov	 cl, 56			; 00000038H
  000ab	e8 00 00 00 00	 call	 __allshl
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _SystemSegment$[ebp]
  000b3	8b 31		 mov	 esi, DWORD PTR [ecx]
  000b5	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000b8	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  000be	0b f0		 or	 esi, eax
  000c0	0b ca		 or	 ecx, edx
  000c2	8b 45 fc	 mov	 eax, DWORD PTR _SystemSegment$[ebp]
  000c5	89 30		 mov	 DWORD PTR [eax], esi
  000c7	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1087 : 
; 1088 : #if defined(BOOT_X64)
; 1089 : 
; 1090 :     SystemSegment->Base_63_32 = Base >> 32;
; 1091 : 
; 1092 : #endif
; 1093 : 
; 1094 :     if (Limit <= 0xFFFFF) {

  000ca	81 7d 0c ff ff
	0f 00		 cmp	 DWORD PTR _Limit$[ebp], 1048575 ; 000fffffH
  000d1	77 60		 ja	 SHORT $LN2@BlMmInitia@3

; 1095 : 
; 1096 :         SystemSegment->Limit_15_0 = Limit & 0xFFFF;

  000d3	8b 45 0c	 mov	 eax, DWORD PTR _Limit$[ebp]
  000d6	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000db	33 c9		 xor	 ecx, ecx
  000dd	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000e2	83 e1 00	 and	 ecx, 0
  000e5	8b 55 fc	 mov	 edx, DWORD PTR _SystemSegment$[ebp]
  000e8	8b 32		 mov	 esi, DWORD PTR [edx]
  000ea	81 e6 00 00 ff
	ff		 and	 esi, -65536		; ffff0000H
  000f0	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000f3	0b f0		 or	 esi, eax
  000f5	0b d1		 or	 edx, ecx
  000f7	8b 45 fc	 mov	 eax, DWORD PTR _SystemSegment$[ebp]
  000fa	89 30		 mov	 DWORD PTR [eax], esi
  000fc	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1097 :         SystemSegment->Limit_19_16 = (Limit >> 16) & 0xF;

  000ff	8b 45 0c	 mov	 eax, DWORD PTR _Limit$[ebp]
  00102	c1 e8 10	 shr	 eax, 16			; 00000010H
  00105	83 e0 0f	 and	 eax, 15			; 0000000fH
  00108	33 d2		 xor	 edx, edx
  0010a	83 e0 0f	 and	 eax, 15			; 0000000fH
  0010d	83 e2 00	 and	 edx, 0
  00110	b1 30		 mov	 cl, 48			; 00000030H
  00112	e8 00 00 00 00	 call	 __allshl
  00117	8b 4d fc	 mov	 ecx, DWORD PTR _SystemSegment$[ebp]
  0011a	8b 31		 mov	 esi, DWORD PTR [ecx]
  0011c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0011f	81 e1 ff ff f0
	ff		 and	 ecx, -983041		; fff0ffffH
  00125	0b f0		 or	 esi, eax
  00127	0b ca		 or	 ecx, edx
  00129	8b 45 fc	 mov	 eax, DWORD PTR _SystemSegment$[ebp]
  0012c	89 30		 mov	 DWORD PTR [eax], esi
  0012e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1098 : 
; 1099 :     } else {

  00131	eb 76		 jmp	 SHORT $LN3@BlMmInitia@3
$LN2@BlMmInitia@3:

; 1100 : 
; 1101 :         SystemSegment->Granularity = 1;

  00133	8b 45 fc	 mov	 eax, DWORD PTR _SystemSegment$[ebp]
  00136	8b 08		 mov	 ecx, DWORD PTR [eax]
  00138	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0013b	0d 00 00 80 00	 or	 eax, 8388608		; 00800000H
  00140	8b 55 fc	 mov	 edx, DWORD PTR _SystemSegment$[ebp]
  00143	89 0a		 mov	 DWORD PTR [edx], ecx
  00145	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1102 :         SystemSegment->Limit_15_0 = (Limit >> 12) & 0xFFFF;

  00148	8b 45 0c	 mov	 eax, DWORD PTR _Limit$[ebp]
  0014b	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  0014e	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00153	33 c9		 xor	 ecx, ecx
  00155	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0015a	83 e1 00	 and	 ecx, 0
  0015d	8b 55 fc	 mov	 edx, DWORD PTR _SystemSegment$[ebp]
  00160	8b 32		 mov	 esi, DWORD PTR [edx]
  00162	81 e6 00 00 ff
	ff		 and	 esi, -65536		; ffff0000H
  00168	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0016b	0b f0		 or	 esi, eax
  0016d	0b d1		 or	 edx, ecx
  0016f	8b 45 fc	 mov	 eax, DWORD PTR _SystemSegment$[ebp]
  00172	89 30		 mov	 DWORD PTR [eax], esi
  00174	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1103 :         SystemSegment->Limit_19_16 = (Limit >> 28) & 0xF;

  00177	8b 45 0c	 mov	 eax, DWORD PTR _Limit$[ebp]
  0017a	c1 e8 1c	 shr	 eax, 28			; 0000001cH
  0017d	83 e0 0f	 and	 eax, 15			; 0000000fH
  00180	33 d2		 xor	 edx, edx
  00182	83 e0 0f	 and	 eax, 15			; 0000000fH
  00185	83 e2 00	 and	 edx, 0
  00188	b1 30		 mov	 cl, 48			; 00000030H
  0018a	e8 00 00 00 00	 call	 __allshl
  0018f	8b 4d fc	 mov	 ecx, DWORD PTR _SystemSegment$[ebp]
  00192	8b 31		 mov	 esi, DWORD PTR [ecx]
  00194	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00197	81 e1 ff ff f0
	ff		 and	 ecx, -983041		; fff0ffffH
  0019d	0b f0		 or	 esi, eax
  0019f	0b ca		 or	 ecx, edx
  001a1	8b 45 fc	 mov	 eax, DWORD PTR _SystemSegment$[ebp]
  001a4	89 30		 mov	 DWORD PTR [eax], esi
  001a6	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@BlMmInitia@3:

; 1104 :     }
; 1105 : 
; 1106 :     return;
; 1107 : }

  001a9	5e		 pop	 esi
  001aa	c9		 leave
  001ab	c2 08 00	 ret	 8
?BlMmInitializeSystemSegment@@YIXPAU_SYSTEM_SEGMENT@@KKK@Z ENDP ; BlMmInitializeSystemSegment
_TEXT	ENDS
PUBLIC	?BlMmEnableA20Gate@@YIXXZ			; BlMmEnableA20Gate
EXTRN	?BlRtlWritePort8@@YIXGE@Z:PROC			; BlRtlWritePort8
EXTRN	?BlRtlReadPort8@@YIEG@Z:PROC			; BlRtlReadPort8
; Function compile flags: /Odsp
;	COMDAT ?BlMmEnableA20Gate@@YIXXZ
_TEXT	SEGMENT
?BlMmEnableA20Gate@@YIXXZ PROC				; BlMmEnableA20Gate, COMDAT

; 1123 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$LN10@BlMmEnable:

; 1124 :     BL_KEYBOARD_WRITE_OUTPUT_PORT(BL_KEYBOARD_A20_ENABLE);

  00003	66 b9 64 00	 mov	 cx, 100			; 00000064H
  00007	e8 00 00 00 00	 call	 ?BlRtlReadPort8@@YIEG@Z	; BlRtlReadPort8
  0000c	0f b6 c0	 movzx	 eax, al
  0000f	83 e0 02	 and	 eax, 2
  00012	74 02		 je	 SHORT $LN9@BlMmEnable
  00014	eb ed		 jmp	 SHORT $LN10@BlMmEnable
$LN9@BlMmEnable:
  00016	b2 d1		 mov	 dl, 209			; 000000d1H
  00018	66 b9 64 00	 mov	 cx, 100			; 00000064H
  0001c	e8 00 00 00 00	 call	 ?BlRtlWritePort8@@YIXGE@Z ; BlRtlWritePort8
$LN8@BlMmEnable:
  00021	66 b9 64 00	 mov	 cx, 100			; 00000064H
  00025	e8 00 00 00 00	 call	 ?BlRtlReadPort8@@YIEG@Z	; BlRtlReadPort8
  0002a	0f b6 c0	 movzx	 eax, al
  0002d	83 e0 02	 and	 eax, 2
  00030	74 02		 je	 SHORT $LN7@BlMmEnable
  00032	eb ed		 jmp	 SHORT $LN8@BlMmEnable
$LN7@BlMmEnable:
  00034	b2 df		 mov	 dl, 223			; 000000dfH
  00036	66 b9 60 00	 mov	 cx, 96			; 00000060H
  0003a	e8 00 00 00 00	 call	 ?BlRtlWritePort8@@YIXGE@Z ; BlRtlWritePort8
$LN6@BlMmEnable:
  0003f	66 b9 64 00	 mov	 cx, 100			; 00000064H
  00043	e8 00 00 00 00	 call	 ?BlRtlReadPort8@@YIEG@Z	; BlRtlReadPort8
  00048	0f b6 c0	 movzx	 eax, al
  0004b	83 e0 02	 and	 eax, 2
  0004e	74 02		 je	 SHORT $LN4@BlMmEnable
  00050	eb ed		 jmp	 SHORT $LN6@BlMmEnable
$LN4@BlMmEnable:

; 1125 : 
; 1126 :     BL_KEYBOARD_WRITE_COMMAND(BL_KEYBOARD_COMMAND_PULSE_OUTPUT_PORT);

  00052	66 b9 64 00	 mov	 cx, 100			; 00000064H
  00056	e8 00 00 00 00	 call	 ?BlRtlReadPort8@@YIEG@Z	; BlRtlReadPort8
  0005b	0f b6 c0	 movzx	 eax, al
  0005e	83 e0 02	 and	 eax, 2
  00061	74 02		 je	 SHORT $LN3@BlMmEnable
  00063	eb ed		 jmp	 SHORT $LN4@BlMmEnable
$LN3@BlMmEnable:
  00065	80 ca ff	 or	 dl, 255			; 000000ffH
  00068	66 b9 64 00	 mov	 cx, 100			; 00000064H
  0006c	e8 00 00 00 00	 call	 ?BlRtlWritePort8@@YIXGE@Z ; BlRtlWritePort8
$LN2@BlMmEnable:
  00071	66 b9 64 00	 mov	 cx, 100			; 00000064H
  00075	e8 00 00 00 00	 call	 ?BlRtlReadPort8@@YIEG@Z	; BlRtlReadPort8
  0007a	0f b6 c0	 movzx	 eax, al
  0007d	83 e0 02	 and	 eax, 2
  00080	74 02		 je	 SHORT $LN11@BlMmEnable
  00082	eb ed		 jmp	 SHORT $LN2@BlMmEnable
$LN11@BlMmEnable:

; 1127 : 
; 1128 :     return;
; 1129 : }

  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
?BlMmEnableA20Gate@@YIXXZ ENDP				; BlMmEnableA20Gate
_TEXT	ENDS
PUBLIC	?BlMmGetExtendedBiosDataArea@@YIPAXXZ		; BlMmGetExtendedBiosDataArea
; Function compile flags: /Odsp
;	COMDAT ?BlMmGetExtendedBiosDataArea@@YIPAXXZ
_TEXT	SEGMENT
_Segment$ = -4						; size = 2
?BlMmGetExtendedBiosDataArea@@YIPAXXZ PROC		; BlMmGetExtendedBiosDataArea, COMDAT

; 1149 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1150 :     UINT16 Segment;
; 1151 : 
; 1152 :     Segment = *((PUINT16) (ULONG_PTR) 0x40E);

  00004	66 a1 0e 04 00
	00		 mov	 ax, WORD PTR ds:1038
  0000a	66 89 45 fc	 mov	 WORD PTR _Segment$[ebp], ax

; 1153 : 
; 1154 :     return (PVOID) (((ULONG_PTR) Segment) << 4);

  0000e	0f b7 45 fc	 movzx	 eax, WORD PTR _Segment$[ebp]
  00012	c1 e0 04	 shl	 eax, 4

; 1155 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?BlMmGetExtendedBiosDataArea@@YIPAXXZ ENDP		; BlMmGetExtendedBiosDataArea
_TEXT	ENDS
PUBLIC	?BlMmInitializeSystem@@YIXXZ			; BlMmInitializeSystem
EXTRN	?BlPoolAllocateBlock@@YIPAXK@Z:PROC		; BlPoolAllocateBlock
EXTRN	?BlPoolInitialize@@YIXXZ:PROC			; BlPoolInitialize
EXTRN	?BlSystemMemoryMap@@3U_BL_SMAP@@A:BYTE		; BlSystemMemoryMap
EXTRN	?BlRtlInitializeListHead@@YIXPAU_LIST_ENTRY@@@Z:PROC ; BlRtlInitializeListHead
EXTRN	?BlSmapInitialize@@YIXXZ:PROC			; BlSmapInitialize
EXTRN	?BlMmGetGdtr@@YIXPAU_GDTR@@@Z:PROC		; BlMmGetGdtr
EXTRN	?BlMmGetCr3@@YIKXZ:PROC				; BlMmGetCr3
; Function compile flags: /Odsp
;	COMDAT ?BlMmInitializeSystem@@YIXXZ
_TEXT	SEGMENT
tv255 = -52						; size = 4
tv241 = -48						; size = 8
tv182 = -40						; size = 8
tv164 = -32						; size = 4
tv159 = -28						; size = 4
_Delta$ = -24						; size = 8
_SmapEntry$ = -12					; size = 4
_PhysicalRegion$ = -8					; size = 4
_Index$ = -4						; size = 4
?BlMmInitializeSystem@@YIXXZ PROC			; BlMmInitializeSystem, COMDAT

; 1170 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H

; 1171 :     UINT64 Delta;
; 1172 :     UINT32 Index;
; 1173 :     PBL_MM_PHYSICAL_REGION PhysicalRegion;
; 1174 :     PBL_SMAP_ENTRY SmapEntry;
; 1175 : 
; 1176 : #if !defined(BOOT_PXE)
; 1177 :     //
; 1178 :     // Enable A20 gate.
; 1179 :     //
; 1180 : 
; 1181 :     BlMmEnableA20Gate();

  00006	e8 00 00 00 00	 call	 ?BlMmEnableA20Gate@@YIXXZ ; BlMmEnableA20Gate

; 1182 : #endif
; 1183 : 
; 1184 :     //
; 1185 :     // Get extended BIOS data area.
; 1186 :     //
; 1187 : 
; 1188 :     BlMmExtendedBiosDataArea = BlMmGetExtendedBiosDataArea();

  0000b	e8 00 00 00 00	 call	 ?BlMmGetExtendedBiosDataArea@@YIPAXXZ ; BlMmGetExtendedBiosDataArea
  00010	a3 00 00 00 00	 mov	 DWORD PTR ?BlMmExtendedBiosDataArea@@3PAXA, eax ; BlMmExtendedBiosDataArea

; 1189 : 
; 1190 :     //
; 1191 :     // Get legacy CR3 value;
; 1192 :     //
; 1193 : 
; 1194 :     BlMmLegacyCr3 = BlMmGetCr3();

  00015	e8 00 00 00 00	 call	 ?BlMmGetCr3@@YIKXZ	; BlMmGetCr3
  0001a	a3 00 00 00 00	 mov	 DWORD PTR ?BlMmLegacyCr3@@3KA, eax ; BlMmLegacyCr3

; 1195 : 
; 1196 :     //
; 1197 :     // Get initial GDTR.
; 1198 :     //
; 1199 : 
; 1200 :     BlMmGetGdtr(&BlMmInitialGdtr);

  0001f	b9 00 00 00 00	 mov	 ecx, OFFSET ?BlMmInitialGdtr@@3U_GDTR@@A ; BlMmInitialGdtr
  00024	e8 00 00 00 00	 call	 ?BlMmGetGdtr@@YIXPAU_GDTR@@@Z ; BlMmGetGdtr

; 1201 : 
; 1202 :     //
; 1203 :     // Initialize memory map.
; 1204 :     //
; 1205 : 
; 1206 :     BlSmapInitialize();

  00029	e8 00 00 00 00	 call	 ?BlSmapInitialize@@YIXXZ ; BlSmapInitialize

; 1207 : 
; 1208 :     //
; 1209 :     // Create physical region lookaside.
; 1210 :     //
; 1211 : 
; 1212 :     BlRtlInitializeListHead(&BlMmPhysicalRegionList);

  0002e	b9 00 00 00 00	 mov	 ecx, OFFSET ?BlMmPhysicalRegionList@@3U_LIST_ENTRY@@A ; BlMmPhysicalRegionList
  00033	e8 00 00 00 00	 call	 ?BlRtlInitializeListHead@@YIXPAU_LIST_ENTRY@@@Z ; BlRtlInitializeListHead

; 1213 : 
; 1214 :     BlRtlInitializeListHead(&BlMmPhysicalRegionLookaside.FreeList);

  00038	b9 80 02 00 00	 mov	 ecx, OFFSET ?BlMmPhysicalRegionLookaside@@3U<unnamed-tag>@@A+640
  0003d	e8 00 00 00 00	 call	 ?BlRtlInitializeListHead@@YIXPAU_LIST_ENTRY@@@Z ; BlRtlInitializeListHead

; 1215 : 
; 1216 :     for (Index = 0; Index < (sizeof(BlMmPhysicalRegionLookaside.StaticArray) / sizeof(BlMmPhysicalRegionLookaside.StaticArray[0])); Index += 1) {

  00042	83 65 fc 00	 and	 DWORD PTR _Index$[ebp], 0
  00046	eb 07		 jmp	 SHORT $LN13@BlMmInitia@4
$LN12@BlMmInitia@4:
  00048	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  0004b	40		 inc	 eax
  0004c	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax
$LN13@BlMmInitia@4:
  0004f	83 7d fc 10	 cmp	 DWORD PTR _Index$[ebp], 16 ; 00000010H
  00053	73 18		 jae	 SHORT $LN11@BlMmInitia@4

; 1217 : 
; 1218 :         BlRtlInsertTailList(&BlMmPhysicalRegionLookaside.FreeList, &BlMmPhysicalRegionLookaside.StaticArray[Index].Entry);

  00055	8b 55 fc	 mov	 edx, DWORD PTR _Index$[ebp]
  00058	6b d2 28	 imul	 edx, 40			; 00000028H
  0005b	81 c2 00 00 00
	00		 add	 edx, OFFSET ?BlMmPhysicalRegionLookaside@@3U<unnamed-tag>@@A ; BlMmPhysicalRegionLookaside
  00061	b9 80 02 00 00	 mov	 ecx, OFFSET ?BlMmPhysicalRegionLookaside@@3U<unnamed-tag>@@A+640
  00066	e8 00 00 00 00	 call	 ?BlRtlInsertTailList@@YIXPAU_LIST_ENTRY@@0@Z ; BlRtlInsertTailList

; 1219 :     }

  0006b	eb db		 jmp	 SHORT $LN12@BlMmInitia@4
$LN11@BlMmInitia@4:

; 1220 : 
; 1221 :     //
; 1222 :     // Initialize page tables.
; 1223 :     //
; 1224 : 
; 1225 :     BlMmInitializePageTables();

  0006d	e8 00 00 00 00	 call	 ?BlMmInitializePageTables@@YIXXZ ; BlMmInitializePageTables

; 1226 : 
; 1227 :     //
; 1228 :     // Create reserved BIOS region.
; 1229 :     //
; 1230 : 
; 1231 :     BlMmCreatePhysicalRegion(0,
; 1232 :                              BL_MM_BIOS_SIZE,
; 1233 :                              BL_MM_PHYSICAL_REGION_BIOS);

  00072	6a 00		 push	 0
  00074	68 00 00 10 00	 push	 1048576			; 00100000H
  00079	6a 00		 push	 0
  0007b	6a 00		 push	 0
  0007d	6a 02		 push	 2
  0007f	59		 pop	 ecx
  00080	e8 00 00 00 00	 call	 ?BlMmCreatePhysicalRegion@@YIX_K0K@Z ; BlMmCreatePhysicalRegion

; 1234 : 
; 1235 :     //
; 1236 :     // Create free regions based on SMAP.
; 1237 :     //
; 1238 : 
; 1239 :     for (Index = 0; Index < BlSystemMemoryMap.EntryCount; Index += 1) {

  00085	83 65 fc 00	 and	 DWORD PTR _Index$[ebp], 0
  00089	eb 07		 jmp	 SHORT $LN10@BlMmInitia@4
$LN9@BlMmInitia@4:
  0008b	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  0008e	40		 inc	 eax
  0008f	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax
$LN10@BlMmInitia@4:
  00092	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  00095	3b 05 00 0c 00
	00		 cmp	 eax, DWORD PTR ?BlSystemMemoryMap@@3U_BL_SMAP@@A+3072
  0009b	0f 83 5c 01 00
	00		 jae	 $LN8@BlMmInitia@4

; 1240 : 
; 1241 :         SmapEntry = &BlSystemMemoryMap.Entry[Index];

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  000a4	6b c0 18	 imul	 eax, 24			; 00000018H
  000a7	05 00 00 00 00	 add	 eax, OFFSET ?BlSystemMemoryMap@@3U_BL_SMAP@@A ; BlSystemMemoryMap
  000ac	89 45 f4	 mov	 DWORD PTR _SmapEntry$[ebp], eax

; 1242 : 
; 1243 :         //
; 1244 :         // Don't use any memory below 1MB (BIOS area) and above 2GB (Singularity uses MSB for marking and such).
; 1245 :         //
; 1246 : 
; 1247 :         if ((SmapEntry->Type == BL_SMAP_AVAILABLE) &&
; 1248 :             (SmapEntry->Base >= BL_MM_BIOS_SIZE) &&
; 1249 :             (SmapEntry->Base < 0x80000000UI64)
; 1250 :             ) {

  000af	8b 45 f4	 mov	 eax, DWORD PTR _SmapEntry$[ebp]
  000b2	83 78 10 01	 cmp	 DWORD PTR [eax+16], 1
  000b6	0f 85 3c 01 00
	00		 jne	 $LN7@BlMmInitia@4
  000bc	8b 45 f4	 mov	 eax, DWORD PTR _SmapEntry$[ebp]
  000bf	89 45 e4	 mov	 DWORD PTR tv159[ebp], eax
  000c2	8b 45 e4	 mov	 eax, DWORD PTR tv159[ebp]
  000c5	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000c9	77 0f		 ja	 SHORT $LN16@BlMmInitia@4
  000cb	8b 45 e4	 mov	 eax, DWORD PTR tv159[ebp]
  000ce	81 38 00 00 10
	00		 cmp	 DWORD PTR [eax], 1048576 ; 00100000H
  000d4	0f 82 1e 01 00
	00		 jb	 $LN7@BlMmInitia@4
$LN16@BlMmInitia@4:
  000da	8b 45 f4	 mov	 eax, DWORD PTR _SmapEntry$[ebp]
  000dd	89 45 e0	 mov	 DWORD PTR tv164[ebp], eax
  000e0	8b 45 e0	 mov	 eax, DWORD PTR tv164[ebp]
  000e3	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000e7	0f 87 0b 01 00
	00		 ja	 $LN7@BlMmInitia@4
  000ed	72 0f		 jb	 SHORT $LN17@BlMmInitia@4
  000ef	8b 45 e0	 mov	 eax, DWORD PTR tv164[ebp]
  000f2	81 38 00 00 00
	80		 cmp	 DWORD PTR [eax], -2147483648 ; 80000000H
  000f8	0f 83 fa 00 00
	00		 jae	 $LN7@BlMmInitia@4
$LN17@BlMmInitia@4:

; 1251 : 
; 1252 :             if ((SmapEntry->Base % PAGE_SIZE) != 0) {

  000fe	8b 45 f4	 mov	 eax, DWORD PTR _SmapEntry$[ebp]
  00101	6a 00		 push	 0
  00103	68 00 10 00 00	 push	 4096			; 00001000H
  00108	ff 70 04	 push	 DWORD PTR [eax+4]
  0010b	ff 30		 push	 DWORD PTR [eax]
  0010d	e8 00 00 00 00	 call	 __aullrem
  00112	89 45 d8	 mov	 DWORD PTR tv182[ebp], eax
  00115	89 55 dc	 mov	 DWORD PTR tv182[ebp+4], edx
  00118	8b 45 d8	 mov	 eax, DWORD PTR tv182[ebp]
  0011b	0b 45 dc	 or	 eax, DWORD PTR tv182[ebp+4]
  0011e	74 54		 je	 SHORT $LN6@BlMmInitia@4

; 1253 : 
; 1254 :                 Delta = PAGE_SIZE - (SmapEntry->Base % PAGE_SIZE);

  00120	8b 45 f4	 mov	 eax, DWORD PTR _SmapEntry$[ebp]
  00123	6a 00		 push	 0
  00125	68 00 10 00 00	 push	 4096			; 00001000H
  0012a	ff 70 04	 push	 DWORD PTR [eax+4]
  0012d	ff 30		 push	 DWORD PTR [eax]
  0012f	e8 00 00 00 00	 call	 __aullrem
  00134	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00139	2b c8		 sub	 ecx, eax
  0013b	6a 00		 push	 0
  0013d	58		 pop	 eax
  0013e	1b c2		 sbb	 eax, edx
  00140	89 4d e8	 mov	 DWORD PTR _Delta$[ebp], ecx
  00143	89 45 ec	 mov	 DWORD PTR _Delta$[ebp+4], eax

; 1255 :                 SmapEntry->Base += Delta;

  00146	8b 45 f4	 mov	 eax, DWORD PTR _SmapEntry$[ebp]
  00149	8b 08		 mov	 ecx, DWORD PTR [eax]
  0014b	03 4d e8	 add	 ecx, DWORD PTR _Delta$[ebp]
  0014e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00151	13 45 ec	 adc	 eax, DWORD PTR _Delta$[ebp+4]
  00154	8b 55 f4	 mov	 edx, DWORD PTR _SmapEntry$[ebp]
  00157	89 0a		 mov	 DWORD PTR [edx], ecx
  00159	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1256 :                 SmapEntry->Size -= Delta;

  0015c	8b 45 f4	 mov	 eax, DWORD PTR _SmapEntry$[ebp]
  0015f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00162	2b 4d e8	 sub	 ecx, DWORD PTR _Delta$[ebp]
  00165	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00168	1b 45 ec	 sbb	 eax, DWORD PTR _Delta$[ebp+4]
  0016b	8b 55 f4	 mov	 edx, DWORD PTR _SmapEntry$[ebp]
  0016e	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00171	89 42 0c	 mov	 DWORD PTR [edx+12], eax
$LN6@BlMmInitia@4:

; 1257 :             }
; 1258 : 
; 1259 :             SmapEntry->Size &= (~(0xFFFUI64));

  00174	8b 45 f4	 mov	 eax, DWORD PTR _SmapEntry$[ebp]
  00177	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0017a	81 e1 00 f0 ff
	ff		 and	 ecx, -4096		; fffff000H
  00180	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00183	8b 55 f4	 mov	 edx, DWORD PTR _SmapEntry$[ebp]
  00186	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00189	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 1260 : 
; 1261 :             if ((SmapEntry->Base + SmapEntry->Size) > 0x80000000UI64) {

  0018c	8b 45 f4	 mov	 eax, DWORD PTR _SmapEntry$[ebp]
  0018f	8b 4d f4	 mov	 ecx, DWORD PTR _SmapEntry$[ebp]
  00192	8b 10		 mov	 edx, DWORD PTR [eax]
  00194	03 51 08	 add	 edx, DWORD PTR [ecx+8]
  00197	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019a	13 41 0c	 adc	 eax, DWORD PTR [ecx+12]
  0019d	89 55 d0	 mov	 DWORD PTR tv241[ebp], edx
  001a0	89 45 d4	 mov	 DWORD PTR tv241[ebp+4], eax
  001a3	75 09		 jne	 SHORT $LN18@BlMmInitia@4
  001a5	81 7d d0 00 00
	00 80		 cmp	 DWORD PTR tv241[ebp], -2147483648 ; 80000000H
  001ac	76 19		 jbe	 SHORT $LN5@BlMmInitia@4
$LN18@BlMmInitia@4:

; 1262 : 
; 1263 :                 SmapEntry->Size = 0x80000000UI64 - SmapEntry->Base;

  001ae	8b 45 f4	 mov	 eax, DWORD PTR _SmapEntry$[ebp]
  001b1	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  001b6	2b 08		 sub	 ecx, DWORD PTR [eax]
  001b8	6a 00		 push	 0
  001ba	5a		 pop	 edx
  001bb	1b 50 04	 sbb	 edx, DWORD PTR [eax+4]
  001be	8b 45 f4	 mov	 eax, DWORD PTR _SmapEntry$[ebp]
  001c1	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  001c4	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$LN5@BlMmInitia@4:

; 1264 :             }
; 1265 : 
; 1266 :             if (SmapEntry->Size > 0) {

  001c7	8b 45 f4	 mov	 eax, DWORD PTR _SmapEntry$[ebp]
  001ca	89 45 cc	 mov	 DWORD PTR tv255[ebp], eax
  001cd	8b 45 cc	 mov	 eax, DWORD PTR tv255[ebp]
  001d0	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  001d4	77 09		 ja	 SHORT $LN19@BlMmInitia@4
  001d6	8b 45 cc	 mov	 eax, DWORD PTR tv255[ebp]
  001d9	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  001dd	76 19		 jbe	 SHORT $LN7@BlMmInitia@4
$LN19@BlMmInitia@4:

; 1267 : 
; 1268 :                 BlMmCreatePhysicalRegion(SmapEntry->Base,
; 1269 :                                          SmapEntry->Size,
; 1270 :                                          BL_MM_PHYSICAL_REGION_FREE);

  001df	8b 45 f4	 mov	 eax, DWORD PTR _SmapEntry$[ebp]
  001e2	ff 70 0c	 push	 DWORD PTR [eax+12]
  001e5	ff 70 08	 push	 DWORD PTR [eax+8]
  001e8	8b 45 f4	 mov	 eax, DWORD PTR _SmapEntry$[ebp]
  001eb	ff 70 04	 push	 DWORD PTR [eax+4]
  001ee	ff 30		 push	 DWORD PTR [eax]
  001f0	33 c9		 xor	 ecx, ecx
  001f2	41		 inc	 ecx
  001f3	e8 00 00 00 00	 call	 ?BlMmCreatePhysicalRegion@@YIX_K0K@Z ; BlMmCreatePhysicalRegion
$LN7@BlMmInitia@4:

; 1271 :             }
; 1272 :         }
; 1273 :     }

  001f8	e9 8e fe ff ff	 jmp	 $LN9@BlMmInitia@4
$LN8@BlMmInitia@4:

; 1274 : 
; 1275 :     //
; 1276 :     // Initialize pool.
; 1277 :     //
; 1278 : 
; 1279 :     BlPoolInitialize();

  001fd	e8 00 00 00 00	 call	 ?BlPoolInitialize@@YIXXZ ; BlPoolInitialize

; 1280 : 
; 1281 :     //
; 1282 :     // Add more entries to the physical region lookaside.
; 1283 :     //
; 1284 : 
; 1285 :     for (Index = 0; Index < 256; Index += 1) {

  00202	83 65 fc 00	 and	 DWORD PTR _Index$[ebp], 0
  00206	eb 07		 jmp	 SHORT $LN3@BlMmInitia@4
$LN2@BlMmInitia@4:
  00208	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  0020b	40		 inc	 eax
  0020c	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax
$LN3@BlMmInitia@4:
  0020f	81 7d fc 00 01
	00 00		 cmp	 DWORD PTR _Index$[ebp], 256 ; 00000100H
  00216	73 1a		 jae	 SHORT $LN14@BlMmInitia@4

; 1286 : 
; 1287 :         PhysicalRegion = (PBL_MM_PHYSICAL_REGION)
; 1288 :             BlPoolAllocateBlock(sizeof(BL_MM_PHYSICAL_REGION));

  00218	6a 28		 push	 40			; 00000028H
  0021a	59		 pop	 ecx
  0021b	e8 00 00 00 00	 call	 ?BlPoolAllocateBlock@@YIPAXK@Z ; BlPoolAllocateBlock
  00220	89 45 f8	 mov	 DWORD PTR _PhysicalRegion$[ebp], eax

; 1289 : 
; 1290 :         BlRtlInsertTailList(&BlMmPhysicalRegionLookaside.FreeList, &PhysicalRegion->Entry);

  00223	8b 55 f8	 mov	 edx, DWORD PTR _PhysicalRegion$[ebp]
  00226	b9 80 02 00 00	 mov	 ecx, OFFSET ?BlMmPhysicalRegionLookaside@@3U<unnamed-tag>@@A+640
  0022b	e8 00 00 00 00	 call	 ?BlRtlInsertTailList@@YIXPAU_LIST_ENTRY@@0@Z ; BlRtlInsertTailList

; 1291 :     }

  00230	eb d6		 jmp	 SHORT $LN2@BlMmInitia@4
$LN14@BlMmInitia@4:

; 1292 : 
; 1293 :     return;
; 1294 : }

  00232	c9		 leave
  00233	c3		 ret	 0
?BlMmInitializeSystem@@YIXXZ ENDP			; BlMmInitializeSystem
_TEXT	ENDS
END
