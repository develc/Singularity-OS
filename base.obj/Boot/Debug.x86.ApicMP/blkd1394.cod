; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	C:\Users\cc\source\repos\Singularity-OS\base\Boot\SingLdrPc\blkd1394.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
_Kd1394Data DD	01H DUP (?)
_KdRegisters DD	01H DUP (?)
_BSS	ENDS
PUBLIC	?BlKd1394StallExecution@@YIKK@Z			; BlKd1394StallExecution
EXTRN	?BlKdSpin@@YIXXZ:PROC				; BlKdSpin
; Function compile flags: /Odsp
; File c:\users\cc\source\repos\singularity-os\base\boot\singldrpc\blkd1394.cpp
;	COMDAT ?BlKd1394StallExecution@@YIKK@Z
_TEXT	SEGMENT
_LoopCount$ = -16					; size = 4
_k$ = -12						; size = 4
_b$ = -8						; size = 4
_i$ = -4						; size = 4
?BlKd1394StallExecution@@YIKK@Z PROC			; BlKd1394StallExecution, COMDAT
; _LoopCount$ = ecx

; 145  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _LoopCount$[ebp], ecx

; 146  :     volatile UINT32 b;
; 147  :     volatile UINT32 k;
; 148  :     volatile UINT32 i;
; 149  : 
; 150  :     b = 1;

  00009	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _b$[ebp], 1

; 151  : 
; 152  :     for (k = 0; k < LoopCount; k++) {

  00010	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  00017	eb 07		 jmp	 SHORT $LN6@BlKd1394St
$LN5@BlKd1394St:
  00019	8b 45 f4	 mov	 eax, DWORD PTR _k$[ebp]
  0001c	40		 inc	 eax
  0001d	89 45 f4	 mov	 DWORD PTR _k$[ebp], eax
$LN6@BlKd1394St:
  00020	8b 45 f4	 mov	 eax, DWORD PTR _k$[ebp]
  00023	3b 45 f0	 cmp	 eax, DWORD PTR _LoopCount$[ebp]
  00026	73 33		 jae	 SHORT $LN4@BlKd1394St

; 153  : 
; 154  :         BlKdSpin();

  00028	e8 00 00 00 00	 call	 ?BlKdSpin@@YIXXZ	; BlKdSpin

; 155  : 
; 156  :         for (i = 1; i < 10000; i++) {

  0002d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00034	eb 07		 jmp	 SHORT $LN3@BlKd1394St
$LN2@BlKd1394St:
  00036	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00039	40		 inc	 eax
  0003a	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN3@BlKd1394St:
  0003d	81 7d fc 10 27
	00 00		 cmp	 DWORD PTR _i$[ebp], 10000 ; 00002710H
  00044	73 13		 jae	 SHORT $LN1@BlKd1394St

; 157  : 
; 158  :             b = b * (i>>k);

  00046	8a 4d f4	 mov	 cl, BYTE PTR _k$[ebp]
  00049	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0004c	d3 e8		 shr	 eax, cl
  0004e	8b 4d f8	 mov	 ecx, DWORD PTR _b$[ebp]
  00051	0f af c8	 imul	 ecx, eax
  00054	89 4d f8	 mov	 DWORD PTR _b$[ebp], ecx

; 159  :         }

  00057	eb dd		 jmp	 SHORT $LN2@BlKd1394St
$LN1@BlKd1394St:

; 160  :     }

  00059	eb be		 jmp	 SHORT $LN5@BlKd1394St
$LN4@BlKd1394St:

; 161  :     return b;

  0005b	8b 45 f8	 mov	 eax, DWORD PTR _b$[ebp]

; 162  : }

  0005e	c9		 leave
  0005f	c3		 ret	 0
?BlKd1394StallExecution@@YIKK@Z ENDP			; BlKd1394StallExecution
_TEXT	ENDS
PUBLIC	?BlKd1394ByteSwap@@YIKK@Z			; BlKd1394ByteSwap
; Function compile flags: /Odsp
;	COMDAT ?BlKd1394ByteSwap@@YIKK@Z
_TEXT	SEGMENT
_Source$ = -4						; size = 4
?BlKd1394ByteSwap@@YIKK@Z PROC				; BlKd1394ByteSwap, COMDAT
; _Source$ = ecx

; 185  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _Source$[ebp], ecx

; 186  :     return (((Source)              << (8 * 3)) |
; 187  :             ((Source & 0x0000FF00) << (8 * 1)) |
; 188  :             ((Source & 0x00FF0000) >> (8 * 1)) |
; 189  :             ((Source)              >> (8 * 3)));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _Source$[ebp]
  0000a	c1 e0 18	 shl	 eax, 24			; 00000018H
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _Source$[ebp]
  00010	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00016	c1 e1 08	 shl	 ecx, 8
  00019	0b c1		 or	 eax, ecx
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _Source$[ebp]
  0001e	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00024	c1 e9 08	 shr	 ecx, 8
  00027	0b c1		 or	 eax, ecx
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _Source$[ebp]
  0002c	c1 e9 18	 shr	 ecx, 24			; 00000018H
  0002f	0b c1		 or	 eax, ecx

; 190  : }

  00031	c9		 leave
  00032	c3		 ret	 0
?BlKd1394ByteSwap@@YIKK@Z ENDP				; BlKd1394ByteSwap
_TEXT	ENDS
PUBLIC	?BlKd1394Crc16@@YIKKK@Z				; BlKd1394Crc16
; Function compile flags: /Odsp
;	COMDAT ?BlKd1394Crc16@@YIKKK@Z
_TEXT	SEGMENT
_Check$ = -20						; size = 4
_Data$ = -16						; size = 4
_Sum$4057 = -12						; size = 4
_Next$ = -8						; size = 4
_Shift$ = -4						; size = 4
?BlKd1394Crc16@@YIKKK@Z PROC				; BlKd1394Crc16, COMDAT
; _Data$ = ecx
; _Check$ = edx

; 217  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 55 ec	 mov	 DWORD PTR _Check$[ebp], edx
  00009	89 4d f0	 mov	 DWORD PTR _Data$[ebp], ecx

; 218  :     UINT32 Next = Check;

  0000c	8b 45 ec	 mov	 eax, DWORD PTR _Check$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR _Next$[ebp], eax

; 219  :     INT32 Shift;
; 220  : 
; 221  :     for (Shift = 28; Shift >= 0; Shift -= 4) {

  00012	c7 45 fc 1c 00
	00 00		 mov	 DWORD PTR _Shift$[ebp], 28 ; 0000001cH
  00019	eb 09		 jmp	 SHORT $LN3@BlKd1394Cr
$LN2@BlKd1394Cr:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _Shift$[ebp]
  0001e	83 e8 04	 sub	 eax, 4
  00021	89 45 fc	 mov	 DWORD PTR _Shift$[ebp], eax
$LN3@BlKd1394Cr:
  00024	83 7d fc 00	 cmp	 DWORD PTR _Shift$[ebp], 0
  00028	7c 34		 jl	 SHORT $LN1@BlKd1394Cr

; 222  :         UINT32 Sum;
; 223  : 
; 224  :         Sum = ((Next >> 12) ^ (Data >> Shift)) & 0xf;

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _Next$[ebp]
  0002d	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  00030	8b 55 f0	 mov	 edx, DWORD PTR _Data$[ebp]
  00033	8b 4d fc	 mov	 ecx, DWORD PTR _Shift$[ebp]
  00036	d3 ea		 shr	 edx, cl
  00038	33 c2		 xor	 eax, edx
  0003a	83 e0 0f	 and	 eax, 15			; 0000000fH
  0003d	89 45 f4	 mov	 DWORD PTR _Sum$4057[ebp], eax

; 225  :         Next = (Next << 4) ^ (Sum << 12) ^ (Sum << 5) ^ (Sum);

  00040	8b 45 f8	 mov	 eax, DWORD PTR _Next$[ebp]
  00043	c1 e0 04	 shl	 eax, 4
  00046	8b 4d f4	 mov	 ecx, DWORD PTR _Sum$4057[ebp]
  00049	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  0004c	33 c1		 xor	 eax, ecx
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR _Sum$4057[ebp]
  00051	c1 e1 05	 shl	 ecx, 5
  00054	33 c1		 xor	 eax, ecx
  00056	33 45 f4	 xor	 eax, DWORD PTR _Sum$4057[ebp]
  00059	89 45 f8	 mov	 DWORD PTR _Next$[ebp], eax

; 226  :     }

  0005c	eb bd		 jmp	 SHORT $LN2@BlKd1394Cr
$LN1@BlKd1394Cr:

; 227  :     return (Next & 0xFFFF);

  0005e	8b 45 f8	 mov	 eax, DWORD PTR _Next$[ebp]
  00061	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH

; 228  : }

  00066	c9		 leave
  00067	c3		 ret	 0
?BlKd1394Crc16@@YIKKK@Z ENDP				; BlKd1394Crc16
_TEXT	ENDS
PUBLIC	?BlKd1394CalculateCrc@@YIGPAKK@Z		; BlKd1394CalculateCrc
; Function compile flags: /Odsp
;	COMDAT ?BlKd1394CalculateCrc@@YIGPAKK@Z
_TEXT	SEGMENT
_Length$ = -16						; size = 4
_Quadlet$ = -12						; size = 4
_Temp$ = -8						; size = 4
_Index$ = -4						; size = 4
?BlKd1394CalculateCrc@@YIGPAKK@Z PROC			; BlKd1394CalculateCrc, COMDAT
; _Quadlet$ = ecx
; _Length$ = edx

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 55 f0	 mov	 DWORD PTR _Length$[ebp], edx
  00009	89 4d f4	 mov	 DWORD PTR _Quadlet$[ebp], ecx

; 255  :     UINT32 Temp = 0;

  0000c	83 65 f8 00	 and	 DWORD PTR _Temp$[ebp], 0

; 256  :     UINT32 Index;
; 257  : 
; 258  :     Temp = 0;

  00010	83 65 f8 00	 and	 DWORD PTR _Temp$[ebp], 0

; 259  : 
; 260  :     for (Index = 0; Index < Length; Index++) {

  00014	83 65 fc 00	 and	 DWORD PTR _Index$[ebp], 0
  00018	eb 07		 jmp	 SHORT $LN3@BlKd1394Ca
$LN2@BlKd1394Ca:
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  0001d	40		 inc	 eax
  0001e	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax
$LN3@BlKd1394Ca:
  00021	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  00024	3b 45 f0	 cmp	 eax, DWORD PTR _Length$[ebp]
  00027	73 16		 jae	 SHORT $LN1@BlKd1394Ca

; 261  : 
; 262  :         Temp = BlKd1394Crc16(Quadlet[Index], Temp);

  00029	8b 55 f8	 mov	 edx, DWORD PTR _Temp$[ebp]
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  0002f	8b 4d f4	 mov	 ecx, DWORD PTR _Quadlet$[ebp]
  00032	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00035	e8 00 00 00 00	 call	 ?BlKd1394Crc16@@YIKKK@Z	; BlKd1394Crc16
  0003a	89 45 f8	 mov	 DWORD PTR _Temp$[ebp], eax

; 263  :     }

  0003d	eb db		 jmp	 SHORT $LN2@BlKd1394Ca
$LN1@BlKd1394Ca:

; 264  : 
; 265  :     return (UINT16)Temp;

  0003f	66 8b 45 f8	 mov	 ax, WORD PTR _Temp$[ebp]

; 266  : }

  00043	c9		 leave
  00044	c3		 ret	 0
?BlKd1394CalculateCrc@@YIGPAKK@Z ENDP			; BlKd1394CalculateCrc
_TEXT	ENDS
PUBLIC	?BlKd1394InitHardware@@YIEGPAX@Z		; BlKd1394InitHardware
EXTRN	?BlRtlZeroMemory@@YIXPAXK@Z:PROC		; BlRtlZeroMemory
EXTRN	?BlSingularityOhci1394Buffer@@3PAEA:BYTE	; BlSingularityOhci1394Buffer
; Function compile flags: /Odsp
;	COMDAT ?BlKd1394InitHardware@@YIEGPAX@Z
_TEXT	SEGMENT
tv185 = -62						; size = 2
_IoRegion$ = -60					; size = 4
_Channel$ = -56						; size = 2
_Data$ = -49						; size = 1
_retry$ = -48						; size = 4
_LinkControl$ = -44					; size = 4
_DirInfo$ = -40						; size = 4
_ulVersion$ = -36					; size = 4
_PhyControl$ = -32					; size = 4
_Registers$ = -28					; size = 4
_ConfigRomHeader$ = -24					; size = 4
_HCControl$ = -20					; size = 4
_NodeId$ = -16						; size = 4
_MajorVersion$ = -9					; size = 1
_BusOptions$ = -8					; size = 4
_CromEntry$ = -4					; size = 4
?BlKd1394InitHardware@@YIEGPAX@Z PROC			; BlKd1394InitHardware, COMDAT
; _Channel$ = cx
; _IoRegion$ = edx

; 292  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	89 55 c4	 mov	 DWORD PTR _IoRegion$[ebp], edx
  00009	66 89 4d c8	 mov	 WORD PTR _Channel$[ebp], cx

; 293  :     UINT32 ulVersion;
; 294  :     UINT8 MajorVersion;
; 295  :     HC_CONTROL_REGISTER HCControl;
; 296  :     UINT32 retry;
; 297  :     LINK_CONTROL_REGISTER LinkControl;
; 298  :     NODE_ID_REGISTER NodeId;
; 299  :     BUS_OPTIONS_REGISTER BusOptions;
; 300  :     CONFIG_ROM_INFO ConfigRomHeader;
; 301  :     IMMEDIATE_ENTRY CromEntry;
; 302  :     DIRECTORY_INFO DirInfo;
; 303  :     PHY_CONTROL_REGISTER PhyControl;
; 304  :     UINT8 Data;
; 305  :     volatile OHCI_REGISTER_MAP * Registers;
; 306  : 
; 307  : #if KD_VERBOSE
; 308  : 
; 309  :     BlVideoPrintf("1394: IoRegion: %p\n", IoRegion);
; 310  : 
; 311  : #endif
; 312  : 
; 313  :     //
; 314  :     // Note: Kd1394Data must be in the low 32-bits of address space due to
; 315  :     //       limits on valid 1394 DMA addresses.  It must also be contiguous.
; 316  :     //       It must be in the low 24-bits of address space to statisfy KD.
; 317  :     //
; 318  : 
; 319  :     Kd1394Data = (DEBUG_1394_DATA *) BlSingularityOhci1394Buffer;

  0000d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Kd1394Data, OFFSET ?BlSingularityOhci1394Buffer@@3PAEA ; BlSingularityOhci1394Buffer

; 320  :     BlRtlZeroMemory(Kd1394Data, sizeof(*Kd1394Data));

  00017	ba 00 24 00 00	 mov	 edx, 9216		; 00002400H
  0001c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  00022	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 321  : 
; 322  :     //
; 323  :     // Get our base address.
; 324  :     //
; 325  : 
; 326  :     Registers = (volatile OHCI_REGISTER_MAP *)IoRegion;

  00027	8b 45 c4	 mov	 eax, DWORD PTR _IoRegion$[ebp]
  0002a	89 45 e4	 mov	 DWORD PTR _Registers$[ebp], eax

; 327  : 
; 328  :     //
; 329  :     // Initialize our config info for host debugger to read.
; 330  :     //
; 331  : 
; 332  :     Kd1394Data->Config.Tag = DEBUG_1394_CONFIG_TAG;

  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  00032	c7 80 e0 03 00
	00 ba ba ba ba	 mov	 DWORD PTR [eax+992], -1162167622 ; babababaH

; 333  :     Kd1394Data->Config.MajorVersion = DEBUG_1394_MAJOR_VERSION;

  0003c	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  00041	66 c7 80 e4 03
	00 00 01 00	 mov	 WORD PTR [eax+996], 1

; 334  :     Kd1394Data->Config.MinorVersion = DEBUG_1394_MINOR_VERSION;

  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  0004f	66 83 a0 e6 03
	00 00 00	 and	 WORD PTR [eax+998], 0

; 335  :     Kd1394Data->Config.Id = Channel;

  00057	0f b7 45 c8	 movzx	 eax, WORD PTR _Channel$[ebp]
  0005b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  00061	89 81 e8 03 00
	00		 mov	 DWORD PTR [ecx+1000], eax

; 336  :     Kd1394Data->Config.BusPresent = FALSE;

  00067	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  0006c	83 a0 ec 03 00
	00 00		 and	 DWORD PTR [eax+1004], 0

; 337  :     Kd1394Data->Config.SendPacket = (UINT64) &Kd1394Data->SendPacket;

  00073	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  00078	05 00 04 00 00	 add	 eax, 1024		; 00000400H
  0007d	99		 cdq
  0007e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  00084	89 81 f0 03 00
	00		 mov	 DWORD PTR [ecx+1008], eax
  0008a	89 91 f4 03 00
	00		 mov	 DWORD PTR [ecx+1012], edx

; 338  :     Kd1394Data->Config.ReceivePacket = (UINT64) &Kd1394Data->ReceivePacket;

  00090	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  00095	05 00 14 00 00	 add	 eax, 5120		; 00001400H
  0009a	99		 cdq
  0009b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  000a1	89 81 f8 03 00
	00		 mov	 DWORD PTR [ecx+1016], eax
  000a7	89 91 fc 03 00
	00		 mov	 DWORD PTR [ecx+1020], edx

; 339  : 
; 340  :     //
; 341  :     // Get the transport version.
; 342  :     //
; 343  : 
; 344  :     ulVersion = Registers->Version.all;

  000ad	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  000b0	8b 00		 mov	 eax, DWORD PTR [eax]
  000b2	89 45 dc	 mov	 DWORD PTR _ulVersion$[ebp], eax

; 345  :     MajorVersion = (UINT8)(ulVersion >> 16);

  000b5	8b 45 dc	 mov	 eax, DWORD PTR _ulVersion$[ebp]
  000b8	c1 e8 10	 shr	 eax, 16			; 00000010H
  000bb	88 45 f7	 mov	 BYTE PTR _MajorVersion$[ebp], al

; 346  : 
; 347  :     //
; 348  :     // Make sure we have a valid version.
; 349  :     //
; 350  : 
; 351  :     if (MajorVersion != 1) { // INVESTIGATE

  000be	0f b6 45 f7	 movzx	 eax, BYTE PTR _MajorVersion$[ebp]
  000c2	83 f8 01	 cmp	 eax, 1
  000c5	74 07		 je	 SHORT $LN16@BlKd1394In

; 352  : 
; 353  : #if KD_VERBOSE
; 354  : 
; 355  :         BlVideoPrintf("1394: MajorVersion != 1\n");
; 356  : 
; 357  : #endif
; 358  : 
; 359  :         return FALSE;

  000c7	32 c0		 xor	 al, al
  000c9	e9 23 04 00 00	 jmp	 $LN17@BlKd1394In
$LN16@BlKd1394In:

; 360  :     }
; 361  : 
; 362  :     //
; 363  :     // Soft reset to initialize the controller.
; 364  :     //
; 365  : 
; 366  :     HCControl.all = 0;

  000ce	83 65 ec 00	 and	 DWORD PTR _HCControl$[ebp], 0

; 367  :     HCControl.SoftReset = TRUE;

  000d2	8b 45 ec	 mov	 eax, DWORD PTR _HCControl$[ebp]
  000d5	0d 00 00 01 00	 or	 eax, 65536		; 00010000H
  000da	89 45 ec	 mov	 DWORD PTR _HCControl$[ebp], eax

; 368  :     Registers->HCControlSet.all = HCControl.all;

  000dd	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  000e0	8b 4d ec	 mov	 ecx, DWORD PTR _HCControl$[ebp]
  000e3	89 48 50	 mov	 DWORD PTR [eax+80], ecx

; 369  : 
; 370  :     //
; 371  :     // wait until reset completes.
; 372  :     //
; 373  : 
; 374  :     retry = 1000; // ??

  000e6	c7 45 d0 e8 03
	00 00		 mov	 DWORD PTR _retry$[ebp], 1000 ; 000003e8H
$LN15@BlKd1394In:

; 375  : 
; 376  :     do {
; 377  : 
; 378  :         HCControl.all = Registers->HCControlSet.all;

  000ed	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  000f0	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  000f3	89 45 ec	 mov	 DWORD PTR _HCControl$[ebp], eax

; 379  : 
; 380  :         BlKd1394StallExecution(1);

  000f6	33 c9		 xor	 ecx, ecx
  000f8	41		 inc	 ecx
  000f9	e8 00 00 00 00	 call	 ?BlKd1394StallExecution@@YIKK@Z ; BlKd1394StallExecution

; 381  : 
; 382  :     } while ((HCControl.SoftReset) && (--retry));

  000fe	8b 45 ec	 mov	 eax, DWORD PTR _HCControl$[ebp]
  00101	c1 e8 10	 shr	 eax, 16			; 00000010H
  00104	83 e0 01	 and	 eax, 1
  00107	74 09		 je	 SHORT $LN13@BlKd1394In
  00109	8b 45 d0	 mov	 eax, DWORD PTR _retry$[ebp]
  0010c	48		 dec	 eax
  0010d	89 45 d0	 mov	 DWORD PTR _retry$[ebp], eax
  00110	75 db		 jne	 SHORT $LN15@BlKd1394In
$LN13@BlKd1394In:

; 383  : 
; 384  :     if (retry == 0) {

  00112	83 7d d0 00	 cmp	 DWORD PTR _retry$[ebp], 0
  00116	75 07		 jne	 SHORT $LN11@BlKd1394In

; 385  : 
; 386  : #if KD_VERBOSE
; 387  : 
; 388  :         BlVideoPrintf("1394: Reset failed\n");
; 389  : 
; 390  : #endif
; 391  : 
; 392  :         return FALSE;

  00118	32 c0		 xor	 al, al
  0011a	e9 d2 03 00 00	 jmp	 $LN17@BlKd1394In
$LN11@BlKd1394In:

; 393  :     }
; 394  : 
; 395  :     //
; 396  :     // Enable link to phy communication.
; 397  :     //
; 398  : 
; 399  :     HCControl.all = 0;

  0011f	83 65 ec 00	 and	 DWORD PTR _HCControl$[ebp], 0

; 400  :     HCControl.Lps = TRUE;

  00123	8b 45 ec	 mov	 eax, DWORD PTR _HCControl$[ebp]
  00126	0d 00 00 08 00	 or	 eax, 524288		; 00080000H
  0012b	89 45 ec	 mov	 DWORD PTR _HCControl$[ebp], eax

; 401  :     Registers->HCControlSet.all = HCControl.all;

  0012e	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  00131	8b 4d ec	 mov	 ecx, DWORD PTR _HCControl$[ebp]
  00134	89 48 50	 mov	 DWORD PTR [eax+80], ecx

; 402  : 
; 403  :     BlKd1394StallExecution(20);

  00137	6a 14		 push	 20			; 00000014H
  00139	59		 pop	 ecx
  0013a	e8 00 00 00 00	 call	 ?BlKd1394StallExecution@@YIKK@Z ; BlKd1394StallExecution

; 404  : 
; 405  :     //
; 406  :     // Initialize HCControl register
; 407  :     // Send data in little-endian order (i.e. do byte swap).
; 408  :     //
; 409  : 
; 410  :     HCControl.all = 0;

  0013f	83 65 ec 00	 and	 DWORD PTR _HCControl$[ebp], 0

; 411  :     HCControl.NoByteSwapData = TRUE;

  00143	8b 45 ec	 mov	 eax, DWORD PTR _HCControl$[ebp]
  00146	0d 00 00 00 40	 or	 eax, 1073741824		; 40000000H
  0014b	89 45 ec	 mov	 DWORD PTR _HCControl$[ebp], eax

; 412  :     Registers->HCControlClear.all = HCControl.all;

  0014e	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  00151	8b 4d ec	 mov	 ecx, DWORD PTR _HCControl$[ebp]
  00154	89 48 54	 mov	 DWORD PTR [eax+84], ecx

; 413  : 
; 414  :     //
; 415  :     // Enable posted writes.
; 416  :     //
; 417  : 
; 418  :     HCControl.all = 0;

  00157	83 65 ec 00	 and	 DWORD PTR _HCControl$[ebp], 0

; 419  :     HCControl.PostedWriteEnable = TRUE;

  0015b	8b 45 ec	 mov	 eax, DWORD PTR _HCControl$[ebp]
  0015e	0d 00 00 04 00	 or	 eax, 262144		; 00040000H
  00163	89 45 ec	 mov	 DWORD PTR _HCControl$[ebp], eax

; 420  :     Registers->HCControlSet.all = HCControl.all;

  00166	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  00169	8b 4d ec	 mov	 ecx, DWORD PTR _HCControl$[ebp]
  0016c	89 48 50	 mov	 DWORD PTR [eax+80], ecx

; 421  : 
; 422  :     //
; 423  :     // Setup the link control.
; 424  :     //
; 425  : 
; 426  :     LinkControl.all = 0;

  0016f	83 65 d4 00	 and	 DWORD PTR _LinkControl$[ebp], 0

; 427  :     LinkControl.CycleTimerEnable = TRUE;

  00173	8b 45 d4	 mov	 eax, DWORD PTR _LinkControl$[ebp]
  00176	0d 00 00 10 00	 or	 eax, 1048576		; 00100000H
  0017b	89 45 d4	 mov	 DWORD PTR _LinkControl$[ebp], eax

; 428  :     LinkControl.CycleMaster = TRUE;

  0017e	8b 45 d4	 mov	 eax, DWORD PTR _LinkControl$[ebp]
  00181	0d 00 00 20 00	 or	 eax, 2097152		; 00200000H
  00186	89 45 d4	 mov	 DWORD PTR _LinkControl$[ebp], eax

; 429  :     LinkControl.RcvPhyPkt = TRUE;

  00189	8b 45 d4	 mov	 eax, DWORD PTR _LinkControl$[ebp]
  0018c	0d 00 04 00 00	 or	 eax, 1024		; 00000400H
  00191	89 45 d4	 mov	 DWORD PTR _LinkControl$[ebp], eax

; 430  :     LinkControl.RcvSelfId = TRUE;

  00194	8b 45 d4	 mov	 eax, DWORD PTR _LinkControl$[ebp]
  00197	0d 00 02 00 00	 or	 eax, 512		; 00000200H
  0019c	89 45 d4	 mov	 DWORD PTR _LinkControl$[ebp], eax

; 431  :     Registers->LinkControlClear.all = LinkControl.all;

  0019f	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  001a2	8b 4d d4	 mov	 ecx, DWORD PTR _LinkControl$[ebp]
  001a5	89 88 e4 00 00
	00		 mov	 DWORD PTR [eax+228], ecx

; 432  : 
; 433  :     LinkControl.all = 0;

  001ab	83 65 d4 00	 and	 DWORD PTR _LinkControl$[ebp], 0

; 434  :     LinkControl.CycleTimerEnable = TRUE;

  001af	8b 45 d4	 mov	 eax, DWORD PTR _LinkControl$[ebp]
  001b2	0d 00 00 10 00	 or	 eax, 1048576		; 00100000H
  001b7	89 45 d4	 mov	 DWORD PTR _LinkControl$[ebp], eax

; 435  :     LinkControl.CycleMaster = TRUE;

  001ba	8b 45 d4	 mov	 eax, DWORD PTR _LinkControl$[ebp]
  001bd	0d 00 00 20 00	 or	 eax, 2097152		; 00200000H
  001c2	89 45 d4	 mov	 DWORD PTR _LinkControl$[ebp], eax

; 436  :     Registers->LinkControlSet.all = LinkControl.all;

  001c5	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  001c8	8b 4d d4	 mov	 ecx, DWORD PTR _LinkControl$[ebp]
  001cb	89 88 e0 00 00
	00		 mov	 DWORD PTR [eax+224], ecx

; 437  : 
; 438  :     //
; 439  :     // Set the bus number (hardcoded to 0x3FF) - ??? what about node id??
; 440  :     //
; 441  : 
; 442  :     NodeId.all = 0;

  001d1	83 65 f0 00	 and	 DWORD PTR _NodeId$[ebp], 0

; 443  :     NodeId.BusId = (UINT16)0x3FF;

  001d5	8b 45 f0	 mov	 eax, DWORD PTR _NodeId$[ebp]
  001d8	0d c0 ff 00 00	 or	 eax, 65472		; 0000ffc0H
  001dd	89 45 f0	 mov	 DWORD PTR _NodeId$[ebp], eax

; 444  :     Registers->NodeId.all = NodeId.all;

  001e0	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  001e3	8b 4d f0	 mov	 ecx, DWORD PTR _NodeId$[ebp]
  001e6	89 88 e8 00 00
	00		 mov	 DWORD PTR [eax+232], ecx

; 445  : 
; 446  :     //
; 447  :     // Do something with the crom...
; 448  :     //
; 449  : 
; 450  :     //
; 451  :     // 0xf0000404 - bus id register
; 452  :     //
; 453  :     Kd1394Data->CromBuffer[1] = 0x31333934;

  001ec	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  001f1	c7 40 04 34 39
	33 31		 mov	 DWORD PTR [eax+4], 825440564 ; 31333934H

; 454  : 
; 455  :     //
; 456  :     // 0xf0000408 - bus options register
; 457  :     //
; 458  : 
; 459  :     BusOptions.all = BlKd1394ByteSwap(Registers->BusOptions.all);

  001f8	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  001fb	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  001fe	e8 00 00 00 00	 call	 ?BlKd1394ByteSwap@@YIKK@Z ; BlKd1394ByteSwap
  00203	89 45 f8	 mov	 DWORD PTR _BusOptions$[ebp], eax

; 460  :     BusOptions.Pmc = FALSE;

  00206	8b 45 f8	 mov	 eax, DWORD PTR _BusOptions$[ebp]
  00209	25 ff ff ff f7	 and	 eax, -134217729		; f7ffffffH
  0020e	89 45 f8	 mov	 DWORD PTR _BusOptions$[ebp], eax

; 461  :     BusOptions.Bmc = FALSE;

  00211	8b 45 f8	 mov	 eax, DWORD PTR _BusOptions$[ebp]
  00214	25 ff ff ff ef	 and	 eax, -268435457		; efffffffH
  00219	89 45 f8	 mov	 DWORD PTR _BusOptions$[ebp], eax

; 462  :     BusOptions.Isc = FALSE;

  0021c	8b 45 f8	 mov	 eax, DWORD PTR _BusOptions$[ebp]
  0021f	25 ff ff ff df	 and	 eax, -536870913		; dfffffffH
  00224	89 45 f8	 mov	 DWORD PTR _BusOptions$[ebp], eax

; 463  :     BusOptions.Cmc = FALSE;

  00227	8b 45 f8	 mov	 eax, DWORD PTR _BusOptions$[ebp]
  0022a	25 ff ff ff bf	 and	 eax, -1073741825	; bfffffffH
  0022f	89 45 f8	 mov	 DWORD PTR _BusOptions$[ebp], eax

; 464  :     BusOptions.Irmc = FALSE;

  00232	8b 45 f8	 mov	 eax, DWORD PTR _BusOptions$[ebp]
  00235	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH
  0023a	89 45 f8	 mov	 DWORD PTR _BusOptions$[ebp], eax

; 465  :     BusOptions.g = 1;

  0023d	8b 45 f8	 mov	 eax, DWORD PTR _BusOptions$[ebp]
  00240	25 3f ff ff ff	 and	 eax, -193		; ffffff3fH
  00245	83 c8 40	 or	 eax, 64			; 00000040H
  00248	89 45 f8	 mov	 DWORD PTR _BusOptions$[ebp], eax

; 466  :     Kd1394Data->CromBuffer[2] = BlKd1394ByteSwap(BusOptions.all);

  0024b	8b 4d f8	 mov	 ecx, DWORD PTR _BusOptions$[ebp]
  0024e	e8 00 00 00 00	 call	 ?BlKd1394ByteSwap@@YIKK@Z ; BlKd1394ByteSwap
  00253	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  00259	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 467  : 
; 468  :     //
; 469  :     // 0xf000040c - global unique id hi
; 470  :     //
; 471  : 
; 472  :     Kd1394Data->CromBuffer[3] = Registers->GuidHi;

  0025c	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  0025f	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00262	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  00268	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 473  : 
; 474  :     //
; 475  :     // 0xf0000410 - global unique id lo
; 476  :     //
; 477  : 
; 478  :     Kd1394Data->CromBuffer[4] = Registers->GuidLo;

  0026b	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  0026e	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00271	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  00277	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 479  : 
; 480  :     //
; 481  :     // 0xf0000400 - config ROM header - set last to calculate CRC!
; 482  :     //
; 483  : 
; 484  :     ConfigRomHeader.all = 0;

  0027a	83 65 e8 00	 and	 DWORD PTR _ConfigRomHeader$[ebp], 0

; 485  :     ConfigRomHeader.CRI_Info_Length = 4;

  0027e	c6 45 eb 04	 mov	 BYTE PTR _ConfigRomHeader$[ebp+3], 4

; 486  :     ConfigRomHeader.CRI_CRC_Length = 4;

  00282	c6 45 ea 04	 mov	 BYTE PTR _ConfigRomHeader$[ebp+2], 4

; 487  :     ConfigRomHeader.CRI_CRC_Value = BlKd1394CalculateCrc(&Kd1394Data->CromBuffer[1],
; 488  :                                                          ConfigRomHeader.CRI_CRC_Length);

  00286	0f b6 55 ea	 movzx	 edx, BYTE PTR _ConfigRomHeader$[ebp+2]
  0028a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  00290	83 c1 04	 add	 ecx, 4
  00293	e8 00 00 00 00	 call	 ?BlKd1394CalculateCrc@@YIGPAKK@Z ; BlKd1394CalculateCrc
  00298	66 89 45 c2	 mov	 WORD PTR tv185[ebp], ax
  0029c	66 8b 45 c2	 mov	 ax, WORD PTR tv185[ebp]
  002a0	66 8b 4d e8	 mov	 cx, WORD PTR _ConfigRomHeader$[ebp]
  002a4	66 83 e1 00	 and	 cx, 0
  002a8	66 0b c8	 or	 cx, ax
  002ab	66 89 4d e8	 mov	 WORD PTR _ConfigRomHeader$[ebp], cx

; 489  :     Kd1394Data->CromBuffer[0] = ConfigRomHeader.all;

  002af	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  002b4	8b 4d e8	 mov	 ecx, DWORD PTR _ConfigRomHeader$[ebp]
  002b7	89 08		 mov	 DWORD PTR [eax], ecx

; 490  : 
; 491  :     Kd1394Data->CromBuffer[6] = 0xC083000C; // 0xf0000418 - node capabilities

  002b9	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  002be	c7 40 18 0c 00
	83 c0		 mov	 DWORD PTR [eax+24], -1065156596 ; c083000cH

; 492  :     Kd1394Data->CromBuffer[7] = 0xF2500003; // 0xf000041C - module vendor id

  002c5	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  002ca	c7 40 1c 03 00
	50 f2		 mov	 DWORD PTR [eax+28], -229638141 ; f2500003H

; 493  : 
; 494  :     //
; 495  :     // KD's state machine looks for 1c w/ 50f2, 1d w/ 02, then 1e w/ address.
; 496  :     //
; 497  : 
; 498  :     Kd1394Data->CromBuffer[8] = 0xF250001C; // 0xf0000420 - extended key (for KD)

  002d1	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  002d6	c7 40 20 1c 00
	50 f2		 mov	 DWORD PTR [eax+32], -229638116 ; f250001cH

; 499  :     Kd1394Data->CromBuffer[9] = 0x0200001D; // 0xf0000424 - debug key (for KD)

  002dd	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  002e2	c7 40 24 1d 00
	00 02		 mov	 DWORD PTR [eax+36], 33554461 ; 0200001dH

; 500  : 
; 501  :     //
; 502  :     // 0xf0000428 - debug value (for KD)
; 503  :     //
; 504  : 
; 505  :     CromEntry.all = (UINT32)(ULONG_PTR) &Kd1394Data->Config;

  002e9	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  002ee	05 e0 03 00 00	 add	 eax, 992		; 000003e0H
  002f3	89 45 fc	 mov	 DWORD PTR _CromEntry$[ebp], eax

; 506  :     CromEntry.IE_Key = 0x1E;

  002f6	8b 45 fc	 mov	 eax, DWORD PTR _CromEntry$[ebp]
  002f9	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  002fe	0d 00 00 00 1e	 or	 eax, 503316480		; 1e000000H
  00303	89 45 fc	 mov	 DWORD PTR _CromEntry$[ebp], eax

; 507  :     Kd1394Data->CromBuffer[10] = BlKd1394ByteSwap(CromEntry.all);

  00306	8b 4d fc	 mov	 ecx, DWORD PTR _CromEntry$[ebp]
  00309	e8 00 00 00 00	 call	 ?BlKd1394ByteSwap@@YIKK@Z ; BlKd1394ByteSwap
  0030e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  00314	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 508  : 
; 509  :     //
; 510  :     // 0xf0000414 - root directory header - set last to calculate CRC!
; 511  :     //
; 512  : 
; 513  :     DirInfo.all = 0;

  00317	83 65 d8 00	 and	 DWORD PTR _DirInfo$[ebp], 0

; 514  :     DirInfo.DI_Length = 5;

  0031b	66 c7 45 da 05
	00		 mov	 WORD PTR _DirInfo$[ebp+2], 5

; 515  :     DirInfo.DI_CRC = BlKd1394CalculateCrc(&Kd1394Data->CromBuffer[6], DirInfo.DI_Length);

  00321	0f b7 55 da	 movzx	 edx, WORD PTR _DirInfo$[ebp+2]
  00325	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  0032b	83 c1 18	 add	 ecx, 24			; 00000018H
  0032e	e8 00 00 00 00	 call	 ?BlKd1394CalculateCrc@@YIGPAKK@Z ; BlKd1394CalculateCrc
  00333	66 89 45 d8	 mov	 WORD PTR _DirInfo$[ebp], ax

; 516  :     Kd1394Data->CromBuffer[5] = BlKd1394ByteSwap(DirInfo.all);

  00337	8b 4d d8	 mov	 ecx, DWORD PTR _DirInfo$[ebp]
  0033a	e8 00 00 00 00	 call	 ?BlKd1394ByteSwap@@YIKK@Z ; BlKd1394ByteSwap
  0033f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  00345	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 517  : 
; 518  :     //
; 519  :     // Write the first few registers.
; 520  :     //
; 521  : 
; 522  :     Registers->ConfigRomHeader.all = Kd1394Data->CromBuffer[0];

  00348	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  0034b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  00351	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00353	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 523  :     Registers->BusId = Kd1394Data->CromBuffer[1];

  00356	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  00359	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  0035f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00362	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 524  :     Registers->BusOptions.all = Kd1394Data->CromBuffer[2];

  00365	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  00368	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  0036e	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00371	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 525  :     Registers->GuidHi = Kd1394Data->CromBuffer[3];

  00374	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  00377	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  0037d	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00380	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 526  :     Registers->GuidLo = Kd1394Data->CromBuffer[4];

  00383	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  00386	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  0038c	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0038f	89 48 28	 mov	 DWORD PTR [eax+40], ecx

; 527  : 
; 528  :     //
; 529  :     // Set our crom.
; 530  :     //
; 531  : 
; 532  :     Registers->ConfigRomMap = (UINT32)(ULONG_PTR) &Kd1394Data->CromBuffer;

  00392	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  00395	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  0039b	89 48 34	 mov	 DWORD PTR [eax+52], ecx

; 533  : 
; 534  :     //
; 535  :     // Disable all interrupts, we use polling for the debugger transport.
; 536  :     //
; 537  : 
; 538  :     Registers->IntMaskClear.all = 0xFFFFFFFF;

  0039e	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  003a1	c7 80 8c 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+140], -1

; 539  : 
; 540  :     //
; 541  :     // Enable the link.
; 542  :     //
; 543  : 
; 544  :     HCControl.all = 0;

  003ab	83 65 ec 00	 and	 DWORD PTR _HCControl$[ebp], 0

; 545  :     HCControl.LinkEnable = TRUE;

  003af	8b 45 ec	 mov	 eax, DWORD PTR _HCControl$[ebp]
  003b2	0d 00 00 02 00	 or	 eax, 131072		; 00020000H
  003b7	89 45 ec	 mov	 DWORD PTR _HCControl$[ebp], eax

; 546  :     Registers->HCControlSet.all = HCControl.all;

  003ba	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  003bd	8b 4d ec	 mov	 ecx, DWORD PTR _HCControl$[ebp]
  003c0	89 48 50	 mov	 DWORD PTR [eax+80], ecx

; 547  : 
; 548  :     BlKd1394StallExecution(1000);

  003c3	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  003c8	e8 00 00 00 00	 call	 ?BlKd1394StallExecution@@YIKK@Z ; BlKd1394StallExecution

; 549  : 
; 550  :     //
; 551  :     // Enable access filters to all nodes.
; 552  :     //
; 553  : 
; 554  :     Registers->AsynchReqFilterLoSet = 0xFFFFFFFF;

  003cd	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  003d0	c7 80 08 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+264], -1

; 555  :     Registers->AsynchReqFilterHiSet = 0xFFFFFFFF;

  003da	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  003dd	c7 80 00 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+256], -1

; 556  :     Registers->PhyReqFilterHiSet = 0xFFFFFFFF;

  003e7	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  003ea	c7 80 10 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+272], -1

; 557  :     Registers->PhyReqFilterLoSet = 0xFFFFFFFF;

  003f4	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  003f7	c7 80 18 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+280], -1

; 558  : 
; 559  :     //
; 560  :     // Hard reset on the bus (so KD will look for us).
; 561  :     //
; 562  : 
; 563  :     PhyControl.all = 0;

  00401	83 65 e0 00	 and	 DWORD PTR _PhyControl$[ebp], 0

; 564  :     PhyControl.RdReg = TRUE;

  00405	8b 45 e0	 mov	 eax, DWORD PTR _PhyControl$[ebp]
  00408	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  0040d	89 45 e0	 mov	 DWORD PTR _PhyControl$[ebp], eax

; 565  :     PhyControl.RegAddr = 1;

  00410	8b 45 e0	 mov	 eax, DWORD PTR _PhyControl$[ebp]
  00413	25 ff f0 ff ff	 and	 eax, -3841		; fffff0ffH
  00418	0d 00 01 00 00	 or	 eax, 256		; 00000100H
  0041d	89 45 e0	 mov	 DWORD PTR _PhyControl$[ebp], eax

; 566  :     Registers->PhyControl.all = PhyControl.all;

  00420	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  00423	8b 4d e0	 mov	 ecx, DWORD PTR _PhyControl$[ebp]
  00426	89 88 ec 00 00
	00		 mov	 DWORD PTR [eax+236], ecx

; 567  : 
; 568  :     retry = MAX_REGISTER_READS;

  0042c	c7 45 d0 80 1a
	06 00		 mov	 DWORD PTR _retry$[ebp], 400000 ; 00061a80H
$LN10@BlKd1394In:

; 569  : 
; 570  :     do {
; 571  : 
; 572  :         PhyControl.all = Registers->PhyControl.all;

  00433	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  00436	8b 80 ec 00 00
	00		 mov	 eax, DWORD PTR [eax+236]
  0043c	89 45 e0	 mov	 DWORD PTR _PhyControl$[ebp], eax

; 573  : 
; 574  :     } while ((!PhyControl.RdDone) && --retry);

  0043f	8b 45 e0	 mov	 eax, DWORD PTR _PhyControl$[ebp]
  00442	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00445	83 e0 01	 and	 eax, 1
  00448	75 09		 jne	 SHORT $LN8@BlKd1394In
  0044a	8b 45 d0	 mov	 eax, DWORD PTR _retry$[ebp]
  0044d	48		 dec	 eax
  0044e	89 45 d0	 mov	 DWORD PTR _retry$[ebp], eax
  00451	75 e0		 jne	 SHORT $LN10@BlKd1394In
$LN8@BlKd1394In:

; 575  : 
; 576  :     if (retry == 0) {

  00453	83 7d d0 00	 cmp	 DWORD PTR _retry$[ebp], 0
  00457	75 07		 jne	 SHORT $LN6@BlKd1394In

; 577  : 
; 578  : #if KD_VERBOSE
; 579  : 
; 580  :         BlVideoPrintf("1394: Bus read failed.\n");
; 581  : 
; 582  : #endif
; 583  : 
; 584  :         return FALSE;

  00459	32 c0		 xor	 al, al
  0045b	e9 91 00 00 00	 jmp	 $LN17@BlKd1394In
$LN6@BlKd1394In:

; 585  :     }
; 586  : 
; 587  :     Data = ((UINT8)PhyControl.RdData | PHY_INITIATE_BUS_RESET);

  00460	8b 45 e0	 mov	 eax, DWORD PTR _PhyControl$[ebp]
  00463	c1 e8 10	 shr	 eax, 16			; 00000010H
  00466	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0046b	0f b6 c0	 movzx	 eax, al
  0046e	83 c8 40	 or	 eax, 64			; 00000040H
  00471	88 45 cf	 mov	 BYTE PTR _Data$[ebp], al

; 588  : 
; 589  :     PhyControl.all = 0;

  00474	83 65 e0 00	 and	 DWORD PTR _PhyControl$[ebp], 0

; 590  :     PhyControl.WrReg = TRUE;

  00478	8b 45 e0	 mov	 eax, DWORD PTR _PhyControl$[ebp]
  0047b	0d 00 40 00 00	 or	 eax, 16384		; 00004000H
  00480	89 45 e0	 mov	 DWORD PTR _PhyControl$[ebp], eax

; 591  :     PhyControl.RegAddr = 1;

  00483	8b 45 e0	 mov	 eax, DWORD PTR _PhyControl$[ebp]
  00486	25 ff f0 ff ff	 and	 eax, -3841		; fffff0ffH
  0048b	0d 00 01 00 00	 or	 eax, 256		; 00000100H
  00490	89 45 e0	 mov	 DWORD PTR _PhyControl$[ebp], eax

; 592  :     PhyControl.WrData = Data;

  00493	0f b6 45 cf	 movzx	 eax, BYTE PTR _Data$[ebp]
  00497	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0049c	8b 4d e0	 mov	 ecx, DWORD PTR _PhyControl$[ebp]
  0049f	81 e1 00 ff ff
	ff		 and	 ecx, -256		; ffffff00H
  004a5	0b c8		 or	 ecx, eax
  004a7	89 4d e0	 mov	 DWORD PTR _PhyControl$[ebp], ecx

; 593  :     Registers->PhyControl.all = PhyControl.all;

  004aa	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  004ad	8b 4d e0	 mov	 ecx, DWORD PTR _PhyControl$[ebp]
  004b0	89 88 ec 00 00
	00		 mov	 DWORD PTR [eax+236], ecx

; 594  : 
; 595  :     retry = MAX_REGISTER_READS;

  004b6	c7 45 d0 80 1a
	06 00		 mov	 DWORD PTR _retry$[ebp], 400000 ; 00061a80H
$LN5@BlKd1394In:

; 596  : 
; 597  :     do {
; 598  : 
; 599  :         PhyControl.all = Registers->PhyControl.all;

  004bd	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  004c0	8b 80 ec 00 00
	00		 mov	 eax, DWORD PTR [eax+236]
  004c6	89 45 e0	 mov	 DWORD PTR _PhyControl$[ebp], eax

; 600  : 
; 601  :     } while (PhyControl.WrReg && --retry);

  004c9	8b 45 e0	 mov	 eax, DWORD PTR _PhyControl$[ebp]
  004cc	c1 e8 0e	 shr	 eax, 14			; 0000000eH
  004cf	83 e0 01	 and	 eax, 1
  004d2	74 09		 je	 SHORT $LN3@BlKd1394In
  004d4	8b 45 d0	 mov	 eax, DWORD PTR _retry$[ebp]
  004d7	48		 dec	 eax
  004d8	89 45 d0	 mov	 DWORD PTR _retry$[ebp], eax
  004db	75 e0		 jne	 SHORT $LN5@BlKd1394In
$LN3@BlKd1394In:

; 602  : 
; 603  :     if (retry == 0) {

  004dd	83 7d d0 00	 cmp	 DWORD PTR _retry$[ebp], 0
  004e1	75 04		 jne	 SHORT $LN1@BlKd1394In

; 604  : 
; 605  : #if KD_VERBOSE
; 606  : 
; 607  :         BlVideoPrintf("1394: Hard reset of bus failed\n");
; 608  : 
; 609  : #endif
; 610  : 
; 611  :         return FALSE;

  004e3	32 c0		 xor	 al, al
  004e5	eb 0a		 jmp	 SHORT $LN17@BlKd1394In
$LN1@BlKd1394In:

; 612  :     }
; 613  : 
; 614  : #if KD_VERBOSE
; 615  : 
; 616  :     BlVideoPrintf("1394: Hardware init succeeded.\n");
; 617  : 
; 618  : #endif
; 619  : 
; 620  :     KdRegisters = Registers;

  004e7	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  004ea	a3 00 00 00 00	 mov	 DWORD PTR _KdRegisters, eax

; 621  : 
; 622  :     return TRUE;

  004ef	b0 01		 mov	 al, 1
$LN17@BlKd1394In:

; 623  : }

  004f1	c9		 leave
  004f2	c3		 ret	 0
?BlKd1394InitHardware@@YIEGPAX@Z ENDP			; BlKd1394InitHardware
_TEXT	ENDS
PUBLIC	??_C@_0CM@ILELODI@1394?3?5EnablePhysicalAccess?5IntEv@ ; `string'
PUBLIC	??_C@_0CM@ODCPEIPD@1394?3?5EnablePhysicalAccess?5HCCon@ ; `string'
PUBLIC	?BlKd1394EnablePhysicalAccess@@YIXXZ		; BlKd1394EnablePhysicalAccess
EXTRN	?BlVideoPrintf@@YAEPBDZZ:PROC			; BlVideoPrintf
;	COMDAT ??_C@_0CM@ILELODI@1394?3?5EnablePhysicalAccess?5IntEv@
CONST	SEGMENT
??_C@_0CM@ILELODI@1394?3?5EnablePhysicalAccess?5IntEv@ DB '1394: EnablePh'
	DB	'ysicalAccess IntEvent =%08x!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@ODCPEIPD@1394?3?5EnablePhysicalAccess?5HCCon@
CONST	SEGMENT
??_C@_0CM@ODCPEIPD@1394?3?5EnablePhysicalAccess?5HCCon@ DB '1394: EnableP'
	DB	'hysicalAccess HCControl=%08x!', 0aH, 00H	; `string'
; Function compile flags: /Odsp
CONST	ENDS
;	COMDAT ?BlKd1394EnablePhysicalAccess@@YIXXZ
_TEXT	SEGMENT
_IntEvent$ = -8						; size = 4
_HCControl$ = -4					; size = 4
?BlKd1394EnablePhysicalAccess@@YIXXZ PROC		; BlKd1394EnablePhysicalAccess, COMDAT

; 629  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 630  :     HC_CONTROL_REGISTER HCControl;
; 631  :     INT_EVENT_MASK_REGISTER IntEvent;
; 632  : 
; 633  :     //
; 634  :     // See if ohci1394 is being loaded...
; 635  :     //
; 636  : 
; 637  :     HCControl.all = KdRegisters->HCControlSet.all;

  00005	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdRegisters
  0000a	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  0000d	89 45 fc	 mov	 DWORD PTR _HCControl$[ebp], eax

; 638  :     if (!HCControl.LinkEnable || !HCControl.Lps || HCControl.SoftReset) {

  00010	8b 45 fc	 mov	 eax, DWORD PTR _HCControl$[ebp]
  00013	c1 e8 11	 shr	 eax, 17			; 00000011H
  00016	83 e0 01	 and	 eax, 1
  00019	74 16		 je	 SHORT $LN4@BlKd1394En
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _HCControl$[ebp]
  0001e	c1 e8 13	 shr	 eax, 19			; 00000013H
  00021	83 e0 01	 and	 eax, 1
  00024	74 0b		 je	 SHORT $LN4@BlKd1394En
  00026	8b 45 fc	 mov	 eax, DWORD PTR _HCControl$[ebp]
  00029	c1 e8 10	 shr	 eax, 16			; 00000010H
  0002c	83 e0 01	 and	 eax, 1
  0002f	74 18		 je	 SHORT $LN5@BlKd1394En
$LN4@BlKd1394En:

; 639  : 
; 640  :         KDDBG("1394: EnablePhysicalAccess HCControl=%08x!\n", HCControl.all);

  00031	33 c0		 xor	 eax, eax
  00033	74 0f		 je	 SHORT $LN3@BlKd1394En
  00035	ff 75 fc	 push	 DWORD PTR _HCControl$[ebp]
  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@ODCPEIPD@1394?3?5EnablePhysicalAccess?5HCCon@
  0003d	e8 00 00 00 00	 call	 ?BlVideoPrintf@@YAEPBDZZ ; BlVideoPrintf
  00042	59		 pop	 ecx
  00043	59		 pop	 ecx
$LN3@BlKd1394En:

; 641  : 
; 642  :         return;

  00044	e9 85 00 00 00	 jmp	 $LN6@BlKd1394En
$LN5@BlKd1394En:

; 643  :     }
; 644  : 
; 645  :     //
; 646  :     // If the bus reset interrupt is not cleared, we have to clear it...
; 647  :     //
; 648  : 
; 649  :     IntEvent.all = KdRegisters->IntEventSet.all;

  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdRegisters
  0004e	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [eax+128]
  00054	89 45 f8	 mov	 DWORD PTR _IntEvent$[ebp], eax

; 650  :     if (IntEvent.BusReset) {

  00057	8b 45 f8	 mov	 eax, DWORD PTR _IntEvent$[ebp]
  0005a	c1 e8 11	 shr	 eax, 17			; 00000011H
  0005d	83 e0 01	 and	 eax, 1
  00060	74 30		 je	 SHORT $LN2@BlKd1394En

; 651  : 
; 652  :         KDDBG("1394: EnablePhysicalAccess IntEvent =%08x!\n", IntEvent.all);

  00062	33 c0		 xor	 eax, eax
  00064	74 0f		 je	 SHORT $LN1@BlKd1394En
  00066	ff 75 f8	 push	 DWORD PTR _IntEvent$[ebp]
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@ILELODI@1394?3?5EnablePhysicalAccess?5IntEv@
  0006e	e8 00 00 00 00	 call	 ?BlVideoPrintf@@YAEPBDZZ ; BlVideoPrintf
  00073	59		 pop	 ecx
  00074	59		 pop	 ecx
$LN1@BlKd1394En:

; 653  : 
; 654  :         IntEvent.all = 0;

  00075	83 65 f8 00	 and	 DWORD PTR _IntEvent$[ebp], 0

; 655  :         IntEvent.BusReset = 1;

  00079	8b 45 f8	 mov	 eax, DWORD PTR _IntEvent$[ebp]
  0007c	0d 00 00 02 00	 or	 eax, 131072		; 00020000H
  00081	89 45 f8	 mov	 DWORD PTR _IntEvent$[ebp], eax

; 656  :         KdRegisters->IntEventClear.all = IntEvent.all;

  00084	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdRegisters
  00089	8b 4d f8	 mov	 ecx, DWORD PTR _IntEvent$[ebp]
  0008c	89 88 84 00 00
	00		 mov	 DWORD PTR [eax+132], ecx
$LN2@BlKd1394En:

; 657  :     }
; 658  : 
; 659  :     //
; 660  :     // Re-enable physical access as it may be necessary.
; 661  :     //
; 662  : 
; 663  :     KdRegisters->AsynchReqFilterHiSet = 0xFFFFFFFF;

  00092	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdRegisters
  00097	c7 80 00 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+256], -1

; 664  :     KdRegisters->AsynchReqFilterLoSet = 0xFFFFFFFF;

  000a1	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdRegisters
  000a6	c7 80 08 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+264], -1

; 665  :     KdRegisters->PhyReqFilterHiSet = 0xFFFFFFFF;

  000b0	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdRegisters
  000b5	c7 80 10 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+272], -1

; 666  :     KdRegisters->PhyReqFilterLoSet = 0xFFFFFFFF;

  000bf	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdRegisters
  000c4	c7 80 18 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+280], -1
$LN6@BlKd1394En:

; 667  : 
; 668  :     return;
; 669  : }

  000ce	c9		 leave
  000cf	c3		 ret	 0
?BlKd1394EnablePhysicalAccess@@YIXXZ ENDP		; BlKd1394EnablePhysicalAccess
_TEXT	ENDS
PUBLIC	??_C@_0DM@MFBJDALE@LOOP?5?$CFd?5?$FLSendPacket?$DN?$CFp?5?$CF08x?5?$CF08x@ ; `string'
PUBLIC	??_C@_0BE@JKEJJOAO@BlKd1394SendPacket?6?$AA@	; `string'
PUBLIC	?BlKd1394SendPacket@@YIEGPBXG0G@Z		; BlKd1394SendPacket
EXTRN	?BlRtlCopyMemory@@YIXPAXPBXK@Z:PROC		; BlRtlCopyMemory
EXTRN	?BlKdComputeChecksum@@YIKPBXK@Z:PROC		; BlKdComputeChecksum
EXTRN	?BlKdNextPacketId@@3KA:DWORD			; BlKdNextPacketId
;	COMDAT ??_C@_0DM@MFBJDALE@LOOP?5?$CFd?5?$FLSendPacket?$DN?$CFp?5?$CF08x?5?$CF08x@
CONST	SEGMENT
??_C@_0DM@MFBJDALE@LOOP?5?$CFd?5?$FLSendPacket?$DN?$CFp?5?$CF08x?5?$CF08x@ DB 'L'
	DB	'OOP %d [SendPacket=%p %08x %08x %08x %02x %02x %02x %02x]', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JKEJJOAO@BlKd1394SendPacket?6?$AA@
CONST	SEGMENT
??_C@_0BE@JKEJJOAO@BlKd1394SendPacket?6?$AA@ DB 'BlKd1394SendPacket', 0aH
	DB	00H						; `string'
; Function compile flags: /Odsp
CONST	ENDS
;	COMDAT ?BlKd1394SendPacket@@YIEGPBXG0G@Z
_TEXT	SEGMENT
_Header$ = -36						; size = 4
_PacketType$ = -32					; size = 2
_pStatus$ = -28						; size = 4
_Retries$ = -24						; size = 4
_PacketHeader$ = -20					; size = 16
_count$ = -4						; size = 4
_HeaderSize$ = 8					; size = 2
_Data$ = 12						; size = 4
_DataSize$ = 16						; size = 2
?BlKd1394SendPacket@@YIEGPBXG0G@Z PROC			; BlKd1394SendPacket, COMDAT
; _PacketType$ = cx
; _Header$ = edx

; 705  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	56		 push	 esi
  00007	89 55 dc	 mov	 DWORD PTR _Header$[ebp], edx
  0000a	66 89 4d e0	 mov	 WORD PTR _PacketType$[ebp], cx

; 706  :     KD_PACKET PacketHeader;
; 707  :     UINT32 Retries;
; 708  :     UINT32 count;
; 709  :     volatile UINT32 *pStatus;
; 710  : 
; 711  :     KDDBG2("BlKd1394SendPacket\n");

  0000e	33 c0		 xor	 eax, eax
  00010	74 0b		 je	 SHORT $LN13@BlKd1394Se
  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JKEJJOAO@BlKd1394SendPacket?6?$AA@
  00017	e8 00 00 00 00	 call	 ?BlVideoPrintf@@YAEPBDZZ ; BlVideoPrintf
  0001c	59		 pop	 ecx
$LN13@BlKd1394Se:

; 712  : 
; 713  :     //
; 714  :     // Abort if the hardware hasn't been initialized.
; 715  :     //
; 716  : 
; 717  :     if (KdRegisters == NULL) {

  0001d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _KdRegisters, 0
  00024	75 07		 jne	 SHORT $LN12@BlKd1394Se

; 718  : 
; 719  :         return FALSE;

  00026	32 c0		 xor	 al, al
  00028	e9 02 02 00 00	 jmp	 $LN14@BlKd1394Se
$LN12@BlKd1394Se:

; 720  :     }
; 721  : 
; 722  :     //
; 723  :     // Initialize the packet header.
; 724  :     //
; 725  : 
; 726  :     PacketHeader.PacketLeader = KD_PACKET_LEADER;

  0002d	c7 45 ec 30 30
	30 30		 mov	 DWORD PTR _PacketHeader$[ebp], 808464432 ; 30303030H

; 727  :     PacketHeader.ByteCount = HeaderSize + DataSize;

  00034	0f b7 45 08	 movzx	 eax, WORD PTR _HeaderSize$[ebp]
  00038	0f b7 4d 10	 movzx	 ecx, WORD PTR _DataSize$[ebp]
  0003c	03 c1		 add	 eax, ecx
  0003e	66 89 45 f2	 mov	 WORD PTR _PacketHeader$[ebp+6], ax

; 728  :     PacketHeader.PacketType = PacketType;

  00042	66 8b 45 e0	 mov	 ax, WORD PTR _PacketType$[ebp]
  00046	66 89 45 f0	 mov	 WORD PTR _PacketHeader$[ebp+4], ax

; 729  :     PacketHeader.PacketId = BlKdNextPacketId++;

  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlKdNextPacketId@@3KA ; BlKdNextPacketId
  0004f	89 45 f4	 mov	 DWORD PTR _PacketHeader$[ebp+8], eax
  00052	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlKdNextPacketId@@3KA ; BlKdNextPacketId
  00057	40		 inc	 eax
  00058	a3 00 00 00 00	 mov	 DWORD PTR ?BlKdNextPacketId@@3KA, eax ; BlKdNextPacketId

; 730  :     PacketHeader.Checksum = (BlKdComputeChecksum(Header, HeaderSize) +
; 731  :                              BlKdComputeChecksum(Data, DataSize));

  0005d	0f b7 55 08	 movzx	 edx, WORD PTR _HeaderSize$[ebp]
  00061	8b 4d dc	 mov	 ecx, DWORD PTR _Header$[ebp]
  00064	e8 00 00 00 00	 call	 ?BlKdComputeChecksum@@YIKPBXK@Z ; BlKdComputeChecksum
  00069	8b f0		 mov	 esi, eax
  0006b	0f b7 55 10	 movzx	 edx, WORD PTR _DataSize$[ebp]
  0006f	8b 4d 0c	 mov	 ecx, DWORD PTR _Data$[ebp]
  00072	e8 00 00 00 00	 call	 ?BlKdComputeChecksum@@YIKPBXK@Z ; BlKdComputeChecksum
  00077	03 f0		 add	 esi, eax
  00079	89 75 f8	 mov	 DWORD PTR _PacketHeader$[ebp+12], esi

; 732  : 
; 733  :     //
; 734  :     // Setup our send packet.
; 735  :     //
; 736  : 
; 737  :     BlRtlZeroMemory(&Kd1394Data->SendPacket, sizeof(DEBUG_1394_SEND_PACKET));

  0007c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  00082	81 c1 00 04 00
	00		 add	 ecx, 1024		; 00000400H
  00088	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  0008d	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 738  :     Kd1394Data->SendPacket.Length = 0;  // Redundant.

  00092	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  00097	83 a0 14 04 00
	00 00		 and	 DWORD PTR [eax+1044], 0

; 739  : 
; 740  :     //
; 741  :     // Copy our packet header into the transmit region.
; 742  :     //
; 743  : 
; 744  :     BlRtlCopyMemory(&Kd1394Data->SendPacket.PacketHeader[0], &PacketHeader, sizeof(KD_PACKET));

  0009e	6a 10		 push	 16			; 00000010H
  000a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  000a6	81 c1 04 04 00
	00		 add	 ecx, 1028		; 00000404H
  000ac	8d 55 ec	 lea	 edx, DWORD PTR _PacketHeader$[ebp]
  000af	e8 00 00 00 00	 call	 ?BlRtlCopyMemory@@YIXPAXPBXK@Z ; BlRtlCopyMemory

; 745  : 
; 746  :     //
; 747  :     // Setup our message header.
; 748  :     //
; 749  : 
; 750  :     if (HeaderSize > 0) {

  000b4	0f b7 45 08	 movzx	 eax, WORD PTR _HeaderSize$[ebp]
  000b8	85 c0		 test	 eax, eax
  000ba	7e 29		 jle	 SHORT $LN11@BlKd1394Se

; 751  : 
; 752  :         BlRtlCopyMemory(&Kd1394Data->SendPacket.Packet[0], Header, HeaderSize);

  000bc	0f b7 45 08	 movzx	 eax, WORD PTR _HeaderSize$[ebp]
  000c0	50		 push	 eax
  000c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  000c7	81 c1 18 04 00
	00		 add	 ecx, 1048		; 00000418H
  000cd	8b 55 dc	 mov	 edx, DWORD PTR _Header$[ebp]
  000d0	e8 00 00 00 00	 call	 ?BlRtlCopyMemory@@YIXPAXPBXK@Z ; BlRtlCopyMemory

; 753  :         Kd1394Data->SendPacket.Length = HeaderSize;

  000d5	0f b7 45 08	 movzx	 eax, WORD PTR _HeaderSize$[ebp]
  000d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  000df	89 81 14 04 00
	00		 mov	 DWORD PTR [ecx+1044], eax
$LN11@BlKd1394Se:

; 754  :     }
; 755  : 
; 756  :     //
; 757  :     // Setup our message data.
; 758  :     //
; 759  : 
; 760  :     if (DataSize > 0) {

  000e5	0f b7 45 10	 movzx	 eax, WORD PTR _DataSize$[ebp]
  000e9	85 c0		 test	 eax, eax
  000eb	7e 41		 jle	 SHORT $LN10@BlKd1394Se

; 761  : 
; 762  :         BlRtlCopyMemory(&Kd1394Data->SendPacket.Packet[Kd1394Data->SendPacket.Length], Data, DataSize);

  000ed	0f b7 45 10	 movzx	 eax, WORD PTR _DataSize$[ebp]
  000f1	50		 push	 eax
  000f2	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  000f7	8b 80 14 04 00
	00		 mov	 eax, DWORD PTR [eax+1044]
  000fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  00103	8d 8c 01 18 04
	00 00		 lea	 ecx, DWORD PTR [ecx+eax+1048]
  0010a	8b 55 0c	 mov	 edx, DWORD PTR _Data$[ebp]
  0010d	e8 00 00 00 00	 call	 ?BlRtlCopyMemory@@YIXPAXPBXK@Z ; BlRtlCopyMemory

; 763  :         Kd1394Data->SendPacket.Length += DataSize;

  00112	0f b7 45 10	 movzx	 eax, WORD PTR _DataSize$[ebp]
  00116	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  0011c	03 81 14 04 00
	00		 add	 eax, DWORD PTR [ecx+1044]
  00122	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  00128	89 81 14 04 00
	00		 mov	 DWORD PTR [ecx+1044], eax
$LN10@BlKd1394Se:

; 764  :     }
; 765  : 
; 766  :     //
; 767  :     // Mark the packet as ready for processing by host.
; 768  :     //
; 769  : 
; 770  :     Kd1394Data->SendPacket.TransferStatus = PACKET_PENDING;

  0012e	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  00133	c7 80 00 04 00
	00 03 01 00 00	 mov	 DWORD PTR [eax+1024], 259 ; 00000103H

; 771  : 
; 772  :     //
; 773  :     // Wait for our packet to be acknowledged by the host.
; 774  :     //
; 775  : 
; 776  :     for (Retries = KD_RETRY_COUNT; Retries > 0; Retries--) {

  0013d	c7 45 e8 10 00
	00 00		 mov	 DWORD PTR _Retries$[ebp], 16 ; 00000010H
  00144	eb 07		 jmp	 SHORT $LN9@BlKd1394Se
$LN8@BlKd1394Se:
  00146	8b 45 e8	 mov	 eax, DWORD PTR _Retries$[ebp]
  00149	48		 dec	 eax
  0014a	89 45 e8	 mov	 DWORD PTR _Retries$[ebp], eax
$LN9@BlKd1394Se:
  0014d	83 7d e8 00	 cmp	 DWORD PTR _Retries$[ebp], 0
  00151	0f 86 d6 00 00
	00		 jbe	 $LN7@BlKd1394Se

; 777  : 
; 778  :         KDDBG2("LOOP %d [SendPacket=%p %08x %08x %08x %02x %02x %02x %02x]\n",

  00157	33 c0		 xor	 eax, eax
  00159	74 70		 je	 SHORT $LN6@BlKd1394Se

; 779  :                Retries,
; 780  :                &Kd1394Data->SendPacket,
; 781  :                Kd1394Data->SendPacket.TransferStatus,
; 782  :                * (UINT32*) &Kd1394Data->SendPacket.PacketHeader,
; 783  :                Kd1394Data->SendPacket.Length,
; 784  :                Kd1394Data->SendPacket.Packet[0],
; 785  :                Kd1394Data->SendPacket.Packet[1],
; 786  :                Kd1394Data->SendPacket.Packet[2],
; 787  :                Kd1394Data->SendPacket.Packet[3]);

  0015b	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  00160	0f b6 80 1b 04
	00 00		 movzx	 eax, BYTE PTR [eax+1051]
  00167	50		 push	 eax
  00168	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  0016d	0f b6 80 1a 04
	00 00		 movzx	 eax, BYTE PTR [eax+1050]
  00174	50		 push	 eax
  00175	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  0017a	0f b6 80 19 04
	00 00		 movzx	 eax, BYTE PTR [eax+1049]
  00181	50		 push	 eax
  00182	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  00187	0f b6 80 18 04
	00 00		 movzx	 eax, BYTE PTR [eax+1048]
  0018e	50		 push	 eax
  0018f	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  00194	ff b0 14 04 00
	00		 push	 DWORD PTR [eax+1044]
  0019a	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  0019f	ff b0 04 04 00
	00		 push	 DWORD PTR [eax+1028]
  001a5	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  001aa	ff b0 00 04 00
	00		 push	 DWORD PTR [eax+1024]
  001b0	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  001b5	05 00 04 00 00	 add	 eax, 1024		; 00000400H
  001ba	50		 push	 eax
  001bb	ff 75 e8	 push	 DWORD PTR _Retries$[ebp]
  001be	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@MFBJDALE@LOOP?5?$CFd?5?$FLSendPacket?$DN?$CFp?5?$CF08x?5?$CF08x@
  001c3	e8 00 00 00 00	 call	 ?BlVideoPrintf@@YAEPBDZZ ; BlVideoPrintf
  001c8	83 c4 28	 add	 esp, 40			; 00000028H
$LN6@BlKd1394Se:

; 788  : 
; 789  :         //
; 790  :         // make sure our link is enabled..
; 791  :         //
; 792  : 
; 793  :         BlKd1394EnablePhysicalAccess();

  001cb	e8 00 00 00 00	 call	 ?BlKd1394EnablePhysicalAccess@@YIXXZ ; BlKd1394EnablePhysicalAccess

; 794  : 
; 795  :         pStatus = &Kd1394Data->ReceivePacket.TransferStatus;

  001d0	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  001d5	05 00 14 00 00	 add	 eax, 5120		; 00001400H
  001da	89 45 e4	 mov	 DWORD PTR _pStatus$[ebp], eax

; 796  : 
; 797  :         //
; 798  :         // now sit here and poll for a response from the host machine
; 799  :         //
; 800  : 
; 801  :         for (count = 0; count < TIMEOUT_COUNT; count++) {

  001dd	83 65 fc 00	 and	 DWORD PTR _count$[ebp], 0
  001e1	eb 07		 jmp	 SHORT $LN5@BlKd1394Se
$LN4@BlKd1394Se:
  001e3	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  001e6	40		 inc	 eax
  001e7	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN5@BlKd1394Se:
  001ea	81 7d fc a0 86
	01 00		 cmp	 DWORD PTR _count$[ebp], 100000 ; 000186a0H
  001f1	73 35		 jae	 SHORT $LN3@BlKd1394Se

; 802  : 
; 803  :             //
; 804  :             // make sure our link is enabled..
; 805  :             //
; 806  : 
; 807  :             BlKd1394EnablePhysicalAccess();

  001f3	e8 00 00 00 00	 call	 ?BlKd1394EnablePhysicalAccess@@YIXXZ ; BlKd1394EnablePhysicalAccess

; 808  :             BlKdSpin();

  001f8	e8 00 00 00 00	 call	 ?BlKdSpin@@YIXXZ	; BlKdSpin

; 809  : 
; 810  :             //
; 811  :             // Check to see if the host has ACK'd our packet.
; 812  :             //
; 813  : 
; 814  :             if (Kd1394Data->SendPacket.TransferStatus != PACKET_PENDING) {

  001fd	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  00202	81 b8 00 04 00
	00 03 01 00 00	 cmp	 DWORD PTR [eax+1024], 259 ; 00000103H
  0020c	74 04		 je	 SHORT $LN2@BlKd1394Se

; 815  :                 return TRUE;

  0020e	b0 01		 mov	 al, 1
  00210	eb 1d		 jmp	 SHORT $LN14@BlKd1394Se
$LN2@BlKd1394Se:

; 816  :             }
; 817  : 
; 818  :             //
; 819  :             // While in this loop check if the host has submitted a new request.
; 820  :             // If they did, ACK it, and retry.
; 821  :             //
; 822  : 
; 823  :             if (*pStatus == PACKET_PENDING) {

  00212	8b 45 e4	 mov	 eax, DWORD PTR _pStatus$[ebp]
  00215	81 38 03 01 00
	00		 cmp	 DWORD PTR [eax], 259	; 00000103H
  0021b	75 09		 jne	 SHORT $LN1@BlKd1394Se

; 824  : 
; 825  :                 //
; 826  :                 // ACK the packet from the debugger so it will accept our packet.
; 827  :                 //
; 828  : 
; 829  :                 *pStatus = PACKET_READY;

  0021d	8b 45 e4	 mov	 eax, DWORD PTR _pStatus$[ebp]
  00220	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN1@BlKd1394Se:

; 830  :             }
; 831  :         }

  00226	eb bb		 jmp	 SHORT $LN4@BlKd1394Se
$LN3@BlKd1394Se:

; 832  :     }

  00228	e9 19 ff ff ff	 jmp	 $LN8@BlKd1394Se
$LN7@BlKd1394Se:

; 833  : 
; 834  :     return FALSE;

  0022d	32 c0		 xor	 al, al
$LN14@BlKd1394Se:

; 835  : }

  0022f	5e		 pop	 esi
  00230	c9		 leave
  00231	c2 0c 00	 ret	 12			; 0000000cH
?BlKd1394SendPacket@@YIEGPBXG0G@Z ENDP			; BlKd1394SendPacket
_TEXT	ENDS
PUBLIC	??_C@_1O@ENAGAFIM@?$AA1?$AA3?$AA9?$AA4?$AA?$CB?$AA?6?$AA?$AA@ ; `string'
PUBLIC	?BlKd1394Connect@@YIEXZ				; BlKd1394Connect
EXTRN	?BlPciOhci1394BaseAddress@@3KA:DWORD		; BlPciOhci1394BaseAddress
;	COMDAT ??_C@_1O@ENAGAFIM@?$AA1?$AA3?$AA9?$AA4?$AA?$CB?$AA?6?$AA?$AA@
CONST	SEGMENT
??_C@_1O@ENAGAFIM@?$AA1?$AA3?$AA9?$AA4?$AA?$CB?$AA?6?$AA?$AA@ DB '1', 00H
	DB	'3', 00H, '9', 00H, '4', 00H, '!', 00H, 0aH, 00H, 00H, 00H ; `string'
; Function compile flags: /Odsp
CONST	ENDS
;	COMDAT ?BlKd1394Connect@@YIEXZ
_TEXT	SEGMENT
_Packet$4160 = -16					; size = 16
?BlKd1394Connect@@YIEXZ PROC				; BlKd1394Connect, COMDAT

; 855  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 856  :     //
; 857  :     // Abort if there is no 1394 hardware.
; 858  :     //
; 859  : 
; 860  :     if (BlPciOhci1394BaseAddress == 0) {

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?BlPciOhci1394BaseAddress@@3KA, 0 ; BlPciOhci1394BaseAddress
  0000d	75 04		 jne	 SHORT $LN3@BlKd1394Co

; 861  : 
; 862  :         return FALSE;

  0000f	32 c0		 xor	 al, al
  00011	eb 54		 jmp	 SHORT $LN4@BlKd1394Co
$LN3@BlKd1394Co:

; 863  :     }
; 864  : 
; 865  :     //
; 866  :     // Initialize the underlying hardware.
; 867  :     //
; 868  : 
; 869  :     if (BlKd1394InitHardware(0, (PVOID)(ULONG_PTR) BlPciOhci1394BaseAddress)) {

  00013	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?BlPciOhci1394BaseAddress@@3KA ; BlPciOhci1394BaseAddress
  00019	66 33 c9	 xor	 cx, cx
  0001c	e8 00 00 00 00	 call	 ?BlKd1394InitHardware@@YIEGPAX@Z ; BlKd1394InitHardware
  00021	0f b6 c0	 movzx	 eax, al
  00024	85 c0		 test	 eax, eax
  00026	74 36		 je	 SHORT $LN2@BlKd1394Co

; 870  : 
; 871  :         KD_DEBUG_IO Packet;
; 872  : 
; 873  :         //
; 874  :         // Send a test packet to verify the debugger is attached.
; 875  :         //
; 876  : 
; 877  :         BlRtlZeroMemory(&Packet, sizeof(Packet));

  00028	6a 10		 push	 16			; 00000010H
  0002a	5a		 pop	 edx
  0002b	8d 4d f0	 lea	 ecx, DWORD PTR _Packet$4160[ebp]
  0002e	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 878  : 
; 879  :         Packet.ApiNumber = KD_API_PRINT_STRING;

  00033	c7 45 f0 30 32
	00 00		 mov	 DWORD PTR _Packet$4160[ebp], 12848 ; 00003230H

; 880  :         Packet.u1.PrintString.LengthOfString = 0;

  0003a	83 65 f8 00	 and	 DWORD PTR _Packet$4160[ebp+8], 0

; 881  : 
; 882  :         if (BlKd1394SendPacket(KD_PACKET_TYPE_KD_DEBUG_IO, &Packet, sizeof(Packet), L"1394!\n", 7)) {

  0003e	6a 07		 push	 7
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_1O@ENAGAFIM@?$AA1?$AA3?$AA9?$AA4?$AA?$CB?$AA?6?$AA?$AA@
  00045	6a 10		 push	 16			; 00000010H
  00047	8d 55 f0	 lea	 edx, DWORD PTR _Packet$4160[ebp]
  0004a	66 b9 03 00	 mov	 cx, 3
  0004e	e8 00 00 00 00	 call	 ?BlKd1394SendPacket@@YIEGPBXG0G@Z ; BlKd1394SendPacket
  00053	0f b6 c0	 movzx	 eax, al
  00056	85 c0		 test	 eax, eax
  00058	74 04		 je	 SHORT $LN2@BlKd1394Co

; 883  : 
; 884  :             return TRUE;

  0005a	b0 01		 mov	 al, 1
  0005c	eb 09		 jmp	 SHORT $LN4@BlKd1394Co
$LN2@BlKd1394Co:

; 885  :         }
; 886  :     }
; 887  : 
; 888  :     BlPciOhci1394BaseAddress = 0;

  0005e	83 25 00 00 00
	00 00		 and	 DWORD PTR ?BlPciOhci1394BaseAddress@@3KA, 0 ; BlPciOhci1394BaseAddress

; 889  : 
; 890  :     return FALSE;

  00065	32 c0		 xor	 al, al
$LN4@BlKd1394Co:

; 891  : }

  00067	c9		 leave
  00068	c3		 ret	 0
?BlKd1394Connect@@YIEXZ ENDP				; BlKd1394Connect
_TEXT	ENDS
END
