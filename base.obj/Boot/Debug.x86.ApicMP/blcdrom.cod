; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	C:\Users\cc\source\repos\Singularity-OS\base\Boot\SingLdrPc\blcdrom.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?BlCdTemporaryBlock@@3PAU_ISO9660_LOGICAL_BLOCK@@A ; BlCdTemporaryBlock
PUBLIC	?BlCdDriveParameters@@3U_INT13_DRIVE_PARAMETERS@@A ; BlCdDriveParameters
PUBLIC	?BlCdDriveId@@3EA				; BlCdDriveId
PUBLIC	?BlCdVolumeDescriptor@@3U_ISO9660_VOLUME_DESCRIPTOR@@A ; BlCdVolumeDescriptor
PUBLIC	?BlCdTemporaryBlockCount@@3GA			; BlCdTemporaryBlockCount
_BSS	SEGMENT
?BlCdTemporaryBlock@@3PAU_ISO9660_LOGICAL_BLOCK@@A DB 010000H DUP (?) ; BlCdTemporaryBlock
?BlCdDriveParameters@@3U_INT13_DRIVE_PARAMETERS@@A DB 01aH DUP (?) ; BlCdDriveParameters
	ALIGN	4

?BlCdDriveId@@3EA DB 01H DUP (?)			; BlCdDriveId
	ALIGN	4

?BlCdVolumeDescriptor@@3U_ISO9660_VOLUME_DESCRIPTOR@@A DB 0800H DUP (?) ; BlCdVolumeDescriptor
_BSS	ENDS
_DATA	SEGMENT
?BlCdTemporaryBlockCount@@3GA DW 020H			; BlCdTemporaryBlockCount
_DATA	ENDS
PUBLIC	??_C@_0M@CKJPMOGI@blcdrom?4cpp?$AA@		; `string'
PUBLIC	??_C@_0DC@EBKPCJGO@CDROM?3?5I?1O?5Error?3?5DriveID?$DN0x?$CF02x@ ; `string'
PUBLIC	?BlCdReadLogicalBlock@@YIXKKPAU_ISO9660_LOGICAL_BLOCK@@@Z ; BlCdReadLogicalBlock
EXTRN	?BlRtlCopyMemory@@YIXPAXPBXK@Z:PROC		; BlRtlCopyMemory
EXTRN	?BlRtlHaltInternal@@YIXPBDK@Z:PROC		; BlRtlHaltInternal
EXTRN	?BlRtlPrintf@@YAEPBDZZ:PROC			; BlRtlPrintf
EXTRN	?BlRtlReadDrive@@YIEE_KGPAX@Z:PROC		; BlRtlReadDrive
;	COMDAT ??_C@_0M@CKJPMOGI@blcdrom?4cpp?$AA@
; File c:\users\cc\source\repos\singularity-os\base\boot\singldrpc\blcdrom.cpp
CONST	SEGMENT
??_C@_0M@CKJPMOGI@blcdrom?4cpp?$AA@ DB 'blcdrom.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@EBKPCJGO@CDROM?3?5I?1O?5Error?3?5DriveID?$DN0x?$CF02x@
CONST	SEGMENT
??_C@_0DC@EBKPCJGO@CDROM?3?5I?1O?5Error?3?5DriveID?$DN0x?$CF02x@ DB 'CDRO'
	DB	'M: I/O Error: DriveID=0x%02x LBN=%u Count=%u', 0aH, 00H ; `string'
; Function compile flags: /Odsp
CONST	ENDS
;	COMDAT ?BlCdReadLogicalBlock@@YIXKKPAU_ISO9660_LOGICAL_BLOCK@@@Z
_TEXT	SEGMENT
_NumberOfBlocks$ = -16					; size = 4
_LogicalBlockNumber$ = -12				; size = 4
_ChunkSize$ = -8					; size = 2
_Result$ = -1						; size = 1
_LogicalBlock$ = 8					; size = 4
?BlCdReadLogicalBlock@@YIXKKPAU_ISO9660_LOGICAL_BLOCK@@@Z PROC ; BlCdReadLogicalBlock, COMDAT
; _LogicalBlockNumber$ = ecx
; _NumberOfBlocks$ = edx

; 191  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 55 f0	 mov	 DWORD PTR _NumberOfBlocks$[ebp], edx
  00009	89 4d f4	 mov	 DWORD PTR _LogicalBlockNumber$[ebp], ecx
$LN5@BlCdReadLo:

; 192  :     UINT16 ChunkSize;
; 193  :     BOOLEAN Result;
; 194  : 
; 195  :     while (NumberOfBlocks > 0) {

  0000c	83 7d f0 00	 cmp	 DWORD PTR _NumberOfBlocks$[ebp], 0
  00010	0f 86 ae 00 00
	00		 jbe	 $LN6@BlCdReadLo

; 196  : 
; 197  :         if (NumberOfBlocks < BlCdTemporaryBlockCount) {

  00016	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?BlCdTemporaryBlockCount@@3GA ; BlCdTemporaryBlockCount
  0001d	39 45 f0	 cmp	 DWORD PTR _NumberOfBlocks$[ebp], eax
  00020	73 0a		 jae	 SHORT $LN3@BlCdReadLo

; 198  : 
; 199  :             ChunkSize = (UINT16) NumberOfBlocks;

  00022	66 8b 45 f0	 mov	 ax, WORD PTR _NumberOfBlocks$[ebp]
  00026	66 89 45 f8	 mov	 WORD PTR _ChunkSize$[ebp], ax

; 200  : 
; 201  :         } else {

  0002a	eb 0a		 jmp	 SHORT $LN2@BlCdReadLo
$LN3@BlCdReadLo:

; 202  : 
; 203  :             ChunkSize = BlCdTemporaryBlockCount;

  0002c	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?BlCdTemporaryBlockCount@@3GA ; BlCdTemporaryBlockCount
  00032	66 89 45 f8	 mov	 WORD PTR _ChunkSize$[ebp], ax
$LN2@BlCdReadLo:

; 204  :         }
; 205  : 
; 206  :         Result = BlRtlReadDrive(BlCdDriveId,
; 207  :                                 LogicalBlockNumber,
; 208  :                                 ChunkSize,
; 209  :                                 BlCdTemporaryBlock);

  00036	68 00 00 00 00	 push	 OFFSET ?BlCdTemporaryBlock@@3PAU_ISO9660_LOGICAL_BLOCK@@A ; BlCdTemporaryBlock
  0003b	8b 45 f4	 mov	 eax, DWORD PTR _LogicalBlockNumber$[ebp]
  0003e	33 c9		 xor	 ecx, ecx
  00040	51		 push	 ecx
  00041	50		 push	 eax
  00042	8b 55 f8	 mov	 edx, DWORD PTR _ChunkSize$[ebp]
  00045	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?BlCdDriveId@@3EA ; BlCdDriveId
  0004b	e8 00 00 00 00	 call	 ?BlRtlReadDrive@@YIEE_KGPAX@Z ; BlRtlReadDrive
  00050	88 45 ff	 mov	 BYTE PTR _Result$[ebp], al

; 210  : 
; 211  :         if (Result == FALSE) {

  00053	0f b6 45 ff	 movzx	 eax, BYTE PTR _Result$[ebp]
  00057	85 c0		 test	 eax, eax
  00059	75 2c		 jne	 SHORT $LN1@BlCdReadLo

; 212  : 
; 213  :             BlRtlPrintf("CDROM: I/O Error: DriveID=0x%02x LBN=%u Count=%u\n",
; 214  :                         BlCdDriveId,
; 215  :                         LogicalBlockNumber,
; 216  :                         ChunkSize);

  0005b	0f b7 45 f8	 movzx	 eax, WORD PTR _ChunkSize$[ebp]
  0005f	50		 push	 eax
  00060	ff 75 f4	 push	 DWORD PTR _LogicalBlockNumber$[ebp]
  00063	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?BlCdDriveId@@3EA ; BlCdDriveId
  0006a	50		 push	 eax
  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@EBKPCJGO@CDROM?3?5I?1O?5Error?3?5DriveID?$DN0x?$CF02x@
  00070	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  00075	83 c4 10	 add	 esp, 16			; 00000010H

; 217  : 
; 218  :             BlRtlHalt();

  00078	ba da 00 00 00	 mov	 edx, 218		; 000000daH
  0007d	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0M@CKJPMOGI@blcdrom?4cpp?$AA@
  00082	e8 00 00 00 00	 call	 ?BlRtlHaltInternal@@YIXPBDK@Z ; BlRtlHaltInternal
$LN1@BlCdReadLo:

; 219  :         }
; 220  : 
; 221  :         BlRtlCopyMemory(LogicalBlock,
; 222  :                         BlCdTemporaryBlock,
; 223  :                         ChunkSize * sizeof(ISO9660_LOGICAL_BLOCK));

  00087	0f b7 45 f8	 movzx	 eax, WORD PTR _ChunkSize$[ebp]
  0008b	c1 e0 0b	 shl	 eax, 11			; 0000000bH
  0008e	50		 push	 eax
  0008f	ba 00 00 00 00	 mov	 edx, OFFSET ?BlCdTemporaryBlock@@3PAU_ISO9660_LOGICAL_BLOCK@@A ; BlCdTemporaryBlock
  00094	8b 4d 08	 mov	 ecx, DWORD PTR _LogicalBlock$[ebp]
  00097	e8 00 00 00 00	 call	 ?BlRtlCopyMemory@@YIXPAXPBXK@Z ; BlRtlCopyMemory

; 224  : 
; 225  :         LogicalBlockNumber += ChunkSize;

  0009c	0f b7 45 f8	 movzx	 eax, WORD PTR _ChunkSize$[ebp]
  000a0	03 45 f4	 add	 eax, DWORD PTR _LogicalBlockNumber$[ebp]
  000a3	89 45 f4	 mov	 DWORD PTR _LogicalBlockNumber$[ebp], eax

; 226  :         LogicalBlock += ChunkSize;

  000a6	0f b7 45 f8	 movzx	 eax, WORD PTR _ChunkSize$[ebp]
  000aa	c1 e0 0b	 shl	 eax, 11			; 0000000bH
  000ad	03 45 08	 add	 eax, DWORD PTR _LogicalBlock$[ebp]
  000b0	89 45 08	 mov	 DWORD PTR _LogicalBlock$[ebp], eax

; 227  :         NumberOfBlocks -= ChunkSize;

  000b3	0f b7 45 f8	 movzx	 eax, WORD PTR _ChunkSize$[ebp]
  000b7	8b 4d f0	 mov	 ecx, DWORD PTR _NumberOfBlocks$[ebp]
  000ba	2b c8		 sub	 ecx, eax
  000bc	89 4d f0	 mov	 DWORD PTR _NumberOfBlocks$[ebp], ecx

; 228  :     }

  000bf	e9 48 ff ff ff	 jmp	 $LN5@BlCdReadLo
$LN6@BlCdReadLo:

; 229  : 
; 230  :     return;
; 231  : }

  000c4	c9		 leave
  000c5	c2 04 00	 ret	 4
?BlCdReadLogicalBlock@@YIXKKPAU_ISO9660_LOGICAL_BLOCK@@@Z ENDP ; BlCdReadLogicalBlock
_TEXT	ENDS
PUBLIC	?BlCdFindDirectoryRecord@@YIEPBDPAU_ISO9660_DIRECTORY_RECORD@@@Z ; BlCdFindDirectoryRecord
EXTRN	?BlPoolFreeBlock@@YIXPAX@Z:PROC			; BlPoolFreeBlock
EXTRN	?BlRtlCompareMemory@@YIEPBX0K@Z:PROC		; BlRtlCompareMemory
EXTRN	?BlPoolAllocateBlock@@YIPAXK@Z:PROC		; BlPoolAllocateBlock
EXTRN	?BlRtlConvertCharacterToUpperCase@@YIDD@Z:PROC	; BlRtlConvertCharacterToUpperCase
EXTRN	?BlRtlAssertFailed@@YIXPBDK@Z:PROC		; BlRtlAssertFailed
; Function compile flags: /Odsp
;	COMDAT ?BlCdFindDirectoryRecord@@YIEPBDPAU_ISO9660_DIRECTORY_RECORD@@@Z
_TEXT	SEGMENT
_DirectoryRecord$ = -568				; size = 4
_Path$ = -564						; size = 4
_DirectoryData$ = -560					; size = 4
_Separator$ = -556					; size = 4
_Token$ = -552						; size = 255
_DirectoryDataExtentSize$ = -292			; size = 4
_Temp$ = -288						; size = 255
_NextToken$ = -28					; size = 4
_DirectoryDataIndex$ = -24				; size = 4
_Entry$ = -20						; size = 4
_DirectoryDataLimit$ = -16				; size = 4
_DirectoryDataExtentStart$ = -12			; size = 4
_Index$ = -8						; size = 4
_TokenSize$ = -4					; size = 4
?BlCdFindDirectoryRecord@@YIEPBDPAU_ISO9660_DIRECTORY_RECORD@@@Z PROC ; BlCdFindDirectoryRecord, COMDAT
; _Path$ = ecx
; _DirectoryRecord$ = edx

; 258  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 38 02 00
	00		 sub	 esp, 568		; 00000238H
  00009	89 95 c8 fd ff
	ff		 mov	 DWORD PTR _DirectoryRecord$[ebp], edx
  0000f	89 8d cc fd ff
	ff		 mov	 DWORD PTR _Path$[ebp], ecx

; 259  :     PISO9660_LOGICAL_BLOCK DirectoryData;
; 260  :     UINT32 DirectoryDataIndex;
; 261  :     ULONG_PTR DirectoryDataLimit;
; 262  :     UINT32 DirectoryDataExtentStart;
; 263  :     UINT32 DirectoryDataExtentSize;
; 264  :     PISO9660_DIRECTORY_RECORD Entry;
; 265  :     UINT32 Index;
; 266  :     PCSTR NextToken;
; 267  :     PCSTR Separator;
; 268  :     CHAR Temp[ISO9660_MAX_PATH];
; 269  :     CHAR Token[ISO9660_MAX_PATH];
; 270  :     UINT32 TokenSize;
; 271  : 
; 272  :     DirectoryDataExtentStart = BlCdVolumeDescriptor.u1.Supplementary.RootDirectory.ExtentLocation;

  00015	a1 9e 00 00 00	 mov	 eax, DWORD PTR ?BlCdVolumeDescriptor@@3U_ISO9660_VOLUME_DESCRIPTOR@@A+158
  0001a	89 45 f4	 mov	 DWORD PTR _DirectoryDataExtentStart$[ebp], eax

; 273  :     DirectoryDataExtentSize = ROUND_UP_TO_POWER2(BlCdVolumeDescriptor.u1.Supplementary.RootDirectory.DataLength, ISO9660_LOGICAL_BLOCK_SIZE) / ISO9660_LOGICAL_BLOCK_SIZE;

  0001d	a1 a6 00 00 00	 mov	 eax, DWORD PTR ?BlCdVolumeDescriptor@@3U_ISO9660_VOLUME_DESCRIPTOR@@A+166
  00022	05 ff 07 00 00	 add	 eax, 2047		; 000007ffH
  00027	25 00 f8 ff ff	 and	 eax, -2048		; fffff800H
  0002c	c1 e8 0b	 shr	 eax, 11			; 0000000bH
  0002f	89 85 dc fe ff
	ff		 mov	 DWORD PTR _DirectoryDataExtentSize$[ebp], eax

; 274  : 
; 275  :     NextToken = Path;

  00035	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _Path$[ebp]
  0003b	89 45 e4	 mov	 DWORD PTR _NextToken$[ebp], eax
$LN26@BlCdFindDi:

; 276  : 
; 277  :     for (;;) {
; 278  : 
; 279  :         BLASSERT(DirectoryDataExtentStart > ISO9660_VOLUME_SPACE_DATA_AREA_LBN);

  0003e	83 7d f4 10	 cmp	 DWORD PTR _DirectoryDataExtentStart$[ebp], 16 ; 00000010H
  00042	77 0f		 ja	 SHORT $LN24@BlCdFindDi
  00044	ba 17 01 00 00	 mov	 edx, 279		; 00000117H
  00049	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0M@CKJPMOGI@blcdrom?4cpp?$AA@
  0004e	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN24@BlCdFindDi:

; 280  : 
; 281  :         BLASSERT(DirectoryDataExtentSize > 0);

  00053	83 bd dc fe ff
	ff 00		 cmp	 DWORD PTR _DirectoryDataExtentSize$[ebp], 0
  0005a	77 0f		 ja	 SHORT $LN23@BlCdFindDi
  0005c	ba 19 01 00 00	 mov	 edx, 281		; 00000119H
  00061	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0M@CKJPMOGI@blcdrom?4cpp?$AA@
  00066	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN23@BlCdFindDi:

; 282  : 
; 283  :         BLASSERT((*NextToken != 0) && (*NextToken != '/'));

  0006b	8b 45 e4	 mov	 eax, DWORD PTR _NextToken$[ebp]
  0006e	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00071	85 c0		 test	 eax, eax
  00073	74 0b		 je	 SHORT $LN21@BlCdFindDi
  00075	8b 45 e4	 mov	 eax, DWORD PTR _NextToken$[ebp]
  00078	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0007b	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0007e	75 0f		 jne	 SHORT $LN22@BlCdFindDi
$LN21@BlCdFindDi:
  00080	ba 1b 01 00 00	 mov	 edx, 283		; 0000011bH
  00085	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0M@CKJPMOGI@blcdrom?4cpp?$AA@
  0008a	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN22@BlCdFindDi:

; 284  : 
; 285  :         Separator = NextToken;

  0008f	8b 45 e4	 mov	 eax, DWORD PTR _NextToken$[ebp]
  00092	89 85 d4 fd ff
	ff		 mov	 DWORD PTR _Separator$[ebp], eax
$LN20@BlCdFindDi:

; 286  : 
; 287  :         while ((*Separator != '/') && (*Separator != 0)) {

  00098	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _Separator$[ebp]
  0009e	0f be 00	 movsx	 eax, BYTE PTR [eax]
  000a1	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  000a4	74 1c		 je	 SHORT $LN19@BlCdFindDi
  000a6	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _Separator$[ebp]
  000ac	0f be 00	 movsx	 eax, BYTE PTR [eax]
  000af	85 c0		 test	 eax, eax
  000b1	74 0f		 je	 SHORT $LN19@BlCdFindDi

; 288  : 
; 289  :             Separator += 1;

  000b3	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _Separator$[ebp]
  000b9	40		 inc	 eax
  000ba	89 85 d4 fd ff
	ff		 mov	 DWORD PTR _Separator$[ebp], eax

; 290  :         }

  000c0	eb d6		 jmp	 SHORT $LN20@BlCdFindDi
$LN19@BlCdFindDi:

; 291  : 
; 292  :         TokenSize = (UINT32) (Separator - NextToken);

  000c2	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _Separator$[ebp]
  000c8	2b 45 e4	 sub	 eax, DWORD PTR _NextToken$[ebp]
  000cb	89 45 fc	 mov	 DWORD PTR _TokenSize$[ebp], eax

; 293  : 
; 294  :         for (Index = 0; Index < TokenSize; Index += 1) {

  000ce	83 65 f8 00	 and	 DWORD PTR _Index$[ebp], 0
  000d2	eb 07		 jmp	 SHORT $LN18@BlCdFindDi
$LN17@BlCdFindDi:
  000d4	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  000d7	40		 inc	 eax
  000d8	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax
$LN18@BlCdFindDi:
  000db	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  000de	3b 45 fc	 cmp	 eax, DWORD PTR _TokenSize$[ebp]
  000e1	73 19		 jae	 SHORT $LN16@BlCdFindDi

; 295  : 
; 296  :             Token[Index] = BlRtlConvertCharacterToUpperCase(NextToken[Index]);

  000e3	8b 45 e4	 mov	 eax, DWORD PTR _NextToken$[ebp]
  000e6	03 45 f8	 add	 eax, DWORD PTR _Index$[ebp]
  000e9	8a 08		 mov	 cl, BYTE PTR [eax]
  000eb	e8 00 00 00 00	 call	 ?BlRtlConvertCharacterToUpperCase@@YIDD@Z ; BlRtlConvertCharacterToUpperCase
  000f0	8b 4d f8	 mov	 ecx, DWORD PTR _Index$[ebp]
  000f3	88 84 0d d8 fd
	ff ff		 mov	 BYTE PTR _Token$[ebp+ecx], al

; 297  :         }

  000fa	eb d8		 jmp	 SHORT $LN17@BlCdFindDi
$LN16@BlCdFindDi:

; 298  : 
; 299  :         Token[TokenSize] = 0;

  000fc	8b 45 fc	 mov	 eax, DWORD PTR _TokenSize$[ebp]
  000ff	c6 84 05 d8 fd
	ff ff 00	 mov	 BYTE PTR _Token$[ebp+eax], 0

; 300  : 
; 301  :         DirectoryData = (PISO9660_LOGICAL_BLOCK) BlPoolAllocateBlock(DirectoryDataExtentSize * ISO9660_LOGICAL_BLOCK_SIZE);

  00107	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _DirectoryDataExtentSize$[ebp]
  0010d	c1 e1 0b	 shl	 ecx, 11			; 0000000bH
  00110	e8 00 00 00 00	 call	 ?BlPoolAllocateBlock@@YIPAXK@Z ; BlPoolAllocateBlock
  00115	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _DirectoryData$[ebp], eax

; 302  :         DirectoryDataLimit = (ULONG_PTR) DirectoryData + (DirectoryDataExtentSize * ISO9660_LOGICAL_BLOCK_SIZE);

  0011b	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _DirectoryDataExtentSize$[ebp]
  00121	c1 e0 0b	 shl	 eax, 11			; 0000000bH
  00124	03 85 d0 fd ff
	ff		 add	 eax, DWORD PTR _DirectoryData$[ebp]
  0012a	89 45 f0	 mov	 DWORD PTR _DirectoryDataLimit$[ebp], eax

; 303  : 
; 304  :         BlCdReadLogicalBlock(DirectoryDataExtentStart,
; 305  :                              DirectoryDataExtentSize,
; 306  :                              DirectoryData);

  0012d	ff b5 d0 fd ff
	ff		 push	 DWORD PTR _DirectoryData$[ebp]
  00133	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _DirectoryDataExtentSize$[ebp]
  00139	8b 4d f4	 mov	 ecx, DWORD PTR _DirectoryDataExtentStart$[ebp]
  0013c	e8 00 00 00 00	 call	 ?BlCdReadLogicalBlock@@YIXKKPAU_ISO9660_LOGICAL_BLOCK@@@Z ; BlCdReadLogicalBlock

; 307  : 
; 308  :         Entry = NULL;

  00141	83 65 ec 00	 and	 DWORD PTR _Entry$[ebp], 0

; 309  : 
; 310  :         for (DirectoryDataIndex = 0; (Entry == NULL) && (DirectoryDataIndex < DirectoryDataExtentSize); DirectoryDataIndex += 1) {

  00145	83 65 e8 00	 and	 DWORD PTR _DirectoryDataIndex$[ebp], 0
  00149	eb 07		 jmp	 SHORT $LN15@BlCdFindDi
$LN14@BlCdFindDi:
  0014b	8b 45 e8	 mov	 eax, DWORD PTR _DirectoryDataIndex$[ebp]
  0014e	40		 inc	 eax
  0014f	89 45 e8	 mov	 DWORD PTR _DirectoryDataIndex$[ebp], eax
$LN15@BlCdFindDi:
  00152	83 7d ec 00	 cmp	 DWORD PTR _Entry$[ebp], 0
  00156	0f 85 b9 00 00
	00		 jne	 $LN13@BlCdFindDi
  0015c	8b 45 e8	 mov	 eax, DWORD PTR _DirectoryDataIndex$[ebp]
  0015f	3b 85 dc fe ff
	ff		 cmp	 eax, DWORD PTR _DirectoryDataExtentSize$[ebp]
  00165	0f 83 aa 00 00
	00		 jae	 $LN13@BlCdFindDi

; 311  : 
; 312  :             Entry = (PISO9660_DIRECTORY_RECORD) &DirectoryData[DirectoryDataIndex];

  0016b	8b 45 e8	 mov	 eax, DWORD PTR _DirectoryDataIndex$[ebp]
  0016e	c1 e0 0b	 shl	 eax, 11			; 0000000bH
  00171	03 85 d0 fd ff
	ff		 add	 eax, DWORD PTR _DirectoryData$[ebp]
  00177	89 45 ec	 mov	 DWORD PTR _Entry$[ebp], eax
$LN12@BlCdFindDi:

; 313  : 
; 314  :             for (;;) {
; 315  : 
; 316  :                 if (Entry->DirectoryRecordLength == 0) {

  0017a	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  0017d	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00180	85 c0		 test	 eax, eax
  00182	75 09		 jne	 SHORT $LN10@BlCdFindDi

; 317  : 
; 318  :                     Entry = NULL;

  00184	83 65 ec 00	 and	 DWORD PTR _Entry$[ebp], 0

; 319  :                     break;

  00188	e9 83 00 00 00	 jmp	 $LN11@BlCdFindDi
$LN10@BlCdFindDi:

; 320  :                 }
; 321  : 
; 322  :                 if (Entry->FileIdentifierLength == (TokenSize * 2)) {

  0018d	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  00190	0f b6 40 20	 movzx	 eax, BYTE PTR [eax+32]
  00194	8b 4d fc	 mov	 ecx, DWORD PTR _TokenSize$[ebp]
  00197	d1 e1		 shl	 ecx, 1
  00199	3b c1		 cmp	 eax, ecx
  0019b	75 4d		 jne	 SHORT $LN9@BlCdFindDi

; 323  : 
; 324  :                     for (Index = 0; Index < TokenSize; Index += 1) {

  0019d	83 65 f8 00	 and	 DWORD PTR _Index$[ebp], 0
  001a1	eb 07		 jmp	 SHORT $LN8@BlCdFindDi
$LN7@BlCdFindDi:
  001a3	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  001a6	40		 inc	 eax
  001a7	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax
$LN8@BlCdFindDi:
  001aa	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  001ad	3b 45 fc	 cmp	 eax, DWORD PTR _TokenSize$[ebp]
  001b0	73 1b		 jae	 SHORT $LN6@BlCdFindDi

; 325  : 
; 326  :                         Temp[Index] = BlRtlConvertCharacterToUpperCase(Entry->FileIdentifier[(Index * 2) + 1]);

  001b2	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  001b5	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  001b8	8a 4c 41 22	 mov	 cl, BYTE PTR [ecx+eax*2+34]
  001bc	e8 00 00 00 00	 call	 ?BlRtlConvertCharacterToUpperCase@@YIDD@Z ; BlRtlConvertCharacterToUpperCase
  001c1	8b 4d f8	 mov	 ecx, DWORD PTR _Index$[ebp]
  001c4	88 84 0d e0 fe
	ff ff		 mov	 BYTE PTR _Temp$[ebp+ecx], al

; 327  :                     }

  001cb	eb d6		 jmp	 SHORT $LN7@BlCdFindDi
$LN6@BlCdFindDi:

; 328  : 
; 329  :                     if (BlRtlCompareMemory(Temp, Token, TokenSize) != FALSE) {

  001cd	ff 75 fc	 push	 DWORD PTR _TokenSize$[ebp]
  001d0	8d 95 d8 fd ff
	ff		 lea	 edx, DWORD PTR _Token$[ebp]
  001d6	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _Temp$[ebp]
  001dc	e8 00 00 00 00	 call	 ?BlRtlCompareMemory@@YIEPBX0K@Z ; BlRtlCompareMemory
  001e1	0f b6 c0	 movzx	 eax, al
  001e4	85 c0		 test	 eax, eax
  001e6	74 02		 je	 SHORT $LN9@BlCdFindDi

; 330  : 
; 331  :                         break;

  001e8	eb 26		 jmp	 SHORT $LN11@BlCdFindDi
$LN9@BlCdFindDi:

; 332  :                     }
; 333  :                 }
; 334  : 
; 335  :                 Entry = (PISO9660_DIRECTORY_RECORD) ROUND_UP_TO_POWER2((((ULONG_PTR) Entry) + Entry->DirectoryRecordLength), 2);

  001ea	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  001ed	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  001f0	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  001f3	8d 44 01 01	 lea	 eax, DWORD PTR [ecx+eax+1]
  001f7	83 e0 fe	 and	 eax, -2			; fffffffeH
  001fa	89 45 ec	 mov	 DWORD PTR _Entry$[ebp], eax

; 336  : 
; 337  :                 if ((ULONG_PTR) Entry >= DirectoryDataLimit) {

  001fd	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  00200	3b 45 f0	 cmp	 eax, DWORD PTR _DirectoryDataLimit$[ebp]
  00203	72 06		 jb	 SHORT $LN4@BlCdFindDi

; 338  : 
; 339  :                     Entry = NULL;

  00205	83 65 ec 00	 and	 DWORD PTR _Entry$[ebp], 0

; 340  :                     break;

  00209	eb 05		 jmp	 SHORT $LN11@BlCdFindDi
$LN4@BlCdFindDi:

; 341  :                 }
; 342  :             }

  0020b	e9 6a ff ff ff	 jmp	 $LN12@BlCdFindDi
$LN11@BlCdFindDi:

; 343  :         }

  00210	e9 36 ff ff ff	 jmp	 $LN14@BlCdFindDi
$LN13@BlCdFindDi:

; 344  : 
; 345  :         if (Entry == NULL) {

  00215	83 7d ec 00	 cmp	 DWORD PTR _Entry$[ebp], 0
  00219	75 12		 jne	 SHORT $LN3@BlCdFindDi

; 346  : 
; 347  :             BlPoolFreeBlock(DirectoryData);

  0021b	8b 8d d0 fd ff
	ff		 mov	 ecx, DWORD PTR _DirectoryData$[ebp]
  00221	e8 00 00 00 00	 call	 ?BlPoolFreeBlock@@YIXPAX@Z ; BlPoolFreeBlock

; 348  : 
; 349  :             return FALSE;

  00226	32 c0		 xor	 al, al
  00228	e9 88 00 00 00	 jmp	 $LN27@BlCdFindDi
$LN3@BlCdFindDi:

; 350  :         }
; 351  : 
; 352  :         if (*Separator == 0) {

  0022d	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _Separator$[ebp]
  00233	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00236	85 c0		 test	 eax, eax
  00238	75 1f		 jne	 SHORT $LN2@BlCdFindDi

; 353  : 
; 354  :             BlRtlCopyMemory(DirectoryRecord,
; 355  :                             Entry,
; 356  :                             sizeof(ISO9660_DIRECTORY_RECORD));

  0023a	6a 22		 push	 34			; 00000022H
  0023c	8b 55 ec	 mov	 edx, DWORD PTR _Entry$[ebp]
  0023f	8b 8d c8 fd ff
	ff		 mov	 ecx, DWORD PTR _DirectoryRecord$[ebp]
  00245	e8 00 00 00 00	 call	 ?BlRtlCopyMemory@@YIXPAXPBXK@Z ; BlRtlCopyMemory

; 357  : 
; 358  :             BlPoolFreeBlock(DirectoryData);

  0024a	8b 8d d0 fd ff
	ff		 mov	 ecx, DWORD PTR _DirectoryData$[ebp]
  00250	e8 00 00 00 00	 call	 ?BlPoolFreeBlock@@YIXPAX@Z ; BlPoolFreeBlock

; 359  : 
; 360  :             return TRUE;

  00255	b0 01		 mov	 al, 1
  00257	eb 5c		 jmp	 SHORT $LN27@BlCdFindDi
$LN2@BlCdFindDi:

; 361  :         }
; 362  : 
; 363  :         if (Entry->u1.s1.Directory == FALSE) {

  00259	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  0025c	8a 40 19	 mov	 al, BYTE PTR [eax+25]
  0025f	d0 e8		 shr	 al, 1
  00261	24 01		 and	 al, 1
  00263	0f b6 c0	 movzx	 eax, al
  00266	85 c0		 test	 eax, eax
  00268	75 0f		 jne	 SHORT $LN1@BlCdFindDi

; 364  : 
; 365  :             BlPoolFreeBlock(DirectoryData);

  0026a	8b 8d d0 fd ff
	ff		 mov	 ecx, DWORD PTR _DirectoryData$[ebp]
  00270	e8 00 00 00 00	 call	 ?BlPoolFreeBlock@@YIXPAX@Z ; BlPoolFreeBlock

; 366  : 
; 367  :             return FALSE;

  00275	32 c0		 xor	 al, al
  00277	eb 3c		 jmp	 SHORT $LN27@BlCdFindDi
$LN1@BlCdFindDi:

; 368  :         }
; 369  : 
; 370  :         DirectoryDataExtentStart = Entry->ExtentLocation;

  00279	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  0027c	8b 40 02	 mov	 eax, DWORD PTR [eax+2]
  0027f	89 45 f4	 mov	 DWORD PTR _DirectoryDataExtentStart$[ebp], eax

; 371  :         DirectoryDataExtentSize = ROUND_UP_TO_POWER2(Entry->DataLength, ISO9660_LOGICAL_BLOCK_SIZE) / ISO9660_LOGICAL_BLOCK_SIZE;

  00282	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  00285	8b 40 0a	 mov	 eax, DWORD PTR [eax+10]
  00288	05 ff 07 00 00	 add	 eax, 2047		; 000007ffH
  0028d	25 00 f8 ff ff	 and	 eax, -2048		; fffff800H
  00292	c1 e8 0b	 shr	 eax, 11			; 0000000bH
  00295	89 85 dc fe ff
	ff		 mov	 DWORD PTR _DirectoryDataExtentSize$[ebp], eax

; 372  :         NextToken = Separator + 1;

  0029b	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _Separator$[ebp]
  002a1	40		 inc	 eax
  002a2	89 45 e4	 mov	 DWORD PTR _NextToken$[ebp], eax

; 373  : 
; 374  :         BlPoolFreeBlock(DirectoryData);

  002a5	8b 8d d0 fd ff
	ff		 mov	 ecx, DWORD PTR _DirectoryData$[ebp]
  002ab	e8 00 00 00 00	 call	 ?BlPoolFreeBlock@@YIXPAX@Z ; BlPoolFreeBlock

; 375  :     }

  002b0	e9 89 fd ff ff	 jmp	 $LN26@BlCdFindDi
$LN27@BlCdFindDi:

; 376  : }

  002b5	c9		 leave
  002b6	c3		 ret	 0
?BlCdFindDirectoryRecord@@YIEPBDPAU_ISO9660_DIRECTORY_RECORD@@@Z ENDP ; BlCdFindDirectoryRecord
_TEXT	ENDS
PUBLIC	??_C@_0BO@OBEOJDCJ@CdGetFileSize?3?5?$FL?$CFs?$FN?5FAILED?52?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@ODAICNHA@CdGetFileSize?3?5?$FL?$CFs?$FN?5FAILED?51?6?$AA@ ; `string'
PUBLIC	?BlCdGetFileSize@@YIEPBDPAK@Z			; BlCdGetFileSize
;	COMDAT ??_C@_0BO@OBEOJDCJ@CdGetFileSize?3?5?$FL?$CFs?$FN?5FAILED?52?6?$AA@
CONST	SEGMENT
??_C@_0BO@OBEOJDCJ@CdGetFileSize?3?5?$FL?$CFs?$FN?5FAILED?52?6?$AA@ DB 'C'
	DB	'dGetFileSize: [%s] FAILED 2', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@ODAICNHA@CdGetFileSize?3?5?$FL?$CFs?$FN?5FAILED?51?6?$AA@
CONST	SEGMENT
??_C@_0BO@ODAICNHA@CdGetFileSize?3?5?$FL?$CFs?$FN?5FAILED?51?6?$AA@ DB 'C'
	DB	'dGetFileSize: [%s] FAILED 1', 0aH, 00H	; `string'
; Function compile flags: /Odsp
CONST	ENDS
;	COMDAT ?BlCdGetFileSize@@YIEPBDPAK@Z
_TEXT	SEGMENT
_FileSize$ = -44					; size = 4
_Path$ = -40						; size = 4
_DirectoryRecord$ = -36					; size = 34
?BlCdGetFileSize@@YIEPBDPAK@Z PROC			; BlCdGetFileSize, COMDAT
; _Path$ = ecx
; _FileSize$ = edx

; 403  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 55 d4	 mov	 DWORD PTR _FileSize$[ebp], edx
  00009	89 4d d8	 mov	 DWORD PTR _Path$[ebp], ecx

; 404  :     ISO9660_DIRECTORY_RECORD DirectoryRecord;
; 405  : 
; 406  :     if (BlCdFindDirectoryRecord(Path, &DirectoryRecord) == FALSE) {

  0000c	8d 55 dc	 lea	 edx, DWORD PTR _DirectoryRecord$[ebp]
  0000f	8b 4d d8	 mov	 ecx, DWORD PTR _Path$[ebp]
  00012	e8 00 00 00 00	 call	 ?BlCdFindDirectoryRecord@@YIEPBDPAU_ISO9660_DIRECTORY_RECORD@@@Z ; BlCdFindDirectoryRecord
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	75 13		 jne	 SHORT $LN2@BlCdGetFil

; 407  : 
; 408  :         BlRtlPrintf("CdGetFileSize: [%s] FAILED 1\n", Path);

  0001e	ff 75 d8	 push	 DWORD PTR _Path$[ebp]
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@ODAICNHA@CdGetFileSize?3?5?$FL?$CFs?$FN?5FAILED?51?6?$AA@
  00026	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  0002b	59		 pop	 ecx
  0002c	59		 pop	 ecx

; 409  : 
; 410  :         return FALSE;

  0002d	32 c0		 xor	 al, al
  0002f	eb 2b		 jmp	 SHORT $LN3@BlCdGetFil
$LN2@BlCdGetFil:

; 411  :     }
; 412  : 
; 413  :     if (DirectoryRecord.u1.s1.Directory != FALSE) {

  00031	8a 45 f5	 mov	 al, BYTE PTR _DirectoryRecord$[ebp+25]
  00034	d0 e8		 shr	 al, 1
  00036	24 01		 and	 al, 1
  00038	0f b6 c0	 movzx	 eax, al
  0003b	85 c0		 test	 eax, eax
  0003d	74 13		 je	 SHORT $LN1@BlCdGetFil

; 414  : 
; 415  :         BlRtlPrintf("CdGetFileSize: [%s] FAILED 2\n", Path);

  0003f	ff 75 d8	 push	 DWORD PTR _Path$[ebp]
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@OBEOJDCJ@CdGetFileSize?3?5?$FL?$CFs?$FN?5FAILED?52?6?$AA@
  00047	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  0004c	59		 pop	 ecx
  0004d	59		 pop	 ecx

; 416  : 
; 417  :         return FALSE;

  0004e	32 c0		 xor	 al, al
  00050	eb 0a		 jmp	 SHORT $LN3@BlCdGetFil
$LN1@BlCdGetFil:

; 418  :     }
; 419  : 
; 420  :     *FileSize = DirectoryRecord.DataLength;

  00052	8b 45 d4	 mov	 eax, DWORD PTR _FileSize$[ebp]
  00055	8b 4d e6	 mov	 ecx, DWORD PTR _DirectoryRecord$[ebp+10]
  00058	89 08		 mov	 DWORD PTR [eax], ecx

; 421  :     return TRUE;

  0005a	b0 01		 mov	 al, 1
$LN3@BlCdGetFil:

; 422  : }

  0005c	c9		 leave
  0005d	c3		 ret	 0
?BlCdGetFileSize@@YIEPBDPAK@Z ENDP			; BlCdGetFileSize
_TEXT	ENDS
PUBLIC	?BlCdReadFile@@YIEPBDPAXK@Z			; BlCdReadFile
; Function compile flags: /Odsp
;	COMDAT ?BlCdReadFile@@YIEPBDPAXK@Z
_TEXT	SEGMENT
_Buffer$ = -2112					; size = 4
_Path$ = -2108						; size = 4
_Block$ = -2104						; size = 2048
_Next$ = -52						; size = 4
_ChunkSize$ = -44					; size = 4
_DirectoryRecord$ = -40					; size = 34
_Offset$ = -4						; size = 4
_NumberOfBytes$ = 8					; size = 4
?BlCdReadFile@@YIEPBDPAXK@Z PROC			; BlCdReadFile, COMDAT
; _Path$ = ecx
; _Buffer$ = edx

; 452  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 40 08 00
	00		 sub	 esp, 2112		; 00000840H
  00009	89 95 c0 f7 ff
	ff		 mov	 DWORD PTR _Buffer$[ebp], edx
  0000f	89 8d c4 f7 ff
	ff		 mov	 DWORD PTR _Path$[ebp], ecx

; 453  :     ISO9660_LOGICAL_BLOCK Block;
; 454  :     UINT32 ChunkOffset;
; 455  :     UINT32 ChunkSize;
; 456  :     ISO9660_DIRECTORY_RECORD DirectoryRecord;
; 457  :     PUINT8 Next;
; 458  :     UINT32 Offset = 0;

  00015	83 65 fc 00	 and	 DWORD PTR _Offset$[ebp], 0

; 459  : 
; 460  :     if (BlCdFindDirectoryRecord(Path, &DirectoryRecord) == FALSE) {

  00019	8d 55 d8	 lea	 edx, DWORD PTR _DirectoryRecord$[ebp]
  0001c	8b 8d c4 f7 ff
	ff		 mov	 ecx, DWORD PTR _Path$[ebp]
  00022	e8 00 00 00 00	 call	 ?BlCdFindDirectoryRecord@@YIEPBDPAU_ISO9660_DIRECTORY_RECORD@@@Z ; BlCdFindDirectoryRecord
  00027	0f b6 c0	 movzx	 eax, al
  0002a	85 c0		 test	 eax, eax
  0002c	75 07		 jne	 SHORT $LN7@BlCdReadFi

; 461  : 
; 462  :         return FALSE;

  0002e	32 c0		 xor	 al, al
  00030	e9 cc 00 00 00	 jmp	 $LN8@BlCdReadFi
$LN7@BlCdReadFi:

; 463  :     }
; 464  : 
; 465  :     if (DirectoryRecord.u1.s1.Directory != FALSE) {

  00035	8a 45 f1	 mov	 al, BYTE PTR _DirectoryRecord$[ebp+25]
  00038	d0 e8		 shr	 al, 1
  0003a	24 01		 and	 al, 1
  0003c	0f b6 c0	 movzx	 eax, al
  0003f	85 c0		 test	 eax, eax
  00041	74 07		 je	 SHORT $LN6@BlCdReadFi

; 466  : 
; 467  :         return FALSE;

  00043	32 c0		 xor	 al, al
  00045	e9 b7 00 00 00	 jmp	 $LN8@BlCdReadFi
$LN6@BlCdReadFi:

; 468  :     }
; 469  : 
; 470  :     if (NumberOfBytes > DirectoryRecord.DataLength) {

  0004a	8b 45 08	 mov	 eax, DWORD PTR _NumberOfBytes$[ebp]
  0004d	3b 45 e2	 cmp	 eax, DWORD PTR _DirectoryRecord$[ebp+10]
  00050	76 07		 jbe	 SHORT $LN5@BlCdReadFi

; 471  : 
; 472  :         return FALSE;

  00052	32 c0		 xor	 al, al
  00054	e9 a8 00 00 00	 jmp	 $LN8@BlCdReadFi
$LN5@BlCdReadFi:

; 473  :     }
; 474  : 
; 475  :     if (NumberOfBytes == 0) {

  00059	83 7d 08 00	 cmp	 DWORD PTR _NumberOfBytes$[ebp], 0
  0005d	75 07		 jne	 SHORT $LN4@BlCdReadFi

; 476  : 
; 477  :         return TRUE;

  0005f	b0 01		 mov	 al, 1
  00061	e9 9b 00 00 00	 jmp	 $LN8@BlCdReadFi
$LN4@BlCdReadFi:

; 478  :     }
; 479  : 
; 480  :     Next = (PUINT8) Buffer;

  00066	8b 85 c0 f7 ff
	ff		 mov	 eax, DWORD PTR _Buffer$[ebp]
  0006c	89 45 cc	 mov	 DWORD PTR _Next$[ebp], eax

; 481  : 
; 482  :     //
; 483  :     // Handle full-read blocks in a single step.
; 484  :     //
; 485  : 
; 486  :     if (NumberOfBytes >= ISO9660_LOGICAL_BLOCK_SIZE) {

  0006f	81 7d 08 00 08
	00 00		 cmp	 DWORD PTR _NumberOfBytes$[ebp], 2048 ; 00000800H
  00076	72 40		 jb	 SHORT $LN3@BlCdReadFi

; 487  : 
; 488  :         ChunkSize = NumberOfBytes - (NumberOfBytes % ISO9660_LOGICAL_BLOCK_SIZE);

  00078	8b 45 08	 mov	 eax, DWORD PTR _NumberOfBytes$[ebp]
  0007b	33 d2		 xor	 edx, edx
  0007d	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00082	f7 f1		 div	 ecx
  00084	8b 45 08	 mov	 eax, DWORD PTR _NumberOfBytes$[ebp]
  00087	2b c2		 sub	 eax, edx
  00089	89 45 d4	 mov	 DWORD PTR _ChunkSize$[ebp], eax

; 489  : 
; 490  :         BlCdReadLogicalBlock(DirectoryRecord.ExtentLocation,
; 491  :                              ChunkSize / ISO9660_LOGICAL_BLOCK_SIZE,
; 492  :                              (PISO9660_LOGICAL_BLOCK) Next);

  0008c	ff 75 cc	 push	 DWORD PTR _Next$[ebp]
  0008f	8b 55 d4	 mov	 edx, DWORD PTR _ChunkSize$[ebp]
  00092	c1 ea 0b	 shr	 edx, 11			; 0000000bH
  00095	8b 4d da	 mov	 ecx, DWORD PTR _DirectoryRecord$[ebp+2]
  00098	e8 00 00 00 00	 call	 ?BlCdReadLogicalBlock@@YIXKKPAU_ISO9660_LOGICAL_BLOCK@@@Z ; BlCdReadLogicalBlock

; 493  : 
; 494  :         Next += ChunkSize;

  0009d	8b 45 cc	 mov	 eax, DWORD PTR _Next$[ebp]
  000a0	03 45 d4	 add	 eax, DWORD PTR _ChunkSize$[ebp]
  000a3	89 45 cc	 mov	 DWORD PTR _Next$[ebp], eax

; 495  :         Offset += ChunkSize;

  000a6	8b 45 fc	 mov	 eax, DWORD PTR _Offset$[ebp]
  000a9	03 45 d4	 add	 eax, DWORD PTR _ChunkSize$[ebp]
  000ac	89 45 fc	 mov	 DWORD PTR _Offset$[ebp], eax

; 496  :         NumberOfBytes -= ChunkSize;

  000af	8b 45 08	 mov	 eax, DWORD PTR _NumberOfBytes$[ebp]
  000b2	2b 45 d4	 sub	 eax, DWORD PTR _ChunkSize$[ebp]
  000b5	89 45 08	 mov	 DWORD PTR _NumberOfBytes$[ebp], eax
$LN3@BlCdReadFi:

; 497  :     }
; 498  : 
; 499  :     //
; 500  :     // Check if the ending block is a partial read.
; 501  :     //
; 502  : 
; 503  :     BLASSERT(NumberOfBytes < ISO9660_LOGICAL_BLOCK_SIZE);

  000b8	81 7d 08 00 08
	00 00		 cmp	 DWORD PTR _NumberOfBytes$[ebp], 2048 ; 00000800H
  000bf	72 0f		 jb	 SHORT $LN2@BlCdReadFi
  000c1	ba f7 01 00 00	 mov	 edx, 503		; 000001f7H
  000c6	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0M@CKJPMOGI@blcdrom?4cpp?$AA@
  000cb	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN2@BlCdReadFi:

; 504  : 
; 505  :     if (NumberOfBytes > 0) {

  000d0	83 7d 08 00	 cmp	 DWORD PTR _NumberOfBytes$[ebp], 0
  000d4	76 29		 jbe	 SHORT $LN1@BlCdReadFi

; 506  : 
; 507  :         BlCdReadLogicalBlock(DirectoryRecord.ExtentLocation + (Offset / ISO9660_LOGICAL_BLOCK_SIZE),
; 508  :                              1,
; 509  :                              &Block);

  000d6	8d 85 c8 f7 ff
	ff		 lea	 eax, DWORD PTR _Block$[ebp]
  000dc	50		 push	 eax
  000dd	8b 4d fc	 mov	 ecx, DWORD PTR _Offset$[ebp]
  000e0	c1 e9 0b	 shr	 ecx, 11			; 0000000bH
  000e3	03 4d da	 add	 ecx, DWORD PTR _DirectoryRecord$[ebp+2]
  000e6	33 d2		 xor	 edx, edx
  000e8	42		 inc	 edx
  000e9	e8 00 00 00 00	 call	 ?BlCdReadLogicalBlock@@YIXKKPAU_ISO9660_LOGICAL_BLOCK@@@Z ; BlCdReadLogicalBlock

; 510  : 
; 511  :         BlRtlCopyMemory(Next,
; 512  :                         Block.Data,
; 513  :                         NumberOfBytes);

  000ee	ff 75 08	 push	 DWORD PTR _NumberOfBytes$[ebp]
  000f1	8d 95 c8 f7 ff
	ff		 lea	 edx, DWORD PTR _Block$[ebp]
  000f7	8b 4d cc	 mov	 ecx, DWORD PTR _Next$[ebp]
  000fa	e8 00 00 00 00	 call	 ?BlRtlCopyMemory@@YIXPAXPBXK@Z ; BlRtlCopyMemory
$LN1@BlCdReadFi:

; 514  :     }
; 515  : 
; 516  :     return TRUE;

  000ff	b0 01		 mov	 al, 1
$LN8@BlCdReadFi:

; 517  : }

  00101	c9		 leave
  00102	c2 04 00	 ret	 4
?BlCdReadFile@@YIEPBDPAXK@Z ENDP			; BlCdReadFile
_TEXT	ENDS
PUBLIC	??_C@_0DB@HHGHCLEJ@CDROM?3?5Unable?5to?5find?5Joliet?5vol@ ; `string'
PUBLIC	??_C@_0CA@FBNAKALG@CDROM?3?5Unexpected?5sector?5size?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0CI@PDLGCFII@CDROM?3?5Unable?5to?5get?5drive?5param@ ; `string'
PUBLIC	?BlCdInitialize@@YIXE@Z				; BlCdInitialize
EXTRN	?BlFsReadFile@@3P6IEPBDPAXK@ZA:DWORD		; BlFsReadFile
EXTRN	?BlFsGetFileSize@@3P6IEPBDPAK@ZA:DWORD		; BlFsGetFileSize
EXTRN	?BlRtlGetDriveParameters@@YIEEPAU_INT13_DRIVE_PARAMETERS@@@Z:PROC ; BlRtlGetDriveParameters
;	COMDAT ??_C@_0DB@HHGHCLEJ@CDROM?3?5Unable?5to?5find?5Joliet?5vol@
CONST	SEGMENT
??_C@_0DB@HHGHCLEJ@CDROM?3?5Unable?5to?5find?5Joliet?5vol@ DB 'CDROM: Una'
	DB	'ble to find Joliet volume descriptor.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FBNAKALG@CDROM?3?5Unexpected?5sector?5size?$CB?6?$AA@
CONST	SEGMENT
??_C@_0CA@FBNAKALG@CDROM?3?5Unexpected?5sector?5size?$CB?6?$AA@ DB 'CDROM'
	DB	': Unexpected sector size!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@PDLGCFII@CDROM?3?5Unable?5to?5get?5drive?5param@
CONST	SEGMENT
??_C@_0CI@PDLGCFII@CDROM?3?5Unable?5to?5get?5drive?5param@ DB 'CDROM: Una'
	DB	'ble to get drive parameters!', 0aH, 00H	; `string'
; Function compile flags: /Odsp
CONST	ENDS
;	COMDAT ?BlCdInitialize@@YIXE@Z
_TEXT	SEGMENT
_DriveId$ = -8						; size = 1
_LogicalBlockNumber$ = -4				; size = 4
?BlCdInitialize@@YIXE@Z PROC				; BlCdInitialize, COMDAT
; _DriveId$ = cl

; 536  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	88 4d f8	 mov	 BYTE PTR _DriveId$[ebp], cl

; 537  :     UINT32 LogicalBlockNumber;
; 538  : 
; 539  :     BlCdDriveId = DriveId;

  00008	8a 45 f8	 mov	 al, BYTE PTR _DriveId$[ebp]
  0000b	a2 00 00 00 00	 mov	 BYTE PTR ?BlCdDriveId@@3EA, al ; BlCdDriveId

; 540  : 
; 541  :     if (BlRtlGetDriveParameters(BlCdDriveId, &BlCdDriveParameters) == FALSE) {

  00010	ba 00 00 00 00	 mov	 edx, OFFSET ?BlCdDriveParameters@@3U_INT13_DRIVE_PARAMETERS@@A ; BlCdDriveParameters
  00015	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?BlCdDriveId@@3EA ; BlCdDriveId
  0001b	e8 00 00 00 00	 call	 ?BlRtlGetDriveParameters@@YIEEPAU_INT13_DRIVE_PARAMETERS@@@Z ; BlRtlGetDriveParameters
  00020	0f b6 c0	 movzx	 eax, al
  00023	85 c0		 test	 eax, eax
  00025	75 1a		 jne	 SHORT $LN6@BlCdInitia

; 542  : 
; 543  :         BlRtlPrintf("CDROM: Unable to get drive parameters!\n");

  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@PDLGCFII@CDROM?3?5Unable?5to?5get?5drive?5param@
  0002c	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  00031	59		 pop	 ecx

; 544  :         BlRtlHalt();

  00032	ba 20 02 00 00	 mov	 edx, 544		; 00000220H
  00037	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0M@CKJPMOGI@blcdrom?4cpp?$AA@
  0003c	e8 00 00 00 00	 call	 ?BlRtlHaltInternal@@YIXPBDK@Z ; BlRtlHaltInternal
$LN6@BlCdInitia:

; 545  :     }
; 546  : 
; 547  :     if (BlCdDriveParameters.BytesPerSector != ISO9660_LOGICAL_BLOCK_SIZE) {

  00041	0f b7 05 18 00
	00 00		 movzx	 eax, WORD PTR ?BlCdDriveParameters@@3U_INT13_DRIVE_PARAMETERS@@A+24
  00048	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  0004d	74 1a		 je	 SHORT $LN5@BlCdInitia

; 548  : 
; 549  :         BlRtlPrintf("CDROM: Unexpected sector size!\n");

  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@FBNAKALG@CDROM?3?5Unexpected?5sector?5size?$CB?6?$AA@
  00054	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  00059	59		 pop	 ecx

; 550  :         BlRtlHalt();

  0005a	ba 26 02 00 00	 mov	 edx, 550		; 00000226H
  0005f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0M@CKJPMOGI@blcdrom?4cpp?$AA@
  00064	e8 00 00 00 00	 call	 ?BlRtlHaltInternal@@YIXPBDK@Z ; BlRtlHaltInternal
$LN5@BlCdInitia:

; 551  :     }
; 552  : 
; 553  :     //
; 554  :     // Locate Joliet volume descriptor.
; 555  :     //
; 556  : 
; 557  :     LogicalBlockNumber = ISO9660_VOLUME_SPACE_DATA_AREA_LBN;

  00069	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR _LogicalBlockNumber$[ebp], 16 ; 00000010H
$LN4@BlCdInitia:

; 558  : 
; 559  :     for (;;) {
; 560  : 
; 561  :         BlCdReadLogicalBlock(LogicalBlockNumber,
; 562  :                              1,
; 563  :                              (PISO9660_LOGICAL_BLOCK) &BlCdVolumeDescriptor);

  00070	68 00 00 00 00	 push	 OFFSET ?BlCdVolumeDescriptor@@3U_ISO9660_VOLUME_DESCRIPTOR@@A ; BlCdVolumeDescriptor
  00075	33 d2		 xor	 edx, edx
  00077	42		 inc	 edx
  00078	8b 4d fc	 mov	 ecx, DWORD PTR _LogicalBlockNumber$[ebp]
  0007b	e8 00 00 00 00	 call	 ?BlCdReadLogicalBlock@@YIXKKPAU_ISO9660_LOGICAL_BLOCK@@@Z ; BlCdReadLogicalBlock

; 564  : 
; 565  :         if ((BlCdVolumeDescriptor.u1.VolumeDescriptorType == ISO9660_VOLUME_DESCRIPTOR_TYPE_SUPPLEMENTARY) &&
; 566  :             (BlCdVolumeDescriptor.u1.Supplementary.EscapeSequences[0] == 0x25) &&
; 567  :             (BlCdVolumeDescriptor.u1.Supplementary.EscapeSequences[1] == 0x2F) &&
; 568  :             (BlCdVolumeDescriptor.u1.Supplementary.EscapeSequences[2] == 0x45)){

  00080	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?BlCdVolumeDescriptor@@3U_ISO9660_VOLUME_DESCRIPTOR@@A
  00087	83 f8 02	 cmp	 eax, 2
  0008a	75 26		 jne	 SHORT $LN2@BlCdInitia
  0008c	0f b6 05 58 00
	00 00		 movzx	 eax, BYTE PTR ?BlCdVolumeDescriptor@@3U_ISO9660_VOLUME_DESCRIPTOR@@A+88
  00093	83 f8 25	 cmp	 eax, 37			; 00000025H
  00096	75 1a		 jne	 SHORT $LN2@BlCdInitia
  00098	0f b6 05 59 00
	00 00		 movzx	 eax, BYTE PTR ?BlCdVolumeDescriptor@@3U_ISO9660_VOLUME_DESCRIPTOR@@A+89
  0009f	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  000a2	75 0e		 jne	 SHORT $LN2@BlCdInitia
  000a4	0f b6 05 5a 00
	00 00		 movzx	 eax, BYTE PTR ?BlCdVolumeDescriptor@@3U_ISO9660_VOLUME_DESCRIPTOR@@A+90
  000ab	83 f8 45	 cmp	 eax, 69			; 00000045H
  000ae	75 02		 jne	 SHORT $LN2@BlCdInitia

; 569  : 
; 570  :             break;

  000b0	eb 31		 jmp	 SHORT $LN3@BlCdInitia
$LN2@BlCdInitia:

; 571  :         }
; 572  : 
; 573  :         if (BlCdVolumeDescriptor.u1.VolumeDescriptorType == ISO9660_VOLUME_DESCRIPTOR_TYPE_TERMINATOR) {

  000b2	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?BlCdVolumeDescriptor@@3U_ISO9660_VOLUME_DESCRIPTOR@@A
  000b9	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000be	75 1a		 jne	 SHORT $LN1@BlCdInitia

; 574  : 
; 575  :             BlRtlPrintf("CDROM: Unable to find Joliet volume descriptor.\n");

  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@HHGHCLEJ@CDROM?3?5Unable?5to?5find?5Joliet?5vol@
  000c5	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  000ca	59		 pop	 ecx

; 576  :             BlRtlHalt();

  000cb	ba 40 02 00 00	 mov	 edx, 576		; 00000240H
  000d0	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0M@CKJPMOGI@blcdrom?4cpp?$AA@
  000d5	e8 00 00 00 00	 call	 ?BlRtlHaltInternal@@YIXPBDK@Z ; BlRtlHaltInternal
$LN1@BlCdInitia:

; 577  :         }
; 578  : 
; 579  :         LogicalBlockNumber += 1;

  000da	8b 45 fc	 mov	 eax, DWORD PTR _LogicalBlockNumber$[ebp]
  000dd	40		 inc	 eax
  000de	89 45 fc	 mov	 DWORD PTR _LogicalBlockNumber$[ebp], eax

; 580  :     }

  000e1	eb 8d		 jmp	 SHORT $LN4@BlCdInitia
$LN3@BlCdInitia:

; 581  : 
; 582  :     BlFsGetFileSize = BlCdGetFileSize;

  000e3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?BlFsGetFileSize@@3P6IEPBDPAK@ZA, OFFSET ?BlCdGetFileSize@@YIEPBDPAK@Z ; BlFsGetFileSize, BlCdGetFileSize

; 583  :     BlFsReadFile = BlCdReadFile;

  000ed	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?BlFsReadFile@@3P6IEPBDPAXK@ZA, OFFSET ?BlCdReadFile@@YIEPBDPAXK@Z ; BlFsReadFile, BlCdReadFile

; 584  : 
; 585  :     return;
; 586  : }

  000f7	c9		 leave
  000f8	c3		 ret	 0
?BlCdInitialize@@YIXE@Z ENDP				; BlCdInitialize
_TEXT	ENDS
END
