; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	C:\Users\cc\source\repos\Singularity-OS\base\Boot\SingLdrPc\blstring.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?BlRtlConvertCharacterToUpperCase@@YIDD@Z	; BlRtlConvertCharacterToUpperCase
; Function compile flags: /Odsp
; File c:\users\cc\source\repos\singularity-os\base\boot\singldrpc\blstring.cpp
;	COMDAT ?BlRtlConvertCharacterToUpperCase@@YIDD@Z
_TEXT	SEGMENT
_C$ = -4						; size = 1
?BlRtlConvertCharacterToUpperCase@@YIDD@Z PROC		; BlRtlConvertCharacterToUpperCase, COMDAT
; _C$ = cl

; 50   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	88 4d fc	 mov	 BYTE PTR _C$[ebp], cl

; 51   :     if ((C >= 'a') && (C <= 'z')) {

  00007	0f be 45 fc	 movsx	 eax, BYTE PTR _C$[ebp]
  0000b	83 f8 61	 cmp	 eax, 97			; 00000061H
  0000e	7c 12		 jl	 SHORT $LN1@BlRtlConve
  00010	0f be 45 fc	 movsx	 eax, BYTE PTR _C$[ebp]
  00014	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  00017	7f 09		 jg	 SHORT $LN1@BlRtlConve

; 52   : 
; 53   :         return C + 'A' - 'a';

  00019	0f be 45 fc	 movsx	 eax, BYTE PTR _C$[ebp]
  0001d	83 e8 20	 sub	 eax, 32			; 00000020H
  00020	eb 03		 jmp	 SHORT $LN2@BlRtlConve
$LN1@BlRtlConve:

; 54   :     }
; 55   : 
; 56   :     return C;

  00022	8a 45 fc	 mov	 al, BYTE PTR _C$[ebp]
$LN2@BlRtlConve:

; 57   : }

  00025	c9		 leave
  00026	c3		 ret	 0
?BlRtlConvertCharacterToUpperCase@@YIDD@Z ENDP		; BlRtlConvertCharacterToUpperCase
_TEXT	ENDS
PUBLIC	?BlRtlParsePositiveDecimal@@YIEPBDPAK1@Z	; BlRtlParsePositiveDecimal
; Function compile flags: /Odsp
;	COMDAT ?BlRtlParsePositiveDecimal@@YIEPBDPAK1@Z
_TEXT	SEGMENT
_Number$ = -20						; size = 4
_String$ = -16						; size = 4
_Digit$ = -12						; size = 4
_Temp$ = -8						; size = 4
_Index$ = -4						; size = 4
_CharactersConsumed$ = 8				; size = 4
?BlRtlParsePositiveDecimal@@YIEPBDPAK1@Z PROC		; BlRtlParsePositiveDecimal, COMDAT
; _String$ = ecx
; _Number$ = edx

; 88   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 55 ec	 mov	 DWORD PTR _Number$[ebp], edx
  00009	89 4d f0	 mov	 DWORD PTR _String$[ebp], ecx

; 89   :     UINT32 Digit;
; 90   :     UINT32 Index;
; 91   :     UINT32 Temp;
; 92   : 
; 93   :     if ((String[0] < '0') || (String[0] > '9')) {

  0000c	8b 45 f0	 mov	 eax, DWORD PTR _String$[ebp]
  0000f	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00012	83 f8 30	 cmp	 eax, 48			; 00000030H
  00015	7c 0b		 jl	 SHORT $LN6@BlRtlParse
  00017	8b 45 f0	 mov	 eax, DWORD PTR _String$[ebp]
  0001a	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0001d	83 f8 39	 cmp	 eax, 57			; 00000039H
  00020	7e 04		 jle	 SHORT $LN7@BlRtlParse
$LN6@BlRtlParse:

; 94   : 
; 95   :         return FALSE;

  00022	32 c0		 xor	 al, al
  00024	eb 6e		 jmp	 SHORT $LN8@BlRtlParse
$LN7@BlRtlParse:

; 96   :     }
; 97   : 
; 98   :     Index = 0;

  00026	83 65 fc 00	 and	 DWORD PTR _Index$[ebp], 0

; 99   :     Temp = 0;

  0002a	83 65 f8 00	 and	 DWORD PTR _Temp$[ebp], 0
$LN5@BlRtlParse:

; 100  : 
; 101  :     for (;;) {
; 102  : 
; 103  :         if ((String[Index] < '0') || (String[Index] > '9')) {

  0002e	8b 45 f0	 mov	 eax, DWORD PTR _String$[ebp]
  00031	03 45 fc	 add	 eax, DWORD PTR _Index$[ebp]
  00034	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00037	83 f8 30	 cmp	 eax, 48			; 00000030H
  0003a	7c 0e		 jl	 SHORT $LN2@BlRtlParse
  0003c	8b 45 f0	 mov	 eax, DWORD PTR _String$[ebp]
  0003f	03 45 fc	 add	 eax, DWORD PTR _Index$[ebp]
  00042	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00045	83 f8 39	 cmp	 eax, 57			; 00000039H
  00048	7e 14		 jle	 SHORT $LN3@BlRtlParse
$LN2@BlRtlParse:

; 104  : 
; 105  :             *Number = Temp;

  0004a	8b 45 ec	 mov	 eax, DWORD PTR _Number$[ebp]
  0004d	8b 4d f8	 mov	 ecx, DWORD PTR _Temp$[ebp]
  00050	89 08		 mov	 DWORD PTR [eax], ecx

; 106  :             *CharactersConsumed = Index;

  00052	8b 45 08	 mov	 eax, DWORD PTR _CharactersConsumed$[ebp]
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _Index$[ebp]
  00058	89 08		 mov	 DWORD PTR [eax], ecx

; 107  :             return TRUE;

  0005a	b0 01		 mov	 al, 1
  0005c	eb 36		 jmp	 SHORT $LN8@BlRtlParse
$LN3@BlRtlParse:

; 108  :         }
; 109  : 
; 110  :         Digit = String[Index] - '0';

  0005e	8b 45 f0	 mov	 eax, DWORD PTR _String$[ebp]
  00061	03 45 fc	 add	 eax, DWORD PTR _Index$[ebp]
  00064	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00067	83 e8 30	 sub	 eax, 48			; 00000030H
  0006a	89 45 f4	 mov	 DWORD PTR _Digit$[ebp], eax

; 111  : 
; 112  :         if (((Temp * 10) + Digit) < Temp) {

  0006d	8b 45 f8	 mov	 eax, DWORD PTR _Temp$[ebp]
  00070	6b c0 0a	 imul	 eax, 10			; 0000000aH
  00073	03 45 f4	 add	 eax, DWORD PTR _Digit$[ebp]
  00076	3b 45 f8	 cmp	 eax, DWORD PTR _Temp$[ebp]
  00079	73 04		 jae	 SHORT $LN1@BlRtlParse

; 113  : 
; 114  :             return FALSE;

  0007b	32 c0		 xor	 al, al
  0007d	eb 15		 jmp	 SHORT $LN8@BlRtlParse
$LN1@BlRtlParse:

; 115  :         }
; 116  : 
; 117  :         Temp = (Temp * 10) + Digit;

  0007f	8b 45 f8	 mov	 eax, DWORD PTR _Temp$[ebp]
  00082	6b c0 0a	 imul	 eax, 10			; 0000000aH
  00085	03 45 f4	 add	 eax, DWORD PTR _Digit$[ebp]
  00088	89 45 f8	 mov	 DWORD PTR _Temp$[ebp], eax

; 118  :         Index += 1;

  0008b	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  0008e	40		 inc	 eax
  0008f	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax

; 119  :     }

  00092	eb 9a		 jmp	 SHORT $LN5@BlRtlParse
$LN8@BlRtlParse:

; 120  : }

  00094	c9		 leave
  00095	c2 04 00	 ret	 4
?BlRtlParsePositiveDecimal@@YIEPBDPAK1@Z ENDP		; BlRtlParsePositiveDecimal
_TEXT	ENDS
PUBLIC	??_C@_01PAPGNFGE@c?$AA@				; `string'
PUBLIC	??_C@_01LKDEMHDF@s?$AA@				; `string'
PUBLIC	??_C@_01JBBJJEPG@p?$AA@				; `string'
PUBLIC	??_C@_04HNPKCLBF@I64x?$AA@			; `string'
PUBLIC	??_C@_04MIFEFFFI@I64u?$AA@			; `string'
PUBLIC	??_C@_04JLINHGEI@I64d?$AA@			; `string'
PUBLIC	??_C@_01FJMABOPO@x?$AA@				; `string'
PUBLIC	??_C@_01OMGOGALD@u?$AA@				; `string'
PUBLIC	?BlRtlEqualStringN@@YIEPBD0K@Z			; BlRtlEqualStringN
PUBLIC	??_C@_01LPLHEDKD@d?$AA@				; `string'
PUBLIC	?BlRtlParseTypeSpecifier@@YIEPBDPAJPADPAEPAK@Z	; BlRtlParseTypeSpecifier
;	COMDAT ??_C@_01PAPGNFGE@c?$AA@
CONST	SEGMENT
??_C@_01PAPGNFGE@c?$AA@ DB 'c', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LKDEMHDF@s?$AA@
CONST	SEGMENT
??_C@_01LKDEMHDF@s?$AA@ DB 's', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JBBJJEPG@p?$AA@
CONST	SEGMENT
??_C@_01JBBJJEPG@p?$AA@ DB 'p', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HNPKCLBF@I64x?$AA@
CONST	SEGMENT
??_C@_04HNPKCLBF@I64x?$AA@ DB 'I64x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MIFEFFFI@I64u?$AA@
CONST	SEGMENT
??_C@_04MIFEFFFI@I64u?$AA@ DB 'I64u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JLINHGEI@I64d?$AA@
CONST	SEGMENT
??_C@_04JLINHGEI@I64d?$AA@ DB 'I64d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01FJMABOPO@x?$AA@
CONST	SEGMENT
??_C@_01FJMABOPO@x?$AA@ DB 'x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01OMGOGALD@u?$AA@
CONST	SEGMENT
??_C@_01OMGOGALD@u?$AA@ DB 'u', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LPLHEDKD@d?$AA@
CONST	SEGMENT
??_C@_01LPLHEDKD@d?$AA@ DB 'd', 00H			; `string'
; Function compile flags: /Odsp
CONST	ENDS
;	COMDAT ?BlRtlParseTypeSpecifier@@YIEPBDPAJPADPAEPAK@Z
_TEXT	SEGMENT
tv88 = -29						; size = 1
_Width$ = -28						; size = 4
_String$ = -24						; size = 4
_Advance$ = -20						; size = 4
_Zero$ = -14						; size = 1
_WidthPresent$ = -13					; size = 1
_WidthPositiveValue$ = -12				; size = 4
_Index$ = -8						; size = 4
_Minus$ = -1						; size = 1
_PadCharacter$ = 8					; size = 4
_TokenType$ = 12					; size = 4
_CharactersConsumed$ = 16				; size = 4
?BlRtlParseTypeSpecifier@@YIEPBDPAJPADPAEPAK@Z PROC	; BlRtlParseTypeSpecifier, COMDAT
; _String$ = ecx
; _Width$ = edx

; 157  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 55 e4	 mov	 DWORD PTR _Width$[ebp], edx
  00009	89 4d e8	 mov	 DWORD PTR _String$[ebp], ecx

; 158  :     UINT32 Advance;
; 159  :     BOOLEAN WidthPresent;
; 160  :     UINT32 Index;
; 161  :     BOOLEAN Minus;
; 162  :     UINT32 WidthPositiveValue;
; 163  :     BOOLEAN Zero;
; 164  : 
; 165  :     SATISFY_OVERZEALOUS_COMPILER(WidthPositiveValue = 0);

  0000c	83 65 f4 00	 and	 DWORD PTR _WidthPositiveValue$[ebp], 0

; 166  : 
; 167  :     //
; 168  :     // Check if type specifier character is present.
; 169  :     //
; 170  : 
; 171  :     if (String[0] != '%') {

  00010	8b 45 e8	 mov	 eax, DWORD PTR _String$[ebp]
  00013	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00016	83 f8 25	 cmp	 eax, 37			; 00000025H
  00019	74 07		 je	 SHORT $LN38@BlRtlParse@2

; 172  : 
; 173  :         return FALSE;

  0001b	32 c0		 xor	 al, al
  0001d	e9 c7 02 00 00	 jmp	 $LN39@BlRtlParse@2
$LN38@BlRtlParse@2:

; 174  :     }
; 175  : 
; 176  :     Index = 1;

  00022	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _Index$[ebp], 1

; 177  : 
; 178  :     //
; 179  :     // Check for pad modifiers.
; 180  :     //
; 181  : 
; 182  :     Minus = FALSE;

  00029	c6 45 ff 00	 mov	 BYTE PTR _Minus$[ebp], 0

; 183  :     Zero = FALSE;

  0002d	c6 45 f2 00	 mov	 BYTE PTR _Zero$[ebp], 0
$LN37@BlRtlParse@2:

; 184  : 
; 185  :     for (;;) {
; 186  : 
; 187  :         if (String[Index] == '-') {

  00031	8b 45 e8	 mov	 eax, DWORD PTR _String$[ebp]
  00034	03 45 f8	 add	 eax, DWORD PTR _Index$[ebp]
  00037	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0003a	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0003d	75 1c		 jne	 SHORT $LN35@BlRtlParse@2

; 188  : 
; 189  :             if (Minus != FALSE) {

  0003f	0f b6 45 ff	 movzx	 eax, BYTE PTR _Minus$[ebp]
  00043	85 c0		 test	 eax, eax
  00045	74 07		 je	 SHORT $LN34@BlRtlParse@2

; 190  : 
; 191  :                 return FALSE;

  00047	32 c0		 xor	 al, al
  00049	e9 9b 02 00 00	 jmp	 $LN39@BlRtlParse@2
$LN34@BlRtlParse@2:

; 192  :             }
; 193  : 
; 194  :             Minus = TRUE;

  0004e	c6 45 ff 01	 mov	 BYTE PTR _Minus$[ebp], 1

; 195  :             Index += 1;

  00052	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  00055	40		 inc	 eax
  00056	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax
  00059	eb 2c		 jmp	 SHORT $LN33@BlRtlParse@2
$LN35@BlRtlParse@2:

; 196  : 
; 197  :         } else if (String[Index] == '0') {

  0005b	8b 45 e8	 mov	 eax, DWORD PTR _String$[ebp]
  0005e	03 45 f8	 add	 eax, DWORD PTR _Index$[ebp]
  00061	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00064	83 f8 30	 cmp	 eax, 48			; 00000030H
  00067	75 1c		 jne	 SHORT $LN32@BlRtlParse@2

; 198  : 
; 199  :             if (Zero != FALSE) {

  00069	0f b6 45 f2	 movzx	 eax, BYTE PTR _Zero$[ebp]
  0006d	85 c0		 test	 eax, eax
  0006f	74 07		 je	 SHORT $LN31@BlRtlParse@2

; 200  : 
; 201  :                 return FALSE;

  00071	32 c0		 xor	 al, al
  00073	e9 71 02 00 00	 jmp	 $LN39@BlRtlParse@2
$LN31@BlRtlParse@2:

; 202  :             }
; 203  : 
; 204  :             Zero = TRUE;

  00078	c6 45 f2 01	 mov	 BYTE PTR _Zero$[ebp], 1

; 205  :             Index += 1;

  0007c	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  0007f	40		 inc	 eax
  00080	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax

; 206  : 
; 207  :         } else {

  00083	eb 02		 jmp	 SHORT $LN33@BlRtlParse@2
$LN32@BlRtlParse@2:

; 208  : 
; 209  :             break;

  00085	eb 02		 jmp	 SHORT $LN36@BlRtlParse@2
$LN33@BlRtlParse@2:

; 210  :         }
; 211  :     }

  00087	eb a8		 jmp	 SHORT $LN37@BlRtlParse@2
$LN36@BlRtlParse@2:

; 212  : 
; 213  :     //
; 214  :     // - and 0 pad modifiers are mutually exclusive.
; 215  :     //
; 216  : 
; 217  :     if ((Minus != FALSE) && (Zero != FALSE)) {

  00089	0f b6 45 ff	 movzx	 eax, BYTE PTR _Minus$[ebp]
  0008d	85 c0		 test	 eax, eax
  0008f	74 0f		 je	 SHORT $LN29@BlRtlParse@2
  00091	0f b6 45 f2	 movzx	 eax, BYTE PTR _Zero$[ebp]
  00095	85 c0		 test	 eax, eax
  00097	74 07		 je	 SHORT $LN29@BlRtlParse@2

; 218  : 
; 219  :         return FALSE;

  00099	32 c0		 xor	 al, al
  0009b	e9 49 02 00 00	 jmp	 $LN39@BlRtlParse@2
$LN29@BlRtlParse@2:

; 220  :     }
; 221  : 
; 222  :     //
; 223  :     // If there is a width value, then parse it.
; 224  :     //
; 225  : 
; 226  :     WidthPresent = ((String[Index] >= '1') && (String[Index] <= '9'));

  000a0	8b 45 e8	 mov	 eax, DWORD PTR _String$[ebp]
  000a3	03 45 f8	 add	 eax, DWORD PTR _Index$[ebp]
  000a6	0f be 00	 movsx	 eax, BYTE PTR [eax]
  000a9	83 f8 31	 cmp	 eax, 49			; 00000031H
  000ac	7c 14		 jl	 SHORT $LN41@BlRtlParse@2
  000ae	8b 45 e8	 mov	 eax, DWORD PTR _String$[ebp]
  000b1	03 45 f8	 add	 eax, DWORD PTR _Index$[ebp]
  000b4	0f be 00	 movsx	 eax, BYTE PTR [eax]
  000b7	83 f8 39	 cmp	 eax, 57			; 00000039H
  000ba	7f 06		 jg	 SHORT $LN41@BlRtlParse@2
  000bc	c6 45 e3 01	 mov	 BYTE PTR tv88[ebp], 1
  000c0	eb 04		 jmp	 SHORT $LN42@BlRtlParse@2
$LN41@BlRtlParse@2:
  000c2	c6 45 e3 00	 mov	 BYTE PTR tv88[ebp], 0
$LN42@BlRtlParse@2:
  000c6	8a 45 e3	 mov	 al, BYTE PTR tv88[ebp]
  000c9	88 45 f3	 mov	 BYTE PTR _WidthPresent$[ebp], al

; 227  : 
; 228  :     if (WidthPresent != FALSE) {

  000cc	0f b6 45 f3	 movzx	 eax, BYTE PTR _WidthPresent$[ebp]
  000d0	85 c0		 test	 eax, eax
  000d2	74 29		 je	 SHORT $LN28@BlRtlParse@2

; 229  : 
; 230  :         if (BlRtlParsePositiveDecimal(&String[Index],
; 231  :                                       &WidthPositiveValue,
; 232  :                                       &Advance) == FALSE) {

  000d4	8d 45 ec	 lea	 eax, DWORD PTR _Advance$[ebp]
  000d7	50		 push	 eax
  000d8	8b 4d e8	 mov	 ecx, DWORD PTR _String$[ebp]
  000db	03 4d f8	 add	 ecx, DWORD PTR _Index$[ebp]
  000de	8d 55 f4	 lea	 edx, DWORD PTR _WidthPositiveValue$[ebp]
  000e1	e8 00 00 00 00	 call	 ?BlRtlParsePositiveDecimal@@YIEPBDPAK1@Z ; BlRtlParsePositiveDecimal
  000e6	0f b6 c0	 movzx	 eax, al
  000e9	85 c0		 test	 eax, eax
  000eb	75 07		 jne	 SHORT $LN27@BlRtlParse@2

; 233  : 
; 234  :             return FALSE;

  000ed	32 c0		 xor	 al, al
  000ef	e9 f5 01 00 00	 jmp	 $LN39@BlRtlParse@2
$LN27@BlRtlParse@2:

; 235  :         }
; 236  : 
; 237  :         Index += Advance;

  000f4	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  000f7	03 45 ec	 add	 eax, DWORD PTR _Advance$[ebp]
  000fa	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax
$LN28@BlRtlParse@2:

; 238  :     }
; 239  : 
; 240  :     //
; 241  :     // Pad modifiers require width value.
; 242  :     //
; 243  : 
; 244  :     if (((Minus != FALSE) || (Zero != FALSE)) && (WidthPresent == FALSE)) {

  000fd	0f b6 45 ff	 movzx	 eax, BYTE PTR _Minus$[ebp]
  00101	85 c0		 test	 eax, eax
  00103	75 08		 jne	 SHORT $LN25@BlRtlParse@2
  00105	0f b6 45 f2	 movzx	 eax, BYTE PTR _Zero$[ebp]
  00109	85 c0		 test	 eax, eax
  0010b	74 0f		 je	 SHORT $LN26@BlRtlParse@2
$LN25@BlRtlParse@2:
  0010d	0f b6 45 f3	 movzx	 eax, BYTE PTR _WidthPresent$[ebp]
  00111	85 c0		 test	 eax, eax
  00113	75 07		 jne	 SHORT $LN26@BlRtlParse@2

; 245  : 
; 246  :         return FALSE;

  00115	32 c0		 xor	 al, al
  00117	e9 cd 01 00 00	 jmp	 $LN39@BlRtlParse@2
$LN26@BlRtlParse@2:

; 247  :     }
; 248  : 
; 249  :     //
; 250  :     // Set pad character.
; 251  :     //
; 252  : 
; 253  :     if (Zero != FALSE) {

  0011c	0f b6 45 f2	 movzx	 eax, BYTE PTR _Zero$[ebp]
  00120	85 c0		 test	 eax, eax
  00122	74 08		 je	 SHORT $LN24@BlRtlParse@2

; 254  : 
; 255  :         *PadCharacter = '0';

  00124	8b 45 08	 mov	 eax, DWORD PTR _PadCharacter$[ebp]
  00127	c6 00 30	 mov	 BYTE PTR [eax], 48	; 00000030H

; 256  : 
; 257  :     } else {

  0012a	eb 06		 jmp	 SHORT $LN23@BlRtlParse@2
$LN24@BlRtlParse@2:

; 258  : 
; 259  :         *PadCharacter = ' ';

  0012c	8b 45 08	 mov	 eax, DWORD PTR _PadCharacter$[ebp]
  0012f	c6 00 20	 mov	 BYTE PTR [eax], 32	; 00000020H
$LN23@BlRtlParse@2:

; 260  :     }
; 261  : 
; 262  :     //
; 263  :     // Compute signed width value.
; 264  :     //
; 265  : 
; 266  :     if (WidthPresent == FALSE) {

  00132	0f b6 45 f3	 movzx	 eax, BYTE PTR _WidthPresent$[ebp]
  00136	85 c0		 test	 eax, eax
  00138	75 08		 jne	 SHORT $LN22@BlRtlParse@2

; 267  : 
; 268  :         *Width = 0;

  0013a	8b 45 e4	 mov	 eax, DWORD PTR _Width$[ebp]
  0013d	83 20 00	 and	 DWORD PTR [eax], 0
  00140	eb 1c		 jmp	 SHORT $LN21@BlRtlParse@2
$LN22@BlRtlParse@2:

; 269  : 
; 270  :     } else if (Minus == FALSE) {

  00142	0f b6 45 ff	 movzx	 eax, BYTE PTR _Minus$[ebp]
  00146	85 c0		 test	 eax, eax
  00148	75 0a		 jne	 SHORT $LN20@BlRtlParse@2

; 271  : 
; 272  :         *Width = (INT32) WidthPositiveValue;

  0014a	8b 45 e4	 mov	 eax, DWORD PTR _Width$[ebp]
  0014d	8b 4d f4	 mov	 ecx, DWORD PTR _WidthPositiveValue$[ebp]
  00150	89 08		 mov	 DWORD PTR [eax], ecx

; 273  : 
; 274  :     } else {

  00152	eb 0a		 jmp	 SHORT $LN21@BlRtlParse@2
$LN20@BlRtlParse@2:

; 275  : 
; 276  :         *Width = -((INT32) WidthPositiveValue);

  00154	8b 45 f4	 mov	 eax, DWORD PTR _WidthPositiveValue$[ebp]
  00157	f7 d8		 neg	 eax
  00159	8b 4d e4	 mov	 ecx, DWORD PTR _Width$[ebp]
  0015c	89 01		 mov	 DWORD PTR [ecx], eax
$LN21@BlRtlParse@2:

; 277  :     }
; 278  : 
; 279  :     //
; 280  :     // Set type character.
; 281  :     //
; 282  : 
; 283  :     if (BlRtlEqualStringN(&String[Index], "d", 1) != FALSE) {

  0015e	6a 01		 push	 1
  00160	8b 4d e8	 mov	 ecx, DWORD PTR _String$[ebp]
  00163	03 4d f8	 add	 ecx, DWORD PTR _Index$[ebp]
  00166	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01LPLHEDKD@d?$AA@
  0016b	e8 00 00 00 00	 call	 ?BlRtlEqualStringN@@YIEPBD0K@Z ; BlRtlEqualStringN
  00170	0f b6 c0	 movzx	 eax, al
  00173	85 c0		 test	 eax, eax
  00175	74 12		 je	 SHORT $LN18@BlRtlParse@2

; 284  : 
; 285  :         *TokenType = STRING_TOKEN_LONG;

  00177	8b 45 0c	 mov	 eax, DWORD PTR _TokenType$[ebp]
  0017a	c6 00 01	 mov	 BYTE PTR [eax], 1

; 286  :         Index += 1;

  0017d	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  00180	40		 inc	 eax
  00181	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax
  00184	e9 56 01 00 00	 jmp	 $LN17@BlRtlParse@2
$LN18@BlRtlParse@2:

; 287  : 
; 288  :     } else if (BlRtlEqualStringN(&String[Index], "u", 1) != FALSE) {

  00189	6a 01		 push	 1
  0018b	8b 4d e8	 mov	 ecx, DWORD PTR _String$[ebp]
  0018e	03 4d f8	 add	 ecx, DWORD PTR _Index$[ebp]
  00191	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01OMGOGALD@u?$AA@
  00196	e8 00 00 00 00	 call	 ?BlRtlEqualStringN@@YIEPBD0K@Z ; BlRtlEqualStringN
  0019b	0f b6 c0	 movzx	 eax, al
  0019e	85 c0		 test	 eax, eax
  001a0	74 12		 je	 SHORT $LN16@BlRtlParse@2

; 289  : 
; 290  :         *TokenType = STRING_TOKEN_ULONG;

  001a2	8b 45 0c	 mov	 eax, DWORD PTR _TokenType$[ebp]
  001a5	c6 00 02	 mov	 BYTE PTR [eax], 2

; 291  :         Index += 1;

  001a8	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  001ab	40		 inc	 eax
  001ac	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax
  001af	e9 2b 01 00 00	 jmp	 $LN17@BlRtlParse@2
$LN16@BlRtlParse@2:

; 292  : 
; 293  :     } else if (BlRtlEqualStringN(&String[Index], "x", 1) != FALSE) {

  001b4	6a 01		 push	 1
  001b6	8b 4d e8	 mov	 ecx, DWORD PTR _String$[ebp]
  001b9	03 4d f8	 add	 ecx, DWORD PTR _Index$[ebp]
  001bc	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01FJMABOPO@x?$AA@
  001c1	e8 00 00 00 00	 call	 ?BlRtlEqualStringN@@YIEPBD0K@Z ; BlRtlEqualStringN
  001c6	0f b6 c0	 movzx	 eax, al
  001c9	85 c0		 test	 eax, eax
  001cb	74 12		 je	 SHORT $LN14@BlRtlParse@2

; 294  : 
; 295  :         *TokenType = STRING_TOKEN_ULONG_HEX;

  001cd	8b 45 0c	 mov	 eax, DWORD PTR _TokenType$[ebp]
  001d0	c6 00 03	 mov	 BYTE PTR [eax], 3

; 296  :         Index += 1;

  001d3	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  001d6	40		 inc	 eax
  001d7	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax
  001da	e9 00 01 00 00	 jmp	 $LN17@BlRtlParse@2
$LN14@BlRtlParse@2:

; 297  : 
; 298  :     } else if (BlRtlEqualStringN(&String[Index], "I64d", 4) != FALSE) {

  001df	6a 04		 push	 4
  001e1	8b 4d e8	 mov	 ecx, DWORD PTR _String$[ebp]
  001e4	03 4d f8	 add	 ecx, DWORD PTR _Index$[ebp]
  001e7	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_04JLINHGEI@I64d?$AA@
  001ec	e8 00 00 00 00	 call	 ?BlRtlEqualStringN@@YIEPBD0K@Z ; BlRtlEqualStringN
  001f1	0f b6 c0	 movzx	 eax, al
  001f4	85 c0		 test	 eax, eax
  001f6	74 14		 je	 SHORT $LN12@BlRtlParse@2

; 299  : 
; 300  :         *TokenType = STRING_TOKEN_LONGLONG;

  001f8	8b 45 0c	 mov	 eax, DWORD PTR _TokenType$[ebp]
  001fb	c6 00 04	 mov	 BYTE PTR [eax], 4

; 301  :         Index += 4;

  001fe	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  00201	83 c0 04	 add	 eax, 4
  00204	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax
  00207	e9 d3 00 00 00	 jmp	 $LN17@BlRtlParse@2
$LN12@BlRtlParse@2:

; 302  : 
; 303  :     } else if (BlRtlEqualStringN(&String[Index], "I64u", 4) != FALSE) {

  0020c	6a 04		 push	 4
  0020e	8b 4d e8	 mov	 ecx, DWORD PTR _String$[ebp]
  00211	03 4d f8	 add	 ecx, DWORD PTR _Index$[ebp]
  00214	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_04MIFEFFFI@I64u?$AA@
  00219	e8 00 00 00 00	 call	 ?BlRtlEqualStringN@@YIEPBD0K@Z ; BlRtlEqualStringN
  0021e	0f b6 c0	 movzx	 eax, al
  00221	85 c0		 test	 eax, eax
  00223	74 14		 je	 SHORT $LN10@BlRtlParse@2

; 304  : 
; 305  :         *TokenType = STRING_TOKEN_ULONGLONG;

  00225	8b 45 0c	 mov	 eax, DWORD PTR _TokenType$[ebp]
  00228	c6 00 05	 mov	 BYTE PTR [eax], 5

; 306  :         Index += 4;

  0022b	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  0022e	83 c0 04	 add	 eax, 4
  00231	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax
  00234	e9 a6 00 00 00	 jmp	 $LN17@BlRtlParse@2
$LN10@BlRtlParse@2:

; 307  : 
; 308  :     } else if (BlRtlEqualStringN(&String[Index], "I64x", 4) != FALSE) {

  00239	6a 04		 push	 4
  0023b	8b 4d e8	 mov	 ecx, DWORD PTR _String$[ebp]
  0023e	03 4d f8	 add	 ecx, DWORD PTR _Index$[ebp]
  00241	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_04HNPKCLBF@I64x?$AA@
  00246	e8 00 00 00 00	 call	 ?BlRtlEqualStringN@@YIEPBD0K@Z ; BlRtlEqualStringN
  0024b	0f b6 c0	 movzx	 eax, al
  0024e	85 c0		 test	 eax, eax
  00250	74 11		 je	 SHORT $LN8@BlRtlParse@2

; 309  : 
; 310  :         *TokenType = STRING_TOKEN_ULONGLONG_HEX;

  00252	8b 45 0c	 mov	 eax, DWORD PTR _TokenType$[ebp]
  00255	c6 00 06	 mov	 BYTE PTR [eax], 6

; 311  :         Index += 4;

  00258	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  0025b	83 c0 04	 add	 eax, 4
  0025e	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax
  00261	eb 7c		 jmp	 SHORT $LN17@BlRtlParse@2
$LN8@BlRtlParse@2:

; 312  : 
; 313  :     } else if (BlRtlEqualStringN(&String[Index], "p", 1) != FALSE) {

  00263	6a 01		 push	 1
  00265	8b 4d e8	 mov	 ecx, DWORD PTR _String$[ebp]
  00268	03 4d f8	 add	 ecx, DWORD PTR _Index$[ebp]
  0026b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01JBBJJEPG@p?$AA@
  00270	e8 00 00 00 00	 call	 ?BlRtlEqualStringN@@YIEPBD0K@Z ; BlRtlEqualStringN
  00275	0f b6 c0	 movzx	 eax, al
  00278	85 c0		 test	 eax, eax
  0027a	74 0f		 je	 SHORT $LN6@BlRtlParse@2

; 314  : 
; 315  :         *TokenType = STRING_TOKEN_PVOID;

  0027c	8b 45 0c	 mov	 eax, DWORD PTR _TokenType$[ebp]
  0027f	c6 00 07	 mov	 BYTE PTR [eax], 7

; 316  :         Index += 1;

  00282	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  00285	40		 inc	 eax
  00286	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax
  00289	eb 54		 jmp	 SHORT $LN17@BlRtlParse@2
$LN6@BlRtlParse@2:

; 317  : 
; 318  :     } else if (BlRtlEqualStringN(&String[Index], "s", 1) != FALSE) {

  0028b	6a 01		 push	 1
  0028d	8b 4d e8	 mov	 ecx, DWORD PTR _String$[ebp]
  00290	03 4d f8	 add	 ecx, DWORD PTR _Index$[ebp]
  00293	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01LKDEMHDF@s?$AA@
  00298	e8 00 00 00 00	 call	 ?BlRtlEqualStringN@@YIEPBD0K@Z ; BlRtlEqualStringN
  0029d	0f b6 c0	 movzx	 eax, al
  002a0	85 c0		 test	 eax, eax
  002a2	74 0f		 je	 SHORT $LN4@BlRtlParse@2

; 319  : 
; 320  :         *TokenType = STRING_TOKEN_PCHAR;

  002a4	8b 45 0c	 mov	 eax, DWORD PTR _TokenType$[ebp]
  002a7	c6 00 08	 mov	 BYTE PTR [eax], 8

; 321  :         Index += 1;

  002aa	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  002ad	40		 inc	 eax
  002ae	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax
  002b1	eb 2c		 jmp	 SHORT $LN17@BlRtlParse@2
$LN4@BlRtlParse@2:

; 322  : 
; 323  :     } else if (BlRtlEqualStringN(&String[Index], "c", 1) != FALSE) {

  002b3	6a 01		 push	 1
  002b5	8b 4d e8	 mov	 ecx, DWORD PTR _String$[ebp]
  002b8	03 4d f8	 add	 ecx, DWORD PTR _Index$[ebp]
  002bb	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01PAPGNFGE@c?$AA@
  002c0	e8 00 00 00 00	 call	 ?BlRtlEqualStringN@@YIEPBD0K@Z ; BlRtlEqualStringN
  002c5	0f b6 c0	 movzx	 eax, al
  002c8	85 c0		 test	 eax, eax
  002ca	74 0f		 je	 SHORT $LN2@BlRtlParse@2

; 324  : 
; 325  :         *TokenType = STRING_TOKEN_CHAR;

  002cc	8b 45 0c	 mov	 eax, DWORD PTR _TokenType$[ebp]
  002cf	c6 00 09	 mov	 BYTE PTR [eax], 9

; 326  :         Index += 1;

  002d2	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  002d5	40		 inc	 eax
  002d6	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax

; 327  : 
; 328  :     } else {

  002d9	eb 04		 jmp	 SHORT $LN17@BlRtlParse@2
$LN2@BlRtlParse@2:

; 329  : 
; 330  :         return FALSE;

  002db	32 c0		 xor	 al, al
  002dd	eb 0a		 jmp	 SHORT $LN39@BlRtlParse@2
$LN17@BlRtlParse@2:

; 331  :     }
; 332  : 
; 333  :     //
; 334  :     // Set number of characters consumed.
; 335  :     //
; 336  : 
; 337  :     *CharactersConsumed = Index;

  002df	8b 45 10	 mov	 eax, DWORD PTR _CharactersConsumed$[ebp]
  002e2	8b 4d f8	 mov	 ecx, DWORD PTR _Index$[ebp]
  002e5	89 08		 mov	 DWORD PTR [eax], ecx

; 338  : 
; 339  :     return TRUE;

  002e7	b0 01		 mov	 al, 1
$LN39@BlRtlParse@2:

; 340  : }

  002e9	c9		 leave
  002ea	c2 0c 00	 ret	 12			; 0000000cH
?BlRtlParseTypeSpecifier@@YIEPBDPAJPADPAEPAK@Z ENDP	; BlRtlParseTypeSpecifier
_TEXT	ENDS
PUBLIC	?BlRtlFormatSignedDecimalLong@@YIEPADKJJPAK@Z	; BlRtlFormatSignedDecimalLong
; Function compile flags: /Odsp
;	COMDAT ?BlRtlFormatSignedDecimalLong@@YIEPADKJJPAK@Z
_TEXT	SEGMENT
tv89 = -44						; size = 4
tv77 = -40						; size = 4
tv68 = -36						; size = 4
_OutputSize$ = -32					; size = 4
_Output$ = -28						; size = 4
_Temp$ = -24						; size = 4
_MinimumWidth$ = -20					; size = 4
_PadWidth$ = -16					; size = 4
_NumberWidth$ = -12					; size = 4
_Index$ = -8						; size = 4
_Minus$ = -1						; size = 1
_Value$ = 8						; size = 4
_Width$ = 12						; size = 4
_CharactersConsumed$ = 16				; size = 4
?BlRtlFormatSignedDecimalLong@@YIEPADKJJPAK@Z PROC	; BlRtlFormatSignedDecimalLong, COMDAT
; _Output$ = ecx
; _OutputSize$ = edx

; 377  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 55 e0	 mov	 DWORD PTR _OutputSize$[ebp], edx
  00009	89 4d e4	 mov	 DWORD PTR _Output$[ebp], ecx

; 378  :     UINT32 Index;
; 379  :     UINT32 MinimumWidth;
; 380  :     BOOLEAN Minus;
; 381  :     UINT32 NumberWidth;
; 382  :     UINT32 PadWidth;
; 383  :     UINT32 Temp;
; 384  : 
; 385  :     //
; 386  :     // Check if this is a negative value.
; 387  :     //
; 388  : 
; 389  :     Minus = (BOOLEAN) (Value < 0);

  0000c	83 7d 08 00	 cmp	 DWORD PTR _Value$[ebp], 0
  00010	0f 9c c0	 setl	 al
  00013	88 45 ff	 mov	 BYTE PTR _Minus$[ebp], al

; 390  : 
; 391  :     //
; 392  :     // Compute the number of characters necessary.
; 393  :     //
; 394  : 
; 395  :     Temp = ABS(Value);

  00016	83 7d 08 00	 cmp	 DWORD PTR _Value$[ebp], 0
  0001a	7d 0a		 jge	 SHORT $LN18@BlRtlForma
  0001c	8b 45 08	 mov	 eax, DWORD PTR _Value$[ebp]
  0001f	f7 d8		 neg	 eax
  00021	89 45 dc	 mov	 DWORD PTR tv68[ebp], eax
  00024	eb 06		 jmp	 SHORT $LN19@BlRtlForma
$LN18@BlRtlForma:
  00026	8b 45 08	 mov	 eax, DWORD PTR _Value$[ebp]
  00029	89 45 dc	 mov	 DWORD PTR tv68[ebp], eax
$LN19@BlRtlForma:
  0002c	8b 45 dc	 mov	 eax, DWORD PTR tv68[ebp]
  0002f	89 45 e8	 mov	 DWORD PTR _Temp$[ebp], eax

; 396  :     NumberWidth = 0;

  00032	83 65 f4 00	 and	 DWORD PTR _NumberWidth$[ebp], 0
$LN15@BlRtlForma:

; 397  : 
; 398  :     do {
; 399  : 
; 400  :         NumberWidth += 1;

  00036	8b 45 f4	 mov	 eax, DWORD PTR _NumberWidth$[ebp]
  00039	40		 inc	 eax
  0003a	89 45 f4	 mov	 DWORD PTR _NumberWidth$[ebp], eax

; 401  :         Temp = Temp / 10;

  0003d	8b 45 e8	 mov	 eax, DWORD PTR _Temp$[ebp]
  00040	33 d2		 xor	 edx, edx
  00042	6a 0a		 push	 10			; 0000000aH
  00044	59		 pop	 ecx
  00045	f7 f1		 div	 ecx
  00047	89 45 e8	 mov	 DWORD PTR _Temp$[ebp], eax

; 402  : 
; 403  :     } while (Temp > 0);

  0004a	83 7d e8 00	 cmp	 DWORD PTR _Temp$[ebp], 0
  0004e	77 e6		 ja	 SHORT $LN15@BlRtlForma

; 404  : 
; 405  :     if (Minus != FALSE) {

  00050	0f b6 45 ff	 movzx	 eax, BYTE PTR _Minus$[ebp]
  00054	85 c0		 test	 eax, eax
  00056	74 07		 je	 SHORT $LN12@BlRtlForma

; 406  : 
; 407  :         NumberWidth += 1;

  00058	8b 45 f4	 mov	 eax, DWORD PTR _NumberWidth$[ebp]
  0005b	40		 inc	 eax
  0005c	89 45 f4	 mov	 DWORD PTR _NumberWidth$[ebp], eax
$LN12@BlRtlForma:

; 408  :     }
; 409  : 
; 410  :     PadWidth = 0;

  0005f	83 65 f0 00	 and	 DWORD PTR _PadWidth$[ebp], 0

; 411  :     MinimumWidth = ABS(Width);

  00063	83 7d 0c 00	 cmp	 DWORD PTR _Width$[ebp], 0
  00067	7d 0a		 jge	 SHORT $LN20@BlRtlForma
  00069	8b 45 0c	 mov	 eax, DWORD PTR _Width$[ebp]
  0006c	f7 d8		 neg	 eax
  0006e	89 45 d8	 mov	 DWORD PTR tv77[ebp], eax
  00071	eb 06		 jmp	 SHORT $LN21@BlRtlForma
$LN20@BlRtlForma:
  00073	8b 45 0c	 mov	 eax, DWORD PTR _Width$[ebp]
  00076	89 45 d8	 mov	 DWORD PTR tv77[ebp], eax
$LN21@BlRtlForma:
  00079	8b 45 d8	 mov	 eax, DWORD PTR tv77[ebp]
  0007c	89 45 ec	 mov	 DWORD PTR _MinimumWidth$[ebp], eax

; 412  : 
; 413  :     if (MinimumWidth > NumberWidth) {

  0007f	8b 45 ec	 mov	 eax, DWORD PTR _MinimumWidth$[ebp]
  00082	3b 45 f4	 cmp	 eax, DWORD PTR _NumberWidth$[ebp]
  00085	76 09		 jbe	 SHORT $LN11@BlRtlForma

; 414  : 
; 415  :         PadWidth = MinimumWidth - NumberWidth;

  00087	8b 45 ec	 mov	 eax, DWORD PTR _MinimumWidth$[ebp]
  0008a	2b 45 f4	 sub	 eax, DWORD PTR _NumberWidth$[ebp]
  0008d	89 45 f0	 mov	 DWORD PTR _PadWidth$[ebp], eax
$LN11@BlRtlForma:

; 416  :     }
; 417  : 
; 418  :     //
; 419  :     // Check if there is sufficient space in the output buffer.
; 420  :     //
; 421  : 
; 422  :     if ((NumberWidth + PadWidth) > OutputSize) {

  00090	8b 45 f4	 mov	 eax, DWORD PTR _NumberWidth$[ebp]
  00093	03 45 f0	 add	 eax, DWORD PTR _PadWidth$[ebp]
  00096	3b 45 e0	 cmp	 eax, DWORD PTR _OutputSize$[ebp]
  00099	76 07		 jbe	 SHORT $LN10@BlRtlForma

; 423  : 
; 424  :         return FALSE;

  0009b	32 c0		 xor	 al, al
  0009d	e9 c7 00 00 00	 jmp	 $LN16@BlRtlForma
$LN10@BlRtlForma:

; 425  :     }
; 426  : 
; 427  :     Index = 0;

  000a2	83 65 f8 00	 and	 DWORD PTR _Index$[ebp], 0

; 428  : 
; 429  :     //
; 430  :     // If right alignment is specified, then insert any necessary pads before the number.
; 431  :     //
; 432  : 
; 433  :     if (Width > 0) {

  000a6	83 7d 0c 00	 cmp	 DWORD PTR _Width$[ebp], 0
  000aa	7e 1f		 jle	 SHORT $LN9@BlRtlForma
$LN8@BlRtlForma:

; 434  : 
; 435  :         while (PadWidth > 0) {

  000ac	83 7d f0 00	 cmp	 DWORD PTR _PadWidth$[ebp], 0
  000b0	76 19		 jbe	 SHORT $LN9@BlRtlForma

; 436  : 
; 437  :             Output[Index] = ' ';

  000b2	8b 45 e4	 mov	 eax, DWORD PTR _Output$[ebp]
  000b5	03 45 f8	 add	 eax, DWORD PTR _Index$[ebp]
  000b8	c6 00 20	 mov	 BYTE PTR [eax], 32	; 00000020H

; 438  :             Index += 1;

  000bb	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  000be	40		 inc	 eax
  000bf	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax

; 439  :             PadWidth -= 1;

  000c2	8b 45 f0	 mov	 eax, DWORD PTR _PadWidth$[ebp]
  000c5	48		 dec	 eax
  000c6	89 45 f0	 mov	 DWORD PTR _PadWidth$[ebp], eax

; 440  :         }

  000c9	eb e1		 jmp	 SHORT $LN8@BlRtlForma
$LN9@BlRtlForma:

; 441  :     }
; 442  : 
; 443  :     //
; 444  :     // Insert absolute number starting with the least significant digit, going right to left.
; 445  :     //
; 446  : 
; 447  :     Temp = ABS(Value);

  000cb	83 7d 08 00	 cmp	 DWORD PTR _Value$[ebp], 0
  000cf	7d 0a		 jge	 SHORT $LN22@BlRtlForma
  000d1	8b 45 08	 mov	 eax, DWORD PTR _Value$[ebp]
  000d4	f7 d8		 neg	 eax
  000d6	89 45 d4	 mov	 DWORD PTR tv89[ebp], eax
  000d9	eb 06		 jmp	 SHORT $LN23@BlRtlForma
$LN22@BlRtlForma:
  000db	8b 45 08	 mov	 eax, DWORD PTR _Value$[ebp]
  000de	89 45 d4	 mov	 DWORD PTR tv89[ebp], eax
$LN23@BlRtlForma:
  000e1	8b 45 d4	 mov	 eax, DWORD PTR tv89[ebp]
  000e4	89 45 e8	 mov	 DWORD PTR _Temp$[ebp], eax

; 448  :     Index += NumberWidth;

  000e7	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  000ea	03 45 f4	 add	 eax, DWORD PTR _NumberWidth$[ebp]
  000ed	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax
$LN6@BlRtlForma:

; 449  : 
; 450  :     do {
; 451  : 
; 452  :         Index -= 1;

  000f0	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  000f3	48		 dec	 eax
  000f4	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax

; 453  :         Output[Index] = (CHAR) ('0' + (Temp % 10));

  000f7	8b 45 e8	 mov	 eax, DWORD PTR _Temp$[ebp]
  000fa	33 d2		 xor	 edx, edx
  000fc	6a 0a		 push	 10			; 0000000aH
  000fe	59		 pop	 ecx
  000ff	f7 f1		 div	 ecx
  00101	83 c2 30	 add	 edx, 48			; 00000030H
  00104	8b 45 e4	 mov	 eax, DWORD PTR _Output$[ebp]
  00107	03 45 f8	 add	 eax, DWORD PTR _Index$[ebp]
  0010a	88 10		 mov	 BYTE PTR [eax], dl

; 454  :         Temp = Temp / 10;

  0010c	8b 45 e8	 mov	 eax, DWORD PTR _Temp$[ebp]
  0010f	33 d2		 xor	 edx, edx
  00111	6a 0a		 push	 10			; 0000000aH
  00113	59		 pop	 ecx
  00114	f7 f1		 div	 ecx
  00116	89 45 e8	 mov	 DWORD PTR _Temp$[ebp], eax

; 455  : 
; 456  :     } while (Temp > 0);

  00119	83 7d e8 00	 cmp	 DWORD PTR _Temp$[ebp], 0
  0011d	77 d1		 ja	 SHORT $LN6@BlRtlForma

; 457  : 
; 458  :     //
; 459  :     // If the number is negative, then insert the negative sign.
; 460  :     //
; 461  : 
; 462  :     if (Minus != FALSE) {

  0011f	0f b6 45 ff	 movzx	 eax, BYTE PTR _Minus$[ebp]
  00123	85 c0		 test	 eax, eax
  00125	74 10		 je	 SHORT $LN3@BlRtlForma

; 463  : 
; 464  :         Index -= 1;

  00127	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  0012a	48		 dec	 eax
  0012b	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax

; 465  :         Output[Index] = '-';

  0012e	8b 45 e4	 mov	 eax, DWORD PTR _Output$[ebp]
  00131	03 45 f8	 add	 eax, DWORD PTR _Index$[ebp]
  00134	c6 00 2d	 mov	 BYTE PTR [eax], 45	; 0000002dH
$LN3@BlRtlForma:

; 466  :     }
; 467  : 
; 468  :     //
; 469  :     // If left alignment was specified, then insert any necessary pads after the number.
; 470  :     //
; 471  : 
; 472  :     Index += NumberWidth;

  00137	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  0013a	03 45 f4	 add	 eax, DWORD PTR _NumberWidth$[ebp]
  0013d	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax
$LN2@BlRtlForma:

; 473  : 
; 474  :     while (PadWidth > 0) {

  00140	83 7d f0 00	 cmp	 DWORD PTR _PadWidth$[ebp], 0
  00144	76 19		 jbe	 SHORT $LN1@BlRtlForma

; 475  : 
; 476  :         Output[Index] = ' ';

  00146	8b 45 e4	 mov	 eax, DWORD PTR _Output$[ebp]
  00149	03 45 f8	 add	 eax, DWORD PTR _Index$[ebp]
  0014c	c6 00 20	 mov	 BYTE PTR [eax], 32	; 00000020H

; 477  :         Index += 1;

  0014f	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  00152	40		 inc	 eax
  00153	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax

; 478  :         PadWidth -= 1;

  00156	8b 45 f0	 mov	 eax, DWORD PTR _PadWidth$[ebp]
  00159	48		 dec	 eax
  0015a	89 45 f0	 mov	 DWORD PTR _PadWidth$[ebp], eax

; 479  :     }

  0015d	eb e1		 jmp	 SHORT $LN2@BlRtlForma
$LN1@BlRtlForma:

; 480  : 
; 481  :     //
; 482  :     // Set number of characters consumed in the buffer.
; 483  :     //
; 484  : 
; 485  :     *CharactersConsumed = Index;

  0015f	8b 45 10	 mov	 eax, DWORD PTR _CharactersConsumed$[ebp]
  00162	8b 4d f8	 mov	 ecx, DWORD PTR _Index$[ebp]
  00165	89 08		 mov	 DWORD PTR [eax], ecx

; 486  : 
; 487  :     return TRUE;

  00167	b0 01		 mov	 al, 1
$LN16@BlRtlForma:

; 488  : }

  00169	c9		 leave
  0016a	c2 0c 00	 ret	 12			; 0000000cH
?BlRtlFormatSignedDecimalLong@@YIEPADKJJPAK@Z ENDP	; BlRtlFormatSignedDecimalLong
_TEXT	ENDS
PUBLIC	?BlRtlFormatUnsignedLong@@YIEPADKKEJKPAK@Z	; BlRtlFormatUnsignedLong
; Function compile flags: /Odsp
;	COMDAT ?BlRtlFormatUnsignedLong@@YIEPADKKEJKPAK@Z
_TEXT	SEGMENT
tv82 = -36						; size = 4
tv70 = -32						; size = 4
_OutputSize$ = -28					; size = 4
_Output$ = -24						; size = 4
_Temp$ = -20						; size = 4
_MinimumWidth$ = -16					; size = 4
_PadWidth$ = -12					; size = 4
_NumberWidth$ = -8					; size = 4
_Index$ = -4						; size = 4
_Value$ = 8						; size = 4
_PadCharacter$ = 12					; size = 1
_Width$ = 16						; size = 4
_Base$ = 20						; size = 4
_CharactersConsumed$ = 24				; size = 4
?BlRtlFormatUnsignedLong@@YIEPADKKEJKPAK@Z PROC		; BlRtlFormatUnsignedLong, COMDAT
; _Output$ = ecx
; _OutputSize$ = edx

; 531  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 55 e4	 mov	 DWORD PTR _OutputSize$[ebp], edx
  00009	89 4d e8	 mov	 DWORD PTR _Output$[ebp], ecx

; 532  :     UINT32 Index;
; 533  :     UINT32 MinimumWidth;
; 534  :     UINT32 NumberWidth;
; 535  :     UINT32 PadWidth;
; 536  :     UINT32 Temp;
; 537  : 
; 538  :     if (Base == 0) {

  0000c	83 7d 14 00	 cmp	 DWORD PTR _Base$[ebp], 0
  00010	75 07		 jne	 SHORT $LN21@BlRtlForma@2

; 539  : 
; 540  :         return FALSE;

  00012	32 c0		 xor	 al, al
  00014	e9 4f 01 00 00	 jmp	 $LN22@BlRtlForma@2
$LN21@BlRtlForma@2:

; 541  :     }
; 542  : 
; 543  :     //
; 544  :     // Compute the number of characters necessary.
; 545  :     //
; 546  : 
; 547  :     Temp = Value;

  00019	8b 45 08	 mov	 eax, DWORD PTR _Value$[ebp]
  0001c	89 45 ec	 mov	 DWORD PTR _Temp$[ebp], eax

; 548  :     NumberWidth = 0;

  0001f	83 65 f8 00	 and	 DWORD PTR _NumberWidth$[ebp], 0
$LN20@BlRtlForma@2:

; 549  : 
; 550  :     do {
; 551  : 
; 552  :         NumberWidth += 1;

  00023	8b 45 f8	 mov	 eax, DWORD PTR _NumberWidth$[ebp]
  00026	40		 inc	 eax
  00027	89 45 f8	 mov	 DWORD PTR _NumberWidth$[ebp], eax

; 553  :         Temp = Temp / Base;

  0002a	8b 45 ec	 mov	 eax, DWORD PTR _Temp$[ebp]
  0002d	33 d2		 xor	 edx, edx
  0002f	f7 75 14	 div	 DWORD PTR _Base$[ebp]
  00032	89 45 ec	 mov	 DWORD PTR _Temp$[ebp], eax

; 554  : 
; 555  :     } while (Temp > 0);

  00035	83 7d ec 00	 cmp	 DWORD PTR _Temp$[ebp], 0
  00039	77 e8		 ja	 SHORT $LN20@BlRtlForma@2

; 556  : 
; 557  :     PadWidth = 0;

  0003b	83 65 f4 00	 and	 DWORD PTR _PadWidth$[ebp], 0

; 558  :     MinimumWidth = ABS(Width);

  0003f	83 7d 10 00	 cmp	 DWORD PTR _Width$[ebp], 0
  00043	7d 0a		 jge	 SHORT $LN24@BlRtlForma@2
  00045	8b 45 10	 mov	 eax, DWORD PTR _Width$[ebp]
  00048	f7 d8		 neg	 eax
  0004a	89 45 e0	 mov	 DWORD PTR tv70[ebp], eax
  0004d	eb 06		 jmp	 SHORT $LN25@BlRtlForma@2
$LN24@BlRtlForma@2:
  0004f	8b 45 10	 mov	 eax, DWORD PTR _Width$[ebp]
  00052	89 45 e0	 mov	 DWORD PTR tv70[ebp], eax
$LN25@BlRtlForma@2:
  00055	8b 45 e0	 mov	 eax, DWORD PTR tv70[ebp]
  00058	89 45 f0	 mov	 DWORD PTR _MinimumWidth$[ebp], eax

; 559  : 
; 560  :     if (MinimumWidth > NumberWidth) {

  0005b	8b 45 f0	 mov	 eax, DWORD PTR _MinimumWidth$[ebp]
  0005e	3b 45 f8	 cmp	 eax, DWORD PTR _NumberWidth$[ebp]
  00061	76 09		 jbe	 SHORT $LN17@BlRtlForma@2

; 561  : 
; 562  :         PadWidth = MinimumWidth - NumberWidth;

  00063	8b 45 f0	 mov	 eax, DWORD PTR _MinimumWidth$[ebp]
  00066	2b 45 f8	 sub	 eax, DWORD PTR _NumberWidth$[ebp]
  00069	89 45 f4	 mov	 DWORD PTR _PadWidth$[ebp], eax
$LN17@BlRtlForma@2:

; 563  :     }
; 564  : 
; 565  :     //
; 566  :     // Check if there is sufficient space in the output buffer.
; 567  :     //
; 568  : 
; 569  :     if ((NumberWidth + PadWidth) > OutputSize) {

  0006c	8b 45 f8	 mov	 eax, DWORD PTR _NumberWidth$[ebp]
  0006f	03 45 f4	 add	 eax, DWORD PTR _PadWidth$[ebp]
  00072	3b 45 e4	 cmp	 eax, DWORD PTR _OutputSize$[ebp]
  00075	76 07		 jbe	 SHORT $LN16@BlRtlForma@2

; 570  : 
; 571  :         return FALSE;

  00077	32 c0		 xor	 al, al
  00079	e9 ea 00 00 00	 jmp	 $LN22@BlRtlForma@2
$LN16@BlRtlForma@2:

; 572  :     }
; 573  : 
; 574  :     Index = 0;

  0007e	83 65 fc 00	 and	 DWORD PTR _Index$[ebp], 0

; 575  : 
; 576  :     //
; 577  :     // If right alignment is specified, then insert any necessary pads before the number.
; 578  :     //
; 579  : 
; 580  :     if (Width > 0) {

  00082	83 7d 10 00	 cmp	 DWORD PTR _Width$[ebp], 0
  00086	7e 21		 jle	 SHORT $LN15@BlRtlForma@2
$LN14@BlRtlForma@2:

; 581  : 
; 582  :         while (PadWidth > 0) {

  00088	83 7d f4 00	 cmp	 DWORD PTR _PadWidth$[ebp], 0
  0008c	76 1b		 jbe	 SHORT $LN15@BlRtlForma@2

; 583  : 
; 584  :             Output[Index] = PadCharacter;

  0008e	8b 45 e8	 mov	 eax, DWORD PTR _Output$[ebp]
  00091	03 45 fc	 add	 eax, DWORD PTR _Index$[ebp]
  00094	8a 4d 0c	 mov	 cl, BYTE PTR _PadCharacter$[ebp]
  00097	88 08		 mov	 BYTE PTR [eax], cl

; 585  :             Index += 1;

  00099	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  0009c	40		 inc	 eax
  0009d	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax

; 586  :             PadWidth -= 1;

  000a0	8b 45 f4	 mov	 eax, DWORD PTR _PadWidth$[ebp]
  000a3	48		 dec	 eax
  000a4	89 45 f4	 mov	 DWORD PTR _PadWidth$[ebp], eax

; 587  :         }

  000a7	eb df		 jmp	 SHORT $LN14@BlRtlForma@2
$LN15@BlRtlForma@2:

; 588  :     }
; 589  : 
; 590  :     //
; 591  :     // Insert absolute number starting with the least significant digit, going right to left.
; 592  :     //
; 593  : 
; 594  :     Temp = Value;

  000a9	8b 45 08	 mov	 eax, DWORD PTR _Value$[ebp]
  000ac	89 45 ec	 mov	 DWORD PTR _Temp$[ebp], eax

; 595  :     Index += NumberWidth;

  000af	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  000b2	03 45 f8	 add	 eax, DWORD PTR _NumberWidth$[ebp]
  000b5	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax
$LN12@BlRtlForma@2:

; 596  : 
; 597  :     do {
; 598  : 
; 599  :         Index -= 1;

  000b8	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  000bb	48		 dec	 eax
  000bc	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax

; 600  : 
; 601  :         switch (Base) {

  000bf	8b 45 14	 mov	 eax, DWORD PTR _Base$[ebp]
  000c2	89 45 dc	 mov	 DWORD PTR tv82[ebp], eax
  000c5	83 7d dc 0a	 cmp	 DWORD PTR tv82[ebp], 10	; 0000000aH
  000c9	74 08		 je	 SHORT $LN7@BlRtlForma@2
  000cb	83 7d dc 10	 cmp	 DWORD PTR tv82[ebp], 16	; 00000010H
  000cf	74 17		 je	 SHORT $LN6@BlRtlForma@2
  000d1	eb 4c		 jmp	 SHORT $LN3@BlRtlForma@2
$LN7@BlRtlForma@2:

; 602  : 
; 603  :             case 10: {
; 604  : 
; 605  :                 Output[Index] = (CHAR) ('0' + (Temp % Base));

  000d3	8b 45 ec	 mov	 eax, DWORD PTR _Temp$[ebp]
  000d6	33 d2		 xor	 edx, edx
  000d8	f7 75 14	 div	 DWORD PTR _Base$[ebp]
  000db	83 c2 30	 add	 edx, 48			; 00000030H
  000de	8b 45 e8	 mov	 eax, DWORD PTR _Output$[ebp]
  000e1	03 45 fc	 add	 eax, DWORD PTR _Index$[ebp]
  000e4	88 10		 mov	 BYTE PTR [eax], dl

; 606  :                 break;

  000e6	eb 3b		 jmp	 SHORT $LN8@BlRtlForma@2
$LN6@BlRtlForma@2:

; 607  :             }
; 608  : 
; 609  :             case 16: {
; 610  : 
; 611  :                 if ((Temp % Base) < 10) {

  000e8	8b 45 ec	 mov	 eax, DWORD PTR _Temp$[ebp]
  000eb	33 d2		 xor	 edx, edx
  000ed	f7 75 14	 div	 DWORD PTR _Base$[ebp]
  000f0	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  000f3	73 15		 jae	 SHORT $LN5@BlRtlForma@2

; 612  : 
; 613  :                     Output[Index] = (CHAR) ('0' + (Temp % Base));

  000f5	8b 45 ec	 mov	 eax, DWORD PTR _Temp$[ebp]
  000f8	33 d2		 xor	 edx, edx
  000fa	f7 75 14	 div	 DWORD PTR _Base$[ebp]
  000fd	83 c2 30	 add	 edx, 48			; 00000030H
  00100	8b 45 e8	 mov	 eax, DWORD PTR _Output$[ebp]
  00103	03 45 fc	 add	 eax, DWORD PTR _Index$[ebp]
  00106	88 10		 mov	 BYTE PTR [eax], dl

; 614  : 
; 615  :                 } else {

  00108	eb 13		 jmp	 SHORT $LN4@BlRtlForma@2
$LN5@BlRtlForma@2:

; 616  : 
; 617  :                     Output[Index] = (CHAR) ('A' + (Temp % Base) - 10);

  0010a	8b 45 ec	 mov	 eax, DWORD PTR _Temp$[ebp]
  0010d	33 d2		 xor	 edx, edx
  0010f	f7 75 14	 div	 DWORD PTR _Base$[ebp]
  00112	83 c2 37	 add	 edx, 55			; 00000037H
  00115	8b 45 e8	 mov	 eax, DWORD PTR _Output$[ebp]
  00118	03 45 fc	 add	 eax, DWORD PTR _Index$[ebp]
  0011b	88 10		 mov	 BYTE PTR [eax], dl
$LN4@BlRtlForma@2:

; 618  :                 }
; 619  : 
; 620  :                 break;

  0011d	eb 04		 jmp	 SHORT $LN8@BlRtlForma@2
$LN3@BlRtlForma@2:

; 621  :             }
; 622  : 
; 623  :             default: {
; 624  : 
; 625  :                 return FALSE;

  0011f	32 c0		 xor	 al, al
  00121	eb 45		 jmp	 SHORT $LN22@BlRtlForma@2
$LN8@BlRtlForma@2:

; 626  :             }
; 627  :         }
; 628  : 
; 629  :         Temp = Temp / Base;

  00123	8b 45 ec	 mov	 eax, DWORD PTR _Temp$[ebp]
  00126	33 d2		 xor	 edx, edx
  00128	f7 75 14	 div	 DWORD PTR _Base$[ebp]
  0012b	89 45 ec	 mov	 DWORD PTR _Temp$[ebp], eax

; 630  : 
; 631  :     } while (Temp > 0);

  0012e	83 7d ec 00	 cmp	 DWORD PTR _Temp$[ebp], 0
  00132	77 84		 ja	 SHORT $LN12@BlRtlForma@2

; 632  : 
; 633  :     //
; 634  :     // If left alignment was specified, then insert any necessary pads after the number.
; 635  :     //
; 636  : 
; 637  :     Index += NumberWidth;

  00134	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  00137	03 45 f8	 add	 eax, DWORD PTR _NumberWidth$[ebp]
  0013a	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax
$LN2@BlRtlForma@2:

; 638  : 
; 639  :     while (PadWidth > 0) {

  0013d	83 7d f4 00	 cmp	 DWORD PTR _PadWidth$[ebp], 0
  00141	76 1b		 jbe	 SHORT $LN1@BlRtlForma@2

; 640  : 
; 641  :         Output[Index] = PadCharacter;

  00143	8b 45 e8	 mov	 eax, DWORD PTR _Output$[ebp]
  00146	03 45 fc	 add	 eax, DWORD PTR _Index$[ebp]
  00149	8a 4d 0c	 mov	 cl, BYTE PTR _PadCharacter$[ebp]
  0014c	88 08		 mov	 BYTE PTR [eax], cl

; 642  :         Index += 1;

  0014e	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  00151	40		 inc	 eax
  00152	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax

; 643  :         PadWidth -= 1;

  00155	8b 45 f4	 mov	 eax, DWORD PTR _PadWidth$[ebp]
  00158	48		 dec	 eax
  00159	89 45 f4	 mov	 DWORD PTR _PadWidth$[ebp], eax

; 644  :     }

  0015c	eb df		 jmp	 SHORT $LN2@BlRtlForma@2
$LN1@BlRtlForma@2:

; 645  : 
; 646  :     //
; 647  :     // Set number of characters consumed in the buffer.
; 648  :     //
; 649  : 
; 650  :     *CharactersConsumed = Index;

  0015e	8b 45 18	 mov	 eax, DWORD PTR _CharactersConsumed$[ebp]
  00161	8b 4d fc	 mov	 ecx, DWORD PTR _Index$[ebp]
  00164	89 08		 mov	 DWORD PTR [eax], ecx

; 651  : 
; 652  :     return TRUE;

  00166	b0 01		 mov	 al, 1
$LN22@BlRtlForma@2:

; 653  : }

  00168	c9		 leave
  00169	c2 14 00	 ret	 20			; 00000014H
?BlRtlFormatUnsignedLong@@YIEPADKKEJKPAK@Z ENDP		; BlRtlFormatUnsignedLong
_TEXT	ENDS
PUBLIC	?BlRtlFormatUnsignedLongLong@@YIEPADK_KEJKPAK@Z	; BlRtlFormatUnsignedLongLong
EXTRN	__aullrem:PROC
EXTRN	__aulldiv:PROC
; Function compile flags: /Odsp
;	COMDAT ?BlRtlFormatUnsignedLongLong@@YIEPADK_KEJKPAK@Z
_TEXT	SEGMENT
tv211 = -48						; size = 8
tv83 = -40						; size = 4
tv71 = -36						; size = 4
_OutputSize$ = -32					; size = 4
_Output$ = -28						; size = 4
_Temp$ = -24						; size = 8
_MinimumWidth$ = -16					; size = 4
_PadWidth$ = -12					; size = 4
_NumberWidth$ = -8					; size = 4
_Index$ = -4						; size = 4
_Value$ = 8						; size = 8
_PadCharacter$ = 16					; size = 1
_Width$ = 20						; size = 4
_Base$ = 24						; size = 4
_CharactersConsumed$ = 28				; size = 4
?BlRtlFormatUnsignedLongLong@@YIEPADK_KEJKPAK@Z PROC	; BlRtlFormatUnsignedLongLong, COMDAT
; _Output$ = ecx
; _OutputSize$ = edx

; 696  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 55 e0	 mov	 DWORD PTR _OutputSize$[ebp], edx
  00009	89 4d e4	 mov	 DWORD PTR _Output$[ebp], ecx

; 697  :     UINT32 Index;
; 698  :     UINT32 MinimumWidth;
; 699  :     UINT32 NumberWidth;
; 700  :     UINT32 PadWidth;
; 701  :     UINT64 Temp;
; 702  : 
; 703  :     if (Base == 0) {

  0000c	83 7d 18 00	 cmp	 DWORD PTR _Base$[ebp], 0
  00010	75 07		 jne	 SHORT $LN21@BlRtlForma@3

; 704  : 
; 705  :         return FALSE;

  00012	32 c0		 xor	 al, al
  00014	e9 d6 01 00 00	 jmp	 $LN22@BlRtlForma@3
$LN21@BlRtlForma@3:

; 706  :     }
; 707  : 
; 708  :     //
; 709  :     // Compute the number of characters necessary.
; 710  :     //
; 711  : 
; 712  :     Temp = Value;

  00019	8b 45 08	 mov	 eax, DWORD PTR _Value$[ebp]
  0001c	89 45 e8	 mov	 DWORD PTR _Temp$[ebp], eax
  0001f	8b 45 0c	 mov	 eax, DWORD PTR _Value$[ebp+4]
  00022	89 45 ec	 mov	 DWORD PTR _Temp$[ebp+4], eax

; 713  :     NumberWidth = 0;

  00025	83 65 f8 00	 and	 DWORD PTR _NumberWidth$[ebp], 0
$LN20@BlRtlForma@3:

; 714  : 
; 715  :     do {
; 716  : 
; 717  :         NumberWidth += 1;

  00029	8b 45 f8	 mov	 eax, DWORD PTR _NumberWidth$[ebp]
  0002c	40		 inc	 eax
  0002d	89 45 f8	 mov	 DWORD PTR _NumberWidth$[ebp], eax

; 718  :         Temp = Temp / Base;

  00030	8b 45 18	 mov	 eax, DWORD PTR _Base$[ebp]
  00033	33 c9		 xor	 ecx, ecx
  00035	51		 push	 ecx
  00036	50		 push	 eax
  00037	ff 75 ec	 push	 DWORD PTR _Temp$[ebp+4]
  0003a	ff 75 e8	 push	 DWORD PTR _Temp$[ebp]
  0003d	e8 00 00 00 00	 call	 __aulldiv
  00042	89 45 e8	 mov	 DWORD PTR _Temp$[ebp], eax
  00045	89 55 ec	 mov	 DWORD PTR _Temp$[ebp+4], edx

; 719  : 
; 720  :     } while (Temp > 0);

  00048	83 7d ec 00	 cmp	 DWORD PTR _Temp$[ebp+4], 0
  0004c	77 db		 ja	 SHORT $LN20@BlRtlForma@3
  0004e	72 06		 jb	 SHORT $LN18@BlRtlForma@3
  00050	83 7d e8 00	 cmp	 DWORD PTR _Temp$[ebp], 0
  00054	77 d3		 ja	 SHORT $LN20@BlRtlForma@3
$LN18@BlRtlForma@3:

; 721  : 
; 722  :     PadWidth = 0;

  00056	83 65 f4 00	 and	 DWORD PTR _PadWidth$[ebp], 0

; 723  :     MinimumWidth = ABS(Width);

  0005a	83 7d 14 00	 cmp	 DWORD PTR _Width$[ebp], 0
  0005e	7d 0a		 jge	 SHORT $LN24@BlRtlForma@3
  00060	8b 45 14	 mov	 eax, DWORD PTR _Width$[ebp]
  00063	f7 d8		 neg	 eax
  00065	89 45 dc	 mov	 DWORD PTR tv71[ebp], eax
  00068	eb 06		 jmp	 SHORT $LN25@BlRtlForma@3
$LN24@BlRtlForma@3:
  0006a	8b 45 14	 mov	 eax, DWORD PTR _Width$[ebp]
  0006d	89 45 dc	 mov	 DWORD PTR tv71[ebp], eax
$LN25@BlRtlForma@3:
  00070	8b 45 dc	 mov	 eax, DWORD PTR tv71[ebp]
  00073	89 45 f0	 mov	 DWORD PTR _MinimumWidth$[ebp], eax

; 724  : 
; 725  :     if (MinimumWidth > NumberWidth) {

  00076	8b 45 f0	 mov	 eax, DWORD PTR _MinimumWidth$[ebp]
  00079	3b 45 f8	 cmp	 eax, DWORD PTR _NumberWidth$[ebp]
  0007c	76 09		 jbe	 SHORT $LN17@BlRtlForma@3

; 726  : 
; 727  :         PadWidth = MinimumWidth - NumberWidth;

  0007e	8b 45 f0	 mov	 eax, DWORD PTR _MinimumWidth$[ebp]
  00081	2b 45 f8	 sub	 eax, DWORD PTR _NumberWidth$[ebp]
  00084	89 45 f4	 mov	 DWORD PTR _PadWidth$[ebp], eax
$LN17@BlRtlForma@3:

; 728  :     }
; 729  : 
; 730  :     //
; 731  :     // Check if there is sufficient space in the output buffer.
; 732  :     //
; 733  : 
; 734  :     if ((NumberWidth + PadWidth) > OutputSize) {

  00087	8b 45 f8	 mov	 eax, DWORD PTR _NumberWidth$[ebp]
  0008a	03 45 f4	 add	 eax, DWORD PTR _PadWidth$[ebp]
  0008d	3b 45 e0	 cmp	 eax, DWORD PTR _OutputSize$[ebp]
  00090	76 07		 jbe	 SHORT $LN16@BlRtlForma@3

; 735  : 
; 736  :         return FALSE;

  00092	32 c0		 xor	 al, al
  00094	e9 56 01 00 00	 jmp	 $LN22@BlRtlForma@3
$LN16@BlRtlForma@3:

; 737  :     }
; 738  : 
; 739  :     Index = 0;

  00099	83 65 fc 00	 and	 DWORD PTR _Index$[ebp], 0

; 740  : 
; 741  :     //
; 742  :     // If right alignment is specified, then insert any necessary pads before the number.
; 743  :     //
; 744  : 
; 745  :     if (Width > 0) {

  0009d	83 7d 14 00	 cmp	 DWORD PTR _Width$[ebp], 0
  000a1	7e 21		 jle	 SHORT $LN15@BlRtlForma@3
$LN14@BlRtlForma@3:

; 746  : 
; 747  :         while (PadWidth > 0) {

  000a3	83 7d f4 00	 cmp	 DWORD PTR _PadWidth$[ebp], 0
  000a7	76 1b		 jbe	 SHORT $LN15@BlRtlForma@3

; 748  : 
; 749  :             Output[Index] = PadCharacter;

  000a9	8b 45 e4	 mov	 eax, DWORD PTR _Output$[ebp]
  000ac	03 45 fc	 add	 eax, DWORD PTR _Index$[ebp]
  000af	8a 4d 10	 mov	 cl, BYTE PTR _PadCharacter$[ebp]
  000b2	88 08		 mov	 BYTE PTR [eax], cl

; 750  :             Index += 1;

  000b4	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  000b7	40		 inc	 eax
  000b8	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax

; 751  :             PadWidth -= 1;

  000bb	8b 45 f4	 mov	 eax, DWORD PTR _PadWidth$[ebp]
  000be	48		 dec	 eax
  000bf	89 45 f4	 mov	 DWORD PTR _PadWidth$[ebp], eax

; 752  :         }

  000c2	eb df		 jmp	 SHORT $LN14@BlRtlForma@3
$LN15@BlRtlForma@3:

; 753  :     }
; 754  : 
; 755  :     //
; 756  :     // Insert absolute number starting with the least significant digit, going right to left.
; 757  :     //
; 758  : 
; 759  :     Temp = Value;

  000c4	8b 45 08	 mov	 eax, DWORD PTR _Value$[ebp]
  000c7	89 45 e8	 mov	 DWORD PTR _Temp$[ebp], eax
  000ca	8b 45 0c	 mov	 eax, DWORD PTR _Value$[ebp+4]
  000cd	89 45 ec	 mov	 DWORD PTR _Temp$[ebp+4], eax

; 760  :     Index += NumberWidth;

  000d0	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  000d3	03 45 f8	 add	 eax, DWORD PTR _NumberWidth$[ebp]
  000d6	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax
$LN12@BlRtlForma@3:

; 761  : 
; 762  :     do {
; 763  : 
; 764  :         Index -= 1;

  000d9	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  000dc	48		 dec	 eax
  000dd	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax

; 765  : 
; 766  :         switch (Base) {

  000e0	8b 45 18	 mov	 eax, DWORD PTR _Base$[ebp]
  000e3	89 45 d8	 mov	 DWORD PTR tv83[ebp], eax
  000e6	83 7d d8 0a	 cmp	 DWORD PTR tv83[ebp], 10	; 0000000aH
  000ea	74 0b		 je	 SHORT $LN7@BlRtlForma@3
  000ec	83 7d d8 10	 cmp	 DWORD PTR tv83[ebp], 16	; 00000010H
  000f0	74 27		 je	 SHORT $LN6@BlRtlForma@3
  000f2	e9 92 00 00 00	 jmp	 $LN3@BlRtlForma@3
$LN7@BlRtlForma@3:

; 767  : 
; 768  :             case 10: {
; 769  : 
; 770  :                 Output[Index] = (CHAR) ('0' + (Temp % Base));

  000f7	8b 45 18	 mov	 eax, DWORD PTR _Base$[ebp]
  000fa	33 c9		 xor	 ecx, ecx
  000fc	51		 push	 ecx
  000fd	50		 push	 eax
  000fe	ff 75 ec	 push	 DWORD PTR _Temp$[ebp+4]
  00101	ff 75 e8	 push	 DWORD PTR _Temp$[ebp]
  00104	e8 00 00 00 00	 call	 __aullrem
  00109	83 c0 30	 add	 eax, 48			; 00000030H
  0010c	83 d2 00	 adc	 edx, 0
  0010f	8b 4d e4	 mov	 ecx, DWORD PTR _Output$[ebp]
  00112	03 4d fc	 add	 ecx, DWORD PTR _Index$[ebp]
  00115	88 01		 mov	 BYTE PTR [ecx], al

; 771  :                 break;

  00117	eb 74		 jmp	 SHORT $LN8@BlRtlForma@3
$LN6@BlRtlForma@3:

; 772  :             }
; 773  : 
; 774  :             case 16: {
; 775  : 
; 776  :                 if ((Temp % Base) < 10) {

  00119	8b 45 18	 mov	 eax, DWORD PTR _Base$[ebp]
  0011c	33 c9		 xor	 ecx, ecx
  0011e	51		 push	 ecx
  0011f	50		 push	 eax
  00120	ff 75 ec	 push	 DWORD PTR _Temp$[ebp+4]
  00123	ff 75 e8	 push	 DWORD PTR _Temp$[ebp]
  00126	e8 00 00 00 00	 call	 __aullrem
  0012b	89 45 d0	 mov	 DWORD PTR tv211[ebp], eax
  0012e	89 55 d4	 mov	 DWORD PTR tv211[ebp+4], edx
  00131	83 7d d4 00	 cmp	 DWORD PTR tv211[ebp+4], 0
  00135	77 2a		 ja	 SHORT $LN5@BlRtlForma@3
  00137	72 06		 jb	 SHORT $LN27@BlRtlForma@3
  00139	83 7d d0 0a	 cmp	 DWORD PTR tv211[ebp], 10 ; 0000000aH
  0013d	73 22		 jae	 SHORT $LN5@BlRtlForma@3
$LN27@BlRtlForma@3:

; 777  : 
; 778  :                     Output[Index] = (CHAR) ('0' + (Temp % Base));

  0013f	8b 45 18	 mov	 eax, DWORD PTR _Base$[ebp]
  00142	33 c9		 xor	 ecx, ecx
  00144	51		 push	 ecx
  00145	50		 push	 eax
  00146	ff 75 ec	 push	 DWORD PTR _Temp$[ebp+4]
  00149	ff 75 e8	 push	 DWORD PTR _Temp$[ebp]
  0014c	e8 00 00 00 00	 call	 __aullrem
  00151	83 c0 30	 add	 eax, 48			; 00000030H
  00154	83 d2 00	 adc	 edx, 0
  00157	8b 4d e4	 mov	 ecx, DWORD PTR _Output$[ebp]
  0015a	03 4d fc	 add	 ecx, DWORD PTR _Index$[ebp]
  0015d	88 01		 mov	 BYTE PTR [ecx], al

; 779  : 
; 780  :                 } else {

  0015f	eb 26		 jmp	 SHORT $LN4@BlRtlForma@3
$LN5@BlRtlForma@3:

; 781  : 
; 782  :                     Output[Index] = (CHAR) ('A' + (Temp % Base) - 10);

  00161	8b 45 18	 mov	 eax, DWORD PTR _Base$[ebp]
  00164	33 c9		 xor	 ecx, ecx
  00166	51		 push	 ecx
  00167	50		 push	 eax
  00168	ff 75 ec	 push	 DWORD PTR _Temp$[ebp+4]
  0016b	ff 75 e8	 push	 DWORD PTR _Temp$[ebp]
  0016e	e8 00 00 00 00	 call	 __aullrem
  00173	83 c0 41	 add	 eax, 65			; 00000041H
  00176	83 d2 00	 adc	 edx, 0
  00179	83 e8 0a	 sub	 eax, 10			; 0000000aH
  0017c	83 da 00	 sbb	 edx, 0
  0017f	8b 4d e4	 mov	 ecx, DWORD PTR _Output$[ebp]
  00182	03 4d fc	 add	 ecx, DWORD PTR _Index$[ebp]
  00185	88 01		 mov	 BYTE PTR [ecx], al
$LN4@BlRtlForma@3:

; 783  :                 }
; 784  : 
; 785  :                 break;

  00187	eb 04		 jmp	 SHORT $LN8@BlRtlForma@3
$LN3@BlRtlForma@3:

; 786  :             }
; 787  : 
; 788  :             default: {
; 789  : 
; 790  :                 return FALSE;

  00189	32 c0		 xor	 al, al
  0018b	eb 62		 jmp	 SHORT $LN22@BlRtlForma@3
$LN8@BlRtlForma@3:

; 791  :             }
; 792  :         }
; 793  : 
; 794  :         Temp = Temp / Base;

  0018d	8b 45 18	 mov	 eax, DWORD PTR _Base$[ebp]
  00190	33 c9		 xor	 ecx, ecx
  00192	51		 push	 ecx
  00193	50		 push	 eax
  00194	ff 75 ec	 push	 DWORD PTR _Temp$[ebp+4]
  00197	ff 75 e8	 push	 DWORD PTR _Temp$[ebp]
  0019a	e8 00 00 00 00	 call	 __aulldiv
  0019f	89 45 e8	 mov	 DWORD PTR _Temp$[ebp], eax
  001a2	89 55 ec	 mov	 DWORD PTR _Temp$[ebp+4], edx

; 795  : 
; 796  :     } while (Temp > 0);

  001a5	83 7d ec 00	 cmp	 DWORD PTR _Temp$[ebp+4], 0
  001a9	0f 87 2a ff ff
	ff		 ja	 $LN12@BlRtlForma@3
  001af	72 0a		 jb	 SHORT $LN10@BlRtlForma@3
  001b1	83 7d e8 00	 cmp	 DWORD PTR _Temp$[ebp], 0
  001b5	0f 87 1e ff ff
	ff		 ja	 $LN12@BlRtlForma@3
$LN10@BlRtlForma@3:

; 797  : 
; 798  :     //
; 799  :     // If left alignment was specified, then insert any necessary pads after the number.
; 800  :     //
; 801  : 
; 802  :     Index += NumberWidth;

  001bb	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  001be	03 45 f8	 add	 eax, DWORD PTR _NumberWidth$[ebp]
  001c1	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax
$LN2@BlRtlForma@3:

; 803  : 
; 804  :     while (PadWidth > 0) {

  001c4	83 7d f4 00	 cmp	 DWORD PTR _PadWidth$[ebp], 0
  001c8	76 1b		 jbe	 SHORT $LN1@BlRtlForma@3

; 805  : 
; 806  :         Output[Index] = PadCharacter;

  001ca	8b 45 e4	 mov	 eax, DWORD PTR _Output$[ebp]
  001cd	03 45 fc	 add	 eax, DWORD PTR _Index$[ebp]
  001d0	8a 4d 10	 mov	 cl, BYTE PTR _PadCharacter$[ebp]
  001d3	88 08		 mov	 BYTE PTR [eax], cl

; 807  :         Index += 1;

  001d5	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  001d8	40		 inc	 eax
  001d9	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax

; 808  :         PadWidth -= 1;

  001dc	8b 45 f4	 mov	 eax, DWORD PTR _PadWidth$[ebp]
  001df	48		 dec	 eax
  001e0	89 45 f4	 mov	 DWORD PTR _PadWidth$[ebp], eax

; 809  :     }

  001e3	eb df		 jmp	 SHORT $LN2@BlRtlForma@3
$LN1@BlRtlForma@3:

; 810  : 
; 811  :     //
; 812  :     // Set number of characters consumed in the buffer.
; 813  :     //
; 814  : 
; 815  :     *CharactersConsumed = Index;

  001e5	8b 45 1c	 mov	 eax, DWORD PTR _CharactersConsumed$[ebp]
  001e8	8b 4d fc	 mov	 ecx, DWORD PTR _Index$[ebp]
  001eb	89 08		 mov	 DWORD PTR [eax], ecx

; 816  : 
; 817  :     return TRUE;

  001ed	b0 01		 mov	 al, 1
$LN22@BlRtlForma@3:

; 818  : }

  001ef	c9		 leave
  001f0	c2 18 00	 ret	 24			; 00000018H
?BlRtlFormatUnsignedLongLong@@YIEPADK_KEJKPAK@Z ENDP	; BlRtlFormatUnsignedLongLong
_TEXT	ENDS
PUBLIC	?BlRtlStringLength@@YIKPBD@Z			; BlRtlStringLength
; Function compile flags: /Odsp
;	COMDAT ?BlRtlStringLength@@YIKPBD@Z
_TEXT	SEGMENT
_String$ = -8						; size = 4
_Index$ = -4						; size = 4
?BlRtlStringLength@@YIKPBD@Z PROC			; BlRtlStringLength, COMDAT
; _String$ = ecx

; 841  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _String$[ebp], ecx

; 842  :     UINT32 Index;
; 843  : 
; 844  :     Index = 0;

  00008	83 65 fc 00	 and	 DWORD PTR _Index$[ebp], 0
$LN2@BlRtlStrin:

; 845  : 
; 846  :     while (String[Index] != 0) {

  0000c	8b 45 f8	 mov	 eax, DWORD PTR _String$[ebp]
  0000f	03 45 fc	 add	 eax, DWORD PTR _Index$[ebp]
  00012	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00015	85 c0		 test	 eax, eax
  00017	74 09		 je	 SHORT $LN1@BlRtlStrin

; 847  : 
; 848  :         Index += 1;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  0001c	40		 inc	 eax
  0001d	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax

; 849  :     }

  00020	eb ea		 jmp	 SHORT $LN2@BlRtlStrin
$LN1@BlRtlStrin:

; 850  : 
; 851  :     return Index;

  00022	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]

; 852  : }

  00025	c9		 leave
  00026	c3		 ret	 0
?BlRtlStringLength@@YIKPBD@Z ENDP			; BlRtlStringLength
_TEXT	ENDS
PUBLIC	?BlRtlStringLengthW@@YIKPB_W@Z			; BlRtlStringLengthW
; Function compile flags: /Odsp
;	COMDAT ?BlRtlStringLengthW@@YIKPB_W@Z
_TEXT	SEGMENT
_String$ = -8						; size = 4
_Index$ = -4						; size = 4
?BlRtlStringLengthW@@YIKPB_W@Z PROC			; BlRtlStringLengthW, COMDAT
; _String$ = ecx

; 875  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _String$[ebp], ecx

; 876  :     UINT32 Index;
; 877  : 
; 878  :     Index = 0;

  00008	83 65 fc 00	 and	 DWORD PTR _Index$[ebp], 0
$LN2@BlRtlStrin@2:

; 879  : 
; 880  :     while (String[Index] != 0) {

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  0000f	8b 4d f8	 mov	 ecx, DWORD PTR _String$[ebp]
  00012	0f b7 04 41	 movzx	 eax, WORD PTR [ecx+eax*2]
  00016	85 c0		 test	 eax, eax
  00018	74 09		 je	 SHORT $LN1@BlRtlStrin@2

; 881  : 
; 882  :         Index += 1;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  0001d	40		 inc	 eax
  0001e	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax

; 883  :     }

  00021	eb e9		 jmp	 SHORT $LN2@BlRtlStrin@2
$LN1@BlRtlStrin@2:

; 884  : 
; 885  :     return Index;

  00023	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]

; 886  : }

  00026	c9		 leave
  00027	c3		 ret	 0
?BlRtlStringLengthW@@YIKPB_W@Z ENDP			; BlRtlStringLengthW
_TEXT	ENDS
PUBLIC	?BlRtlFormatStringToken@@YIEPADKPBDJPAK@Z	; BlRtlFormatStringToken
; Function compile flags: /Odsp
;	COMDAT ?BlRtlFormatStringToken@@YIEPADKPBDJPAK@Z
_TEXT	SEGMENT
tv68 = -32						; size = 4
_OutputSize$ = -28					; size = 4
_Output$ = -24						; size = 4
_StringIndex$ = -20					; size = 4
_MinimumWidth$ = -16					; size = 4
_PadWidth$ = -12					; size = 4
_StringLength$ = -8					; size = 4
_Index$ = -4						; size = 4
_String$ = 8						; size = 4
_Width$ = 12						; size = 4
_CharactersConsumed$ = 16				; size = 4
?BlRtlFormatStringToken@@YIEPADKPBDJPAK@Z PROC		; BlRtlFormatStringToken, COMDAT
; _Output$ = ecx
; _OutputSize$ = edx

; 923  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 55 e4	 mov	 DWORD PTR _OutputSize$[ebp], edx
  00009	89 4d e8	 mov	 DWORD PTR _Output$[ebp], ecx

; 924  :     UINT32 Index;
; 925  :     UINT32 MinimumWidth;
; 926  :     UINT32 PadWidth;
; 927  :     UINT32 StringIndex;
; 928  :     UINT32 StringLength;
; 929  : 
; 930  :     //
; 931  :     // Compute string length, minimum width, and pad width.
; 932  :     //
; 933  : 
; 934  :     StringLength = BlRtlStringLength(String);

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _String$[ebp]
  0000f	e8 00 00 00 00	 call	 ?BlRtlStringLength@@YIKPBD@Z ; BlRtlStringLength
  00014	89 45 f8	 mov	 DWORD PTR _StringLength$[ebp], eax

; 935  : 
; 936  :     MinimumWidth = ABS(Width);

  00017	83 7d 0c 00	 cmp	 DWORD PTR _Width$[ebp], 0
  0001b	7d 0a		 jge	 SHORT $LN13@BlRtlForma@4
  0001d	8b 45 0c	 mov	 eax, DWORD PTR _Width$[ebp]
  00020	f7 d8		 neg	 eax
  00022	89 45 e0	 mov	 DWORD PTR tv68[ebp], eax
  00025	eb 06		 jmp	 SHORT $LN14@BlRtlForma@4
$LN13@BlRtlForma@4:
  00027	8b 45 0c	 mov	 eax, DWORD PTR _Width$[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR tv68[ebp], eax
$LN14@BlRtlForma@4:
  0002d	8b 45 e0	 mov	 eax, DWORD PTR tv68[ebp]
  00030	89 45 f0	 mov	 DWORD PTR _MinimumWidth$[ebp], eax

; 937  : 
; 938  :     PadWidth = 0;

  00033	83 65 f4 00	 and	 DWORD PTR _PadWidth$[ebp], 0

; 939  : 
; 940  :     if (MinimumWidth > StringLength) {

  00037	8b 45 f0	 mov	 eax, DWORD PTR _MinimumWidth$[ebp]
  0003a	3b 45 f8	 cmp	 eax, DWORD PTR _StringLength$[ebp]
  0003d	76 09		 jbe	 SHORT $LN10@BlRtlForma@4

; 941  : 
; 942  :         PadWidth = MinimumWidth - StringLength;

  0003f	8b 45 f0	 mov	 eax, DWORD PTR _MinimumWidth$[ebp]
  00042	2b 45 f8	 sub	 eax, DWORD PTR _StringLength$[ebp]
  00045	89 45 f4	 mov	 DWORD PTR _PadWidth$[ebp], eax
$LN10@BlRtlForma@4:

; 943  :     }
; 944  : 
; 945  :     //
; 946  :     // Check if there is sufficient space in the output buffer.
; 947  :     //
; 948  : 
; 949  :     if ((StringLength + PadWidth) > OutputSize) {

  00048	8b 45 f8	 mov	 eax, DWORD PTR _StringLength$[ebp]
  0004b	03 45 f4	 add	 eax, DWORD PTR _PadWidth$[ebp]
  0004e	3b 45 e4	 cmp	 eax, DWORD PTR _OutputSize$[ebp]
  00051	76 07		 jbe	 SHORT $LN9@BlRtlForma@4

; 950  : 
; 951  :         return FALSE;

  00053	32 c0		 xor	 al, al
  00055	e9 80 00 00 00	 jmp	 $LN11@BlRtlForma@4
$LN9@BlRtlForma@4:

; 952  :     }
; 953  : 
; 954  :     Index = 0;

  0005a	83 65 fc 00	 and	 DWORD PTR _Index$[ebp], 0

; 955  : 
; 956  :     //
; 957  :     // If right alignment is specified, then insert any necessary pads before the string.
; 958  :     //
; 959  : 
; 960  :     if (Width > 0) {

  0005e	83 7d 0c 00	 cmp	 DWORD PTR _Width$[ebp], 0
  00062	7e 1f		 jle	 SHORT $LN8@BlRtlForma@4
$LN7@BlRtlForma@4:

; 961  : 
; 962  :         while (PadWidth > 0) {

  00064	83 7d f4 00	 cmp	 DWORD PTR _PadWidth$[ebp], 0
  00068	76 19		 jbe	 SHORT $LN8@BlRtlForma@4

; 963  : 
; 964  :             Output[Index] = ' ';

  0006a	8b 45 e8	 mov	 eax, DWORD PTR _Output$[ebp]
  0006d	03 45 fc	 add	 eax, DWORD PTR _Index$[ebp]
  00070	c6 00 20	 mov	 BYTE PTR [eax], 32	; 00000020H

; 965  :             Index += 1;

  00073	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  00076	40		 inc	 eax
  00077	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax

; 966  :             PadWidth -= 1;

  0007a	8b 45 f4	 mov	 eax, DWORD PTR _PadWidth$[ebp]
  0007d	48		 dec	 eax
  0007e	89 45 f4	 mov	 DWORD PTR _PadWidth$[ebp], eax

; 967  :         }

  00081	eb e1		 jmp	 SHORT $LN7@BlRtlForma@4
$LN8@BlRtlForma@4:

; 968  :     }
; 969  : 
; 970  :     //
; 971  :     // Copy the string.
; 972  :     //
; 973  : 
; 974  :     for (StringIndex = 0; StringIndex < StringLength; StringIndex += 1) {

  00083	83 65 ec 00	 and	 DWORD PTR _StringIndex$[ebp], 0
  00087	eb 07		 jmp	 SHORT $LN5@BlRtlForma@4
$LN4@BlRtlForma@4:
  00089	8b 45 ec	 mov	 eax, DWORD PTR _StringIndex$[ebp]
  0008c	40		 inc	 eax
  0008d	89 45 ec	 mov	 DWORD PTR _StringIndex$[ebp], eax
$LN5@BlRtlForma@4:
  00090	8b 45 ec	 mov	 eax, DWORD PTR _StringIndex$[ebp]
  00093	3b 45 f8	 cmp	 eax, DWORD PTR _StringLength$[ebp]
  00096	73 19		 jae	 SHORT $LN2@BlRtlForma@4

; 975  : 
; 976  :         Output[Index] = String[StringIndex];

  00098	8b 45 e8	 mov	 eax, DWORD PTR _Output$[ebp]
  0009b	03 45 fc	 add	 eax, DWORD PTR _Index$[ebp]
  0009e	8b 4d 08	 mov	 ecx, DWORD PTR _String$[ebp]
  000a1	03 4d ec	 add	 ecx, DWORD PTR _StringIndex$[ebp]
  000a4	8a 09		 mov	 cl, BYTE PTR [ecx]
  000a6	88 08		 mov	 BYTE PTR [eax], cl

; 977  :         Index += 1;

  000a8	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  000ab	40		 inc	 eax
  000ac	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax

; 978  :     }

  000af	eb d8		 jmp	 SHORT $LN4@BlRtlForma@4
$LN2@BlRtlForma@4:

; 979  : 
; 980  :     //
; 981  :     // If left alignment was specified, then insert any necessary pads after the string.
; 982  :     //
; 983  : 
; 984  :     while (PadWidth > 0) {

  000b1	83 7d f4 00	 cmp	 DWORD PTR _PadWidth$[ebp], 0
  000b5	76 19		 jbe	 SHORT $LN1@BlRtlForma@4

; 985  : 
; 986  :         Output[Index] = ' ';

  000b7	8b 45 e8	 mov	 eax, DWORD PTR _Output$[ebp]
  000ba	03 45 fc	 add	 eax, DWORD PTR _Index$[ebp]
  000bd	c6 00 20	 mov	 BYTE PTR [eax], 32	; 00000020H

; 987  :         Index += 1;

  000c0	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  000c3	40		 inc	 eax
  000c4	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax

; 988  :         PadWidth -= 1;

  000c7	8b 45 f4	 mov	 eax, DWORD PTR _PadWidth$[ebp]
  000ca	48		 dec	 eax
  000cb	89 45 f4	 mov	 DWORD PTR _PadWidth$[ebp], eax

; 989  :     }

  000ce	eb e1		 jmp	 SHORT $LN2@BlRtlForma@4
$LN1@BlRtlForma@4:

; 990  : 
; 991  :     //
; 992  :     // Set number of characters consumed in the buffer.
; 993  :     //
; 994  : 
; 995  :     *CharactersConsumed = Index;

  000d0	8b 45 10	 mov	 eax, DWORD PTR _CharactersConsumed$[ebp]
  000d3	8b 4d fc	 mov	 ecx, DWORD PTR _Index$[ebp]
  000d6	89 08		 mov	 DWORD PTR [eax], ecx

; 996  : 
; 997  :     return TRUE;

  000d8	b0 01		 mov	 al, 1
$LN11@BlRtlForma@4:

; 998  : }

  000da	c9		 leave
  000db	c2 0c 00	 ret	 12			; 0000000cH
?BlRtlFormatStringToken@@YIEPADKPBDJPAK@Z ENDP		; BlRtlFormatStringToken
_TEXT	ENDS
PUBLIC	?BlRtlFormatChar@@YIEPADKDPAK@Z			; BlRtlFormatChar
; Function compile flags: /Odsp
;	COMDAT ?BlRtlFormatChar@@YIEPADKDPAK@Z
_TEXT	SEGMENT
_OutputSize$ = -8					; size = 4
_Output$ = -4						; size = 4
_Value$ = 8						; size = 1
_CharactersConsumed$ = 12				; size = 4
?BlRtlFormatChar@@YIEPADKDPAK@Z PROC			; BlRtlFormatChar, COMDAT
; _Output$ = ecx
; _OutputSize$ = edx

; 1032 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 55 f8	 mov	 DWORD PTR _OutputSize$[ebp], edx
  00008	89 4d fc	 mov	 DWORD PTR _Output$[ebp], ecx

; 1033 :     //
; 1034 :     // Check if there is sufficient space in the output buffer.
; 1035 :     //
; 1036 : 
; 1037 :     if (1 > OutputSize) {

  0000b	83 7d f8 01	 cmp	 DWORD PTR _OutputSize$[ebp], 1
  0000f	73 04		 jae	 SHORT $LN1@BlRtlForma@5

; 1038 : 
; 1039 :         return FALSE;

  00011	32 c0		 xor	 al, al
  00013	eb 13		 jmp	 SHORT $LN2@BlRtlForma@5
$LN1@BlRtlForma@5:

; 1040 :     }
; 1041 : 
; 1042 :     Output[0] = Value;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _Output$[ebp]
  00018	8a 4d 08	 mov	 cl, BYTE PTR _Value$[ebp]
  0001b	88 08		 mov	 BYTE PTR [eax], cl

; 1043 : 
; 1044 :     //
; 1045 :     // Set number of characters consumed in the buffer.
; 1046 :     //
; 1047 : 
; 1048 :     *CharactersConsumed = 1;

  0001d	8b 45 0c	 mov	 eax, DWORD PTR _CharactersConsumed$[ebp]
  00020	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 1049 : 
; 1050 :     return TRUE;

  00026	b0 01		 mov	 al, 1
$LN2@BlRtlForma@5:

; 1051 : }

  00028	c9		 leave
  00029	c2 08 00	 ret	 8
?BlRtlFormatChar@@YIEPADKDPAK@Z ENDP			; BlRtlFormatChar
_TEXT	ENDS
PUBLIC	?BlRtlFormatString@@YIEPADKPBD0@Z		; BlRtlFormatString
; Function compile flags: /Odsp
;	COMDAT ?BlRtlFormatString@@YIEPADKPBD0@Z
_TEXT	SEGMENT
tv131 = -36						; size = 4
tv75 = -32						; size = 4
_OutputSize$ = -28					; size = 4
_Output$ = -24						; size = 4
_CharactersConsumed$ = -20				; size = 4
_OutputIndex$ = -16					; size = 4
_InputIndex$ = -12					; size = 4
_Width$ = -8						; size = 4
_PadCharacter$ = -2					; size = 1
_TokenType$ = -1					; size = 1
_Format$ = 8						; size = 4
_ArgumentList$ = 12					; size = 4
?BlRtlFormatString@@YIEPADKPBD0@Z PROC			; BlRtlFormatString, COMDAT
; _Output$ = ecx
; _OutputSize$ = edx

; 1084 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 55 e4	 mov	 DWORD PTR _OutputSize$[ebp], edx
  00009	89 4d e8	 mov	 DWORD PTR _Output$[ebp], ecx

; 1085 :     UINT32 CharactersConsumed;
; 1086 :     UINT32 InputIndex;
; 1087 :     UINT32 OutputIndex;
; 1088 :     CHAR PadCharacter;
; 1089 :     UINT8 TokenType;
; 1090 :     INT32 Width;
; 1091 : 
; 1092 :     InputIndex = 0;

  0000c	83 65 f4 00	 and	 DWORD PTR _InputIndex$[ebp], 0

; 1093 :     OutputIndex = 0;

  00010	83 65 f0 00	 and	 DWORD PTR _OutputIndex$[ebp], 0
$LN30@BlRtlForma@6:

; 1094 : 
; 1095 :     for (;;) {
; 1096 : 
; 1097 :         if (OutputIndex == OutputSize) {

  00014	8b 45 f0	 mov	 eax, DWORD PTR _OutputIndex$[ebp]
  00017	3b 45 e4	 cmp	 eax, DWORD PTR _OutputSize$[ebp]
  0001a	75 07		 jne	 SHORT $LN28@BlRtlForma@6

; 1098 : 
; 1099 :             return FALSE;

  0001c	32 c0		 xor	 al, al
  0001e	e9 2f 03 00 00	 jmp	 $LN31@BlRtlForma@6
$LN28@BlRtlForma@6:

; 1100 :         }
; 1101 : 
; 1102 :         if (Format[InputIndex] == 0) {

  00023	8b 45 08	 mov	 eax, DWORD PTR _Format$[ebp]
  00026	03 45 f4	 add	 eax, DWORD PTR _InputIndex$[ebp]
  00029	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0002c	85 c0		 test	 eax, eax
  0002e	75 10		 jne	 SHORT $LN27@BlRtlForma@6

; 1103 : 
; 1104 :             Output[OutputIndex] = 0;

  00030	8b 45 e8	 mov	 eax, DWORD PTR _Output$[ebp]
  00033	03 45 f0	 add	 eax, DWORD PTR _OutputIndex$[ebp]
  00036	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1105 :             return TRUE;

  00039	b0 01		 mov	 al, 1
  0003b	e9 12 03 00 00	 jmp	 $LN31@BlRtlForma@6
$LN27@BlRtlForma@6:

; 1106 :         }
; 1107 : 
; 1108 :         if (Format[InputIndex] == '\\') {

  00040	8b 45 08	 mov	 eax, DWORD PTR _Format$[ebp]
  00043	03 45 f4	 add	 eax, DWORD PTR _InputIndex$[ebp]
  00046	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00049	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  0004c	75 6a		 jne	 SHORT $LN26@BlRtlForma@6

; 1109 : 
; 1110 :             switch (Format[InputIndex + 1]) {

  0004e	8b 45 08	 mov	 eax, DWORD PTR _Format$[ebp]
  00051	03 45 f4	 add	 eax, DWORD PTR _InputIndex$[ebp]
  00054	8a 40 01	 mov	 al, BYTE PTR [eax+1]
  00057	88 45 e0	 mov	 BYTE PTR tv75[ebp], al
  0005a	80 7d e0 5c	 cmp	 BYTE PTR tv75[ebp], 92	; 0000005cH
  0005e	74 0e		 je	 SHORT $LN23@BlRtlForma@6
  00060	80 7d e0 6e	 cmp	 BYTE PTR tv75[ebp], 110	; 0000006eH
  00064	74 2c		 je	 SHORT $LN21@BlRtlForma@6
  00066	80 7d e0 72	 cmp	 BYTE PTR tv75[ebp], 114	; 00000072H
  0006a	74 14		 je	 SHORT $LN22@BlRtlForma@6
  0006c	eb 36		 jmp	 SHORT $LN20@BlRtlForma@6
$LN23@BlRtlForma@6:

; 1111 : 
; 1112 :                 case '\\': {
; 1113 : 
; 1114 :                     Output[OutputIndex] = '\\';

  0006e	8b 45 e8	 mov	 eax, DWORD PTR _Output$[ebp]
  00071	03 45 f0	 add	 eax, DWORD PTR _OutputIndex$[ebp]
  00074	c6 00 5c	 mov	 BYTE PTR [eax], 92	; 0000005cH

; 1115 :                     OutputIndex += 1;

  00077	8b 45 f0	 mov	 eax, DWORD PTR _OutputIndex$[ebp]
  0007a	40		 inc	 eax
  0007b	89 45 f0	 mov	 DWORD PTR _OutputIndex$[ebp], eax

; 1116 :                     break;

  0007e	eb 2b		 jmp	 SHORT $LN24@BlRtlForma@6
$LN22@BlRtlForma@6:

; 1117 :                 }
; 1118 : 
; 1119 :                 case 'r': {
; 1120 : 
; 1121 :                     Output[OutputIndex] = '\r';

  00080	8b 45 e8	 mov	 eax, DWORD PTR _Output$[ebp]
  00083	03 45 f0	 add	 eax, DWORD PTR _OutputIndex$[ebp]
  00086	c6 00 0d	 mov	 BYTE PTR [eax], 13	; 0000000dH

; 1122 :                     OutputIndex += 1;

  00089	8b 45 f0	 mov	 eax, DWORD PTR _OutputIndex$[ebp]
  0008c	40		 inc	 eax
  0008d	89 45 f0	 mov	 DWORD PTR _OutputIndex$[ebp], eax

; 1123 :                     break;

  00090	eb 19		 jmp	 SHORT $LN24@BlRtlForma@6
$LN21@BlRtlForma@6:

; 1124 :                 }
; 1125 : 
; 1126 :                 case 'n': {
; 1127 : 
; 1128 :                     Output[OutputIndex] = '\r';

  00092	8b 45 e8	 mov	 eax, DWORD PTR _Output$[ebp]
  00095	03 45 f0	 add	 eax, DWORD PTR _OutputIndex$[ebp]
  00098	c6 00 0d	 mov	 BYTE PTR [eax], 13	; 0000000dH

; 1129 :                     OutputIndex += 1;

  0009b	8b 45 f0	 mov	 eax, DWORD PTR _OutputIndex$[ebp]
  0009e	40		 inc	 eax
  0009f	89 45 f0	 mov	 DWORD PTR _OutputIndex$[ebp], eax

; 1130 :                     break;

  000a2	eb 07		 jmp	 SHORT $LN24@BlRtlForma@6
$LN20@BlRtlForma@6:

; 1131 :                 }
; 1132 : 
; 1133 :                 default: {
; 1134 : 
; 1135 :                     return FALSE;

  000a4	32 c0		 xor	 al, al
  000a6	e9 a7 02 00 00	 jmp	 $LN31@BlRtlForma@6
$LN24@BlRtlForma@6:

; 1136 :                 }
; 1137 :             }
; 1138 : 
; 1139 :             InputIndex += 2;

  000ab	8b 45 f4	 mov	 eax, DWORD PTR _InputIndex$[ebp]
  000ae	40		 inc	 eax
  000af	40		 inc	 eax
  000b0	89 45 f4	 mov	 DWORD PTR _InputIndex$[ebp], eax

; 1140 :             continue;

  000b3	e9 5c ff ff ff	 jmp	 $LN30@BlRtlForma@6
$LN26@BlRtlForma@6:

; 1141 :         }
; 1142 : 
; 1143 :         if (BlRtlParseTypeSpecifier(&Format[InputIndex],
; 1144 :                                     &Width,
; 1145 :                                     &PadCharacter,
; 1146 :                                     &TokenType,
; 1147 :                                     &CharactersConsumed) != FALSE) {

  000b8	8d 45 ec	 lea	 eax, DWORD PTR _CharactersConsumed$[ebp]
  000bb	50		 push	 eax
  000bc	8d 45 ff	 lea	 eax, DWORD PTR _TokenType$[ebp]
  000bf	50		 push	 eax
  000c0	8d 45 fe	 lea	 eax, DWORD PTR _PadCharacter$[ebp]
  000c3	50		 push	 eax
  000c4	8b 4d 08	 mov	 ecx, DWORD PTR _Format$[ebp]
  000c7	03 4d f4	 add	 ecx, DWORD PTR _InputIndex$[ebp]
  000ca	8d 55 f8	 lea	 edx, DWORD PTR _Width$[ebp]
  000cd	e8 00 00 00 00	 call	 ?BlRtlParseTypeSpecifier@@YIEPBDPAJPADPAEPAK@Z ; BlRtlParseTypeSpecifier
  000d2	0f b6 c0	 movzx	 eax, al
  000d5	85 c0		 test	 eax, eax
  000d7	0f 84 52 02 00
	00		 je	 $LN19@BlRtlForma@6

; 1148 : 
; 1149 :             InputIndex += CharactersConsumed;

  000dd	8b 45 f4	 mov	 eax, DWORD PTR _InputIndex$[ebp]
  000e0	03 45 ec	 add	 eax, DWORD PTR _CharactersConsumed$[ebp]
  000e3	89 45 f4	 mov	 DWORD PTR _InputIndex$[ebp], eax

; 1150 : 
; 1151 :             switch (TokenType) {

  000e6	0f b6 45 ff	 movzx	 eax, BYTE PTR _TokenType$[ebp]
  000ea	89 45 dc	 mov	 DWORD PTR tv131[ebp], eax
  000ed	8b 45 dc	 mov	 eax, DWORD PTR tv131[ebp]
  000f0	48		 dec	 eax
  000f1	89 45 dc	 mov	 DWORD PTR tv131[ebp], eax
  000f4	83 7d dc 08	 cmp	 DWORD PTR tv131[ebp], 8
  000f8	0f 87 2c 02 00
	00		 ja	 $LN17@BlRtlForma@6
  000fe	8b 45 dc	 mov	 eax, DWORD PTR tv131[ebp]
  00101	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@BlRtlForma@6[eax*4]
$LN16@BlRtlForma@6:

; 1152 : 
; 1153 :                 case STRING_TOKEN_LONG: {
; 1154 : 
; 1155 :                     if (BlRtlFormatSignedDecimalLong(&Output[OutputIndex],
; 1156 :                                                      OutputSize - OutputIndex,
; 1157 :                                                      va_arg(ArgumentList, INT32),
; 1158 :                                                      Width,
; 1159 :                                                      &CharactersConsumed) == FALSE) {

  00108	8b 45 0c	 mov	 eax, DWORD PTR _ArgumentList$[ebp]
  0010b	83 c0 04	 add	 eax, 4
  0010e	89 45 0c	 mov	 DWORD PTR _ArgumentList$[ebp], eax
  00111	8d 45 ec	 lea	 eax, DWORD PTR _CharactersConsumed$[ebp]
  00114	50		 push	 eax
  00115	ff 75 f8	 push	 DWORD PTR _Width$[ebp]
  00118	8b 45 0c	 mov	 eax, DWORD PTR _ArgumentList$[ebp]
  0011b	ff 70 fc	 push	 DWORD PTR [eax-4]
  0011e	8b 55 e4	 mov	 edx, DWORD PTR _OutputSize$[ebp]
  00121	2b 55 f0	 sub	 edx, DWORD PTR _OutputIndex$[ebp]
  00124	8b 4d e8	 mov	 ecx, DWORD PTR _Output$[ebp]
  00127	03 4d f0	 add	 ecx, DWORD PTR _OutputIndex$[ebp]
  0012a	e8 00 00 00 00	 call	 ?BlRtlFormatSignedDecimalLong@@YIEPADKJJPAK@Z ; BlRtlFormatSignedDecimalLong
  0012f	0f b6 c0	 movzx	 eax, al
  00132	85 c0		 test	 eax, eax
  00134	75 07		 jne	 SHORT $LN15@BlRtlForma@6

; 1160 : 
; 1161 :                         return FALSE;

  00136	32 c0		 xor	 al, al
  00138	e9 15 02 00 00	 jmp	 $LN31@BlRtlForma@6
$LN15@BlRtlForma@6:

; 1162 :                     }
; 1163 : 
; 1164 :                     OutputIndex += CharactersConsumed;

  0013d	8b 45 f0	 mov	 eax, DWORD PTR _OutputIndex$[ebp]
  00140	03 45 ec	 add	 eax, DWORD PTR _CharactersConsumed$[ebp]
  00143	89 45 f0	 mov	 DWORD PTR _OutputIndex$[ebp], eax

; 1165 :                     break;

  00146	e9 df 01 00 00	 jmp	 $LN17@BlRtlForma@6
$LN14@BlRtlForma@6:

; 1166 :                 }
; 1167 : 
; 1168 :                 case STRING_TOKEN_ULONG: {
; 1169 : 
; 1170 :                     if (BlRtlFormatUnsignedLong(&Output[OutputIndex],
; 1171 :                                                 OutputSize - OutputIndex,
; 1172 :                                                 va_arg(ArgumentList, UINT32),
; 1173 :                                                 PadCharacter,
; 1174 :                                                 Width,
; 1175 :                                                 10,
; 1176 :                                                 &CharactersConsumed) == FALSE) {

  0014b	8b 45 0c	 mov	 eax, DWORD PTR _ArgumentList$[ebp]
  0014e	83 c0 04	 add	 eax, 4
  00151	89 45 0c	 mov	 DWORD PTR _ArgumentList$[ebp], eax
  00154	8d 45 ec	 lea	 eax, DWORD PTR _CharactersConsumed$[ebp]
  00157	50		 push	 eax
  00158	6a 0a		 push	 10			; 0000000aH
  0015a	ff 75 f8	 push	 DWORD PTR _Width$[ebp]
  0015d	ff 75 fe	 push	 DWORD PTR _PadCharacter$[ebp]
  00160	8b 45 0c	 mov	 eax, DWORD PTR _ArgumentList$[ebp]
  00163	ff 70 fc	 push	 DWORD PTR [eax-4]
  00166	8b 55 e4	 mov	 edx, DWORD PTR _OutputSize$[ebp]
  00169	2b 55 f0	 sub	 edx, DWORD PTR _OutputIndex$[ebp]
  0016c	8b 4d e8	 mov	 ecx, DWORD PTR _Output$[ebp]
  0016f	03 4d f0	 add	 ecx, DWORD PTR _OutputIndex$[ebp]
  00172	e8 00 00 00 00	 call	 ?BlRtlFormatUnsignedLong@@YIEPADKKEJKPAK@Z ; BlRtlFormatUnsignedLong
  00177	0f b6 c0	 movzx	 eax, al
  0017a	85 c0		 test	 eax, eax
  0017c	75 07		 jne	 SHORT $LN13@BlRtlForma@6

; 1177 : 
; 1178 :                         return FALSE;

  0017e	32 c0		 xor	 al, al
  00180	e9 cd 01 00 00	 jmp	 $LN31@BlRtlForma@6
$LN13@BlRtlForma@6:

; 1179 :                     }
; 1180 : 
; 1181 :                     OutputIndex += CharactersConsumed;

  00185	8b 45 f0	 mov	 eax, DWORD PTR _OutputIndex$[ebp]
  00188	03 45 ec	 add	 eax, DWORD PTR _CharactersConsumed$[ebp]
  0018b	89 45 f0	 mov	 DWORD PTR _OutputIndex$[ebp], eax

; 1182 :                     break;

  0018e	e9 97 01 00 00	 jmp	 $LN17@BlRtlForma@6
$LN12@BlRtlForma@6:

; 1183 :                 }
; 1184 : 
; 1185 :                 case STRING_TOKEN_ULONG_HEX: {
; 1186 : 
; 1187 :                     if (BlRtlFormatUnsignedLong(&Output[OutputIndex],
; 1188 :                                                 OutputSize - OutputIndex,
; 1189 :                                                 va_arg(ArgumentList, UINT32),
; 1190 :                                                 PadCharacter,
; 1191 :                                                 Width,
; 1192 :                                                 16,
; 1193 :                                                 &CharactersConsumed) == FALSE) {

  00193	8b 45 0c	 mov	 eax, DWORD PTR _ArgumentList$[ebp]
  00196	83 c0 04	 add	 eax, 4
  00199	89 45 0c	 mov	 DWORD PTR _ArgumentList$[ebp], eax
  0019c	8d 45 ec	 lea	 eax, DWORD PTR _CharactersConsumed$[ebp]
  0019f	50		 push	 eax
  001a0	6a 10		 push	 16			; 00000010H
  001a2	ff 75 f8	 push	 DWORD PTR _Width$[ebp]
  001a5	ff 75 fe	 push	 DWORD PTR _PadCharacter$[ebp]
  001a8	8b 45 0c	 mov	 eax, DWORD PTR _ArgumentList$[ebp]
  001ab	ff 70 fc	 push	 DWORD PTR [eax-4]
  001ae	8b 55 e4	 mov	 edx, DWORD PTR _OutputSize$[ebp]
  001b1	2b 55 f0	 sub	 edx, DWORD PTR _OutputIndex$[ebp]
  001b4	8b 4d e8	 mov	 ecx, DWORD PTR _Output$[ebp]
  001b7	03 4d f0	 add	 ecx, DWORD PTR _OutputIndex$[ebp]
  001ba	e8 00 00 00 00	 call	 ?BlRtlFormatUnsignedLong@@YIEPADKKEJKPAK@Z ; BlRtlFormatUnsignedLong
  001bf	0f b6 c0	 movzx	 eax, al
  001c2	85 c0		 test	 eax, eax
  001c4	75 07		 jne	 SHORT $LN11@BlRtlForma@6

; 1194 : 
; 1195 :                         return FALSE;

  001c6	32 c0		 xor	 al, al
  001c8	e9 85 01 00 00	 jmp	 $LN31@BlRtlForma@6
$LN11@BlRtlForma@6:

; 1196 :                     }
; 1197 : 
; 1198 :                     OutputIndex += CharactersConsumed;

  001cd	8b 45 f0	 mov	 eax, DWORD PTR _OutputIndex$[ebp]
  001d0	03 45 ec	 add	 eax, DWORD PTR _CharactersConsumed$[ebp]
  001d3	89 45 f0	 mov	 DWORD PTR _OutputIndex$[ebp], eax

; 1199 :                     break;

  001d6	e9 4f 01 00 00	 jmp	 $LN17@BlRtlForma@6
$LN10@BlRtlForma@6:

; 1200 :                 }
; 1201 : 
; 1202 :                 case STRING_TOKEN_ULONGLONG: {
; 1203 : 
; 1204 :                     if (BlRtlFormatUnsignedLongLong(&Output[OutputIndex],
; 1205 :                                                     OutputSize - OutputIndex,
; 1206 :                                                     va_arg(ArgumentList, UINT64),
; 1207 :                                                     PadCharacter,
; 1208 :                                                     Width,
; 1209 :                                                     10,
; 1210 :                                                     &CharactersConsumed) == FALSE) {

  001db	8b 45 0c	 mov	 eax, DWORD PTR _ArgumentList$[ebp]
  001de	83 c0 08	 add	 eax, 8
  001e1	89 45 0c	 mov	 DWORD PTR _ArgumentList$[ebp], eax
  001e4	8d 45 ec	 lea	 eax, DWORD PTR _CharactersConsumed$[ebp]
  001e7	50		 push	 eax
  001e8	6a 0a		 push	 10			; 0000000aH
  001ea	ff 75 f8	 push	 DWORD PTR _Width$[ebp]
  001ed	ff 75 fe	 push	 DWORD PTR _PadCharacter$[ebp]
  001f0	8b 45 0c	 mov	 eax, DWORD PTR _ArgumentList$[ebp]
  001f3	ff 70 fc	 push	 DWORD PTR [eax-4]
  001f6	ff 70 f8	 push	 DWORD PTR [eax-8]
  001f9	8b 55 e4	 mov	 edx, DWORD PTR _OutputSize$[ebp]
  001fc	2b 55 f0	 sub	 edx, DWORD PTR _OutputIndex$[ebp]
  001ff	8b 4d e8	 mov	 ecx, DWORD PTR _Output$[ebp]
  00202	03 4d f0	 add	 ecx, DWORD PTR _OutputIndex$[ebp]
  00205	e8 00 00 00 00	 call	 ?BlRtlFormatUnsignedLongLong@@YIEPADK_KEJKPAK@Z ; BlRtlFormatUnsignedLongLong
  0020a	0f b6 c0	 movzx	 eax, al
  0020d	85 c0		 test	 eax, eax
  0020f	75 07		 jne	 SHORT $LN9@BlRtlForma@6

; 1211 : 
; 1212 :                         return FALSE;

  00211	32 c0		 xor	 al, al
  00213	e9 3a 01 00 00	 jmp	 $LN31@BlRtlForma@6
$LN9@BlRtlForma@6:

; 1213 :                     }
; 1214 : 
; 1215 :                     OutputIndex += CharactersConsumed;

  00218	8b 45 f0	 mov	 eax, DWORD PTR _OutputIndex$[ebp]
  0021b	03 45 ec	 add	 eax, DWORD PTR _CharactersConsumed$[ebp]
  0021e	89 45 f0	 mov	 DWORD PTR _OutputIndex$[ebp], eax

; 1216 :                     break;

  00221	e9 04 01 00 00	 jmp	 $LN17@BlRtlForma@6
$LN8@BlRtlForma@6:

; 1217 :                 }
; 1218 : 
; 1219 :                 case STRING_TOKEN_ULONGLONG_HEX: {
; 1220 : 
; 1221 :                     if (BlRtlFormatUnsignedLongLong(&Output[OutputIndex],
; 1222 :                                                     OutputSize - OutputIndex,
; 1223 :                                                     va_arg(ArgumentList, UINT64),
; 1224 :                                                     PadCharacter,
; 1225 :                                                     Width,
; 1226 :                                                     16,
; 1227 :                                                     &CharactersConsumed) == FALSE) {

  00226	8b 45 0c	 mov	 eax, DWORD PTR _ArgumentList$[ebp]
  00229	83 c0 08	 add	 eax, 8
  0022c	89 45 0c	 mov	 DWORD PTR _ArgumentList$[ebp], eax
  0022f	8d 45 ec	 lea	 eax, DWORD PTR _CharactersConsumed$[ebp]
  00232	50		 push	 eax
  00233	6a 10		 push	 16			; 00000010H
  00235	ff 75 f8	 push	 DWORD PTR _Width$[ebp]
  00238	ff 75 fe	 push	 DWORD PTR _PadCharacter$[ebp]
  0023b	8b 45 0c	 mov	 eax, DWORD PTR _ArgumentList$[ebp]
  0023e	ff 70 fc	 push	 DWORD PTR [eax-4]
  00241	ff 70 f8	 push	 DWORD PTR [eax-8]
  00244	8b 55 e4	 mov	 edx, DWORD PTR _OutputSize$[ebp]
  00247	2b 55 f0	 sub	 edx, DWORD PTR _OutputIndex$[ebp]
  0024a	8b 4d e8	 mov	 ecx, DWORD PTR _Output$[ebp]
  0024d	03 4d f0	 add	 ecx, DWORD PTR _OutputIndex$[ebp]
  00250	e8 00 00 00 00	 call	 ?BlRtlFormatUnsignedLongLong@@YIEPADK_KEJKPAK@Z ; BlRtlFormatUnsignedLongLong
  00255	0f b6 c0	 movzx	 eax, al
  00258	85 c0		 test	 eax, eax
  0025a	75 07		 jne	 SHORT $LN7@BlRtlForma@6

; 1228 : 
; 1229 :                         return FALSE;

  0025c	32 c0		 xor	 al, al
  0025e	e9 ef 00 00 00	 jmp	 $LN31@BlRtlForma@6
$LN7@BlRtlForma@6:

; 1230 :                     }
; 1231 : 
; 1232 :                     OutputIndex += CharactersConsumed;

  00263	8b 45 f0	 mov	 eax, DWORD PTR _OutputIndex$[ebp]
  00266	03 45 ec	 add	 eax, DWORD PTR _CharactersConsumed$[ebp]
  00269	89 45 f0	 mov	 DWORD PTR _OutputIndex$[ebp], eax

; 1233 :                     break;

  0026c	e9 b9 00 00 00	 jmp	 $LN17@BlRtlForma@6
$LN6@BlRtlForma@6:

; 1234 :                 }
; 1235 : 
; 1236 :                 case STRING_TOKEN_PVOID: {
; 1237 : 
; 1238 : #if defined(BOOT_X86)
; 1239 : 
; 1240 :                     if (BlRtlFormatUnsignedLong(&Output[OutputIndex],
; 1241 :                                                 OutputSize - OutputIndex,
; 1242 :                                                 va_arg(ArgumentList, UINT32),
; 1243 :                                                 '0',
; 1244 :                                                 8,
; 1245 :                                                 16,
; 1246 :                                                 &CharactersConsumed) == FALSE) {

  00271	8b 45 0c	 mov	 eax, DWORD PTR _ArgumentList$[ebp]
  00274	83 c0 04	 add	 eax, 4
  00277	89 45 0c	 mov	 DWORD PTR _ArgumentList$[ebp], eax
  0027a	8d 45 ec	 lea	 eax, DWORD PTR _CharactersConsumed$[ebp]
  0027d	50		 push	 eax
  0027e	6a 10		 push	 16			; 00000010H
  00280	6a 08		 push	 8
  00282	6a 30		 push	 48			; 00000030H
  00284	8b 45 0c	 mov	 eax, DWORD PTR _ArgumentList$[ebp]
  00287	ff 70 fc	 push	 DWORD PTR [eax-4]
  0028a	8b 55 e4	 mov	 edx, DWORD PTR _OutputSize$[ebp]
  0028d	2b 55 f0	 sub	 edx, DWORD PTR _OutputIndex$[ebp]
  00290	8b 4d e8	 mov	 ecx, DWORD PTR _Output$[ebp]
  00293	03 4d f0	 add	 ecx, DWORD PTR _OutputIndex$[ebp]
  00296	e8 00 00 00 00	 call	 ?BlRtlFormatUnsignedLong@@YIEPADKKEJKPAK@Z ; BlRtlFormatUnsignedLong
  0029b	0f b6 c0	 movzx	 eax, al
  0029e	85 c0		 test	 eax, eax
  002a0	75 07		 jne	 SHORT $LN5@BlRtlForma@6

; 1247 : 
; 1248 :                         return FALSE;

  002a2	32 c0		 xor	 al, al
  002a4	e9 a9 00 00 00	 jmp	 $LN31@BlRtlForma@6
$LN5@BlRtlForma@6:

; 1249 :                     }
; 1250 : 
; 1251 : #elif defined(BOOT_X64)
; 1252 : 
; 1253 :                     if (BlRtlFormatUnsignedLongLong(&Output[OutputIndex],
; 1254 :                                                     OutputSize - OutputIndex,
; 1255 :                                                     va_arg(ArgumentList, UINT64),
; 1256 :                                                     '0',
; 1257 :                                                     16,
; 1258 :                                                     16,
; 1259 :                                                     &CharactersConsumed) == FALSE) {
; 1260 : 
; 1261 :                         return FALSE;
; 1262 :                     }
; 1263 : 
; 1264 : #endif
; 1265 : 
; 1266 :                     OutputIndex += CharactersConsumed;

  002a9	8b 45 f0	 mov	 eax, DWORD PTR _OutputIndex$[ebp]
  002ac	03 45 ec	 add	 eax, DWORD PTR _CharactersConsumed$[ebp]
  002af	89 45 f0	 mov	 DWORD PTR _OutputIndex$[ebp], eax

; 1267 :                     break;

  002b2	eb 76		 jmp	 SHORT $LN17@BlRtlForma@6
$LN4@BlRtlForma@6:

; 1268 :                 }
; 1269 : 
; 1270 :                 case STRING_TOKEN_PCHAR: {
; 1271 : 
; 1272 :                     if (BlRtlFormatStringToken(&Output[OutputIndex],
; 1273 :                                                OutputSize - OutputIndex,
; 1274 :                                                va_arg(ArgumentList, PCHAR),
; 1275 :                                                Width,
; 1276 :                                                &CharactersConsumed) == FALSE) {

  002b4	8b 45 0c	 mov	 eax, DWORD PTR _ArgumentList$[ebp]
  002b7	83 c0 04	 add	 eax, 4
  002ba	89 45 0c	 mov	 DWORD PTR _ArgumentList$[ebp], eax
  002bd	8d 45 ec	 lea	 eax, DWORD PTR _CharactersConsumed$[ebp]
  002c0	50		 push	 eax
  002c1	ff 75 f8	 push	 DWORD PTR _Width$[ebp]
  002c4	8b 45 0c	 mov	 eax, DWORD PTR _ArgumentList$[ebp]
  002c7	ff 70 fc	 push	 DWORD PTR [eax-4]
  002ca	8b 55 e4	 mov	 edx, DWORD PTR _OutputSize$[ebp]
  002cd	2b 55 f0	 sub	 edx, DWORD PTR _OutputIndex$[ebp]
  002d0	8b 4d e8	 mov	 ecx, DWORD PTR _Output$[ebp]
  002d3	03 4d f0	 add	 ecx, DWORD PTR _OutputIndex$[ebp]
  002d6	e8 00 00 00 00	 call	 ?BlRtlFormatStringToken@@YIEPADKPBDJPAK@Z ; BlRtlFormatStringToken
  002db	0f b6 c0	 movzx	 eax, al
  002de	85 c0		 test	 eax, eax
  002e0	75 04		 jne	 SHORT $LN3@BlRtlForma@6

; 1277 : 
; 1278 :                         return FALSE;

  002e2	32 c0		 xor	 al, al
  002e4	eb 6c		 jmp	 SHORT $LN31@BlRtlForma@6
$LN3@BlRtlForma@6:

; 1279 :                     }
; 1280 : 
; 1281 :                     OutputIndex += CharactersConsumed;

  002e6	8b 45 f0	 mov	 eax, DWORD PTR _OutputIndex$[ebp]
  002e9	03 45 ec	 add	 eax, DWORD PTR _CharactersConsumed$[ebp]
  002ec	89 45 f0	 mov	 DWORD PTR _OutputIndex$[ebp], eax

; 1282 :                     break;

  002ef	eb 39		 jmp	 SHORT $LN17@BlRtlForma@6
$LN2@BlRtlForma@6:

; 1283 :                 }
; 1284 : 
; 1285 :                 case STRING_TOKEN_CHAR: {
; 1286 : 
; 1287 :                     if (BlRtlFormatChar(&Output[OutputIndex],
; 1288 :                                         OutputSize - OutputIndex,
; 1289 :                                         va_arg(ArgumentList, CHAR),
; 1290 :                                         &CharactersConsumed) == FALSE) {

  002f1	8b 45 0c	 mov	 eax, DWORD PTR _ArgumentList$[ebp]
  002f4	83 c0 04	 add	 eax, 4
  002f7	89 45 0c	 mov	 DWORD PTR _ArgumentList$[ebp], eax
  002fa	8d 45 ec	 lea	 eax, DWORD PTR _CharactersConsumed$[ebp]
  002fd	50		 push	 eax
  002fe	8b 45 0c	 mov	 eax, DWORD PTR _ArgumentList$[ebp]
  00301	8a 40 fc	 mov	 al, BYTE PTR [eax-4]
  00304	50		 push	 eax
  00305	8b 55 e4	 mov	 edx, DWORD PTR _OutputSize$[ebp]
  00308	2b 55 f0	 sub	 edx, DWORD PTR _OutputIndex$[ebp]
  0030b	8b 4d e8	 mov	 ecx, DWORD PTR _Output$[ebp]
  0030e	03 4d f0	 add	 ecx, DWORD PTR _OutputIndex$[ebp]
  00311	e8 00 00 00 00	 call	 ?BlRtlFormatChar@@YIEPADKDPAK@Z ; BlRtlFormatChar
  00316	0f b6 c0	 movzx	 eax, al
  00319	85 c0		 test	 eax, eax
  0031b	75 04		 jne	 SHORT $LN1@BlRtlForma@6

; 1291 : 
; 1292 :                         return FALSE;

  0031d	32 c0		 xor	 al, al
  0031f	eb 31		 jmp	 SHORT $LN31@BlRtlForma@6
$LN1@BlRtlForma@6:

; 1293 :                     }
; 1294 : 
; 1295 :                     OutputIndex += CharactersConsumed;

  00321	8b 45 f0	 mov	 eax, DWORD PTR _OutputIndex$[ebp]
  00324	03 45 ec	 add	 eax, DWORD PTR _CharactersConsumed$[ebp]
  00327	89 45 f0	 mov	 DWORD PTR _OutputIndex$[ebp], eax
$LN17@BlRtlForma@6:

; 1296 :                     break;
; 1297 :                 }
; 1298 :             }
; 1299 : 
; 1300 :             continue;

  0032a	e9 e5 fc ff ff	 jmp	 $LN30@BlRtlForma@6
$LN19@BlRtlForma@6:

; 1301 :         }
; 1302 : 
; 1303 :         Output[OutputIndex] = Format[InputIndex];

  0032f	8b 45 e8	 mov	 eax, DWORD PTR _Output$[ebp]
  00332	03 45 f0	 add	 eax, DWORD PTR _OutputIndex$[ebp]
  00335	8b 4d 08	 mov	 ecx, DWORD PTR _Format$[ebp]
  00338	03 4d f4	 add	 ecx, DWORD PTR _InputIndex$[ebp]
  0033b	8a 09		 mov	 cl, BYTE PTR [ecx]
  0033d	88 08		 mov	 BYTE PTR [eax], cl

; 1304 :         InputIndex += 1;

  0033f	8b 45 f4	 mov	 eax, DWORD PTR _InputIndex$[ebp]
  00342	40		 inc	 eax
  00343	89 45 f4	 mov	 DWORD PTR _InputIndex$[ebp], eax

; 1305 :         OutputIndex += 1;

  00346	8b 45 f0	 mov	 eax, DWORD PTR _OutputIndex$[ebp]
  00349	40		 inc	 eax
  0034a	89 45 f0	 mov	 DWORD PTR _OutputIndex$[ebp], eax

; 1306 :     }

  0034d	e9 c2 fc ff ff	 jmp	 $LN30@BlRtlForma@6
$LN31@BlRtlForma@6:

; 1307 : }

  00352	c9		 leave
  00353	c2 08 00	 ret	 8
  00356	8b ff		 npad	 2
$LN35@BlRtlForma@6:
  00358	00 00 00 00	 DD	 $LN16@BlRtlForma@6
  0035c	00 00 00 00	 DD	 $LN14@BlRtlForma@6
  00360	00 00 00 00	 DD	 $LN12@BlRtlForma@6
  00364	00 00 00 00	 DD	 $LN17@BlRtlForma@6
  00368	00 00 00 00	 DD	 $LN10@BlRtlForma@6
  0036c	00 00 00 00	 DD	 $LN8@BlRtlForma@6
  00370	00 00 00 00	 DD	 $LN6@BlRtlForma@6
  00374	00 00 00 00	 DD	 $LN4@BlRtlForma@6
  00378	00 00 00 00	 DD	 $LN2@BlRtlForma@6
?BlRtlFormatString@@YIEPADKPBD0@Z ENDP			; BlRtlFormatString
_TEXT	ENDS
PUBLIC	?BlRtlPrintf@@YAEPBDZZ				; BlRtlPrintf
EXTRN	?BlKdPrintString@@YIEPBD@Z:PROC			; BlKdPrintString
EXTRN	?BlVideoPrintString@@YIXPBD@Z:PROC		; BlVideoPrintString
; Function compile flags: /Odsp
;	COMDAT ?BlRtlPrintf@@YAEPBDZZ
_TEXT	SEGMENT
_Buffer$ = -4104					; size = 4096
_ArgumentList$ = -4					; size = 4
_Format$ = 8						; size = 4
?BlRtlPrintf@@YAEPBDZZ PROC				; BlRtlPrintf, COMDAT

; 1334 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 10 00
	00		 sub	 esp, 4104		; 00001008H

; 1335 :     va_list ArgumentList;
; 1336 :     CHAR Buffer[4096];
; 1337 : 
; 1338 :     va_start(ArgumentList, Format);

  00009	8d 45 0c	 lea	 eax, DWORD PTR _Format$[ebp+4]
  0000c	89 45 fc	 mov	 DWORD PTR _ArgumentList$[ebp], eax

; 1339 : 
; 1340 :     if (BlRtlFormatString(Buffer, sizeof(Buffer), Format, ArgumentList) == FALSE) {

  0000f	ff 75 fc	 push	 DWORD PTR _ArgumentList$[ebp]
  00012	ff 75 08	 push	 DWORD PTR _Format$[ebp]
  00015	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  0001a	8d 8d f8 ef ff
	ff		 lea	 ecx, DWORD PTR _Buffer$[ebp]
  00020	e8 00 00 00 00	 call	 ?BlRtlFormatString@@YIEPADKPBD0@Z ; BlRtlFormatString
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	75 04		 jne	 SHORT $LN1@BlRtlPrint

; 1341 : 
; 1342 :         return FALSE;

  0002c	32 c0		 xor	 al, al
  0002e	eb 18		 jmp	 SHORT $LN2@BlRtlPrint
$LN1@BlRtlPrint:

; 1343 :     }
; 1344 : 
; 1345 :     BlVideoPrintString(Buffer);

  00030	8d 8d f8 ef ff
	ff		 lea	 ecx, DWORD PTR _Buffer$[ebp]
  00036	e8 00 00 00 00	 call	 ?BlVideoPrintString@@YIXPBD@Z ; BlVideoPrintString

; 1346 : 
; 1347 :     BlKdPrintString(Buffer);

  0003b	8d 8d f8 ef ff
	ff		 lea	 ecx, DWORD PTR _Buffer$[ebp]
  00041	e8 00 00 00 00	 call	 ?BlKdPrintString@@YIEPBD@Z ; BlKdPrintString

; 1348 : 
; 1349 :     return TRUE;

  00046	b0 01		 mov	 al, 1
$LN2@BlRtlPrint:

; 1350 : }

  00048	c9		 leave
  00049	c3		 ret	 0
?BlRtlPrintf@@YAEPBDZZ ENDP				; BlRtlPrintf
; Function compile flags: /Odsp
_TEXT	ENDS
;	COMDAT ?BlRtlEqualStringN@@YIEPBD0K@Z
_TEXT	SEGMENT
_String2$ = -8						; size = 4
_String1$ = -4						; size = 4
_Count$ = 8						; size = 4
?BlRtlEqualStringN@@YIEPBD0K@Z PROC			; BlRtlEqualStringN, COMDAT
; _String1$ = ecx
; _String2$ = edx

; 1380 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 55 f8	 mov	 DWORD PTR _String2$[ebp], edx
  00008	89 4d fc	 mov	 DWORD PTR _String1$[ebp], ecx
$LN5@BlRtlEqual:

; 1381 :     while (Count > 0) {

  0000b	83 7d 08 00	 cmp	 DWORD PTR _Count$[ebp], 0
  0000f	76 43		 jbe	 SHORT $LN4@BlRtlEqual

; 1382 : 
; 1383 :         if ((*String1 == 0) || (*String2 == 0)) {

  00011	8b 45 fc	 mov	 eax, DWORD PTR _String1$[ebp]
  00014	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00017	85 c0		 test	 eax, eax
  00019	74 0a		 je	 SHORT $LN2@BlRtlEqual
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _String2$[ebp]
  0001e	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00021	85 c0		 test	 eax, eax
  00023	75 04		 jne	 SHORT $LN3@BlRtlEqual
$LN2@BlRtlEqual:

; 1384 : 
; 1385 :             return FALSE;

  00025	32 c0		 xor	 al, al
  00027	eb 2d		 jmp	 SHORT $LN6@BlRtlEqual
$LN3@BlRtlEqual:

; 1386 :         }
; 1387 : 
; 1388 :         if (*String1 != *String2) {

  00029	8b 45 fc	 mov	 eax, DWORD PTR _String1$[ebp]
  0002c	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0002f	8b 4d f8	 mov	 ecx, DWORD PTR _String2$[ebp]
  00032	0f be 09	 movsx	 ecx, BYTE PTR [ecx]
  00035	3b c1		 cmp	 eax, ecx
  00037	74 04		 je	 SHORT $LN1@BlRtlEqual

; 1389 : 
; 1390 :             return FALSE;

  00039	32 c0		 xor	 al, al
  0003b	eb 19		 jmp	 SHORT $LN6@BlRtlEqual
$LN1@BlRtlEqual:

; 1391 :         }
; 1392 : 
; 1393 :         String1 += 1;

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _String1$[ebp]
  00040	40		 inc	 eax
  00041	89 45 fc	 mov	 DWORD PTR _String1$[ebp], eax

; 1394 :         String2 += 1;

  00044	8b 45 f8	 mov	 eax, DWORD PTR _String2$[ebp]
  00047	40		 inc	 eax
  00048	89 45 f8	 mov	 DWORD PTR _String2$[ebp], eax

; 1395 :         Count -= 1;

  0004b	8b 45 08	 mov	 eax, DWORD PTR _Count$[ebp]
  0004e	48		 dec	 eax
  0004f	89 45 08	 mov	 DWORD PTR _Count$[ebp], eax

; 1396 :     }

  00052	eb b7		 jmp	 SHORT $LN5@BlRtlEqual
$LN4@BlRtlEqual:

; 1397 : 
; 1398 :     return TRUE;

  00054	b0 01		 mov	 al, 1
$LN6@BlRtlEqual:

; 1399 : }

  00056	c9		 leave
  00057	c2 04 00	 ret	 4
?BlRtlEqualStringN@@YIEPBD0K@Z ENDP			; BlRtlEqualStringN
_TEXT	ENDS
PUBLIC	?BlRtlEqualStringI@@YIEPBD0@Z			; BlRtlEqualStringI
; Function compile flags: /Odsp
;	COMDAT ?BlRtlEqualStringI@@YIEPBD0@Z
_TEXT	SEGMENT
_String2$ = -8						; size = 4
_String1$ = -4						; size = 4
?BlRtlEqualStringI@@YIEPBD0@Z PROC			; BlRtlEqualStringI, COMDAT
; _String1$ = ecx
; _String2$ = edx

; 1426 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	56		 push	 esi
  00006	89 55 f8	 mov	 DWORD PTR _String2$[ebp], edx
  00009	89 4d fc	 mov	 DWORD PTR _String1$[ebp], ecx
$LN4@BlRtlEqual@2:

; 1427 :     for (;;) {
; 1428 : 
; 1429 :         if (BlRtlConvertCharacterToUpperCase(*String1) != BlRtlConvertCharacterToUpperCase(*String2)) {

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _String1$[ebp]
  0000f	8a 08		 mov	 cl, BYTE PTR [eax]
  00011	e8 00 00 00 00	 call	 ?BlRtlConvertCharacterToUpperCase@@YIDD@Z ; BlRtlConvertCharacterToUpperCase
  00016	0f be f0	 movsx	 esi, al
  00019	8b 45 f8	 mov	 eax, DWORD PTR _String2$[ebp]
  0001c	8a 08		 mov	 cl, BYTE PTR [eax]
  0001e	e8 00 00 00 00	 call	 ?BlRtlConvertCharacterToUpperCase@@YIDD@Z ; BlRtlConvertCharacterToUpperCase
  00023	0f be c0	 movsx	 eax, al
  00026	3b f0		 cmp	 esi, eax
  00028	74 04		 je	 SHORT $LN2@BlRtlEqual@2

; 1430 : 
; 1431 :             return FALSE;

  0002a	32 c0		 xor	 al, al
  0002c	eb 1e		 jmp	 SHORT $LN5@BlRtlEqual@2
$LN2@BlRtlEqual@2:

; 1432 :         }
; 1433 : 
; 1434 :         if (*String1 == 0) {

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _String1$[ebp]
  00031	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00034	85 c0		 test	 eax, eax
  00036	75 04		 jne	 SHORT $LN1@BlRtlEqual@2

; 1435 : 
; 1436 :             return TRUE;

  00038	b0 01		 mov	 al, 1
  0003a	eb 10		 jmp	 SHORT $LN5@BlRtlEqual@2
$LN1@BlRtlEqual@2:

; 1437 :         }
; 1438 : 
; 1439 :         String1 += 1;

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _String1$[ebp]
  0003f	40		 inc	 eax
  00040	89 45 fc	 mov	 DWORD PTR _String1$[ebp], eax

; 1440 :         String2 += 1;

  00043	8b 45 f8	 mov	 eax, DWORD PTR _String2$[ebp]
  00046	40		 inc	 eax
  00047	89 45 f8	 mov	 DWORD PTR _String2$[ebp], eax

; 1441 :     }

  0004a	eb c0		 jmp	 SHORT $LN4@BlRtlEqual@2
$LN5@BlRtlEqual@2:

; 1442 : }

  0004c	5e		 pop	 esi
  0004d	c9		 leave
  0004e	c3		 ret	 0
?BlRtlEqualStringI@@YIEPBD0@Z ENDP			; BlRtlEqualStringI
_TEXT	ENDS
PUBLIC	?BlRtlFindSubstring@@YIPBDPBD0@Z		; BlRtlFindSubstring
; Function compile flags: /Odsp
;	COMDAT ?BlRtlFindSubstring@@YIPBDPBD0@Z
_TEXT	SEGMENT
_Substring$ = -12					; size = 4
_String$ = -8						; size = 4
_SubstringLength$ = -4					; size = 4
?BlRtlFindSubstring@@YIPBDPBD0@Z PROC			; BlRtlFindSubstring, COMDAT
; _String$ = ecx
; _Substring$ = edx

; 1469 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 55 f4	 mov	 DWORD PTR _Substring$[ebp], edx
  00009	89 4d f8	 mov	 DWORD PTR _String$[ebp], ecx

; 1470 :     UINT32 SubstringLength;
; 1471 : 
; 1472 :     SubstringLength = BlRtlStringLength(Substring);

  0000c	8b 4d f4	 mov	 ecx, DWORD PTR _Substring$[ebp]
  0000f	e8 00 00 00 00	 call	 ?BlRtlStringLength@@YIKPBD@Z ; BlRtlStringLength
  00014	89 45 fc	 mov	 DWORD PTR _SubstringLength$[ebp], eax
$LN3@BlRtlFindS:

; 1473 : 
; 1474 :     while (*String != 0) {

  00017	8b 45 f8	 mov	 eax, DWORD PTR _String$[ebp]
  0001a	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0001d	85 c0		 test	 eax, eax
  0001f	74 23		 je	 SHORT $LN2@BlRtlFindS

; 1475 : 
; 1476 :         if (BlRtlEqualStringN(String, Substring, SubstringLength) != FALSE) {

  00021	ff 75 fc	 push	 DWORD PTR _SubstringLength$[ebp]
  00024	8b 55 f4	 mov	 edx, DWORD PTR _Substring$[ebp]
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _String$[ebp]
  0002a	e8 00 00 00 00	 call	 ?BlRtlEqualStringN@@YIEPBD0K@Z ; BlRtlEqualStringN
  0002f	0f b6 c0	 movzx	 eax, al
  00032	85 c0		 test	 eax, eax
  00034	74 05		 je	 SHORT $LN1@BlRtlFindS

; 1477 : 
; 1478 :             return String;

  00036	8b 45 f8	 mov	 eax, DWORD PTR _String$[ebp]
  00039	eb 0b		 jmp	 SHORT $LN4@BlRtlFindS
$LN1@BlRtlFindS:

; 1479 :         }
; 1480 : 
; 1481 :         String += 1;

  0003b	8b 45 f8	 mov	 eax, DWORD PTR _String$[ebp]
  0003e	40		 inc	 eax
  0003f	89 45 f8	 mov	 DWORD PTR _String$[ebp], eax

; 1482 :     }

  00042	eb d3		 jmp	 SHORT $LN3@BlRtlFindS
$LN2@BlRtlFindS:

; 1483 : 
; 1484 :     return NULL;

  00044	33 c0		 xor	 eax, eax
$LN4@BlRtlFindS:

; 1485 : }

  00046	c9		 leave
  00047	c3		 ret	 0
?BlRtlFindSubstring@@YIPBDPBD0@Z ENDP			; BlRtlFindSubstring
_TEXT	ENDS
END
